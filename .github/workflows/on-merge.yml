# Main orchestrator for all automation triggered by merges to main
# This workflow replaces the fragile push-event-based chaining with explicit orchestration
#
# DESIGN PRINCIPLES:
# 1. Single entry point: All main-branch automation flows through here
# 2. No cascades: Bot commits are detected and handled differently to prevent infinite loops
# 3. Atomic changes: All regeneration happens together in a single PR
# 4. Single tag: Only one version bump per logical change
# 5. Delayed tagging: Tags ONLY created when content is definitively complete
#
# FIX FOR RACE CONDITION (Issue #252) - DELAYED TAGGING PATTERN:
# The race condition occurred because tags were created BEFORE regeneration PRs merged.
# Solution: Use conditional tagging based on commit type:
#   - Human commit needing regeneration -> Create PR, DO NOT tag (content incomplete)
#   - Human commit NOT needing regeneration -> Tag immediately (content complete)
#   - Bot commit (regeneration merged) -> Tag now (content complete)
#
# FIX FOR MISSING RELEASES (Issue #484) - TAG ON ANY CHANGE:
# Previously, only changes that triggered regeneration would create releases.
# Now, ANY substantive change (code, docs, README, etc.) triggers a release.
# Only workflow file and .gitignore changes are excluded from tagging.
#
# FLOW:
# Human PR merges -> detect-changes -> build-test -> regenerate?
#   -> If regeneration needed: Create PR, skip tagging (wait for PR to merge)
#   -> If no regeneration BUT has substantive changes: Tag and release immediately
#   -> If only workflow/gitignore changes: Skip (no release needed)
# Bot commit (regeneration PR merged) -> Tag and release
#
# REPLACED WORKFLOWS:
# - auto-tag.yml (version tagging now happens here)
# - docs.yml (documentation generation now happens here)
# - generate.yml (provider code generation now happens here)
name: On Merge

on:
  push:
    branches:
      - main
    # Note: No paths-ignore - all changes should trigger workflow
    # Specific path filtering happens in detect-changes job

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: on-merge-${{ github.sha }}
  cancel-in-progress: false

jobs:
  # ===========================================================================
  # STEP 1: Detect what changed and whether to proceed
  # ===========================================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      specs-changed: ${{ steps.changes.outputs.specs }}
      code-changed: ${{ steps.changes.outputs.code }}
      tools-changed: ${{ steps.changes.outputs.tools }}
      functions-changed: ${{ steps.changes.outputs.functions }}
      mcp-changed: ${{ steps.changes.outputs.mcp }}
      docs-changed: ${{ steps.changes.outputs.docs }}
      has-any-changes: ${{ steps.changes.outputs.has_any_changes }}
      is-bot-commit: ${{ steps.check-author.outputs.is_bot }}
      should-process: ${{ steps.should-process.outputs.result }}
      needs-regeneration: ${{ steps.should-process.outputs.needs_regeneration }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - name: Check if bot commit
        id: check-author
        run: |
          AUTHOR=$(git log -1 --format='%an')
          MESSAGE=$(git log -1 --format='%s')
          echo "Author: $AUTHOR"
          echo "Message: $MESSAGE"

          IS_BOT="false"

          # Check for bot author
          if [[ "$AUTHOR" == "github-actions[bot]" ]]; then
            IS_BOT="true"
            echo "Detected github-actions[bot] author"
          fi

          # Check for auto-generated commit messages
          if [[ "$MESSAGE" == "chore: auto-regenerate"* ]] || \
             [[ "$MESSAGE" == "docs: auto-generate"* ]] || \
             [[ "$MESSAGE" == "chore: regenerate provider"* ]]; then
            IS_BOT="true"
            echo "Detected auto-generated commit message"
          fi

          echo "is_bot=$IS_BOT" >> $GITHUB_OUTPUT

      - name: Detect changed paths
        id: changes
        run: |
          # Get changed files since parent commit
          CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD)
          echo "Changed files:"
          echo "$CHANGED"

          # Check for OpenAPI spec changes
          if echo "$CHANGED" | grep -qE '^docs/specifications/api/'; then
            echo "specs=true" >> $GITHUB_OUTPUT
            echo "OpenAPI specs changed"
          else
            echo "specs=false" >> $GITHUB_OUTPUT
          fi

          # Check for provider code changes (EXCLUDE manually-maintained source directories)
          # Manual source dirs: internal/functions/, internal/blindfold/
          # Manual source files: internal/provider/functions_registration.go
          # Note: docs/functions/ is AUTO-GENERATED by tfplugindocs from function metadata
          PROVIDER_CHANGES=$(echo "$CHANGED" | grep -E '^internal/' | grep -vE '^internal/(functions|blindfold)/' | grep -v 'functions_registration.go' || true)
          if [ -n "$PROVIDER_CHANGES" ]; then
            echo "code=true" >> $GITHUB_OUTPUT
            echo "Provider code changed (excluding manual source directories)"
          else
            echo "code=false" >> $GITHUB_OUTPUT
          fi

          # Check for tool changes (includes templates for doc generation)
          if echo "$CHANGED" | grep -qE '^tools/|^templates/'; then
            echo "tools=true" >> $GITHUB_OUTPUT
            echo "Tools/templates changed"
          else
            echo "tools=false" >> $GITHUB_OUTPUT
          fi

          # Check for function source changes (triggers doc regeneration)
          # Function source code in internal/functions/ and internal/blindfold/ triggers
          # tfplugindocs to regenerate docs/functions/*.md
          if echo "$CHANGED" | grep -qE '^internal/(functions|blindfold)/|functions_registration\.go|^examples/functions/'; then
            echo "functions=true" >> $GITHUB_OUTPUT
            echo "Function source changed (will trigger doc regeneration)"
          else
            echo "functions=false" >> $GITHUB_OUTPUT
          fi

          # Check for MCP server source changes
          if echo "$CHANGED" | grep -qE '^mcp-server/src/'; then
            echo "mcp=true" >> $GITHUB_OUTPUT
            echo "MCP server source changed"
          else
            echo "mcp=false" >> $GITHUB_OUTPUT
          fi

          # Check for documentation changes (triggers MCP server rebuild)
          if echo "$CHANGED" | grep -qE '^docs/(resources|data-sources|functions|guides)/'; then
            echo "docs=true" >> $GITHUB_OUTPUT
            echo "Documentation changed (will trigger MCP server rebuild)"
          else
            echo "docs=false" >> $GITHUB_OUTPUT
          fi

          # Check for ANY substantive changes (for tagging even without regeneration)
          # Exclude only workflow files and gitignore - everything else is substantive
          SUBSTANTIVE_CHANGES=$(echo "$CHANGED" | grep -vE '^\.github/workflows/|^\.gitignore' || true)
          if [ -n "$SUBSTANTIVE_CHANGES" ]; then
            echo "has_any_changes=true" >> $GITHUB_OUTPUT
            echo "Substantive changes detected (will trigger tagging)"
          else
            echo "has_any_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine if processing should proceed
        id: should-process
        run: |
          IS_BOT="${{ steps.check-author.outputs.is_bot }}"
          SPECS="${{ steps.changes.outputs.specs }}"
          CODE="${{ steps.changes.outputs.code }}"
          TOOLS="${{ steps.changes.outputs.tools }}"
          FUNCTIONS="${{ steps.changes.outputs.functions }}"
          MCP="${{ steps.changes.outputs.mcp }}"
          HAS_ANY_CHANGES="${{ steps.changes.outputs.has_any_changes }}"

          # Determine if regeneration would be needed
          NEEDS_REGEN="false"
          if [[ "$SPECS" == "true" || "$CODE" == "true" || "$TOOLS" == "true" || "$FUNCTIONS" == "true" ]]; then
            NEEDS_REGEN="true"
          fi
          echo "needs_regeneration=$NEEDS_REGEN" >> $GITHUB_OUTPUT

          # Determine if MCP server build is needed (separate from regeneration)
          NEEDS_MCP="false"
          if [[ "$MCP" == "true" ]]; then
            NEEDS_MCP="true"
          fi

          if [[ "$IS_BOT" == "true" ]]; then
            # Bot commits (from regeneration PR merge) should proceed to tagging
            echo "Processing: Bot commit - will proceed to tag/release"
            echo "result=true" >> $GITHUB_OUTPUT
          elif [[ "$NEEDS_REGEN" == "false" && "$NEEDS_MCP" == "false" ]]; then
            # No regeneration needed - check if there are any substantive changes for tagging
            if [[ "$HAS_ANY_CHANGES" == "true" ]]; then
              echo "Processing: Substantive changes without regeneration - will tag"
              echo "result=true" >> $GITHUB_OUTPUT
            else
              echo "Skipping: No relevant changes detected"
              echo "result=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Processing: Human commit with regeneration/MCP changes"
            echo "result=true" >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # STEP 2: Build and Test (validates the merged code - human commits only)
  # ===========================================================================
  build-test:
    name: Build and Test
    needs: detect-changes
    # Only run for human commits - bot commits (regeneration) don't need testing
    if: |
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true'
    uses: ./.github/workflows/_build-test.yml
    with:
      run-lint: true

  # ===========================================================================
  # STEP 3: Regenerate provider code (if OpenAPI specs OR generator tools changed - human commits only)
  # ===========================================================================
  regenerate-provider:
    name: Regenerate Provider
    needs: [detect-changes, build-test]
    # Only run for human commits that need provider regeneration
    # This includes: OpenAPI spec changes OR generator tool changes (to apply bug fixes)
    if: |
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      (needs.detect-changes.outputs.specs-changed == 'true' ||
       needs.detect-changes.outputs.tools-changed == 'true')
    uses: ./.github/workflows/_generate-provider.yml

  # ===========================================================================
  # STEP 4: Regenerate documentation (if code, tools, or functions changed - human commits only)
  # ===========================================================================
  regenerate-docs:
    name: Regenerate Docs
    needs: [detect-changes, build-test, regenerate-provider]
    # Only run for human commits that need documentation regeneration
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      needs.build-test.result == 'success' &&
      (needs.detect-changes.outputs.code-changed == 'true' ||
       needs.detect-changes.outputs.tools-changed == 'true' ||
       needs.detect-changes.outputs.functions-changed == 'true' ||
       (needs.regenerate-provider.result == 'success' && needs.regenerate-provider.outputs.changed == 'true'))
    uses: ./.github/workflows/_generate-docs.yml

  # ===========================================================================
  # STEP 5: Build MCP Server (when docs, specs, or MCP source changes)
  # ===========================================================================
  build-mcp-server:
    name: Build MCP Server
    needs: [detect-changes, build-test, regenerate-docs]
    # Build MCP server when:
    # 1. MCP server source changed, OR
    # 2. Documentation was regenerated, OR
    # 3. OpenAPI specs changed (MCP server serves these)
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      needs.build-test.result == 'success' &&
      (needs.detect-changes.outputs.mcp-changed == 'true' ||
       needs.detect-changes.outputs.docs-changed == 'true' ||
       needs.detect-changes.outputs.specs-changed == 'true' ||
       needs.regenerate-docs.outputs.changed == 'true')
    uses: ./.github/workflows/_build-mcp-server.yml
    with:
      publish: true
    secrets:
      npm-token: ${{ secrets.NPM_TOKEN }}

  # ===========================================================================
  # STEP 5b: Sync MCP Server version after any release (ensures npm matches GitHub)
  # ===========================================================================
  sync-mcp-version:
    name: Sync MCP Server Version
    needs: [detect-changes, tag-release]
    # Run after ANY successful tag/release to ensure npm version matches
    # This guarantees npm package and GitHub release always have the same version
    if: |
      always() &&
      needs.tag-release.result == 'success'
    uses: ./.github/workflows/_build-mcp-server.yml
    with:
      publish: true
    secrets:
      npm-token: ${{ secrets.NPM_TOKEN }}

  # ===========================================================================
  # STEP 6: Create PR for regenerated content (human commits only)
  # ===========================================================================
  # NOTE: We create a PR instead of pushing directly to respect branch protection.
  # The delayed tagging pattern ensures we DON'T tag here - tagging happens when
  # the regeneration PR is merged (detected as bot commit in next workflow run).
  create-regeneration-pr:
    name: Create Regeneration PR
    needs: [detect-changes, regenerate-provider, regenerate-docs]
    # Only run for human commits that produced regeneration changes
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      ((needs.regenerate-provider.result == 'success' && needs.regenerate-provider.outputs.changed == 'true') ||
       (needs.regenerate-docs.result == 'success' && needs.regenerate-docs.outputs.changed == 'true'))
    runs-on: ubuntu-latest
    outputs:
      pr-created: ${{ steps.create-pr.outputs.pr_created }}
      pr-number: ${{ steps.create-pr.outputs.pr_number }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.AUTO_MERGE_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Install tfplugindocs
        run: |
          # Retry logic for go install (network-dependent)
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "::group::Install tfplugindocs - Attempt $attempt of $max_attempts"
            if go install github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs@latest; then
              echo "::endgroup::"
              break
            fi
            echo "::endgroup::"
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              sleep_time=$((2 ** attempt * 5))
              echo "::warning::go install failed, retrying in ${sleep_time}s..."
              sleep $sleep_time
            fi
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "::error::Failed to install tfplugindocs after $max_attempts attempts"
            exit 1
          fi
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Regenerate provider (if needed)
        if: needs.regenerate-provider.outputs.changed == 'true'
        run: |
          echo "::group::Generate provider code"
          go run tools/generate-all-schemas.go --spec-dir=docs/specifications/api
          echo "::endgroup::"

          # Retry logic for go mod operations (network-dependent)
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "::group::go mod tidy - Attempt $attempt of $max_attempts"
            if go mod tidy; then
              echo "::endgroup::"
              break
            fi
            echo "::endgroup::"
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              sleep_time=$((2 ** attempt * 5))
              echo "::warning::go mod tidy failed, retrying in ${sleep_time}s..."
              sleep $sleep_time
            fi
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "::error::go mod tidy failed after $max_attempts attempts"
            exit 1
          fi

          # Verify build succeeds
          echo "::group::Verify build"
          go build -v .
          echo "::endgroup::"

      - name: Regenerate documentation (if needed)
        # Regenerate docs if:
        # 1. The standalone docs job found changes (template/example changes), OR
        # 2. Provider was regenerated (schema descriptions may have changed)
        if: needs.regenerate-docs.outputs.changed == 'true' || needs.regenerate-provider.outputs.changed == 'true'
        run: |
          go run tools/generate-examples.go
          # Retry tfplugindocs generate
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "::group::tfplugindocs generate - Attempt $attempt of $max_attempts"
            if tfplugindocs generate; then
              echo "::endgroup::"
              break
            fi
            echo "::endgroup::"
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              sleep_time=$((2 ** attempt * 5))
              echo "::warning::tfplugindocs failed, retrying in ${sleep_time}s..."
              sleep $sleep_time
            fi
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "::error::tfplugindocs failed after $max_attempts attempts"
            exit 1
          fi
          go run tools/transform-docs.go

      - name: Check for changes
        id: check
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --cached --stat
          fi

      - name: Configure Git
        if: steps.check.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Close stale auto-regenerate PRs
        if: steps.check.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.AUTO_MERGE_TOKEN }}
        run: |
          # Find and close any open auto-regenerate PRs (they're superseded by this new regeneration)
          echo "Checking for stale auto-regenerate PRs..."
          STALE_PRS=$(gh pr list --state open --json number,headRefName --jq '.[] | select(.headRefName | startswith("auto-regenerate/")) | .number')

          if [ -n "$STALE_PRS" ]; then
            for PR in $STALE_PRS; do
              echo "Closing stale auto-regenerate PR #$PR (superseded by commit ${{ github.sha }})"
              gh pr close "$PR" --comment "Superseded by newer regeneration from commit ${{ github.sha }}" || true
              # Also delete the stale branch
              BRANCH=$(gh pr view "$PR" --json headRefName --jq '.headRefName')
              git push origin --delete "$BRANCH" 2>/dev/null || true
            done
          else
            echo "No stale auto-regenerate PRs found"
          fi

      - name: Create branch and PR
        id: create-pr
        if: steps.check.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.AUTO_MERGE_TOKEN }}
        run: |
          # Create a unique branch name
          BRANCH_NAME="auto-regenerate/${{ github.sha }}"

          # Create and checkout new branch
          git checkout -b "$BRANCH_NAME"

          # Commit the changes
          git commit -m "chore: auto-regenerate provider and documentation

          Triggered by commit: ${{ github.sha }}

          Changes regenerated:
          - Provider code: ${{ needs.regenerate-provider.outputs.changed || 'false' }}
          - Documentation: ${{ needs.regenerate-docs.outputs.changed || 'false' }}

          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>"

          # Push the branch
          git push origin "$BRANCH_NAME"

          # Create the PR body
          PR_BODY="## Summary
          Automated regeneration of provider code and/or documentation.

          ## Triggered By
          Commit: ${{ github.sha }}

          ## Changes
          - Provider code regenerated: ${{ needs.regenerate-provider.outputs.changed || 'false' }}
          - Documentation regenerated: ${{ needs.regenerate-docs.outputs.changed || 'false' }}

          ## Note
          This PR was automatically created. When merged, it will trigger the tag/release workflow.

          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)"

          # Create the PR
          PR_URL=$(gh pr create \
            --title "chore: auto-regenerate provider and documentation" \
            --body "$PR_BODY" \
            --label "automated" \
            --label "regeneration" \
            --base main \
            --head "$BRANCH_NAME")

          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_created=true" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "Created PR #$PR_NUMBER: $PR_URL"

          # Enable auto-merge if available
          gh pr merge "$PR_NUMBER" --auto --squash || echo "Auto-merge not available or already enabled"

      - name: No changes - skip PR creation
        if: steps.check.outputs.has_changes == 'false'
        run: |
          echo "pr_created=false" >> $GITHUB_OUTPUT
          echo "No regeneration changes to commit"

  # ===========================================================================
  # STEP 6: Tag and Release (DELAYED TAGGING PATTERN)
  # ===========================================================================
  # CRITICAL: Tags are ONLY created when content is definitively complete:
  #   1. Bot commit (regeneration PR was merged) -> Tag now, content is complete
  #   2. Human commit with substantive changes (no regen) -> Tag now, content is complete
  #   3. Human commit that created regeneration PR -> DON'T tag, wait for PR merge
  #   4. Human commit with only workflow/gitignore changes -> Skip (no release needed)
  # Tagging conditions (comments cannot be inside if expressions):
  # - Case 1: Bot commit -> Tag immediately (regeneration is complete)
  # - Case 2: Human commit with substantive changes, no regen -> Tag immediately (build passed)
  # - Case 3: Human commit WITH regeneration -> DON'T tag (wait for regen PR to merge)
  # - Case 4: Only workflow/gitignore changes -> Skip (not substantive)
  tag-release:
    name: Tag and Release
    needs: [detect-changes, build-test, create-regeneration-pr]
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      (
        needs.detect-changes.outputs.is-bot-commit == 'true' ||
        (
          needs.detect-changes.outputs.is-bot-commit != 'true' &&
          needs.build-test.result == 'success' &&
          needs.create-regeneration-pr.result == 'skipped'
        )
      )
    uses: ./.github/workflows/_tag-release.yml
    secrets:
      gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
      gpg-passphrase: ${{ secrets.PASSPHRASE }}

  # ===========================================================================
  # STEP 7: Publish to MCP Registry (after release is created)
  # ===========================================================================
  # This job publishes the MCP server to the official MCP Registry.
  # It runs directly after tag-release instead of relying on release triggers,
  # because releases created by GITHUB_TOKEN don't trigger other workflows.
  publish-mcp-registry:
    name: Publish MCP Registry
    needs: [tag-release]
    if: |
      always() &&
      needs.tag-release.result == 'success' &&
      needs.tag-release.outputs.tag-created == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.AUTO_MERGE_TOKEN }}
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: mcp-server/package-lock.json

      - name: Get version from tag
        id: version
        run: |
          VERSION="${{ needs.tag-release.outputs.new-tag }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using version: $VERSION"

      - name: Install dependencies
        working-directory: mcp-server
        run: npm ci

      - name: Build TypeScript
        working-directory: mcp-server
        run: npm run build

      - name: Build MCPB Bundle
        working-directory: mcp-server
        run: |
          ./scripts/build-mcpb.sh --version ${{ steps.version.outputs.version }}

      - name: Calculate SHA-256
        id: hash
        working-directory: mcp-server
        run: |
          SHA256=$(cat build/f5xc-terraform-mcp-${{ steps.version.outputs.version }}.mcpb.sha256)
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "SHA-256: $SHA256"

      - name: Upload MCPB to GitHub Release
        env:
          GH_TOKEN: ${{ secrets.AUTO_MERGE_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="v$VERSION"

          # Wait for release to be available (it was just created)
          sleep 5

          # Upload MCPB bundle and checksum to the release
          gh release upload "$TAG" \
            "mcp-server/build/f5xc-terraform-mcp-${VERSION}.mcpb" \
            "mcp-server/build/f5xc-terraform-mcp-${VERSION}.mcpb.sha256" \
            --clobber || echo "Upload failed or files already exist"

      - name: Update server.json and manifest.json
        working-directory: mcp-server
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHA256="${{ steps.hash.outputs.sha256 }}"
          MCPB_URL="https://github.com/robinmordasiewicz/terraform-provider-f5xc/releases/download/v${VERSION}/f5xc-terraform-mcp-${VERSION}.mcpb"

          # Update version in server.json
          node -e "
          const fs = require('fs');
          const serverJson = JSON.parse(fs.readFileSync('server.json', 'utf8'));
          serverJson.version = '$VERSION';
          if (serverJson.packages) {
            serverJson.packages.forEach(p => {
              p.version = '$VERSION';
              if (p.registryType === 'mcpb') {
                p.identifier = '$MCPB_URL';
                p.file_sha256 = '$SHA256';
              }
            });
          }
          fs.writeFileSync('server.json', JSON.stringify(serverJson, null, 2) + '\n');
          "

          # Update version in manifest.json
          node -e "
          const fs = require('fs');
          const manifest = JSON.parse(fs.readFileSync('manifest.json', 'utf8'));
          manifest.version = '$VERSION';
          fs.writeFileSync('manifest.json', JSON.stringify(manifest, null, 2) + '\n');
          "

      - name: Check for changes
        id: check
        run: |
          if git diff --quiet mcp-server/server.json mcp-server/manifest.json; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request for server.json update
        if: steps.check.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.AUTO_MERGE_TOKEN }}
          commit-message: "chore(mcp): update server.json to v${{ steps.version.outputs.version }}"
          branch: chore/mcp-server-json-${{ steps.version.outputs.version }}
          title: "chore(mcp): update server.json to v${{ steps.version.outputs.version }}"
          body: |
            Automated update of server.json for MCP Registry publication.

            **Version**: ${{ steps.version.outputs.version }}
            **SHA256**: `${{ steps.hash.outputs.sha256 }}`

            This PR updates the server.json with the correct MCPB download URL and hash.
          labels: automated,mcp
          delete-branch: true

      - name: Install mcp-publisher CLI
        run: |
          curl -L "https://github.com/modelcontextprotocol/registry/releases/latest/download/mcp-publisher_linux_amd64.tar.gz" | tar xz
          sudo mv mcp-publisher /usr/local/bin/
          mcp-publisher --version

      - name: Authenticate via GitHub OIDC
        run: mcp-publisher login github-oidc

      - name: Validate server.json (dry run)
        working-directory: mcp-server
        run: mcp-publisher publish --dry-run --file server.json

      - name: Publish to MCP Registry
        working-directory: mcp-server
        run: mcp-publisher publish --file server.json

      - name: Verify publication
        run: |
          SERVER_NAME=$(jq -r '.name' mcp-server/server.json)
          echo "Verifying publication of: $SERVER_NAME"
          sleep 3
          curl -s "https://registry.modelcontextprotocol.io/v0/servers?search=${SERVER_NAME}" | jq '.'

  # ===========================================================================
  # Summary
  # ===========================================================================
  summary:
    name: Workflow Summary
    needs: [detect-changes, build-test, regenerate-provider, regenerate-docs, build-mcp-server, sync-mcp-version, create-regeneration-pr, tag-release, publish-mcp-registry]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Print summary
        run: |
          echo "## On-Merge Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Should Process | ${{ needs.detect-changes.outputs.should-process }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Is Bot Commit | ${{ needs.detect-changes.outputs.is-bot-commit }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Needs Regeneration | ${{ needs.detect-changes.outputs.needs-regeneration }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Specs Changed | ${{ needs.detect-changes.outputs.specs-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Code Changed | ${{ needs.detect-changes.outputs.code-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tools Changed | ${{ needs.detect-changes.outputs.tools-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Functions Changed | ${{ needs.detect-changes.outputs.functions-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Server Changed | ${{ needs.detect-changes.outputs.mcp-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docs Changed | ${{ needs.detect-changes.outputs.docs-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build/Test | ${{ needs.build-test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Provider Regenerated | ${{ needs.regenerate-provider.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docs Regenerated | ${{ needs.regenerate-docs.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Server Built | ${{ needs.build-mcp-server.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Version Synced | ${{ needs.sync-mcp-version.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Regeneration PR Created | ${{ needs.create-regeneration-pr.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tagged/Released | ${{ needs.tag-release.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Registry Published | ${{ needs.publish-mcp-registry.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Delayed Tagging Logic" >> $GITHUB_STEP_SUMMARY
          echo "- Bot commits -> Tag immediately (regeneration complete)" >> $GITHUB_STEP_SUMMARY
          echo "- Human commits without regeneration -> Tag immediately" >> $GITHUB_STEP_SUMMARY
          echo "- Human commits with regeneration PR -> Wait for PR merge to tag" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### MCP Server Version Sync" >> $GITHUB_STEP_SUMMARY
          echo "- Human commits with MCP/docs changes -> Build and publish to npm" >> $GITHUB_STEP_SUMMARY
          echo "- After ANY successful release -> Sync npm version to match GitHub release" >> $GITHUB_STEP_SUMMARY
          echo "- This guarantees npm and GitHub release ALWAYS have matching versions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### MCP Registry Publication" >> $GITHUB_STEP_SUMMARY
          echo "- After successful tag/release -> Build MCPB bundle" >> $GITHUB_STEP_SUMMARY
          echo "- Upload MCPB to GitHub Release assets" >> $GITHUB_STEP_SUMMARY
          echo "- Create PR for server.json version update" >> $GITHUB_STEP_SUMMARY
          echo "- Publish to registry.modelcontextprotocol.io via OIDC" >> $GITHUB_STEP_SUMMARY
          echo "- Enables VSCode @MCP search discovery" >> $GITHUB_STEP_SUMMARY
