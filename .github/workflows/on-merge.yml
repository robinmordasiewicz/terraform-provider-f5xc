# Main orchestrator for all automation triggered by merges to main
# This workflow replaces the fragile push-event-based chaining with explicit orchestration
#
# DESIGN PRINCIPLES:
# 1. Single entry point: All main-branch automation flows through here
# 2. No cascades: Bot commits are detected and handled differently to prevent infinite loops
# 3. Atomic changes: All regeneration happens together in a single PR
# 4. Single tag: Only one version bump per logical change
# 5. Delayed tagging: Tags ONLY created when content is definitively complete
#
# FIX FOR RACE CONDITION (Issue #252) - DELAYED TAGGING PATTERN:
# The race condition occurred because tags were created BEFORE regeneration PRs merged.
# Solution: Use conditional tagging based on commit type:
#   - Human commit needing regeneration -> Create PR, DO NOT tag (content incomplete)
#   - Human commit NOT needing regeneration -> Tag immediately (content complete)
#   - Bot commit (regeneration merged) -> Tag now (content complete)
#
# FLOW:
# Human PR merges -> detect-changes -> build-test -> regenerate?
#   -> If regeneration needed: Create PR, skip tagging (wait for PR to merge)
#   -> If no regeneration: Tag and release immediately
# Bot commit (regeneration PR merged) -> Tag and release
#
# REPLACED WORKFLOWS:
# - auto-tag.yml (version tagging now happens here)
# - docs.yml (documentation generation now happens here)
# - generate.yml (provider code generation now happens here)
name: On Merge

on:
  push:
    branches:
      - main
    paths-ignore:
      - '*.md'
      # Note: Don't ignore workflow files - changes to on-merge.yml itself
      # should be testable via CI, but won't trigger regeneration anyway
      # since the detect-changes job filters by actual code changes.

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: on-merge-${{ github.sha }}
  cancel-in-progress: false

jobs:
  # ===========================================================================
  # STEP 1: Detect what changed and whether to proceed
  # ===========================================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      specs-changed: ${{ steps.changes.outputs.specs }}
      code-changed: ${{ steps.changes.outputs.code }}
      tools-changed: ${{ steps.changes.outputs.tools }}
      functions-changed: ${{ steps.changes.outputs.functions }}
      mcp-changed: ${{ steps.changes.outputs.mcp }}
      docs-changed: ${{ steps.changes.outputs.docs }}
      is-bot-commit: ${{ steps.check-author.outputs.is_bot }}
      should-process: ${{ steps.should-process.outputs.result }}
      needs-regeneration: ${{ steps.should-process.outputs.needs_regeneration }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - name: Check if bot commit
        id: check-author
        run: |
          AUTHOR=$(git log -1 --format='%an')
          MESSAGE=$(git log -1 --format='%s')
          echo "Author: $AUTHOR"
          echo "Message: $MESSAGE"

          IS_BOT="false"

          # Check for bot author
          if [[ "$AUTHOR" == "github-actions[bot]" ]]; then
            IS_BOT="true"
            echo "Detected github-actions[bot] author"
          fi

          # Check for auto-generated commit messages
          if [[ "$MESSAGE" == "chore: auto-regenerate"* ]] || \
             [[ "$MESSAGE" == "docs: auto-generate"* ]] || \
             [[ "$MESSAGE" == "chore: regenerate provider"* ]]; then
            IS_BOT="true"
            echo "Detected auto-generated commit message"
          fi

          echo "is_bot=$IS_BOT" >> $GITHUB_OUTPUT

      - name: Detect changed paths
        id: changes
        run: |
          # Get changed files since parent commit
          CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD)
          echo "Changed files:"
          echo "$CHANGED"

          # Check for OpenAPI spec changes
          if echo "$CHANGED" | grep -qE '^docs/specifications/api/'; then
            echo "specs=true" >> $GITHUB_OUTPUT
            echo "OpenAPI specs changed"
          else
            echo "specs=false" >> $GITHUB_OUTPUT
          fi

          # Check for provider code changes (EXCLUDE manually-maintained source directories)
          # Manual source dirs: internal/functions/, internal/blindfold/
          # Manual source files: internal/provider/functions_registration.go
          # Note: docs/functions/ is AUTO-GENERATED by tfplugindocs from function metadata
          PROVIDER_CHANGES=$(echo "$CHANGED" | grep -E '^internal/' | grep -vE '^internal/(functions|blindfold)/' | grep -v 'functions_registration.go' || true)
          if [ -n "$PROVIDER_CHANGES" ]; then
            echo "code=true" >> $GITHUB_OUTPUT
            echo "Provider code changed (excluding manual source directories)"
          else
            echo "code=false" >> $GITHUB_OUTPUT
          fi

          # Check for tool changes (includes templates for doc generation)
          if echo "$CHANGED" | grep -qE '^tools/|^templates/'; then
            echo "tools=true" >> $GITHUB_OUTPUT
            echo "Tools/templates changed"
          else
            echo "tools=false" >> $GITHUB_OUTPUT
          fi

          # Check for function source changes (triggers doc regeneration)
          # Function source code in internal/functions/ and internal/blindfold/ triggers
          # tfplugindocs to regenerate docs/functions/*.md
          if echo "$CHANGED" | grep -qE '^internal/(functions|blindfold)/|functions_registration\.go|^examples/functions/'; then
            echo "functions=true" >> $GITHUB_OUTPUT
            echo "Function source changed (will trigger doc regeneration)"
          else
            echo "functions=false" >> $GITHUB_OUTPUT
          fi

          # Check for MCP server source changes
          if echo "$CHANGED" | grep -qE '^mcp-server/src/'; then
            echo "mcp=true" >> $GITHUB_OUTPUT
            echo "MCP server source changed"
          else
            echo "mcp=false" >> $GITHUB_OUTPUT
          fi

          # Check for documentation changes (triggers MCP server rebuild)
          if echo "$CHANGED" | grep -qE '^docs/(resources|data-sources|functions|guides)/'; then
            echo "docs=true" >> $GITHUB_OUTPUT
            echo "Documentation changed (will trigger MCP server rebuild)"
          else
            echo "docs=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine if processing should proceed
        id: should-process
        run: |
          IS_BOT="${{ steps.check-author.outputs.is_bot }}"
          SPECS="${{ steps.changes.outputs.specs }}"
          CODE="${{ steps.changes.outputs.code }}"
          TOOLS="${{ steps.changes.outputs.tools }}"
          FUNCTIONS="${{ steps.changes.outputs.functions }}"
          MCP="${{ steps.changes.outputs.mcp }}"

          # Determine if regeneration would be needed
          NEEDS_REGEN="false"
          if [[ "$SPECS" == "true" || "$CODE" == "true" || "$TOOLS" == "true" || "$FUNCTIONS" == "true" ]]; then
            NEEDS_REGEN="true"
          fi
          echo "needs_regeneration=$NEEDS_REGEN" >> $GITHUB_OUTPUT

          # Determine if MCP server build is needed (separate from regeneration)
          NEEDS_MCP="false"
          if [[ "$MCP" == "true" ]]; then
            NEEDS_MCP="true"
          fi

          if [[ "$IS_BOT" == "true" ]]; then
            # Bot commits (from regeneration PR merge) should proceed to tagging
            echo "Processing: Bot commit - will proceed to tag/release"
            echo "result=true" >> $GITHUB_OUTPUT
          elif [[ "$NEEDS_REGEN" == "false" && "$NEEDS_MCP" == "false" ]]; then
            echo "Skipping: No relevant changes detected"
            echo "result=false" >> $GITHUB_OUTPUT
          else
            echo "Processing: Human commit with relevant changes"
            echo "result=true" >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # STEP 2: Build and Test (validates the merged code - human commits only)
  # ===========================================================================
  build-test:
    name: Build and Test
    needs: detect-changes
    # Only run for human commits - bot commits (regeneration) don't need testing
    if: |
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true'
    uses: ./.github/workflows/_build-test.yml
    with:
      run-lint: true

  # ===========================================================================
  # STEP 3: Regenerate provider code (if OpenAPI specs OR generator tools changed - human commits only)
  # ===========================================================================
  regenerate-provider:
    name: Regenerate Provider
    needs: [detect-changes, build-test]
    # Only run for human commits that need provider regeneration
    # This includes: OpenAPI spec changes OR generator tool changes (to apply bug fixes)
    if: |
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      (needs.detect-changes.outputs.specs-changed == 'true' ||
       needs.detect-changes.outputs.tools-changed == 'true')
    uses: ./.github/workflows/_generate-provider.yml

  # ===========================================================================
  # STEP 4: Regenerate documentation (if code, tools, or functions changed - human commits only)
  # ===========================================================================
  regenerate-docs:
    name: Regenerate Docs
    needs: [detect-changes, build-test, regenerate-provider]
    # Only run for human commits that need documentation regeneration
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      needs.build-test.result == 'success' &&
      (needs.detect-changes.outputs.code-changed == 'true' ||
       needs.detect-changes.outputs.tools-changed == 'true' ||
       needs.detect-changes.outputs.functions-changed == 'true' ||
       (needs.regenerate-provider.result == 'success' && needs.regenerate-provider.outputs.changed == 'true'))
    uses: ./.github/workflows/_generate-docs.yml

  # ===========================================================================
  # STEP 5: Build MCP Server (when docs, specs, or MCP source changes)
  # ===========================================================================
  build-mcp-server:
    name: Build MCP Server
    needs: [detect-changes, build-test, regenerate-docs]
    # Build MCP server when:
    # 1. MCP server source changed, OR
    # 2. Documentation was regenerated, OR
    # 3. OpenAPI specs changed (MCP server serves these)
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      needs.build-test.result == 'success' &&
      (needs.detect-changes.outputs.mcp-changed == 'true' ||
       needs.detect-changes.outputs.docs-changed == 'true' ||
       needs.detect-changes.outputs.specs-changed == 'true' ||
       needs.regenerate-docs.outputs.changed == 'true')
    uses: ./.github/workflows/_build-mcp-server.yml
    with:
      publish: true
    secrets:
      npm-token: ${{ secrets.NPM_TOKEN }}

  # ===========================================================================
  # STEP 5b: Sync MCP Server version after any release (ensures npm matches GitHub)
  # ===========================================================================
  sync-mcp-version:
    name: Sync MCP Server Version
    needs: [detect-changes, tag-release]
    # Run after ANY successful tag/release to ensure npm version matches
    # This guarantees npm package and GitHub release always have the same version
    if: |
      always() &&
      needs.tag-release.result == 'success'
    uses: ./.github/workflows/_build-mcp-server.yml
    with:
      publish: true
    secrets:
      npm-token: ${{ secrets.NPM_TOKEN }}

  # ===========================================================================
  # STEP 6: Create PR for regenerated content (human commits only)
  # ===========================================================================
  # NOTE: We create a PR instead of pushing directly to respect branch protection.
  # The delayed tagging pattern ensures we DON'T tag here - tagging happens when
  # the regeneration PR is merged (detected as bot commit in next workflow run).
  create-regeneration-pr:
    name: Create Regeneration PR
    needs: [detect-changes, regenerate-provider, regenerate-docs]
    # Only run for human commits that produced regeneration changes
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      needs.detect-changes.outputs.is-bot-commit != 'true' &&
      ((needs.regenerate-provider.result == 'success' && needs.regenerate-provider.outputs.changed == 'true') ||
       (needs.regenerate-docs.result == 'success' && needs.regenerate-docs.outputs.changed == 'true'))
    runs-on: ubuntu-latest
    outputs:
      pr-created: ${{ steps.create-pr.outputs.pr_created }}
      pr-number: ${{ steps.create-pr.outputs.pr_number }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.AUTO_MERGE_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Install tfplugindocs
        run: |
          # Retry logic for go install (network-dependent)
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "::group::Install tfplugindocs - Attempt $attempt of $max_attempts"
            if go install github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs@latest; then
              echo "::endgroup::"
              break
            fi
            echo "::endgroup::"
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              sleep_time=$((2 ** attempt * 5))
              echo "::warning::go install failed, retrying in ${sleep_time}s..."
              sleep $sleep_time
            fi
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "::error::Failed to install tfplugindocs after $max_attempts attempts"
            exit 1
          fi
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Regenerate provider (if needed)
        if: needs.regenerate-provider.outputs.changed == 'true'
        run: |
          echo "::group::Generate provider code"
          go run tools/generate-all-schemas.go --spec-dir=docs/specifications/api
          echo "::endgroup::"

          # Retry logic for go mod operations (network-dependent)
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "::group::go mod tidy - Attempt $attempt of $max_attempts"
            if go mod tidy; then
              echo "::endgroup::"
              break
            fi
            echo "::endgroup::"
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              sleep_time=$((2 ** attempt * 5))
              echo "::warning::go mod tidy failed, retrying in ${sleep_time}s..."
              sleep $sleep_time
            fi
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "::error::go mod tidy failed after $max_attempts attempts"
            exit 1
          fi

          # Verify build succeeds
          echo "::group::Verify build"
          go build -v .
          echo "::endgroup::"

      - name: Regenerate documentation (if needed)
        # Regenerate docs if:
        # 1. The standalone docs job found changes (template/example changes), OR
        # 2. Provider was regenerated (schema descriptions may have changed)
        if: needs.regenerate-docs.outputs.changed == 'true' || needs.regenerate-provider.outputs.changed == 'true'
        run: |
          go run tools/generate-examples.go
          # Retry tfplugindocs generate
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "::group::tfplugindocs generate - Attempt $attempt of $max_attempts"
            if tfplugindocs generate; then
              echo "::endgroup::"
              break
            fi
            echo "::endgroup::"
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              sleep_time=$((2 ** attempt * 5))
              echo "::warning::tfplugindocs failed, retrying in ${sleep_time}s..."
              sleep $sleep_time
            fi
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "::error::tfplugindocs failed after $max_attempts attempts"
            exit 1
          fi
          go run tools/transform-docs.go

      - name: Check for changes
        id: check
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --cached --stat
          fi

      - name: Configure Git
        if: steps.check.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch and PR
        id: create-pr
        if: steps.check.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.AUTO_MERGE_TOKEN }}
        run: |
          # Create a unique branch name
          BRANCH_NAME="auto-regenerate/${{ github.sha }}"

          # Create and checkout new branch
          git checkout -b "$BRANCH_NAME"

          # Commit the changes
          git commit -m "chore: auto-regenerate provider and documentation

          Triggered by commit: ${{ github.sha }}

          Changes regenerated:
          - Provider code: ${{ needs.regenerate-provider.outputs.changed || 'false' }}
          - Documentation: ${{ needs.regenerate-docs.outputs.changed || 'false' }}

          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>"

          # Push the branch
          git push origin "$BRANCH_NAME"

          # Create the PR body
          PR_BODY="## Summary
          Automated regeneration of provider code and/or documentation.

          ## Triggered By
          Commit: ${{ github.sha }}

          ## Changes
          - Provider code regenerated: ${{ needs.regenerate-provider.outputs.changed || 'false' }}
          - Documentation regenerated: ${{ needs.regenerate-docs.outputs.changed || 'false' }}

          ## Note
          This PR was automatically created. When merged, it will trigger the tag/release workflow.

          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)"

          # Create the PR
          PR_URL=$(gh pr create \
            --title "chore: auto-regenerate provider and documentation" \
            --body "$PR_BODY" \
            --label "automated" \
            --label "regeneration" \
            --base main \
            --head "$BRANCH_NAME")

          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_created=true" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "Created PR #$PR_NUMBER: $PR_URL"

          # Enable auto-merge if available
          gh pr merge "$PR_NUMBER" --auto --squash || echo "Auto-merge not available or already enabled"

      - name: No changes - skip PR creation
        if: steps.check.outputs.has_changes == 'false'
        run: |
          echo "pr_created=false" >> $GITHUB_OUTPUT
          echo "No regeneration changes to commit"

  # ===========================================================================
  # STEP 6: Tag and Release (DELAYED TAGGING PATTERN)
  # ===========================================================================
  # CRITICAL: Tags are ONLY created when content is definitively complete:
  #   1. Bot commit (regeneration PR was merged) -> Tag now, content is complete
  #   2. Human commit that didn't need regeneration -> Tag now, content is complete
  #   3. Human commit that created regeneration PR -> DON'T tag, wait for PR merge
  # Tagging conditions (comments cannot be inside if expressions):
  # - Case 1: Bot commit -> Tag immediately (regeneration is complete)
  # - Case 2: Human commit without regeneration -> Tag immediately (PR job was skipped)
  # - Case 3: Human commit WITH regeneration -> DON'T tag (wait for regen PR to merge)
  tag-release:
    name: Tag and Release
    needs: [detect-changes, build-test, create-regeneration-pr]
    if: |
      always() &&
      needs.detect-changes.outputs.should-process == 'true' &&
      (
        needs.detect-changes.outputs.is-bot-commit == 'true' ||
        (
          needs.detect-changes.outputs.is-bot-commit != 'true' &&
          needs.build-test.result == 'success' &&
          needs.create-regeneration-pr.result == 'skipped'
        )
      )
    uses: ./.github/workflows/_tag-release.yml
    secrets:
      gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
      gpg-passphrase: ${{ secrets.PASSPHRASE }}

  # ===========================================================================
  # Summary
  # ===========================================================================
  summary:
    name: Workflow Summary
    needs: [detect-changes, build-test, regenerate-provider, regenerate-docs, build-mcp-server, sync-mcp-version, create-regeneration-pr, tag-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Print summary
        run: |
          echo "## On-Merge Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Should Process | ${{ needs.detect-changes.outputs.should-process }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Is Bot Commit | ${{ needs.detect-changes.outputs.is-bot-commit }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Needs Regeneration | ${{ needs.detect-changes.outputs.needs-regeneration }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Specs Changed | ${{ needs.detect-changes.outputs.specs-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Code Changed | ${{ needs.detect-changes.outputs.code-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tools Changed | ${{ needs.detect-changes.outputs.tools-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Functions Changed | ${{ needs.detect-changes.outputs.functions-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Server Changed | ${{ needs.detect-changes.outputs.mcp-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docs Changed | ${{ needs.detect-changes.outputs.docs-changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build/Test | ${{ needs.build-test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Provider Regenerated | ${{ needs.regenerate-provider.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docs Regenerated | ${{ needs.regenerate-docs.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Server Built | ${{ needs.build-mcp-server.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Version Synced | ${{ needs.sync-mcp-version.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Regeneration PR Created | ${{ needs.create-regeneration-pr.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tagged/Released | ${{ needs.tag-release.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Delayed Tagging Logic" >> $GITHUB_STEP_SUMMARY
          echo "- Bot commits -> Tag immediately (regeneration complete)" >> $GITHUB_STEP_SUMMARY
          echo "- Human commits without regeneration -> Tag immediately" >> $GITHUB_STEP_SUMMARY
          echo "- Human commits with regeneration PR -> Wait for PR merge to tag" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### MCP Server Version Sync" >> $GITHUB_STEP_SUMMARY
          echo "- Human commits with MCP/docs changes -> Build and publish to npm" >> $GITHUB_STEP_SUMMARY
          echo "- After ANY successful release -> Sync npm version to match GitHub release" >> $GITHUB_STEP_SUMMARY
          echo "- This guarantees npm and GitHub release ALWAYS have matching versions" >> $GITHUB_STEP_SUMMARY
