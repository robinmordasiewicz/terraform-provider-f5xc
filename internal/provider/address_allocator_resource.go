// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AddressAllocatorResource{}
	_ resource.ResourceWithConfigure      = &AddressAllocatorResource{}
	_ resource.ResourceWithImportState    = &AddressAllocatorResource{}
	_ resource.ResourceWithModifyPlan     = &AddressAllocatorResource{}
	_ resource.ResourceWithUpgradeState   = &AddressAllocatorResource{}
	_ resource.ResourceWithValidateConfig = &AddressAllocatorResource{}
)

// address_allocatorSchemaVersion is the schema version for state upgrades
const address_allocatorSchemaVersion int64 = 1

func NewAddressAllocatorResource() resource.Resource {
	return &AddressAllocatorResource{}
}

type AddressAllocatorResource struct {
	client *client.Client
}

// AddressAllocatorEmptyModel represents empty nested blocks
type AddressAllocatorEmptyModel struct {
}

// AddressAllocatorAddressAllocationSchemeModel represents address_allocation_scheme block
type AddressAllocatorAddressAllocationSchemeModel struct {
	AllocationUnit              types.Int64  `tfsdk:"allocation_unit"`
	LocalInterfaceAddressOffset types.Int64  `tfsdk:"local_interface_address_offset"`
	LocalInterfaceAddressType   types.String `tfsdk:"local_interface_address_type"`
}

type AddressAllocatorResourceModel struct {
	Name                    types.String                                  `tfsdk:"name"`
	Namespace               types.String                                  `tfsdk:"namespace"`
	AddressPool             types.List                                    `tfsdk:"address_pool"`
	Annotations             types.Map                                     `tfsdk:"annotations"`
	Description             types.String                                  `tfsdk:"description"`
	Disable                 types.Bool                                    `tfsdk:"disable"`
	Labels                  types.Map                                     `tfsdk:"labels"`
	ID                      types.String                                  `tfsdk:"id"`
	Mode                    types.String                                  `tfsdk:"mode"`
	Timeouts                timeouts.Value                                `tfsdk:"timeouts"`
	AddressAllocationScheme *AddressAllocatorAddressAllocationSchemeModel `tfsdk:"address_allocation_scheme"`
}

func (r *AddressAllocatorResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_address_allocator"
}

func (r *AddressAllocatorResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             address_allocatorSchemaVersion,
		MarkdownDescription: "Manages Address Allocator will create an address allocator object in 'system' namespace of the user in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Address Allocator. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Address Allocator will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"address_pool": schema.ListAttribute{
				MarkdownDescription: "Address Pool. Address pool from which the allocator carves out subnets or addresses to its clients.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"mode": schema.StringAttribute{
				MarkdownDescription: "Allocator Mode. Mode of the address allocator Address allocator is for VERs within the local cluster or site Allocation is per site and then per node. Possible values are `LOCAL`, `GLOBAL_PER_SITE_NODE`. Defaults to `LOCAL`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"address_allocation_scheme": schema.SingleNestedBlock{
				MarkdownDescription: "Address Allocation Scheme. Decides the scheme to be used to allocate addresses from the configured address pool.",
				Attributes: map[string]schema.Attribute{
					"allocation_unit": schema.Int64Attribute{
						MarkdownDescription: "Allocation Unit. Prefix length indicating the size of each allocated subnet. For example, if this is specified as 30, subnets of /30 will be allocated from the given address pool.",
						Optional:            true,
					},
					"local_interface_address_offset": schema.Int64Attribute{
						MarkdownDescription: "Local Interface Address Offset. This is used to derive address for the local interface from the allocated subnet. If Local Interface Address Type is set to 'Offset from beginning of Subnet', this offset value is added to the allocated subnet and used as the local interface address. For example, if the allocated subnet is 169.254.0.0/30 and offset is set to 2 with Local Interface Address Type set to 'Offset from beginning of Subnet', local interface address of 169.254.0.2 is used. If Local Interface Address Type is set to 'Offset from end of Subnet', this offset value is subtracted from the end of the allocated subnet and used as the local interface address. For example, if the allocated subnet is 169.254.0.0/30 and offset is set to 1 with Local Interface Address Type set to 'Offset from end of Subnet', local interface address of 169.254.0.2 is used.",
						Optional:            true,
					},
					"local_interface_address_type": schema.StringAttribute{
						MarkdownDescription: "Local Interface Address Type. Dictates how local interface address is derived from the allocated subnet Use Nth address of the allocated subnet as the local interface address, N being the Local Interface Address Offset. For example, if the allocated subnet is 169.254.0.0/30, Local Interface Address Offset is set to 2 and Local Interface Address Type is set to 'Offset from beginning of Subnet', local address of 169.254.0.2 is used. Use Nth last address of the allocated subnet as the local interface address, N being the Local Interface Address Offset. For example, if the allocated subnet is 169.254.0.0/30, Local Interface Address Offset is set to 1 and Local Interface Address Type is set to 'Offset from end of Subnet', local address of 169.254.0.2 is used. This case is used for external_connector. Possible values are `LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_BEGIN`, `LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_END`, `LOCAL_INTERFACE_ADDRESS_FROM_PREFIX`. Defaults to `LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_BEGIN`.",
						Optional:            true,
					},
				},
			},
		},
	}
}

func (r *AddressAllocatorResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AddressAllocatorResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AddressAllocatorResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AddressAllocatorResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the address_allocator from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AddressAllocatorResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AddressAllocatorResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AddressAllocatorResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AddressAllocatorResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AddressAllocatorResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating address_allocator", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.AddressAllocator{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AddressAllocationScheme != nil {
		address_allocation_schemeMap := make(map[string]interface{})
		if !data.AddressAllocationScheme.AllocationUnit.IsNull() && !data.AddressAllocationScheme.AllocationUnit.IsUnknown() {
			address_allocation_schemeMap["allocation_unit"] = data.AddressAllocationScheme.AllocationUnit.ValueInt64()
		}
		if !data.AddressAllocationScheme.LocalInterfaceAddressOffset.IsNull() && !data.AddressAllocationScheme.LocalInterfaceAddressOffset.IsUnknown() {
			address_allocation_schemeMap["local_interface_address_offset"] = data.AddressAllocationScheme.LocalInterfaceAddressOffset.ValueInt64()
		}
		if !data.AddressAllocationScheme.LocalInterfaceAddressType.IsNull() && !data.AddressAllocationScheme.LocalInterfaceAddressType.IsUnknown() {
			address_allocation_schemeMap["local_interface_address_type"] = data.AddressAllocationScheme.LocalInterfaceAddressType.ValueString()
		}
		createReq.Spec["address_allocation_scheme"] = address_allocation_schemeMap
	}
	if !data.AddressPool.IsNull() && !data.AddressPool.IsUnknown() {
		var address_poolList []string
		resp.Diagnostics.Append(data.AddressPool.ElementsAs(ctx, &address_poolList, false)...)
		if !resp.Diagnostics.HasError() {
			createReq.Spec["address_pool"] = address_poolList
		}
	}
	if !data.Mode.IsNull() && !data.Mode.IsUnknown() {
		createReq.Spec["mode"] = data.Mode.ValueString()
	}

	apiResource, err := r.client.CreateAddressAllocator(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AddressAllocator: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["address_allocation_scheme"].(map[string]interface{}); ok && (isImport || data.AddressAllocationScheme != nil) {
		data.AddressAllocationScheme = &AddressAllocatorAddressAllocationSchemeModel{
			AllocationUnit: func() types.Int64 {
				if v, ok := blockData["allocation_unit"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LocalInterfaceAddressOffset: func() types.Int64 {
				if v, ok := blockData["local_interface_address_offset"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LocalInterfaceAddressType: func() types.String {
				if v, ok := blockData["local_interface_address_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address_pool"].([]interface{}); ok && len(v) > 0 {
		var address_poolList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				address_poolList = append(address_poolList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, address_poolList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.AddressPool = listVal
		}
	} else {
		data.AddressPool = types.ListNull(types.StringType)
	}
	if v, ok := apiResource.Spec["mode"].(string); ok && v != "" {
		data.Mode = types.StringValue(v)
	} else {
		data.Mode = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created AddressAllocator resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AddressAllocatorResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AddressAllocatorResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAddressAllocator(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AddressAllocator not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AddressAllocator: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The address_allocator may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["address_allocation_scheme"].(map[string]interface{}); ok && (isImport || data.AddressAllocationScheme != nil) {
		data.AddressAllocationScheme = &AddressAllocatorAddressAllocationSchemeModel{
			AllocationUnit: func() types.Int64 {
				if v, ok := blockData["allocation_unit"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LocalInterfaceAddressOffset: func() types.Int64 {
				if v, ok := blockData["local_interface_address_offset"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LocalInterfaceAddressType: func() types.String {
				if v, ok := blockData["local_interface_address_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address_pool"].([]interface{}); ok && len(v) > 0 {
		var address_poolList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				address_poolList = append(address_poolList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, address_poolList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.AddressPool = listVal
		}
	} else {
		data.AddressPool = types.ListNull(types.StringType)
	}
	if v, ok := apiResource.Spec["mode"].(string); ok && v != "" {
		data.Mode = types.StringValue(v)
	} else {
		data.Mode = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AddressAllocatorResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AddressAllocatorResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.AddressAllocator{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AddressAllocationScheme != nil {
		address_allocation_schemeMap := make(map[string]interface{})
		if !data.AddressAllocationScheme.AllocationUnit.IsNull() && !data.AddressAllocationScheme.AllocationUnit.IsUnknown() {
			address_allocation_schemeMap["allocation_unit"] = data.AddressAllocationScheme.AllocationUnit.ValueInt64()
		}
		if !data.AddressAllocationScheme.LocalInterfaceAddressOffset.IsNull() && !data.AddressAllocationScheme.LocalInterfaceAddressOffset.IsUnknown() {
			address_allocation_schemeMap["local_interface_address_offset"] = data.AddressAllocationScheme.LocalInterfaceAddressOffset.ValueInt64()
		}
		if !data.AddressAllocationScheme.LocalInterfaceAddressType.IsNull() && !data.AddressAllocationScheme.LocalInterfaceAddressType.IsUnknown() {
			address_allocation_schemeMap["local_interface_address_type"] = data.AddressAllocationScheme.LocalInterfaceAddressType.ValueString()
		}
		apiResource.Spec["address_allocation_scheme"] = address_allocation_schemeMap
	}
	if !data.AddressPool.IsNull() && !data.AddressPool.IsUnknown() {
		var address_poolList []string
		resp.Diagnostics.Append(data.AddressPool.ElementsAs(ctx, &address_poolList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["address_pool"] = address_poolList
		}
	}
	if !data.Mode.IsNull() && !data.Mode.IsUnknown() {
		apiResource.Spec["mode"] = data.Mode.ValueString()
	}

	_, err := r.client.UpdateAddressAllocator(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AddressAllocator: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAddressAllocator(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AddressAllocator after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["mode"].(string); ok && v != "" {
		data.Mode = types.StringValue(v)
	} else if data.Mode.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Mode = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["address_allocation_scheme"].(map[string]interface{}); ok && (isImport || data.AddressAllocationScheme != nil) {
		data.AddressAllocationScheme = &AddressAllocatorAddressAllocationSchemeModel{
			AllocationUnit: func() types.Int64 {
				if v, ok := blockData["allocation_unit"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LocalInterfaceAddressOffset: func() types.Int64 {
				if v, ok := blockData["local_interface_address_offset"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LocalInterfaceAddressType: func() types.String {
				if v, ok := blockData["local_interface_address_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address_pool"].([]interface{}); ok && len(v) > 0 {
		var address_poolList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				address_poolList = append(address_poolList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, address_poolList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.AddressPool = listVal
		}
	} else {
		data.AddressPool = types.ListNull(types.StringType)
	}
	if v, ok := apiResource.Spec["mode"].(string); ok && v != "" {
		data.Mode = types.StringValue(v)
	} else {
		data.Mode = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AddressAllocatorResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AddressAllocatorResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAddressAllocator(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AddressAllocator already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "AddressAllocator delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AddressAllocator: %s", err))
		return
	}
}

func (r *AddressAllocatorResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
