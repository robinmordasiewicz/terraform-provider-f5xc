// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &APMResource{}
	_ resource.ResourceWithConfigure      = &APMResource{}
	_ resource.ResourceWithImportState    = &APMResource{}
	_ resource.ResourceWithModifyPlan     = &APMResource{}
	_ resource.ResourceWithUpgradeState   = &APMResource{}
	_ resource.ResourceWithValidateConfig = &APMResource{}
)

// apmSchemaVersion is the schema version for state upgrades
const apmSchemaVersion int64 = 1

func NewAPMResource() resource.Resource {
	return &APMResource{}
}

type APMResource struct {
	client *client.Client
}

// APMEmptyModel represents empty nested blocks
type APMEmptyModel struct {
}

// APMAWSSiteTypeChoiceModel represents aws_site_type_choice block
type APMAWSSiteTypeChoiceModel struct {
	APMAWSSite       *APMAWSSiteTypeChoiceAPMAWSSiteModel       `tfsdk:"apm_aws_site"`
	MarketPlaceImage *APMAWSSiteTypeChoiceMarketPlaceImageModel `tfsdk:"market_place_image"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteModel represents apm_aws_site block
type APMAWSSiteTypeChoiceAPMAWSSiteModel struct {
	AdminUsername   types.String                                        `tfsdk:"admin_username"`
	SSHKey          types.String                                        `tfsdk:"ssh_key"`
	AdminPassword   *APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel   `tfsdk:"admin_password"`
	AWSTGWSite      *APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel      `tfsdk:"aws_tgw_site"`
	EndpointService *APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel `tfsdk:"endpoint_service"`
	Nodes           []APMAWSSiteTypeChoiceAPMAWSSiteNodesModel          `tfsdk:"nodes"`
	Tags            *APMEmptyModel                                      `tfsdk:"tags"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel represents admin_password block
type APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel represents aws_tgw_site block
type APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel struct {
	AWSTGWSite *APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel `tfsdk:"aws_tgw_site"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel represents aws_tgw_site block
type APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel represents endpoint_service block
type APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel struct {
	ConfiguredVip            types.String                                                      `tfsdk:"configured_vip"`
	AdvertiseOnSLOIP         *APMEmptyModel                                                    `tfsdk:"advertise_on_slo_ip"`
	AdvertiseOnSLOIPExternal *APMEmptyModel                                                    `tfsdk:"advertise_on_slo_ip_external"`
	AutomaticVip             *APMEmptyModel                                                    `tfsdk:"automatic_vip"`
	CustomTCPPorts           *APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel `tfsdk:"custom_tcp_ports"`
	CustomUDPPorts           *APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel `tfsdk:"custom_udp_ports"`
	DefaultTCPPorts          *APMEmptyModel                                                    `tfsdk:"default_tcp_ports"`
	DisableAdvertiseOnSLOIP  *APMEmptyModel                                                    `tfsdk:"disable_advertise_on_slo_ip"`
	HTTPPort                 *APMEmptyModel                                                    `tfsdk:"http_port"`
	HTTPSPort                *APMEmptyModel                                                    `tfsdk:"https_port"`
	NoTCPPorts               *APMEmptyModel                                                    `tfsdk:"no_tcp_ports"`
	NoUDPPorts               *APMEmptyModel                                                    `tfsdk:"no_udp_ports"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel represents custom_tcp_ports block
type APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel represents custom_udp_ports block
type APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesModel represents nodes block
type APMAWSSiteTypeChoiceAPMAWSSiteNodesModel struct {
	AWSAzName          types.String                                        `tfsdk:"aws_az_name"`
	NodeName           types.String                                        `tfsdk:"node_name"`
	TunnelPrefix       types.String                                        `tfsdk:"tunnel_prefix"`
	AutomaticPrefix    *APMEmptyModel                                      `tfsdk:"automatic_prefix"`
	MgmtSubnet         *APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel `tfsdk:"mgmt_subnet"`
	ReservedMgmtSubnet *APMEmptyModel                                      `tfsdk:"reserved_mgmt_subnet"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel represents mgmt_subnet block
type APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel struct {
	ExistingSubnetID types.String                                                   `tfsdk:"existing_subnet_id"`
	SubnetParam      *APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel represents subnet_param block
type APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel struct {
	IPV4 types.String `tfsdk:"ipv4"`
}

// APMAWSSiteTypeChoiceMarketPlaceImageModel represents market_place_image block
type APMAWSSiteTypeChoiceMarketPlaceImageModel struct {
	Bestpluspayg200mbps *APMEmptyModel `tfsdk:"best_plus_pay_g200_mbps"`
	BestPlusPayg1gbps   *APMEmptyModel `tfsdk:"best_plus_payg_1gbps"`
}

// APMBaremetalSiteTypeChoiceModel represents baremetal_site_type_choice block
type APMBaremetalSiteTypeChoiceModel struct {
	F5BareMetalSite *APMBaremetalSiteTypeChoiceF5BareMetalSiteModel `tfsdk:"f5_bare_metal_site"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteModel represents f5_bare_metal_site block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteModel struct {
	AdminUsername     types.String                                                 `tfsdk:"admin_username"`
	PublicDownloadURL types.String                                                 `tfsdk:"public_download_url"`
	SSHKey            types.String                                                 `tfsdk:"ssh_key"`
	AdminPassword     *APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel `tfsdk:"admin_password"`
	BareMetalSite     *APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel `tfsdk:"bare_metal_site"`
	BigiqInstance     *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel `tfsdk:"bigiq_instance"`
	Nodes             []APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel        `tfsdk:"nodes"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel represents admin_password block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel represents bare_metal_site block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel represents bigiq_instance block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel struct {
	LicensePoolName types.String                                                         `tfsdk:"license_pool_name"`
	LicenseServerIP types.String                                                         `tfsdk:"license_server_ip"`
	SkuName         types.String                                                         `tfsdk:"sku_name"`
	Username        types.String                                                         `tfsdk:"username"`
	Password        *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel `tfsdk:"password"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel represents password block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel struct {
	BlindfoldSecretInfo *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel represents clear_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel represents nodes block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel struct {
	BmNodeMemorySize  types.String                                                          `tfsdk:"bm_node_memory_size"`
	BmVirtualCpuCount types.String                                                          `tfsdk:"bm_virtual_cpu_count"`
	NodeName          types.String                                                          `tfsdk:"node_name"`
	ExternalInterface *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel `tfsdk:"external_interface"`
	InternalInterface *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel `tfsdk:"internal_interface"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel represents external_interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel struct {
	NetworkGateway types.String                                                                   `tfsdk:"network_gateway"`
	NetworkSelfIP  types.String                                                                   `tfsdk:"network_self_ip"`
	Interface      *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel `tfsdk:"interface"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel represents interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel represents internal_interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel struct {
	NetworkGateway types.String                                                                   `tfsdk:"network_gateway"`
	NetworkSelfIP  types.String                                                                   `tfsdk:"network_self_ip"`
	Interface      *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel `tfsdk:"interface"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel represents interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementModel represents https_management block
type APMHTTPSManagementModel struct {
	DomainSuffix                  types.String                                      `tfsdk:"domain_suffix"`
	HTTPSPort                     types.Int64                                       `tfsdk:"https_port"`
	AdvertiseOnInternet           *APMHTTPSManagementAdvertiseOnInternetModel       `tfsdk:"advertise_on_internet"`
	AdvertiseOnInternetDefaultVip *APMEmptyModel                                    `tfsdk:"advertise_on_internet_default_vip"`
	AdvertiseOnSLIVip             *APMHTTPSManagementAdvertiseOnSLIVipModel         `tfsdk:"advertise_on_sli_vip"`
	AdvertiseOnSLOInternetVip     *APMHTTPSManagementAdvertiseOnSLOInternetVipModel `tfsdk:"advertise_on_slo_internet_vip"`
	AdvertiseOnSLOSLI             *APMHTTPSManagementAdvertiseOnSLOSLIModel         `tfsdk:"advertise_on_slo_sli"`
	AdvertiseOnSLOVip             *APMHTTPSManagementAdvertiseOnSLOVipModel         `tfsdk:"advertise_on_slo_vip"`
	DefaultHTTPSPort              *APMEmptyModel                                    `tfsdk:"default_https_port"`
}

// APMHTTPSManagementAdvertiseOnInternetModel represents advertise_on_internet block
type APMHTTPSManagementAdvertiseOnInternetModel struct {
	PublicIP *APMHTTPSManagementAdvertiseOnInternetPublicIPModel `tfsdk:"public_ip"`
}

// APMHTTPSManagementAdvertiseOnInternetPublicIPModel represents public_ip block
type APMHTTPSManagementAdvertiseOnInternetPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLIVipModel represents advertise_on_sli_vip block
type APMHTTPSManagementAdvertiseOnSLIVipModel struct {
	NoMtls          *APMEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSLIVipTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSLIVipUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesModel struct {
	CertificateURL       types.String                                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling  *APMEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSLIVipTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSLIVipTLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSLIVipTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                   `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSLIVipTLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSLIVipTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSLIVipUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSLIVipUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                  `tfsdk:"client_certificate_optional"`
	TrustedCaURL              types.String                                                `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSLIVipUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCa                 *APMHTTPSManagementAdvertiseOnSLIVipUseMtlsTrustedCaModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSLIVipUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSLIVipUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSLIVipUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLIVipUseMtlsTrustedCaModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSLIVipUseMtlsTrustedCaModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLIVipUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSLIVipUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipModel represents advertise_on_slo_internet_vip block
type APMHTTPSManagementAdvertiseOnSLOInternetVipModel struct {
	NoMtls          *APMEmptyModel                                                    `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSLOInternetVipTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesModel struct {
	CertificateURL       types.String                                                                         `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                         `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling  *APMEmptyModel                                                                       `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                                       `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSLOInternetVipTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                           `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                           `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                           `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipTLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSLOInternetVipTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                          `tfsdk:"client_certificate_optional"`
	TrustedCaURL              types.String                                                        `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                                      `tfsdk:"no_crl"`
	TrustedCa                 *APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsTrustedCaModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                                      `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsTrustedCaModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsTrustedCaModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSLOInternetVipUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSLOSLIModel represents advertise_on_slo_sli block
type APMHTTPSManagementAdvertiseOnSLOSLIModel struct {
	NoMtls          *APMEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSLOSLITLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesModel struct {
	CertificateURL       types.String                                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling  *APMEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSLOSLITLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSLOSLITLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSLOSLITLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                   `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSLOSLITLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSLOSLITLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                  `tfsdk:"client_certificate_optional"`
	TrustedCaURL              types.String                                                `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCa                 *APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsTrustedCaModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsTrustedCaModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsTrustedCaModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSLOSLIUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSLOVipModel represents advertise_on_slo_vip block
type APMHTTPSManagementAdvertiseOnSLOVipModel struct {
	NoMtls          *APMEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSLOVipTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSLOVipUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesModel struct {
	CertificateURL       types.String                                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling  *APMEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSLOVipTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSLOVipTLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSLOVipTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                   `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSLOVipTLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSLOVipTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSLOVipUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSLOVipUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                  `tfsdk:"client_certificate_optional"`
	TrustedCaURL              types.String                                                `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSLOVipUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCa                 *APMHTTPSManagementAdvertiseOnSLOVipUseMtlsTrustedCaModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSLOVipUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSLOVipUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSLOVipUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLOVipUseMtlsTrustedCaModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSLOVipUseMtlsTrustedCaModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLOVipUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSLOVipUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

type APMResourceModel struct {
	Name                    types.String                     `tfsdk:"name"`
	Namespace               types.String                     `tfsdk:"namespace"`
	Annotations             types.Map                        `tfsdk:"annotations"`
	Description             types.String                     `tfsdk:"description"`
	Disable                 types.Bool                       `tfsdk:"disable"`
	Labels                  types.Map                        `tfsdk:"labels"`
	ID                      types.String                     `tfsdk:"id"`
	Timeouts                timeouts.Value                   `tfsdk:"timeouts"`
	AWSSiteTypeChoice       *APMAWSSiteTypeChoiceModel       `tfsdk:"aws_site_type_choice"`
	BaremetalSiteTypeChoice *APMBaremetalSiteTypeChoiceModel `tfsdk:"baremetal_site_type_choice"`
	HTTPSManagement         *APMHTTPSManagementModel         `tfsdk:"https_management"`
}

func (r *APMResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_apm"
}

func (r *APMResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             apmSchemaVersion,
		MarkdownDescription: "Manages new APM as a service with configured parameters in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the APM. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the APM will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"aws_site_type_choice": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: aws_site_type_choice, baremetal_site_type_choice] AWS Transit Gateway Site choice. Virtual F5 BIG-IP APM service to be deployed as external service on AWS Transit Gateway Site",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"apm_aws_site": schema.SingleNestedBlock{
						MarkdownDescription: "Virtual F5 BIG-IP APM configuration on AWS TGW Site. Virtual F5 BIG-IP configuration for AWS TGW Site using BIG-IP APM service",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Admin Username. Admin Username for BIG-IP",
								Optional:            true,
							},
							"ssh_key": schema.StringAttribute{
								MarkdownDescription: "Public SSH key. Public SSH key for accessing the BIG-IP nodes.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"aws_tgw_site": schema.SingleNestedBlock{
								MarkdownDescription: "BIG-IP AWS TGW Site. BIG-IP AWS TGW site specification",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"aws_tgw_site": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
								},
							},
							"endpoint_service": schema.SingleNestedBlock{
								MarkdownDescription: "Endpoint Service. Endpoint Service is a type of service where the packets are destined to BIG-IP APM device and service modifies the destination with a new destination address",
								Attributes: map[string]schema.Attribute{
									"configured_vip": schema.StringAttribute{
										MarkdownDescription: "Configured VIP. Enter IP address for the default VIP",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_on_slo_ip": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"advertise_on_slo_ip_external": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"automatic_vip": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"custom_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Port Range List. List of port ranges",
										Attributes: map[string]schema.Attribute{
											"ports": schema.ListAttribute{
												MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
									"custom_udp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Port Range List. List of port ranges",
										Attributes: map[string]schema.Attribute{
											"ports": schema.ListAttribute{
												MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
									"default_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"disable_advertise_on_slo_ip": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"http_port": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"https_port": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_udp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Service Nodes. Specify how and where the service nodes are spawned",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"aws_az_name": schema.StringAttribute{
											MarkdownDescription: "AWS AZ Name. The AWS Availability Zone must be consistent with the AWS Region chosen. Please select an AZ in the same Region as your TGW Site",
											Optional:            true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
											Optional:            true,
										},
										"tunnel_prefix": schema.StringAttribute{
											MarkdownDescription: "Tunnel IP Prefix. Enter IP prefix for the tunnel, it has to be /30",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"automatic_prefix": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
											Attributes: map[string]schema.Attribute{
												"existing_subnet_id": schema.StringAttribute{
													MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"subnet_param": schema.SingleNestedBlock{
													MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
													Attributes: map[string]schema.Attribute{
														"ipv4": schema.StringAttribute{
															MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
															Optional:            true,
														},
													},
												},
											},
										},
										"reserved_mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tags": schema.SingleNestedBlock{
								MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
							},
						},
					},
					"market_place_image": schema.SingleNestedBlock{
						MarkdownDescription: "BIG-IP AWS Marketplace Image. Select the flavor of BIG-IP AWS Marketplace to launch the instance on AWS TGW Site",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"best_plus_pay_g200_mbps": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"best_plus_payg_1gbps": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},
			},
			"baremetal_site_type_choice": schema.SingleNestedBlock{
				MarkdownDescription: "Virtual BIG-IP on App Stack Bare Metal Site. Virtual BIG-IP specification for App Stack Bare Metal Site",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"f5_bare_metal_site": schema.SingleNestedBlock{
						MarkdownDescription: "Virtual BIG-IP on App Stack bare metal. Virtual BIG-IP specification for App Stack bare metal",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Admin Username. Admin Username for BIG-IP",
								Optional:            true,
							},
							"public_download_url": schema.StringAttribute{
								MarkdownDescription: "Image URL. Public URL where BIG-IP VE image (qcow2) is hosted",
								Optional:            true,
							},
							"ssh_key": schema.StringAttribute{
								MarkdownDescription: "Public SSH key. Public SSH key for accessing the BIG-IP nodes.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"bare_metal_site": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
									},
								},
							},
							"bigiq_instance": schema.SingleNestedBlock{
								MarkdownDescription: "License Server Details. Specification for BIG-IQ Instance, where and what",
								Attributes: map[string]schema.Attribute{
									"license_pool_name": schema.StringAttribute{
										MarkdownDescription: "License Pool Name. Name of Utility Pool on BIG-IQ",
										Optional:            true,
									},
									"license_server_ip": schema.StringAttribute{
										MarkdownDescription: "License Server IP. IP Address from the TCP Load Balancer which is configured to communicate with License Server",
										Optional:            true,
									},
									"sku_name": schema.StringAttribute{
										MarkdownDescription: "Offering Name. License offering name aka SKU name",
										Optional:            true,
									},
									"username": schema.StringAttribute{
										MarkdownDescription: "User Name. User Name used to access BIG-IQ to activate the license",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"password": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Service Nodes. Specify how and where the service nodes are spawned",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"bm_node_memory_size": schema.StringAttribute{
											MarkdownDescription: "Bare Metal ServiceNode Memory Size. Enum to define amount of memory to be assigned to the node - BM_8_GB_MEMORY: 8 GB - BM_16_GB_MEMORY: 16 GB - BM_32_GB_MEMORY: 32 GB. Possible values are `BM_8_GB_MEMORY`, `BM_16_GB_MEMORY`, `BM_32_GB_MEMORY`. Defaults to `BM_8_GB_MEMORY`.",
											Optional:            true,
										},
										"bm_virtual_cpu_count": schema.StringAttribute{
											MarkdownDescription: "Bare Metal ServiceNode Virtual CPU Count. Enum to define number of virtual CPU's to be assigned to the node - BM_4_VCPU: 4 virtual CPUs - BM_8_VCPU: 8 virtual CPUs. Possible values are `BM_4_VCPU`, `BM_8_VCPU`. Defaults to `BM_4_VCPU`.",
											Optional:            true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"external_interface": schema.SingleNestedBlock{
											MarkdownDescription: "Interface. x-required BIG-IP interface details",
											Attributes: map[string]schema.Attribute{
												"network_gateway": schema.StringAttribute{
													MarkdownDescription: "Default Gateway.",
													Optional:            true,
												},
												"network_self_ip": schema.StringAttribute{
													MarkdownDescription: "Self IP. Self IP CIDR",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"interface": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
										"internal_interface": schema.SingleNestedBlock{
											MarkdownDescription: "Interface. x-required BIG-IP interface details",
											Attributes: map[string]schema.Attribute{
												"network_gateway": schema.StringAttribute{
													MarkdownDescription: "Default Gateway.",
													Optional:            true,
												},
												"network_self_ip": schema.StringAttribute{
													MarkdownDescription: "Self IP. Self IP CIDR",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"interface": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"https_management": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS based management. HTTPS based configuration",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain Suffix. Domain suffix will be used along with node name to form URL to access node management",
						Optional:            true,
					},
					"https_port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS Port. Enter TCP port number",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_internet": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"public_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
									},
								},
							},
						},
					},
					"advertise_on_internet_default_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"advertise_on_sli_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"default_https_port": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
		},
	}
}

func (r *APMResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *APMResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *APMResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the apm from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan APMResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *APMResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := APMResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *APMResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating apm", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.APM{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AWSSiteTypeChoice != nil {
		aws_site_type_choiceMap := make(map[string]interface{})
		if data.AWSSiteTypeChoice.APMAWSSite != nil {
			apm_aws_siteNestedMap := make(map[string]interface{})
			if !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsUnknown() {
				apm_aws_siteNestedMap["admin_username"] = data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.ValueString()
			}
			if !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsUnknown() {
				apm_aws_siteNestedMap["ssh_key"] = data.AWSSiteTypeChoice.APMAWSSite.SSHKey.ValueString()
			}
			aws_site_type_choiceMap["apm_aws_site"] = apm_aws_siteNestedMap
		}
		if data.AWSSiteTypeChoice.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			aws_site_type_choiceMap["market_place_image"] = market_place_imageNestedMap
		}
		createReq.Spec["aws_site_type_choice"] = aws_site_type_choiceMap
	}
	if data.BaremetalSiteTypeChoice != nil {
		baremetal_site_type_choiceMap := make(map[string]interface{})
		if data.BaremetalSiteTypeChoice.F5BareMetalSite != nil {
			f5_bare_metal_siteNestedMap := make(map[string]interface{})
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsUnknown() {
				f5_bare_metal_siteNestedMap["admin_username"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsUnknown() {
				f5_bare_metal_siteNestedMap["public_download_url"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsUnknown() {
				f5_bare_metal_siteNestedMap["ssh_key"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.ValueString()
			}
			baremetal_site_type_choiceMap["f5_bare_metal_site"] = f5_bare_metal_siteNestedMap
		}
		createReq.Spec["baremetal_site_type_choice"] = baremetal_site_type_choiceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVip != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVip != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSLOInternetVip != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSLOSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSLOVip != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		createReq.Spec["https_management"] = https_managementMap
	}

	apiResource, err := r.client.CreateAPM(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create APM: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["aws_site_type_choice"].(map[string]interface{}); ok && isImport && data.AWSSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AWSSiteTypeChoice = &APMAWSSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["baremetal_site_type_choice"].(map[string]interface{}); ok && isImport && data.BaremetalSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BaremetalSiteTypeChoice = &APMBaremetalSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &APMHTTPSManagementModel{
			AdvertiseOnInternet: func() *APMHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVip: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVip: func() *APMHTTPSManagementAdvertiseOnSLIVipModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVip != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLIVipModel{}
				}
				return nil
			}(),
			AdvertiseOnSLOInternetVip: func() *APMHTTPSManagementAdvertiseOnSLOInternetVipModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLOInternetVip != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLOInternetVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLOInternetVipModel{}
				}
				return nil
			}(),
			AdvertiseOnSLOSLI: func() *APMHTTPSManagementAdvertiseOnSLOSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLOSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLOSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLOSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSLOVip: func() *APMHTTPSManagementAdvertiseOnSLOVipModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLOVip != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLOVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLOVipModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created APM resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "APM not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read APM: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The apm may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["aws_site_type_choice"].(map[string]interface{}); ok && isImport && data.AWSSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AWSSiteTypeChoice = &APMAWSSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["baremetal_site_type_choice"].(map[string]interface{}); ok && isImport && data.BaremetalSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BaremetalSiteTypeChoice = &APMBaremetalSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &APMHTTPSManagementModel{
			AdvertiseOnInternet: func() *APMHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVip: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVip: func() *APMHTTPSManagementAdvertiseOnSLIVipModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVip != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLIVipModel{}
				}
				return nil
			}(),
			AdvertiseOnSLOInternetVip: func() *APMHTTPSManagementAdvertiseOnSLOInternetVipModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLOInternetVip != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLOInternetVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLOInternetVipModel{}
				}
				return nil
			}(),
			AdvertiseOnSLOSLI: func() *APMHTTPSManagementAdvertiseOnSLOSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLOSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLOSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLOSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSLOVip: func() *APMHTTPSManagementAdvertiseOnSLOVipModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLOVip != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLOVip
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLOVipModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.APM{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AWSSiteTypeChoice != nil {
		aws_site_type_choiceMap := make(map[string]interface{})
		if data.AWSSiteTypeChoice.APMAWSSite != nil {
			apm_aws_siteNestedMap := make(map[string]interface{})
			if !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsUnknown() {
				apm_aws_siteNestedMap["admin_username"] = data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.ValueString()
			}
			if !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsUnknown() {
				apm_aws_siteNestedMap["ssh_key"] = data.AWSSiteTypeChoice.APMAWSSite.SSHKey.ValueString()
			}
			aws_site_type_choiceMap["apm_aws_site"] = apm_aws_siteNestedMap
		}
		if data.AWSSiteTypeChoice.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			aws_site_type_choiceMap["market_place_image"] = market_place_imageNestedMap
		}
		apiResource.Spec["aws_site_type_choice"] = aws_site_type_choiceMap
	}
	if data.BaremetalSiteTypeChoice != nil {
		baremetal_site_type_choiceMap := make(map[string]interface{})
		if data.BaremetalSiteTypeChoice.F5BareMetalSite != nil {
			f5_bare_metal_siteNestedMap := make(map[string]interface{})
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsUnknown() {
				f5_bare_metal_siteNestedMap["admin_username"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsUnknown() {
				f5_bare_metal_siteNestedMap["public_download_url"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsUnknown() {
				f5_bare_metal_siteNestedMap["ssh_key"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.ValueString()
			}
			baremetal_site_type_choiceMap["f5_bare_metal_site"] = f5_bare_metal_siteNestedMap
		}
		apiResource.Spec["baremetal_site_type_choice"] = baremetal_site_type_choiceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVip != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVip != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSLOInternetVip != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSLOSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSLOVip != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		apiResource.Spec["https_management"] = https_managementMap
	}

	updated, err := r.client.UpdateAPM(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update APM: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "APM already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "APM delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete APM: %s", err))
		return
	}
}

func (r *APMResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
