// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &APMResource{}
	_ resource.ResourceWithConfigure      = &APMResource{}
	_ resource.ResourceWithImportState    = &APMResource{}
	_ resource.ResourceWithModifyPlan     = &APMResource{}
	_ resource.ResourceWithValidateConfig = &APMResource{}
)

func NewAPMResource() resource.Resource {
	return &APMResource{}
}

type APMResource struct {
	client *client.Client
}

// APMEmptyModel represents empty nested blocks
type APMEmptyModel struct {
}

// APMAWSSiteTypeChoiceModel represents aws_site_type_choice block
type APMAWSSiteTypeChoiceModel struct {
	APMAWSSite       *APMAWSSiteTypeChoiceAPMAWSSiteModel       `tfsdk:"apm_aws_site"`
	MarketPlaceImage *APMAWSSiteTypeChoiceMarketPlaceImageModel `tfsdk:"market_place_image"`
}

// APMAWSSiteTypeChoiceModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceModel
var APMAWSSiteTypeChoiceModelAttrTypes = map[string]attr.Type{
	"apm_aws_site":       types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteModelAttrTypes},
	"market_place_image": types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceMarketPlaceImageModelAttrTypes},
}

// APMAWSSiteTypeChoiceAPMAWSSiteModel represents apm_aws_site block
type APMAWSSiteTypeChoiceAPMAWSSiteModel struct {
	AdminUsername   types.String                                        `tfsdk:"admin_username"`
	SSHKey          types.String                                        `tfsdk:"ssh_key"`
	AdminPassword   *APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel   `tfsdk:"admin_password"`
	AWSTGWSite      *APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel      `tfsdk:"aws_tgw_site"`
	EndpointService *APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel `tfsdk:"endpoint_service"`
	Nodes           []APMAWSSiteTypeChoiceAPMAWSSiteNodesModel          `tfsdk:"nodes"`
	Tags            *APMEmptyModel                                      `tfsdk:"tags"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteModel
var APMAWSSiteTypeChoiceAPMAWSSiteModelAttrTypes = map[string]attr.Type{
	"admin_username":   types.StringType,
	"ssh_key":          types.StringType,
	"admin_password":   types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModelAttrTypes},
	"aws_tgw_site":     types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModelAttrTypes},
	"endpoint_service": types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModelAttrTypes},
	"nodes":            types.ListType{ElemType: types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteNodesModelAttrTypes}},
	"tags":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel represents admin_password block
type APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModel
var APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModelAttrTypes},
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModel
var APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModel
var APMAWSSiteTypeChoiceAPMAWSSiteAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel represents aws_tgw_site block
type APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel struct {
	AWSTGWSite *APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel `tfsdk:"aws_tgw_site"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModel
var APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteModelAttrTypes = map[string]attr.Type{
	"aws_tgw_site": types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModelAttrTypes},
}

// APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel represents aws_tgw_site block
type APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModel
var APMAWSSiteTypeChoiceAPMAWSSiteAWSTGWSiteAWSTGWSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel represents endpoint_service block
type APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel struct {
	ConfiguredVIP            types.String                                                      `tfsdk:"configured_vip"`
	AdvertiseOnSloIP         *APMEmptyModel                                                    `tfsdk:"advertise_on_slo_ip"`
	AdvertiseOnSloIPExternal *APMEmptyModel                                                    `tfsdk:"advertise_on_slo_ip_external"`
	AutomaticVIP             *APMEmptyModel                                                    `tfsdk:"automatic_vip"`
	CustomTCPPorts           *APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel `tfsdk:"custom_tcp_ports"`
	CustomUDPPorts           *APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel `tfsdk:"custom_udp_ports"`
	DefaultTCPPorts          *APMEmptyModel                                                    `tfsdk:"default_tcp_ports"`
	DisableAdvertiseOnSloIP  *APMEmptyModel                                                    `tfsdk:"disable_advertise_on_slo_ip"`
	HTTPPort                 *APMEmptyModel                                                    `tfsdk:"http_port"`
	HTTPSPort                *APMEmptyModel                                                    `tfsdk:"https_port"`
	NoTCPPorts               *APMEmptyModel                                                    `tfsdk:"no_tcp_ports"`
	NoUDPPorts               *APMEmptyModel                                                    `tfsdk:"no_udp_ports"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModel
var APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceModelAttrTypes = map[string]attr.Type{
	"configured_vip":               types.StringType,
	"advertise_on_slo_ip":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo_ip_external": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"automatic_vip":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"custom_tcp_ports":             types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModelAttrTypes},
	"custom_udp_ports":             types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModelAttrTypes},
	"default_tcp_ports":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_advertise_on_slo_ip":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_port":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"https_port":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_tcp_ports":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_udp_ports":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel represents custom_tcp_ports block
type APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModel
var APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomTCPPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.StringType},
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel represents custom_udp_ports block
type APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModel
var APMAWSSiteTypeChoiceAPMAWSSiteEndpointServiceCustomUDPPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.StringType},
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesModel represents nodes block
type APMAWSSiteTypeChoiceAPMAWSSiteNodesModel struct {
	AWSAzName          types.String                                        `tfsdk:"aws_az_name"`
	NodeName           types.String                                        `tfsdk:"node_name"`
	TunnelPrefix       types.String                                        `tfsdk:"tunnel_prefix"`
	AutomaticPrefix    *APMEmptyModel                                      `tfsdk:"automatic_prefix"`
	MgmtSubnet         *APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel `tfsdk:"mgmt_subnet"`
	ReservedMgmtSubnet *APMEmptyModel                                      `tfsdk:"reserved_mgmt_subnet"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteNodesModel
var APMAWSSiteTypeChoiceAPMAWSSiteNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":          types.StringType,
	"node_name":            types.StringType,
	"tunnel_prefix":        types.StringType,
	"automatic_prefix":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mgmt_subnet":          types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModelAttrTypes},
	"reserved_mgmt_subnet": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel represents mgmt_subnet block
type APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel struct {
	ExistingSubnetID types.String                                                   `tfsdk:"existing_subnet_id"`
	SubnetParam      *APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModel
var APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModelAttrTypes},
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel represents subnet_param block
type APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModel
var APMAWSSiteTypeChoiceAPMAWSSiteNodesMgmtSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// APMAWSSiteTypeChoiceMarketPlaceImageModel represents market_place_image block
type APMAWSSiteTypeChoiceMarketPlaceImageModel struct {
	Bestpluspayg200mbps *APMEmptyModel `tfsdk:"best_plus_pay_g200_mbps"`
	BestPlusPayg1gbps   *APMEmptyModel `tfsdk:"best_plus_payg_1gbps"`
}

// APMAWSSiteTypeChoiceMarketPlaceImageModelAttrTypes defines the attribute types for APMAWSSiteTypeChoiceMarketPlaceImageModel
var APMAWSSiteTypeChoiceMarketPlaceImageModelAttrTypes = map[string]attr.Type{
	"best_plus_pay_g200_mbps": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"best_plus_payg_1gbps":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMBaremetalSiteTypeChoiceModel represents baremetal_site_type_choice block
type APMBaremetalSiteTypeChoiceModel struct {
	F5BareMetalSite *APMBaremetalSiteTypeChoiceF5BareMetalSiteModel `tfsdk:"f5_bare_metal_site"`
}

// APMBaremetalSiteTypeChoiceModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceModel
var APMBaremetalSiteTypeChoiceModelAttrTypes = map[string]attr.Type{
	"f5_bare_metal_site": types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteModel represents f5_bare_metal_site block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteModel struct {
	AdminUsername     types.String                                                 `tfsdk:"admin_username"`
	PublicDownloadURL types.String                                                 `tfsdk:"public_download_url"`
	SSHKey            types.String                                                 `tfsdk:"ssh_key"`
	AdminPassword     *APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel `tfsdk:"admin_password"`
	BareMetalSite     *APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel `tfsdk:"bare_metal_site"`
	BigiqInstance     *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel `tfsdk:"bigiq_instance"`
	Nodes             []APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel        `tfsdk:"nodes"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteModelAttrTypes = map[string]attr.Type{
	"admin_username":      types.StringType,
	"public_download_url": types.StringType,
	"ssh_key":             types.StringType,
	"admin_password":      types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModelAttrTypes},
	"bare_metal_site":     types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModelAttrTypes},
	"bigiq_instance":      types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModelAttrTypes},
	"nodes":               types.ListType{ElemType: types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModelAttrTypes}},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel represents admin_password block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel represents bare_metal_site block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteBareMetalSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel represents bigiq_instance block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel struct {
	LicensePoolName types.String                                                         `tfsdk:"license_pool_name"`
	LicenseServerIP types.String                                                         `tfsdk:"license_server_ip"`
	SkuName         types.String                                                         `tfsdk:"sku_name"`
	Username        types.String                                                         `tfsdk:"username"`
	Password        *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel `tfsdk:"password"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstanceModelAttrTypes = map[string]attr.Type{
	"license_pool_name": types.StringType,
	"license_server_ip": types.StringType,
	"sku_name":          types.StringType,
	"username":          types.StringType,
	"password":          types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel represents password block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel struct {
	BlindfoldSecretInfo *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel represents clear_secret_info block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteBigiqInstancePasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel represents nodes block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel struct {
	BmNodeMemorySize  types.String                                                          `tfsdk:"bm_node_memory_size"`
	BmVirtualCPUCount types.String                                                          `tfsdk:"bm_virtual_cpu_count"`
	NodeName          types.String                                                          `tfsdk:"node_name"`
	ExternalInterface *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel `tfsdk:"external_interface"`
	InternalInterface *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel `tfsdk:"internal_interface"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesModelAttrTypes = map[string]attr.Type{
	"bm_node_memory_size":  types.StringType,
	"bm_virtual_cpu_count": types.StringType,
	"node_name":            types.StringType,
	"external_interface":   types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModelAttrTypes},
	"internal_interface":   types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel represents external_interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel struct {
	NetworkGateway types.String                                                                   `tfsdk:"network_gateway"`
	NetworkSelfIP  types.String                                                                   `tfsdk:"network_self_ip"`
	Interface      *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel `tfsdk:"interface"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceModelAttrTypes = map[string]attr.Type{
	"network_gateway": types.StringType,
	"network_self_ip": types.StringType,
	"interface":       types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel represents interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesExternalInterfaceInterfaceModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel represents internal_interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel struct {
	NetworkGateway types.String                                                                   `tfsdk:"network_gateway"`
	NetworkSelfIP  types.String                                                                   `tfsdk:"network_self_ip"`
	Interface      *APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel `tfsdk:"interface"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceModelAttrTypes = map[string]attr.Type{
	"network_gateway": types.StringType,
	"network_self_ip": types.StringType,
	"interface":       types.ObjectType{AttrTypes: APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModelAttrTypes},
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel represents interface block
type APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModelAttrTypes defines the attribute types for APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModel
var APMBaremetalSiteTypeChoiceF5BareMetalSiteNodesInternalInterfaceInterfaceModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementModel represents https_management block
type APMHTTPSManagementModel struct {
	DomainSuffix                  types.String                                      `tfsdk:"domain_suffix"`
	HTTPSPort                     types.Int64                                       `tfsdk:"https_port"`
	AdvertiseOnInternet           *APMHTTPSManagementAdvertiseOnInternetModel       `tfsdk:"advertise_on_internet"`
	AdvertiseOnInternetDefaultVIP *APMEmptyModel                                    `tfsdk:"advertise_on_internet_default_vip"`
	AdvertiseOnSLIVIP             *APMHTTPSManagementAdvertiseOnSLIVIPModel         `tfsdk:"advertise_on_sli_vip"`
	AdvertiseOnSloInternetVIP     *APMHTTPSManagementAdvertiseOnSloInternetVIPModel `tfsdk:"advertise_on_slo_internet_vip"`
	AdvertiseOnSloSLI             *APMHTTPSManagementAdvertiseOnSloSLIModel         `tfsdk:"advertise_on_slo_sli"`
	AdvertiseOnSloVIP             *APMHTTPSManagementAdvertiseOnSloVIPModel         `tfsdk:"advertise_on_slo_vip"`
	DefaultHTTPSPort              *APMEmptyModel                                    `tfsdk:"default_https_port"`
}

// APMHTTPSManagementModelAttrTypes defines the attribute types for APMHTTPSManagementModel
var APMHTTPSManagementModelAttrTypes = map[string]attr.Type{
	"domain_suffix":                     types.StringType,
	"https_port":                        types.Int64Type,
	"advertise_on_internet":             types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnInternetModelAttrTypes},
	"advertise_on_internet_default_vip": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_sli_vip":              types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPModelAttrTypes},
	"advertise_on_slo_internet_vip":     types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPModelAttrTypes},
	"advertise_on_slo_sli":              types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLIModelAttrTypes},
	"advertise_on_slo_vip":              types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPModelAttrTypes},
	"default_https_port":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnInternetModel represents advertise_on_internet block
type APMHTTPSManagementAdvertiseOnInternetModel struct {
	PublicIP *APMHTTPSManagementAdvertiseOnInternetPublicIPModel `tfsdk:"public_ip"`
}

// APMHTTPSManagementAdvertiseOnInternetModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnInternetModel
var APMHTTPSManagementAdvertiseOnInternetModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnInternetPublicIPModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnInternetPublicIPModel represents public_ip block
type APMHTTPSManagementAdvertiseOnInternetPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnInternetPublicIPModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnInternetPublicIPModel
var APMHTTPSManagementAdvertiseOnInternetPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSLIVIPModel represents advertise_on_sli_vip block
type APMHTTPSManagementAdvertiseOnSLIVIPModel struct {
	NoMtls          *APMEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPModel
var APMHTTPSManagementAdvertiseOnSLIVIPModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *APMEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                   `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel
var APMHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                  `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel
var APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel
var APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel
var APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel
var APMHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPModel represents advertise_on_slo_internet_vip block
type APMHTTPSManagementAdvertiseOnSloInternetVIPModel struct {
	NoMtls          *APMEmptyModel                                                    `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                         `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                         `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *APMEmptyModel                                                                       `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                                       `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                           `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                           `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                           `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                          `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                        `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                                      `tfsdk:"no_crl"`
	TrustedCA                 *APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                                      `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel
var APMHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSloSLIModel represents advertise_on_slo_sli block
type APMHTTPSManagementAdvertiseOnSloSLIModel struct {
	NoMtls          *APMEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSloSLITLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSloSLIModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLIModel
var APMHTTPSManagementAdvertiseOnSloSLIModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel struct {
	CertificateURL       types.String                                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *APMEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel
var APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel
var APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel
var APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel
var APMHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloSLITLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSloSLITLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                   `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSConfigModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSConfigModel
var APMHTTPSManagementAdvertiseOnSloSLITLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel
var APMHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                  `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModel
var APMHTTPSManagementAdvertiseOnSloSLIUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel
var APMHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel
var APMHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel
var APMHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSloVIPModel represents advertise_on_slo_vip block
type APMHTTPSManagementAdvertiseOnSloVIPModel struct {
	NoMtls          *APMEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// APMHTTPSManagementAdvertiseOnSloVIPModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPModel
var APMHTTPSManagementAdvertiseOnSloVIPModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel represents tls_certificates block
type APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *APMEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *APMEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel represents private_key block
type APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModel represents tls_config block
type APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModel struct {
	CustomSecurity  *APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *APMEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *APMEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *APMEmptyModel                                                   `tfsdk:"medium_security"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel represents custom_security block
type APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel
var APMHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModel represents use_mtls block
type APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                  `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                `tfsdk:"trusted_ca_url"`
	CRL                       *APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *APMEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *APMEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModel
var APMHTTPSManagementAdvertiseOnSloVIPUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModelAttrTypes},
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel represents crl block
type APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel
var APMHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel represents trusted_ca block
type APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel
var APMHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel represents xfcc_options block
type APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModelAttrTypes defines the attribute types for APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel
var APMHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

type APMResourceModel struct {
	Name                    types.String                     `tfsdk:"name"`
	Namespace               types.String                     `tfsdk:"namespace"`
	Annotations             types.Map                        `tfsdk:"annotations"`
	Description             types.String                     `tfsdk:"description"`
	Disable                 types.Bool                       `tfsdk:"disable"`
	Labels                  types.Map                        `tfsdk:"labels"`
	ID                      types.String                     `tfsdk:"id"`
	Timeouts                timeouts.Value                   `tfsdk:"timeouts"`
	AWSSiteTypeChoice       *APMAWSSiteTypeChoiceModel       `tfsdk:"aws_site_type_choice"`
	BaremetalSiteTypeChoice *APMBaremetalSiteTypeChoiceModel `tfsdk:"baremetal_site_type_choice"`
	HTTPSManagement         *APMHTTPSManagementModel         `tfsdk:"https_management"`
}

func (r *APMResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_apm"
}

func (r *APMResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages new APM as a service with configured parameters. in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the APM. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the APM will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"aws_site_type_choice": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: aws_site_type_choice, baremetal_site_type_choice] Virtual F5 BIG-IP APM service to be deployed as external service on AWS Transit Gateway Site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"apm_aws_site": schema.SingleNestedBlock{
						MarkdownDescription: "Virtual F5 BIG-IP configuration for AWS TGW Site using BIG-IP APM service.",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Admin Username for BIG-IP .",
								Optional:            true,
							},
							"ssh_key": schema.StringAttribute{
								MarkdownDescription: "Public SSH key for accessing the BIG-IP nodes.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"aws_tgw_site": schema.SingleNestedBlock{
								MarkdownDescription: "BIG-IP AWS TGW Site. BIG-IP AWS TGW site specification.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"aws_tgw_site": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
								},
							},
							"endpoint_service": schema.SingleNestedBlock{
								MarkdownDescription: "Endpoint Service is a type of service where the packets are destined to BIG-IP APM device and service modifies the destination with a new destination address.",
								Attributes: map[string]schema.Attribute{
									"configured_vip": schema.StringAttribute{
										MarkdownDescription: "Enter IP address for the default VIP.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("automatic_vip"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_on_slo_ip": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"advertise_on_slo_ip_external": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"automatic_vip": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"custom_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Port Range List. List of port ranges.",
										Attributes: map[string]schema.Attribute{
											"ports": schema.ListAttribute{
												MarkdownDescription: "List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192 .",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
									"custom_udp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Port Range List. List of port ranges.",
										Attributes: map[string]schema.Attribute{
											"ports": schema.ListAttribute{
												MarkdownDescription: "List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192 .",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
									"default_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"disable_advertise_on_slo_ip": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"http_port": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"https_port": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_udp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Specify how and where the service nodes are spawned .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"aws_az_name": schema.StringAttribute{
											MarkdownDescription: "The AWS Availability Zone must be consistent with the AWS Region chosen. Please select an AZ in the same Region as your TGW Site .",
											Optional:            true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name will be used to assign as hostname to the service .",
											Optional:            true,
										},
										"tunnel_prefix": schema.StringAttribute{
											MarkdownDescription: "Enter IP prefix for the tunnel, it has to be /30.",
											Optional:            true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(
													path.MatchRelative().AtParent().AtName("automatic_prefix"),
												),
											},
										},
									},
									Blocks: map[string]schema.Block{
										"automatic_prefix": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
											Attributes: map[string]schema.Attribute{
												"existing_subnet_id": schema.StringAttribute{
													MarkdownDescription: "Information about existing subnet ID.",
													Optional:            true,
													Validators: []validator.String{
														stringvalidator.ConflictsWith(
															path.MatchRelative().AtParent().AtName("subnet_param"),
														),
													},
												},
											},
											Blocks: map[string]schema.Block{
												"subnet_param": schema.SingleNestedBlock{
													MarkdownDescription: "Parameters for creating a new cloud subnet.",
													Attributes: map[string]schema.Attribute{
														"ipv4": schema.StringAttribute{
															MarkdownDescription: "IPv4 subnet prefix for this subnet .",
															Optional:            true,
														},
													},
												},
											},
										},
										"reserved_mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tags": schema.SingleNestedBlock{
								MarkdownDescription: "AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
							},
						},
					},
					"market_place_image": schema.SingleNestedBlock{
						MarkdownDescription: "Select the flavor of BIG-IP AWS Marketplace to launch the instance on AWS TGW Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"best_plus_pay_g200_mbps": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"best_plus_payg_1gbps": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"baremetal_site_type_choice": schema.SingleNestedBlock{
				MarkdownDescription: "Virtual BIG-IP specification for App Stack Bare Metal Site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"f5_bare_metal_site": schema.SingleNestedBlock{
						MarkdownDescription: "Virtual BIG-IP specification for App Stack bare metal.",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Admin Username for BIG-IP .",
								Optional:            true,
							},
							"public_download_url": schema.StringAttribute{
								MarkdownDescription: "Public URL where BIG-IP VE image (qcow2) is hosted .",
								Optional:            true,
							},
							"ssh_key": schema.StringAttribute{
								MarkdownDescription: "Public SSH key for accessing the BIG-IP nodes.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"bare_metal_site": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"bigiq_instance": schema.SingleNestedBlock{
								MarkdownDescription: "Specification for BIG-IQ Instance, where and what.",
								Attributes: map[string]schema.Attribute{
									"license_pool_name": schema.StringAttribute{
										MarkdownDescription: "Name of Utility Pool on BIG-IQ .",
										Optional:            true,
									},
									"license_server_ip": schema.StringAttribute{
										MarkdownDescription: "IP Address from the TCP Load Balancer which is configured to communicate with License Server .",
										Optional:            true,
									},
									"sku_name": schema.StringAttribute{
										MarkdownDescription: "License offering name aka SKU name .",
										Optional:            true,
									},
									"username": schema.StringAttribute{
										MarkdownDescription: "User Name used to access BIG-IQ to activate the license .",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"password": schema.SingleNestedBlock{
										MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Specify how and where the service nodes are spawned .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"bm_node_memory_size": schema.StringAttribute{
											MarkdownDescription: "[Enum: BM_8_GB_MEMORY|BM_16_GB_MEMORY|BM_32_GB_MEMORY] Enum to define amount of memory to be assigned to the node - BM_8_GB_MEMORY: 8 GB - BM_16_GB_MEMORY: 16 GB - BM_32_GB_MEMORY: 32 GB. Possible values are `BM_8_GB_MEMORY`, `BM_16_GB_MEMORY`, `BM_32_GB_MEMORY`. Defaults to `BM_8_GB_MEMORY`.",
											Optional:            true,
										},
										"bm_virtual_cpu_count": schema.StringAttribute{
											MarkdownDescription: "[Enum: BM_4_VCPU|BM_8_VCPU] Enum to define number of virtual CPU's to be assigned to the node - BM_4_VCPU: 4 virtual CPUs - BM_8_VCPU: 8 virtual CPUs. Possible values are `BM_4_VCPU`, `BM_8_VCPU`. Defaults to `BM_4_VCPU`.",
											Optional:            true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name will be used to assign as hostname to the service .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"external_interface": schema.SingleNestedBlock{
											MarkdownDescription: "Interface. BIG-IP interface details.",
											Attributes: map[string]schema.Attribute{
												"network_gateway": schema.StringAttribute{
													MarkdownDescription: "Configuration parameter for network gateway.",
													Optional:            true,
												},
												"network_self_ip": schema.StringAttribute{
													MarkdownDescription: "Self IP. Self IP CIDR .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"interface": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"internal_interface": schema.SingleNestedBlock{
											MarkdownDescription: "Interface. BIG-IP interface details.",
											Attributes: map[string]schema.Attribute{
												"network_gateway": schema.StringAttribute{
													MarkdownDescription: "Configuration parameter for network gateway.",
													Optional:            true,
												},
												"network_self_ip": schema.StringAttribute{
													MarkdownDescription: "Self IP. Self IP CIDR .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"interface": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"https_management": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS based management. HTTPS based configuration.",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain suffix will be used along with node name to form URL to access node management .",
						Optional:            true,
					},
					"https_port": schema.Int64Attribute{
						MarkdownDescription: "Enter TCP port number.",
						Optional:            true,
						Validators: []validator.Int64{
							int64validator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("default_https_port"),
							),
						},
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_internet": schema.SingleNestedBlock{
						MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"public_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
						},
					},
					"advertise_on_internet_default_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"advertise_on_sli_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("trusted_ca"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("trusted_ca"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("trusted_ca"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("trusted_ca"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"default_https_port": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
		},
	}
}

func (r *APMResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *APMResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *APMResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the apm from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan APMResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *APMResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating apm", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.APM{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AWSSiteTypeChoice != nil {
		aws_site_type_choiceMap := make(map[string]interface{})
		if data.AWSSiteTypeChoice.APMAWSSite != nil {
			apm_aws_siteNestedMap := make(map[string]interface{})
			if !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsUnknown() {
				apm_aws_siteNestedMap["admin_username"] = data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.ValueString()
			}
			if !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsUnknown() {
				apm_aws_siteNestedMap["ssh_key"] = data.AWSSiteTypeChoice.APMAWSSite.SSHKey.ValueString()
			}
			aws_site_type_choiceMap["apm_aws_site"] = apm_aws_siteNestedMap
		}
		if data.AWSSiteTypeChoice.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			aws_site_type_choiceMap["market_place_image"] = market_place_imageNestedMap
		}
		createReq.Spec["aws_site_type_choice"] = aws_site_type_choiceMap
	}
	if data.BaremetalSiteTypeChoice != nil {
		baremetal_site_type_choiceMap := make(map[string]interface{})
		if data.BaremetalSiteTypeChoice.F5BareMetalSite != nil {
			f5_bare_metal_siteNestedMap := make(map[string]interface{})
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsUnknown() {
				f5_bare_metal_siteNestedMap["admin_username"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsUnknown() {
				f5_bare_metal_siteNestedMap["public_download_url"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsUnknown() {
				f5_bare_metal_siteNestedMap["ssh_key"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.ValueString()
			}
			baremetal_site_type_choiceMap["f5_bare_metal_site"] = f5_bare_metal_siteNestedMap
		}
		createReq.Spec["baremetal_site_type_choice"] = baremetal_site_type_choiceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVIP != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloVIP != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		createReq.Spec["https_management"] = https_managementMap
	}

	apiResource, err := r.client.CreateAPM(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create APM: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["aws_site_type_choice"].(map[string]interface{}); ok && isImport && data.AWSSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AWSSiteTypeChoice = &APMAWSSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["baremetal_site_type_choice"].(map[string]interface{}); ok && isImport && data.BaremetalSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BaremetalSiteTypeChoice = &APMBaremetalSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &APMHTTPSManagementModel{
			AdvertiseOnInternet: func() *APMHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *APMHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *APMHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *APMHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *APMHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if !isImport && data.HTTPSManagement != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSManagement.HTTPSPort
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	tflog.Trace(ctx, "created APM resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "APM not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read APM: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["aws_site_type_choice"].(map[string]interface{}); ok && isImport && data.AWSSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AWSSiteTypeChoice = &APMAWSSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["baremetal_site_type_choice"].(map[string]interface{}); ok && isImport && data.BaremetalSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BaremetalSiteTypeChoice = &APMBaremetalSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &APMHTTPSManagementModel{
			AdvertiseOnInternet: func() *APMHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *APMHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *APMHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *APMHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *APMHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if !isImport && data.HTTPSManagement != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSManagement.HTTPSPort
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.APM{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AWSSiteTypeChoice != nil {
		aws_site_type_choiceMap := make(map[string]interface{})
		if data.AWSSiteTypeChoice.APMAWSSite != nil {
			apm_aws_siteNestedMap := make(map[string]interface{})
			if !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.IsUnknown() {
				apm_aws_siteNestedMap["admin_username"] = data.AWSSiteTypeChoice.APMAWSSite.AdminUsername.ValueString()
			}
			if !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsNull() && !data.AWSSiteTypeChoice.APMAWSSite.SSHKey.IsUnknown() {
				apm_aws_siteNestedMap["ssh_key"] = data.AWSSiteTypeChoice.APMAWSSite.SSHKey.ValueString()
			}
			aws_site_type_choiceMap["apm_aws_site"] = apm_aws_siteNestedMap
		}
		if data.AWSSiteTypeChoice.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			aws_site_type_choiceMap["market_place_image"] = market_place_imageNestedMap
		}
		apiResource.Spec["aws_site_type_choice"] = aws_site_type_choiceMap
	}
	if data.BaremetalSiteTypeChoice != nil {
		baremetal_site_type_choiceMap := make(map[string]interface{})
		if data.BaremetalSiteTypeChoice.F5BareMetalSite != nil {
			f5_bare_metal_siteNestedMap := make(map[string]interface{})
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.IsUnknown() {
				f5_bare_metal_siteNestedMap["admin_username"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.AdminUsername.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.IsUnknown() {
				f5_bare_metal_siteNestedMap["public_download_url"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.PublicDownloadURL.ValueString()
			}
			if !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsNull() && !data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.IsUnknown() {
				f5_bare_metal_siteNestedMap["ssh_key"] = data.BaremetalSiteTypeChoice.F5BareMetalSite.SSHKey.ValueString()
			}
			baremetal_site_type_choiceMap["f5_bare_metal_site"] = f5_bare_metal_siteNestedMap
		}
		apiResource.Spec["baremetal_site_type_choice"] = baremetal_site_type_choiceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVIP != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloVIP != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		apiResource.Spec["https_management"] = https_managementMap
	}

	_, err := r.client.UpdateAPM(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update APM: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read APM after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["aws_site_type_choice"].(map[string]interface{}); ok && isImport && data.AWSSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AWSSiteTypeChoice = &APMAWSSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["baremetal_site_type_choice"].(map[string]interface{}); ok && isImport && data.BaremetalSiteTypeChoice == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BaremetalSiteTypeChoice = &APMBaremetalSiteTypeChoiceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &APMHTTPSManagementModel{
			AdvertiseOnInternet: func() *APMHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *APMHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *APMHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *APMHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *APMHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &APMHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *APMEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &APMEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if !isImport && data.HTTPSManagement != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSManagement.HTTPSPort
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "APM already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "APM delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete APM: %s", err))
		return
	}
}

func (r *APMResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
