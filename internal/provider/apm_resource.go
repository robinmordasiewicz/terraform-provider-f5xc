// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &APMResource{}
	_ resource.ResourceWithConfigure      = &APMResource{}
	_ resource.ResourceWithImportState    = &APMResource{}
	_ resource.ResourceWithModifyPlan     = &APMResource{}
	_ resource.ResourceWithUpgradeState   = &APMResource{}
	_ resource.ResourceWithValidateConfig = &APMResource{}
)

// apmSchemaVersion is the schema version for state upgrades
const apmSchemaVersion int64 = 1

func NewAPMResource() resource.Resource {
	return &APMResource{}
}

type APMResource struct {
	client *client.Client
}

type APMResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

func (r *APMResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_apm"
}

func (r *APMResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             apmSchemaVersion,
		MarkdownDescription: "Manages new APM as a service with configured parameters in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the APM. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the APM will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"aws_site_type_choice": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: aws_site_type_choice, baremetal_site_type_choice] AWS Transit Gateway Site choice. Virtual F5 BIG-IP APM service to be deployed as external service on AWS Transit Gateway Site",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"apm_aws_site": schema.SingleNestedBlock{
						MarkdownDescription: "Virtual F5 BIG-IP APM configuration on AWS TGW Site. Virtual F5 BIG-IP configuration for AWS TGW Site using BIG-IP APM service",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Admin Username. Admin Username for BIG-IP",
								Optional: true,
							},
							"ssh_key": schema.StringAttribute{
								MarkdownDescription: "Public SSH key. Public SSH key for accessing the BIG-IP nodes.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional: true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional: true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional: true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional: true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional: true,
											},
										},
									},
								},
							},
							"aws_tgw_site": schema.SingleNestedBlock{
								MarkdownDescription: "BIG-IP AWS TGW Site. BIG-IP AWS TGW site specification",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"aws_tgw_site": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
								},
							},
							"endpoint_service": schema.SingleNestedBlock{
								MarkdownDescription: "Endpoint Service. Endpoint Service is a type of service where the packets are destined to BIG-IP APM device and service modifies the destination with a new destination address",
								Attributes: map[string]schema.Attribute{
									"configured_vip": schema.StringAttribute{
										MarkdownDescription: "Configured VIP. Enter IP address for the default VIP",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_on_slo_ip": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"advertise_on_slo_ip_external": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"automatic_vip": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"custom_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Port Range List. List of port ranges",
										Attributes: map[string]schema.Attribute{
											"ports": schema.ListAttribute{
												MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
									"custom_udp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Port Range List. List of port ranges",
										Attributes: map[string]schema.Attribute{
											"ports": schema.ListAttribute{
												MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
									"default_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"disable_advertise_on_slo_ip": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"http_port": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"https_port": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_tcp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_udp_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Service Nodes. Specify how and where the service nodes are spawned",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"aws_az_name": schema.StringAttribute{
											MarkdownDescription: "AWS AZ Name. The AWS Availability Zone must be consistent with the AWS Region chosen. Please select an AZ in the same Region as your TGW Site",
											Optional: true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
											Optional: true,
										},
										"tunnel_prefix": schema.StringAttribute{
											MarkdownDescription: "Tunnel IP Prefix. Enter IP prefix for the tunnel, it has to be /30",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"automatic_prefix": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
											Attributes: map[string]schema.Attribute{
												"existing_subnet_id": schema.StringAttribute{
													MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"subnet_param": schema.SingleNestedBlock{
													MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
													Attributes: map[string]schema.Attribute{
														"ipv4": schema.StringAttribute{
															MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
															Optional: true,
														},
													},
												},
											},
										},
										"reserved_mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tags": schema.SingleNestedBlock{
								MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
							},
						},
					},
					"market_place_image": schema.SingleNestedBlock{
						MarkdownDescription: "BIG-IP AWS Marketplace Image. Select the flavor of BIG-IP AWS Marketplace to launch the instance on AWS TGW Site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"best_plus_pay_g200_mbps": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"best_plus_payg_1gbps": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"baremetal_site_type_choice": schema.SingleNestedBlock{
				MarkdownDescription: "Virtual BIG-IP on App Stack Bare Metal Site. Virtual BIG-IP specification for App Stack Bare Metal Site",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"f5_bare_metal_site": schema.SingleNestedBlock{
						MarkdownDescription: "Virtual BIG-IP on App Stack bare metal. Virtual BIG-IP specification for App Stack bare metal",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Admin Username. Admin Username for BIG-IP",
								Optional: true,
							},
							"public_download_url": schema.StringAttribute{
								MarkdownDescription: "Image URL. Public URL where BIG-IP VE image (qcow2) is hosted",
								Optional: true,
							},
							"ssh_key": schema.StringAttribute{
								MarkdownDescription: "Public SSH key. Public SSH key for accessing the BIG-IP nodes.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional: true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional: true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional: true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional: true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional: true,
											},
										},
									},
								},
							},
							"bare_metal_site": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"bigiq_instance": schema.SingleNestedBlock{
								MarkdownDescription: "License Server Details. Specification for BIG-IQ Instance, where and what",
								Attributes: map[string]schema.Attribute{
									"license_pool_name": schema.StringAttribute{
										MarkdownDescription: "License Pool Name. Name of Utility Pool on BIG-IQ",
										Optional: true,
									},
									"license_server_ip": schema.StringAttribute{
										MarkdownDescription: "License Server IP. IP Address from the TCP Load Balancer which is configured to communicate with License Server",
										Optional: true,
									},
									"sku_name": schema.StringAttribute{
										MarkdownDescription: "Offering Name. License offering name aka SKU name",
										Optional: true,
									},
									"username": schema.StringAttribute{
										MarkdownDescription: "User Name. User Name used to access BIG-IQ to activate the license",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"password": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional: true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
														Optional: true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional: true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional: true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Service Nodes. Specify how and where the service nodes are spawned",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"bm_node_memory_size": schema.StringAttribute{
											MarkdownDescription: "Bare Metal ServiceNode Memory Size. Enum to define amount of memory to be assigned to the node - BM_8_GB_MEMORY: 8 GB - BM_16_GB_MEMORY: 16 GB - BM_32_GB_MEMORY: 32 GB. Possible values are `BM_8_GB_MEMORY`, `BM_16_GB_MEMORY`, `BM_32_GB_MEMORY`. Defaults to `BM_8_GB_MEMORY`.",
											Optional: true,
										},
										"bm_virtual_cpu_count": schema.StringAttribute{
											MarkdownDescription: "Bare Metal ServiceNode Virtual CPU Count. Enum to define number of virtual CPU's to be assigned to the node - BM_4_VCPU: 4 virtual CPUs - BM_8_VCPU: 8 virtual CPUs. Possible values are `BM_4_VCPU`, `BM_8_VCPU`. Defaults to `BM_4_VCPU`.",
											Optional: true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"external_interface": schema.SingleNestedBlock{
											MarkdownDescription: "Interface. x-required BIG-IP interface details",
											Attributes: map[string]schema.Attribute{
												"network_gateway": schema.StringAttribute{
													MarkdownDescription: "Default Gateway.",
													Optional: true,
												},
												"network_self_ip": schema.StringAttribute{
													MarkdownDescription: "Self IP. Self IP CIDR",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"interface": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"internal_interface": schema.SingleNestedBlock{
											MarkdownDescription: "Interface. x-required BIG-IP interface details",
											Attributes: map[string]schema.Attribute{
												"network_gateway": schema.StringAttribute{
													MarkdownDescription: "Default Gateway.",
													Optional: true,
												},
												"network_self_ip": schema.StringAttribute{
													MarkdownDescription: "Self IP. Self IP CIDR",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"interface": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"https_management": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS based management. HTTPS based configuration",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain Suffix. Domain suffix will be used along with node name to form URL to access node management",
						Optional: true,
					},
					"https_port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS Port. Enter TCP port number",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_internet": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"public_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
						},
					},
					"advertise_on_internet_default_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"advertise_on_sli_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional: true,
										},
										"description": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional: true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional: true,
										},
										"description": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional: true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional: true,
										},
										"description": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional: true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional: true,
										},
										"description": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional: true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"default_https_port": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
		},
	}
}

func (r *APMResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *APMResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *APMResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the apm from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan APMResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *APMResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := APMResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *APMResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating apm", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.APM{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.APMSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateAPM(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create APM: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(created.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created APM resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read APM: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The apm may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	psd = privatestate.NewPrivateStateData()
	psd.SetUID(apiResource.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.APM{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.APMSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateAPM(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update APM: %s", err))
		return
	}

	data.ID = types.StringValue(data.Name.ValueString())

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(updated.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *APMResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data APMResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()

	err := r.client.DeleteAPM(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete APM: %s", err))
		return
	}
}

func (r *APMResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
