// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AppFirewallResource{}
	_ resource.ResourceWithConfigure      = &AppFirewallResource{}
	_ resource.ResourceWithImportState    = &AppFirewallResource{}
	_ resource.ResourceWithModifyPlan     = &AppFirewallResource{}
	_ resource.ResourceWithUpgradeState   = &AppFirewallResource{}
	_ resource.ResourceWithValidateConfig = &AppFirewallResource{}
)

// app_firewallSchemaVersion is the schema version for state upgrades
const app_firewallSchemaVersion int64 = 1

func NewAppFirewallResource() resource.Resource {
	return &AppFirewallResource{}
}

type AppFirewallResource struct {
	client *client.Client
}

// AppFirewallEmptyModel represents empty nested blocks
type AppFirewallEmptyModel struct {
}

// AppFirewallAiRiskBasedBlockingModel represents ai_risk_based_blocking block
type AppFirewallAiRiskBasedBlockingModel struct {
	HighRiskAction   types.String `tfsdk:"high_risk_action"`
	LowRiskAction    types.String `tfsdk:"low_risk_action"`
	MediumRiskAction types.String `tfsdk:"medium_risk_action"`
}

// AppFirewallAllowedResponseCodesModel represents allowed_response_codes block
type AppFirewallAllowedResponseCodesModel struct {
	ResponseCode types.List `tfsdk:"response_code"`
}

// AppFirewallBlockingPageModel represents blocking_page block
type AppFirewallBlockingPageModel struct {
	BlockingPage types.String `tfsdk:"blocking_page"`
	ResponseCode types.String `tfsdk:"response_code"`
}

// AppFirewallBotProtectionSettingModel represents bot_protection_setting block
type AppFirewallBotProtectionSettingModel struct {
	GoodBotAction       types.String `tfsdk:"good_bot_action"`
	MaliciousBotAction  types.String `tfsdk:"malicious_bot_action"`
	SuspiciousBotAction types.String `tfsdk:"suspicious_bot_action"`
}

// AppFirewallCustomAnonymizationModel represents custom_anonymization block
type AppFirewallCustomAnonymizationModel struct {
	AnonymizationConfig []AppFirewallCustomAnonymizationAnonymizationConfigModel `tfsdk:"anonymization_config"`
}

// AppFirewallCustomAnonymizationAnonymizationConfigModel represents anonymization_config block
type AppFirewallCustomAnonymizationAnonymizationConfigModel struct {
	Cookie         *AppFirewallCustomAnonymizationAnonymizationConfigCookieModel         `tfsdk:"cookie"`
	HTTPHeader     *AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel     `tfsdk:"http_header"`
	QueryParameter *AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel `tfsdk:"query_parameter"`
}

// AppFirewallCustomAnonymizationAnonymizationConfigCookieModel represents cookie block
type AppFirewallCustomAnonymizationAnonymizationConfigCookieModel struct {
	CookieName types.String `tfsdk:"cookie_name"`
}

// AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel represents http_header block
type AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel struct {
	HeaderName types.String `tfsdk:"header_name"`
}

// AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel represents query_parameter block
type AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel struct {
	QueryParamName types.String `tfsdk:"query_param_name"`
}

// AppFirewallDetectionSettingsModel represents detection_settings block
type AppFirewallDetectionSettingsModel struct {
	BotProtectionSetting         *AppFirewallDetectionSettingsBotProtectionSettingModel         `tfsdk:"bot_protection_setting"`
	DefaultBotSetting            *AppFirewallEmptyModel                                         `tfsdk:"default_bot_setting"`
	DefaultViolationSettings     *AppFirewallEmptyModel                                         `tfsdk:"default_violation_settings"`
	DisableStaging               *AppFirewallEmptyModel                                         `tfsdk:"disable_staging"`
	DisableSuppression           *AppFirewallEmptyModel                                         `tfsdk:"disable_suppression"`
	DisableThreatCampaigns       *AppFirewallEmptyModel                                         `tfsdk:"disable_threat_campaigns"`
	EnableSuppression            *AppFirewallEmptyModel                                         `tfsdk:"enable_suppression"`
	EnableThreatCampaigns        *AppFirewallEmptyModel                                         `tfsdk:"enable_threat_campaigns"`
	SignatureSelectionSetting    *AppFirewallDetectionSettingsSignatureSelectionSettingModel    `tfsdk:"signature_selection_setting"`
	StageNewAndUpdatedSignatures *AppFirewallDetectionSettingsStageNewAndUpdatedSignaturesModel `tfsdk:"stage_new_and_updated_signatures"`
	StageNewSignatures           *AppFirewallDetectionSettingsStageNewSignaturesModel           `tfsdk:"stage_new_signatures"`
	ViolationSettings            *AppFirewallDetectionSettingsViolationSettingsModel            `tfsdk:"violation_settings"`
}

// AppFirewallDetectionSettingsBotProtectionSettingModel represents bot_protection_setting block
type AppFirewallDetectionSettingsBotProtectionSettingModel struct {
	GoodBotAction       types.String `tfsdk:"good_bot_action"`
	MaliciousBotAction  types.String `tfsdk:"malicious_bot_action"`
	SuspiciousBotAction types.String `tfsdk:"suspicious_bot_action"`
}

// AppFirewallDetectionSettingsSignatureSelectionSettingModel represents signature_selection_setting block
type AppFirewallDetectionSettingsSignatureSelectionSettingModel struct {
	AttackTypeSettings              *AppFirewallDetectionSettingsSignatureSelectionSettingAttackTypeSettingsModel `tfsdk:"attack_type_settings"`
	DefaultAttackTypeSettings       *AppFirewallEmptyModel                                                        `tfsdk:"default_attack_type_settings"`
	HighMediumAccuracySignatures    *AppFirewallEmptyModel                                                        `tfsdk:"high_medium_accuracy_signatures"`
	HighMediumLowAccuracySignatures *AppFirewallEmptyModel                                                        `tfsdk:"high_medium_low_accuracy_signatures"`
	OnlyHighAccuracySignatures      *AppFirewallEmptyModel                                                        `tfsdk:"only_high_accuracy_signatures"`
}

// AppFirewallDetectionSettingsSignatureSelectionSettingAttackTypeSettingsModel represents attack_type_settings block
type AppFirewallDetectionSettingsSignatureSelectionSettingAttackTypeSettingsModel struct {
	DisabledAttackTypes types.List `tfsdk:"disabled_attack_types"`
}

// AppFirewallDetectionSettingsStageNewAndUpdatedSignaturesModel represents stage_new_and_updated_signatures block
type AppFirewallDetectionSettingsStageNewAndUpdatedSignaturesModel struct {
	StagingPeriod types.Int64 `tfsdk:"staging_period"`
}

// AppFirewallDetectionSettingsStageNewSignaturesModel represents stage_new_signatures block
type AppFirewallDetectionSettingsStageNewSignaturesModel struct {
	StagingPeriod types.Int64 `tfsdk:"staging_period"`
}

// AppFirewallDetectionSettingsViolationSettingsModel represents violation_settings block
type AppFirewallDetectionSettingsViolationSettingsModel struct {
	DisabledViolationTypes types.List `tfsdk:"disabled_violation_types"`
}

type AppFirewallResourceModel struct {
	Name                     types.String                          `tfsdk:"name"`
	Namespace                types.String                          `tfsdk:"namespace"`
	Annotations              types.Map                             `tfsdk:"annotations"`
	Description              types.String                          `tfsdk:"description"`
	Disable                  types.Bool                            `tfsdk:"disable"`
	Labels                   types.Map                             `tfsdk:"labels"`
	ID                       types.String                          `tfsdk:"id"`
	Timeouts                 timeouts.Value                        `tfsdk:"timeouts"`
	AiRiskBasedBlocking      *AppFirewallAiRiskBasedBlockingModel  `tfsdk:"ai_risk_based_blocking"`
	AllowAllResponseCodes    *AppFirewallEmptyModel                `tfsdk:"allow_all_response_codes"`
	AllowedResponseCodes     *AppFirewallAllowedResponseCodesModel `tfsdk:"allowed_response_codes"`
	Blocking                 *AppFirewallEmptyModel                `tfsdk:"blocking"`
	BlockingPage             *AppFirewallBlockingPageModel         `tfsdk:"blocking_page"`
	BotProtectionSetting     *AppFirewallBotProtectionSettingModel `tfsdk:"bot_protection_setting"`
	CustomAnonymization      *AppFirewallCustomAnonymizationModel  `tfsdk:"custom_anonymization"`
	DefaultAnonymization     *AppFirewallEmptyModel                `tfsdk:"default_anonymization"`
	DefaultBotSetting        *AppFirewallEmptyModel                `tfsdk:"default_bot_setting"`
	DefaultDetectionSettings *AppFirewallEmptyModel                `tfsdk:"default_detection_settings"`
	DetectionSettings        *AppFirewallDetectionSettingsModel    `tfsdk:"detection_settings"`
	DisableAnonymization     *AppFirewallEmptyModel                `tfsdk:"disable_anonymization"`
	Monitoring               *AppFirewallEmptyModel                `tfsdk:"monitoring"`
	UseDefaultBlockingPage   *AppFirewallEmptyModel                `tfsdk:"use_default_blocking_page"`
}

func (r *AppFirewallResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_app_firewall"
}

func (r *AppFirewallResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             app_firewallSchemaVersion,
		MarkdownDescription: "[Category: Security] [Namespace: required] [DependsOn: namespace] Manages Application Firewall in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the App Firewall. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the App Firewall will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"ai_risk_based_blocking": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ai_risk_based_blocking, default_detection_settings, detection_settings; Default: default_detection_settings] Risk-Based Blocking (Powered by AI) - Preview. All Attack Types, including high, medium, and low accuracy signatures, automatic Attack Signature tuning, Threat Campaigns, and all Violations will be enabled. AI and ML algorithms will assess request risk, and only high-risk requests will be blocked by default. This feature is in preview mode.",
				Attributes: map[string]schema.Attribute{
					"high_risk_action": schema.StringAttribute{
						MarkdownDescription: "[Enum: AI_BLOCK|AI_REPORT] Risk Based Blocking Action. Action to be performed on the request Log and block Log only. Possible values are `AI_BLOCK`, `AI_REPORT`. Defaults to `AI_BLOCK`.",
						Optional:            true,
					},
					"low_risk_action": schema.StringAttribute{
						MarkdownDescription: "[Enum: AI_BLOCK|AI_REPORT] Risk Based Blocking Action. Action to be performed on the request Log and block Log only. Possible values are `AI_BLOCK`, `AI_REPORT`. Defaults to `AI_BLOCK`.",
						Optional:            true,
					},
					"medium_risk_action": schema.StringAttribute{
						MarkdownDescription: "[Enum: AI_BLOCK|AI_REPORT] Risk Based Blocking Action. Action to be performed on the request Log and block Log only. Possible values are `AI_BLOCK`, `AI_REPORT`. Defaults to `AI_BLOCK`.",
						Optional:            true,
					},
				},
			},
			"allow_all_response_codes": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: allow_all_response_codes, allowed_response_codes] Enable this option",
			},
			"allowed_response_codes": schema.SingleNestedBlock{
				MarkdownDescription: "Allowed Response Codes. List of HTTP response status codes that are allowed",
				Attributes: map[string]schema.Attribute{
					"response_code": schema.ListAttribute{
						MarkdownDescription: "Response Code. List of HTTP response status codes that are allowed",
						Optional:            true,
						ElementType:         types.Int64Type,
					},
				},
			},
			"blocking": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: blocking, monitoring] Enable this option",
			},
			"blocking_page": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: blocking_page, use_default_blocking_page; Default: use_default_blocking_page] Custom Blocking Response Page. Custom blocking response page body",
				Attributes: map[string]schema.Attribute{
					"blocking_page": schema.StringAttribute{
						MarkdownDescription: "Blocking Response Page Body. Define the content of the response page (e.g., an HTML document or a JSON object), use the {{request_id}} placeholder to provide users with a unique identifier to be able to trace the blocked request in the logs. The maximum allowed size of response body is 4096 bytes after base64 encoding, which would be about 3070 bytes in plain text.",
						Optional:            true,
					},
					"response_code": schema.StringAttribute{
						MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
						Optional:            true,
					},
				},
			},
			"bot_protection_setting": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: bot_protection_setting, default_bot_setting; Default: default_bot_setting] Bot Protection. Configuration of WAF Bot Protection",
				Attributes: map[string]schema.Attribute{
					"good_bot_action": schema.StringAttribute{
						MarkdownDescription: "[Enum: BLOCK|REPORT|IGNORE] Bot Action. Action to be performed on the request Log and block Log only Disable detection. Possible values are `BLOCK`, `REPORT`, `IGNORE`. Defaults to `BLOCK`.",
						Optional:            true,
					},
					"malicious_bot_action": schema.StringAttribute{
						MarkdownDescription: "[Enum: BLOCK|REPORT|IGNORE] Bot Action. Action to be performed on the request Log and block Log only Disable detection. Possible values are `BLOCK`, `REPORT`, `IGNORE`. Defaults to `BLOCK`.",
						Optional:            true,
					},
					"suspicious_bot_action": schema.StringAttribute{
						MarkdownDescription: "[Enum: BLOCK|REPORT|IGNORE] Bot Action. Action to be performed on the request Log and block Log only Disable detection. Possible values are `BLOCK`, `REPORT`, `IGNORE`. Defaults to `BLOCK`.",
						Optional:            true,
					},
				},
			},
			"custom_anonymization": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: custom_anonymization, default_anonymization, disable_anonymization; Default: default_anonymization] Anonymization Configuration. Anonymization settings which is a list of HTTP headers, parameters and cookies",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"anonymization_config": schema.ListNestedBlock{
						MarkdownDescription: "Configuration. List of HTTP headers, cookies and query parameters whose values will be masked",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"cookie": schema.SingleNestedBlock{
									MarkdownDescription: "Anonymize HTTP Cookie. Configure anonymization for HTTP Cookies",
									Attributes: map[string]schema.Attribute{
										"cookie_name": schema.StringAttribute{
											MarkdownDescription: "Cookie Name. Masks the cookie value. The setting does not mask the cookie name.",
											Optional:            true,
										},
									},
								},
								"http_header": schema.SingleNestedBlock{
									MarkdownDescription: "Anonymize HTTP Header. Configure anonymization for HTTP Headers",
									Attributes: map[string]schema.Attribute{
										"header_name": schema.StringAttribute{
											MarkdownDescription: "Header Name. Masks the HTTP header value. The setting does not mask the HTTP header name.",
											Optional:            true,
										},
									},
								},
								"query_parameter": schema.SingleNestedBlock{
									MarkdownDescription: "Anonymize HTTP Query Parameter. Configure anonymization for HTTP Parameters",
									Attributes: map[string]schema.Attribute{
										"query_param_name": schema.StringAttribute{
											MarkdownDescription: "Query Parameter Name. Masks the query parameter value. The setting does not mask the query parameter name.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
			"default_anonymization": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"default_bot_setting": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"default_detection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"detection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Detection Settings. Specifies detection settings to be used by WAF",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"bot_protection_setting": schema.SingleNestedBlock{
						MarkdownDescription: "Bot Protection. Configuration of WAF Bot Protection",
						Attributes: map[string]schema.Attribute{
							"good_bot_action": schema.StringAttribute{
								MarkdownDescription: "[Enum: BLOCK|REPORT|IGNORE] Bot Action. Action to be performed on the request Log and block Log only Disable detection. Possible values are `BLOCK`, `REPORT`, `IGNORE`. Defaults to `BLOCK`.",
								Optional:            true,
							},
							"malicious_bot_action": schema.StringAttribute{
								MarkdownDescription: "[Enum: BLOCK|REPORT|IGNORE] Bot Action. Action to be performed on the request Log and block Log only Disable detection. Possible values are `BLOCK`, `REPORT`, `IGNORE`. Defaults to `BLOCK`.",
								Optional:            true,
							},
							"suspicious_bot_action": schema.StringAttribute{
								MarkdownDescription: "[Enum: BLOCK|REPORT|IGNORE] Bot Action. Action to be performed on the request Log and block Log only Disable detection. Possible values are `BLOCK`, `REPORT`, `IGNORE`. Defaults to `BLOCK`.",
								Optional:            true,
							},
						},
					},
					"default_bot_setting": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_violation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_staging": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_suppression": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_threat_campaigns": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_suppression": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_threat_campaigns": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"signature_selection_setting": schema.SingleNestedBlock{
						MarkdownDescription: "Attack Signatures. Attack Signatures are patterns that identify attacks on a web application and its components",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"attack_type_settings": schema.SingleNestedBlock{
								MarkdownDescription: "Attack Type Settings. Specifies attack-type settings to be used by WAF",
								Attributes: map[string]schema.Attribute{
									"disabled_attack_types": schema.ListAttribute{
										MarkdownDescription: "[Enum: ATTACK_TYPE_NONE|ATTACK_TYPE_NON_BROWSER_CLIENT|ATTACK_TYPE_OTHER_APPLICATION_ATTACKS|ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE|ATTACK_TYPE_DETECTION_EVASION|ATTACK_TYPE_VULNERABILITY_SCAN|ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY|ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS|ATTACK_TYPE_BUFFER_OVERFLOW|ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION|ATTACK_TYPE_INFORMATION_LEAKAGE|ATTACK_TYPE_DIRECTORY_INDEXING|ATTACK_TYPE_PATH_TRAVERSAL|ATTACK_TYPE_XPATH_INJECTION|ATTACK_TYPE_LDAP_INJECTION|ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION|ATTACK_TYPE_COMMAND_EXECUTION|ATTACK_TYPE_SQL_INJECTION|ATTACK_TYPE_CROSS_SITE_SCRIPTING|ATTACK_TYPE_DENIAL_OF_SERVICE|ATTACK_TYPE_HTTP_PARSER_ATTACK|ATTACK_TYPE_SESSION_HIJACKING|ATTACK_TYPE_HTTP_RESPONSE_SPLITTING|ATTACK_TYPE_FORCEFUL_BROWSING|ATTACK_TYPE_REMOTE_FILE_INCLUDE|ATTACK_TYPE_MALICIOUS_FILE_UPLOAD|ATTACK_TYPE_GRAPHQL_PARSER_ATTACK] Disabled Attack Types. List of Attack Types that will be ignored and not trigger a detection. Possible values are `ATTACK_TYPE_NONE`, `ATTACK_TYPE_NON_BROWSER_CLIENT`, `ATTACK_TYPE_OTHER_APPLICATION_ATTACKS`, `ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE`, `ATTACK_TYPE_DETECTION_EVASION`, `ATTACK_TYPE_VULNERABILITY_SCAN`, `ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY`, `ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS`, `ATTACK_TYPE_BUFFER_OVERFLOW`, `ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION`, `ATTACK_TYPE_INFORMATION_LEAKAGE`, `ATTACK_TYPE_DIRECTORY_INDEXING`, `ATTACK_TYPE_PATH_TRAVERSAL`, `ATTACK_TYPE_XPATH_INJECTION`, `ATTACK_TYPE_LDAP_INJECTION`, `ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION`, `ATTACK_TYPE_COMMAND_EXECUTION`, `ATTACK_TYPE_SQL_INJECTION`, `ATTACK_TYPE_CROSS_SITE_SCRIPTING`, `ATTACK_TYPE_DENIAL_OF_SERVICE`, `ATTACK_TYPE_HTTP_PARSER_ATTACK`, `ATTACK_TYPE_SESSION_HIJACKING`, `ATTACK_TYPE_HTTP_RESPONSE_SPLITTING`, `ATTACK_TYPE_FORCEFUL_BROWSING`, `ATTACK_TYPE_REMOTE_FILE_INCLUDE`, `ATTACK_TYPE_MALICIOUS_FILE_UPLOAD`, `ATTACK_TYPE_GRAPHQL_PARSER_ATTACK`. Defaults to `ATTACK_TYPE_NONE`.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"default_attack_type_settings": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"high_medium_accuracy_signatures": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"high_medium_low_accuracy_signatures": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"only_high_accuracy_signatures": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"stage_new_and_updated_signatures": schema.SingleNestedBlock{
						MarkdownDescription: "Attack Signatures Staging Settings. Attack Signatures staging configuration.",
						Attributes: map[string]schema.Attribute{
							"staging_period": schema.Int64Attribute{
								MarkdownDescription: "Staging Period. Define staging period in days. The default staging period is 7 days and the max supported staging period is 20 days.",
								Optional:            true,
							},
						},
					},
					"stage_new_signatures": schema.SingleNestedBlock{
						MarkdownDescription: "Attack Signatures Staging Settings. Attack Signatures staging configuration.",
						Attributes: map[string]schema.Attribute{
							"staging_period": schema.Int64Attribute{
								MarkdownDescription: "Staging Period. Define staging period in days. The default staging period is 7 days and the max supported staging period is 20 days.",
								Optional:            true,
							},
						},
					},
					"violation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Violation Settings. Specifies violation settings to be used by WAF",
						Attributes: map[string]schema.Attribute{
							"disabled_violation_types": schema.ListAttribute{
								MarkdownDescription: "[Enum: VIOL_NONE|VIOL_FILETYPE|VIOL_METHOD|VIOL_MANDATORY_HEADER|VIOL_HTTP_RESPONSE_STATUS|VIOL_REQUEST_MAX_LENGTH|VIOL_FILE_UPLOAD|VIOL_FILE_UPLOAD_IN_BODY|VIOL_XML_MALFORMED|VIOL_JSON_MALFORMED|VIOL_ASM_COOKIE_MODIFIED|VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS|VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE|VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT|VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST|VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION|VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS|VIOL_EVASION_DIRECTORY_TRAVERSALS|VIOL_MALFORMED_REQUEST|VIOL_EVASION_MULTIPLE_DECODING|VIOL_DATA_GUARD|VIOL_EVASION_APACHE_WHITESPACE|VIOL_COOKIE_MODIFIED|VIOL_EVASION_IIS_UNICODE_CODEPOINTS|VIOL_EVASION_IIS_BACKSLASHES|VIOL_EVASION_PERCENT_U_DECODING|VIOL_EVASION_BARE_BYTE_DECODING|VIOL_EVASION_BAD_UNESCAPE|VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST|VIOL_ENCODING|VIOL_COOKIE_MALFORMED|VIOL_GRAPHQL_FORMAT|VIOL_GRAPHQL_MALFORMED|VIOL_GRAPHQL_INTROSPECTION_QUERY] Disabled Violations. List of violations to be excluded. Possible values are `VIOL_NONE`, `VIOL_FILETYPE`, `VIOL_METHOD`, `VIOL_MANDATORY_HEADER`, `VIOL_HTTP_RESPONSE_STATUS`, `VIOL_REQUEST_MAX_LENGTH`, `VIOL_FILE_UPLOAD`, `VIOL_FILE_UPLOAD_IN_BODY`, `VIOL_XML_MALFORMED`, `VIOL_JSON_MALFORMED`, `VIOL_ASM_COOKIE_MODIFIED`, `VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS`, `VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE`, `VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT`, `VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST`, `VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION`, `VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS`, `VIOL_EVASION_DIRECTORY_TRAVERSALS`, `VIOL_MALFORMED_REQUEST`, `VIOL_EVASION_MULTIPLE_DECODING`, `VIOL_DATA_GUARD`, `VIOL_EVASION_APACHE_WHITESPACE`, `VIOL_COOKIE_MODIFIED`, `VIOL_EVASION_IIS_UNICODE_CODEPOINTS`, `VIOL_EVASION_IIS_BACKSLASHES`, `VIOL_EVASION_PERCENT_U_DECODING`, `VIOL_EVASION_BARE_BYTE_DECODING`, `VIOL_EVASION_BAD_UNESCAPE`, `VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST`, `VIOL_ENCODING`, `VIOL_COOKIE_MALFORMED`, `VIOL_GRAPHQL_FORMAT`, `VIOL_GRAPHQL_MALFORMED`, `VIOL_GRAPHQL_INTROSPECTION_QUERY`. Defaults to `VIOL_NONE`.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
				},
			},
			"disable_anonymization": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"monitoring": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"use_default_blocking_page": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
		},
	}
}

func (r *AppFirewallResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AppFirewallResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AppFirewallResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the app_firewall from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AppFirewallResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AppFirewallResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AppFirewallResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AppFirewallResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating app_firewall", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.AppFirewall{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AiRiskBasedBlocking != nil {
		ai_risk_based_blockingMap := make(map[string]interface{})
		if !data.AiRiskBasedBlocking.HighRiskAction.IsNull() && !data.AiRiskBasedBlocking.HighRiskAction.IsUnknown() {
			ai_risk_based_blockingMap["high_risk_action"] = data.AiRiskBasedBlocking.HighRiskAction.ValueString()
		}
		if !data.AiRiskBasedBlocking.LowRiskAction.IsNull() && !data.AiRiskBasedBlocking.LowRiskAction.IsUnknown() {
			ai_risk_based_blockingMap["low_risk_action"] = data.AiRiskBasedBlocking.LowRiskAction.ValueString()
		}
		if !data.AiRiskBasedBlocking.MediumRiskAction.IsNull() && !data.AiRiskBasedBlocking.MediumRiskAction.IsUnknown() {
			ai_risk_based_blockingMap["medium_risk_action"] = data.AiRiskBasedBlocking.MediumRiskAction.ValueString()
		}
		createReq.Spec["ai_risk_based_blocking"] = ai_risk_based_blockingMap
	}
	if data.AllowAllResponseCodes != nil {
		allow_all_response_codesMap := make(map[string]interface{})
		createReq.Spec["allow_all_response_codes"] = allow_all_response_codesMap
	}
	if data.AllowedResponseCodes != nil {
		allowed_response_codesMap := make(map[string]interface{})
		if !data.AllowedResponseCodes.ResponseCode.IsNull() && !data.AllowedResponseCodes.ResponseCode.IsUnknown() {
			var response_codeItems []int64
			diags := data.AllowedResponseCodes.ResponseCode.ElementsAs(ctx, &response_codeItems, false)
			if !diags.HasError() {
				allowed_response_codesMap["response_code"] = response_codeItems
			}
		}
		createReq.Spec["allowed_response_codes"] = allowed_response_codesMap
	}
	if data.Blocking != nil {
		blockingMap := make(map[string]interface{})
		createReq.Spec["blocking"] = blockingMap
	}
	if data.BlockingPage != nil {
		blocking_pageMap := make(map[string]interface{})
		if !data.BlockingPage.BlockingPage.IsNull() && !data.BlockingPage.BlockingPage.IsUnknown() {
			blocking_pageMap["blocking_page"] = data.BlockingPage.BlockingPage.ValueString()
		}
		if !data.BlockingPage.ResponseCode.IsNull() && !data.BlockingPage.ResponseCode.IsUnknown() {
			blocking_pageMap["response_code"] = data.BlockingPage.ResponseCode.ValueString()
		}
		createReq.Spec["blocking_page"] = blocking_pageMap
	}
	if data.BotProtectionSetting != nil {
		bot_protection_settingMap := make(map[string]interface{})
		if !data.BotProtectionSetting.GoodBotAction.IsNull() && !data.BotProtectionSetting.GoodBotAction.IsUnknown() {
			bot_protection_settingMap["good_bot_action"] = data.BotProtectionSetting.GoodBotAction.ValueString()
		}
		if !data.BotProtectionSetting.MaliciousBotAction.IsNull() && !data.BotProtectionSetting.MaliciousBotAction.IsUnknown() {
			bot_protection_settingMap["malicious_bot_action"] = data.BotProtectionSetting.MaliciousBotAction.ValueString()
		}
		if !data.BotProtectionSetting.SuspiciousBotAction.IsNull() && !data.BotProtectionSetting.SuspiciousBotAction.IsUnknown() {
			bot_protection_settingMap["suspicious_bot_action"] = data.BotProtectionSetting.SuspiciousBotAction.ValueString()
		}
		createReq.Spec["bot_protection_setting"] = bot_protection_settingMap
	}
	if data.CustomAnonymization != nil {
		custom_anonymizationMap := make(map[string]interface{})
		if len(data.CustomAnonymization.AnonymizationConfig) > 0 {
			var anonymization_configList []map[string]interface{}
			for _, listItem := range data.CustomAnonymization.AnonymizationConfig {
				listItemMap := make(map[string]interface{})
				if listItem.Cookie != nil {
					cookieDeepMap := make(map[string]interface{})
					if !listItem.Cookie.CookieName.IsNull() && !listItem.Cookie.CookieName.IsUnknown() {
						cookieDeepMap["cookie_name"] = listItem.Cookie.CookieName.ValueString()
					}
					listItemMap["cookie"] = cookieDeepMap
				}
				if listItem.HTTPHeader != nil {
					http_headerDeepMap := make(map[string]interface{})
					if !listItem.HTTPHeader.HeaderName.IsNull() && !listItem.HTTPHeader.HeaderName.IsUnknown() {
						http_headerDeepMap["header_name"] = listItem.HTTPHeader.HeaderName.ValueString()
					}
					listItemMap["http_header"] = http_headerDeepMap
				}
				if listItem.QueryParameter != nil {
					query_parameterDeepMap := make(map[string]interface{})
					if !listItem.QueryParameter.QueryParamName.IsNull() && !listItem.QueryParameter.QueryParamName.IsUnknown() {
						query_parameterDeepMap["query_param_name"] = listItem.QueryParameter.QueryParamName.ValueString()
					}
					listItemMap["query_parameter"] = query_parameterDeepMap
				}
				anonymization_configList = append(anonymization_configList, listItemMap)
			}
			custom_anonymizationMap["anonymization_config"] = anonymization_configList
		}
		createReq.Spec["custom_anonymization"] = custom_anonymizationMap
	}
	if data.DefaultAnonymization != nil {
		default_anonymizationMap := make(map[string]interface{})
		createReq.Spec["default_anonymization"] = default_anonymizationMap
	}
	if data.DefaultBotSetting != nil {
		default_bot_settingMap := make(map[string]interface{})
		createReq.Spec["default_bot_setting"] = default_bot_settingMap
	}
	if data.DefaultDetectionSettings != nil {
		default_detection_settingsMap := make(map[string]interface{})
		createReq.Spec["default_detection_settings"] = default_detection_settingsMap
	}
	if data.DetectionSettings != nil {
		detection_settingsMap := make(map[string]interface{})
		if data.DetectionSettings.BotProtectionSetting != nil {
			bot_protection_settingNestedMap := make(map[string]interface{})
			if !data.DetectionSettings.BotProtectionSetting.GoodBotAction.IsNull() && !data.DetectionSettings.BotProtectionSetting.GoodBotAction.IsUnknown() {
				bot_protection_settingNestedMap["good_bot_action"] = data.DetectionSettings.BotProtectionSetting.GoodBotAction.ValueString()
			}
			if !data.DetectionSettings.BotProtectionSetting.MaliciousBotAction.IsNull() && !data.DetectionSettings.BotProtectionSetting.MaliciousBotAction.IsUnknown() {
				bot_protection_settingNestedMap["malicious_bot_action"] = data.DetectionSettings.BotProtectionSetting.MaliciousBotAction.ValueString()
			}
			if !data.DetectionSettings.BotProtectionSetting.SuspiciousBotAction.IsNull() && !data.DetectionSettings.BotProtectionSetting.SuspiciousBotAction.IsUnknown() {
				bot_protection_settingNestedMap["suspicious_bot_action"] = data.DetectionSettings.BotProtectionSetting.SuspiciousBotAction.ValueString()
			}
			detection_settingsMap["bot_protection_setting"] = bot_protection_settingNestedMap
		}
		if data.DetectionSettings.DefaultBotSetting != nil {
			detection_settingsMap["default_bot_setting"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DefaultViolationSettings != nil {
			detection_settingsMap["default_violation_settings"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DisableStaging != nil {
			detection_settingsMap["disable_staging"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DisableSuppression != nil {
			detection_settingsMap["disable_suppression"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DisableThreatCampaigns != nil {
			detection_settingsMap["disable_threat_campaigns"] = map[string]interface{}{}
		}
		if data.DetectionSettings.EnableSuppression != nil {
			detection_settingsMap["enable_suppression"] = map[string]interface{}{}
		}
		if data.DetectionSettings.EnableThreatCampaigns != nil {
			detection_settingsMap["enable_threat_campaigns"] = map[string]interface{}{}
		}
		if data.DetectionSettings.SignatureSelectionSetting != nil {
			signature_selection_settingNestedMap := make(map[string]interface{})
			detection_settingsMap["signature_selection_setting"] = signature_selection_settingNestedMap
		}
		if data.DetectionSettings.StageNewAndUpdatedSignatures != nil {
			stage_new_and_updated_signaturesNestedMap := make(map[string]interface{})
			if !data.DetectionSettings.StageNewAndUpdatedSignatures.StagingPeriod.IsNull() && !data.DetectionSettings.StageNewAndUpdatedSignatures.StagingPeriod.IsUnknown() {
				stage_new_and_updated_signaturesNestedMap["staging_period"] = data.DetectionSettings.StageNewAndUpdatedSignatures.StagingPeriod.ValueInt64()
			}
			detection_settingsMap["stage_new_and_updated_signatures"] = stage_new_and_updated_signaturesNestedMap
		}
		if data.DetectionSettings.StageNewSignatures != nil {
			stage_new_signaturesNestedMap := make(map[string]interface{})
			if !data.DetectionSettings.StageNewSignatures.StagingPeriod.IsNull() && !data.DetectionSettings.StageNewSignatures.StagingPeriod.IsUnknown() {
				stage_new_signaturesNestedMap["staging_period"] = data.DetectionSettings.StageNewSignatures.StagingPeriod.ValueInt64()
			}
			detection_settingsMap["stage_new_signatures"] = stage_new_signaturesNestedMap
		}
		if data.DetectionSettings.ViolationSettings != nil {
			violation_settingsNestedMap := make(map[string]interface{})
			detection_settingsMap["violation_settings"] = violation_settingsNestedMap
		}
		createReq.Spec["detection_settings"] = detection_settingsMap
	}
	if data.DisableAnonymization != nil {
		disable_anonymizationMap := make(map[string]interface{})
		createReq.Spec["disable_anonymization"] = disable_anonymizationMap
	}
	if data.Monitoring != nil {
		monitoringMap := make(map[string]interface{})
		createReq.Spec["monitoring"] = monitoringMap
	}
	if data.UseDefaultBlockingPage != nil {
		use_default_blocking_pageMap := make(map[string]interface{})
		createReq.Spec["use_default_blocking_page"] = use_default_blocking_pageMap
	}

	apiResource, err := r.client.CreateAppFirewall(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AppFirewall: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["ai_risk_based_blocking"].(map[string]interface{}); ok && (isImport || data.AiRiskBasedBlocking != nil) {
		data.AiRiskBasedBlocking = &AppFirewallAiRiskBasedBlockingModel{
			HighRiskAction: func() types.String {
				if v, ok := blockData["high_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LowRiskAction: func() types.String {
				if v, ok := blockData["low_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MediumRiskAction: func() types.String {
				if v, ok := blockData["medium_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["allow_all_response_codes"].(map[string]interface{}); ok && isImport && data.AllowAllResponseCodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AllowAllResponseCodes = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["allowed_response_codes"].(map[string]interface{}); ok && (isImport || data.AllowedResponseCodes != nil) {
		data.AllowedResponseCodes = &AppFirewallAllowedResponseCodesModel{
			ResponseCode: func() types.List {
				if v, ok := blockData["response_code"].([]interface{}); ok && len(v) > 0 {
					var items []int64
					for _, item := range v {
						if n, ok := item.(float64); ok {
							items = append(items, int64(n))
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.Int64Type, items)
					return listVal
				}
				return types.ListNull(types.Int64Type)
			}(),
		}
	}
	if _, ok := apiResource.Spec["blocking"].(map[string]interface{}); ok && isImport && data.Blocking == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Blocking = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocking_page"].(map[string]interface{}); ok && (isImport || data.BlockingPage != nil) {
		data.BlockingPage = &AppFirewallBlockingPageModel{
			BlockingPage: func() types.String {
				if v, ok := blockData["blocking_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ResponseCode: func() types.String {
				if v, ok := blockData["response_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["bot_protection_setting"].(map[string]interface{}); ok && (isImport || data.BotProtectionSetting != nil) {
		data.BotProtectionSetting = &AppFirewallBotProtectionSettingModel{
			GoodBotAction: func() types.String {
				if v, ok := blockData["good_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaliciousBotAction: func() types.String {
				if v, ok := blockData["malicious_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SuspiciousBotAction: func() types.String {
				if v, ok := blockData["suspicious_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_anonymization"].(map[string]interface{}); ok && (isImport || data.CustomAnonymization != nil) {
		data.CustomAnonymization = &AppFirewallCustomAnonymizationModel{
			AnonymizationConfig: func() []AppFirewallCustomAnonymizationAnonymizationConfigModel {
				if listData, ok := blockData["anonymization_config"].([]interface{}); ok && len(listData) > 0 {
					var result []AppFirewallCustomAnonymizationAnonymizationConfigModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AppFirewallCustomAnonymizationAnonymizationConfigModel{
								Cookie: func() *AppFirewallCustomAnonymizationAnonymizationConfigCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigCookieModel{
											CookieName: func() types.String {
												if v, ok := deepMap["cookie_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								HTTPHeader: func() *AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel {
									if deepMap, ok := itemMap["http_header"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel{
											HeaderName: func() types.String {
												if v, ok := deepMap["header_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								QueryParameter: func() *AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel {
									if deepMap, ok := itemMap["query_parameter"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel{
											QueryParamName: func() types.String {
												if v, ok := deepMap["query_param_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_anonymization"].(map[string]interface{}); ok && isImport && data.DefaultAnonymization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultAnonymization = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_bot_setting"].(map[string]interface{}); ok && isImport && data.DefaultBotSetting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBotSetting = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_detection_settings"].(map[string]interface{}); ok && isImport && data.DefaultDetectionSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultDetectionSettings = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["detection_settings"].(map[string]interface{}); ok && isImport && data.DetectionSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DetectionSettings = &AppFirewallDetectionSettingsModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_anonymization"].(map[string]interface{}); ok && isImport && data.DisableAnonymization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAnonymization = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["monitoring"].(map[string]interface{}); ok && isImport && data.Monitoring == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Monitoring = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["use_default_blocking_page"].(map[string]interface{}); ok && isImport && data.UseDefaultBlockingPage == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UseDefaultBlockingPage = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created AppFirewall resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppFirewallResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAppFirewall(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AppFirewall not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AppFirewall: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The app_firewall may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["ai_risk_based_blocking"].(map[string]interface{}); ok && (isImport || data.AiRiskBasedBlocking != nil) {
		data.AiRiskBasedBlocking = &AppFirewallAiRiskBasedBlockingModel{
			HighRiskAction: func() types.String {
				if v, ok := blockData["high_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LowRiskAction: func() types.String {
				if v, ok := blockData["low_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MediumRiskAction: func() types.String {
				if v, ok := blockData["medium_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["allow_all_response_codes"].(map[string]interface{}); ok && isImport && data.AllowAllResponseCodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AllowAllResponseCodes = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["allowed_response_codes"].(map[string]interface{}); ok && (isImport || data.AllowedResponseCodes != nil) {
		data.AllowedResponseCodes = &AppFirewallAllowedResponseCodesModel{
			ResponseCode: func() types.List {
				if v, ok := blockData["response_code"].([]interface{}); ok && len(v) > 0 {
					var items []int64
					for _, item := range v {
						if n, ok := item.(float64); ok {
							items = append(items, int64(n))
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.Int64Type, items)
					return listVal
				}
				return types.ListNull(types.Int64Type)
			}(),
		}
	}
	if _, ok := apiResource.Spec["blocking"].(map[string]interface{}); ok && isImport && data.Blocking == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Blocking = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocking_page"].(map[string]interface{}); ok && (isImport || data.BlockingPage != nil) {
		data.BlockingPage = &AppFirewallBlockingPageModel{
			BlockingPage: func() types.String {
				if v, ok := blockData["blocking_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ResponseCode: func() types.String {
				if v, ok := blockData["response_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["bot_protection_setting"].(map[string]interface{}); ok && (isImport || data.BotProtectionSetting != nil) {
		data.BotProtectionSetting = &AppFirewallBotProtectionSettingModel{
			GoodBotAction: func() types.String {
				if v, ok := blockData["good_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaliciousBotAction: func() types.String {
				if v, ok := blockData["malicious_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SuspiciousBotAction: func() types.String {
				if v, ok := blockData["suspicious_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_anonymization"].(map[string]interface{}); ok && (isImport || data.CustomAnonymization != nil) {
		data.CustomAnonymization = &AppFirewallCustomAnonymizationModel{
			AnonymizationConfig: func() []AppFirewallCustomAnonymizationAnonymizationConfigModel {
				if listData, ok := blockData["anonymization_config"].([]interface{}); ok && len(listData) > 0 {
					var result []AppFirewallCustomAnonymizationAnonymizationConfigModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AppFirewallCustomAnonymizationAnonymizationConfigModel{
								Cookie: func() *AppFirewallCustomAnonymizationAnonymizationConfigCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigCookieModel{
											CookieName: func() types.String {
												if v, ok := deepMap["cookie_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								HTTPHeader: func() *AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel {
									if deepMap, ok := itemMap["http_header"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel{
											HeaderName: func() types.String {
												if v, ok := deepMap["header_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								QueryParameter: func() *AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel {
									if deepMap, ok := itemMap["query_parameter"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel{
											QueryParamName: func() types.String {
												if v, ok := deepMap["query_param_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_anonymization"].(map[string]interface{}); ok && isImport && data.DefaultAnonymization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultAnonymization = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_bot_setting"].(map[string]interface{}); ok && isImport && data.DefaultBotSetting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBotSetting = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_detection_settings"].(map[string]interface{}); ok && isImport && data.DefaultDetectionSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultDetectionSettings = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["detection_settings"].(map[string]interface{}); ok && isImport && data.DetectionSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DetectionSettings = &AppFirewallDetectionSettingsModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_anonymization"].(map[string]interface{}); ok && isImport && data.DisableAnonymization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAnonymization = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["monitoring"].(map[string]interface{}); ok && isImport && data.Monitoring == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Monitoring = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["use_default_blocking_page"].(map[string]interface{}); ok && isImport && data.UseDefaultBlockingPage == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UseDefaultBlockingPage = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppFirewallResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.AppFirewall{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AiRiskBasedBlocking != nil {
		ai_risk_based_blockingMap := make(map[string]interface{})
		if !data.AiRiskBasedBlocking.HighRiskAction.IsNull() && !data.AiRiskBasedBlocking.HighRiskAction.IsUnknown() {
			ai_risk_based_blockingMap["high_risk_action"] = data.AiRiskBasedBlocking.HighRiskAction.ValueString()
		}
		if !data.AiRiskBasedBlocking.LowRiskAction.IsNull() && !data.AiRiskBasedBlocking.LowRiskAction.IsUnknown() {
			ai_risk_based_blockingMap["low_risk_action"] = data.AiRiskBasedBlocking.LowRiskAction.ValueString()
		}
		if !data.AiRiskBasedBlocking.MediumRiskAction.IsNull() && !data.AiRiskBasedBlocking.MediumRiskAction.IsUnknown() {
			ai_risk_based_blockingMap["medium_risk_action"] = data.AiRiskBasedBlocking.MediumRiskAction.ValueString()
		}
		apiResource.Spec["ai_risk_based_blocking"] = ai_risk_based_blockingMap
	}
	if data.AllowAllResponseCodes != nil {
		allow_all_response_codesMap := make(map[string]interface{})
		apiResource.Spec["allow_all_response_codes"] = allow_all_response_codesMap
	}
	if data.AllowedResponseCodes != nil {
		allowed_response_codesMap := make(map[string]interface{})
		if !data.AllowedResponseCodes.ResponseCode.IsNull() && !data.AllowedResponseCodes.ResponseCode.IsUnknown() {
			var response_codeItems []int64
			diags := data.AllowedResponseCodes.ResponseCode.ElementsAs(ctx, &response_codeItems, false)
			if !diags.HasError() {
				allowed_response_codesMap["response_code"] = response_codeItems
			}
		}
		apiResource.Spec["allowed_response_codes"] = allowed_response_codesMap
	}
	if data.Blocking != nil {
		blockingMap := make(map[string]interface{})
		apiResource.Spec["blocking"] = blockingMap
	}
	if data.BlockingPage != nil {
		blocking_pageMap := make(map[string]interface{})
		if !data.BlockingPage.BlockingPage.IsNull() && !data.BlockingPage.BlockingPage.IsUnknown() {
			blocking_pageMap["blocking_page"] = data.BlockingPage.BlockingPage.ValueString()
		}
		if !data.BlockingPage.ResponseCode.IsNull() && !data.BlockingPage.ResponseCode.IsUnknown() {
			blocking_pageMap["response_code"] = data.BlockingPage.ResponseCode.ValueString()
		}
		apiResource.Spec["blocking_page"] = blocking_pageMap
	}
	if data.BotProtectionSetting != nil {
		bot_protection_settingMap := make(map[string]interface{})
		if !data.BotProtectionSetting.GoodBotAction.IsNull() && !data.BotProtectionSetting.GoodBotAction.IsUnknown() {
			bot_protection_settingMap["good_bot_action"] = data.BotProtectionSetting.GoodBotAction.ValueString()
		}
		if !data.BotProtectionSetting.MaliciousBotAction.IsNull() && !data.BotProtectionSetting.MaliciousBotAction.IsUnknown() {
			bot_protection_settingMap["malicious_bot_action"] = data.BotProtectionSetting.MaliciousBotAction.ValueString()
		}
		if !data.BotProtectionSetting.SuspiciousBotAction.IsNull() && !data.BotProtectionSetting.SuspiciousBotAction.IsUnknown() {
			bot_protection_settingMap["suspicious_bot_action"] = data.BotProtectionSetting.SuspiciousBotAction.ValueString()
		}
		apiResource.Spec["bot_protection_setting"] = bot_protection_settingMap
	}
	if data.CustomAnonymization != nil {
		custom_anonymizationMap := make(map[string]interface{})
		if len(data.CustomAnonymization.AnonymizationConfig) > 0 {
			var anonymization_configList []map[string]interface{}
			for _, listItem := range data.CustomAnonymization.AnonymizationConfig {
				listItemMap := make(map[string]interface{})
				if listItem.Cookie != nil {
					cookieDeepMap := make(map[string]interface{})
					if !listItem.Cookie.CookieName.IsNull() && !listItem.Cookie.CookieName.IsUnknown() {
						cookieDeepMap["cookie_name"] = listItem.Cookie.CookieName.ValueString()
					}
					listItemMap["cookie"] = cookieDeepMap
				}
				if listItem.HTTPHeader != nil {
					http_headerDeepMap := make(map[string]interface{})
					if !listItem.HTTPHeader.HeaderName.IsNull() && !listItem.HTTPHeader.HeaderName.IsUnknown() {
						http_headerDeepMap["header_name"] = listItem.HTTPHeader.HeaderName.ValueString()
					}
					listItemMap["http_header"] = http_headerDeepMap
				}
				if listItem.QueryParameter != nil {
					query_parameterDeepMap := make(map[string]interface{})
					if !listItem.QueryParameter.QueryParamName.IsNull() && !listItem.QueryParameter.QueryParamName.IsUnknown() {
						query_parameterDeepMap["query_param_name"] = listItem.QueryParameter.QueryParamName.ValueString()
					}
					listItemMap["query_parameter"] = query_parameterDeepMap
				}
				anonymization_configList = append(anonymization_configList, listItemMap)
			}
			custom_anonymizationMap["anonymization_config"] = anonymization_configList
		}
		apiResource.Spec["custom_anonymization"] = custom_anonymizationMap
	}
	if data.DefaultAnonymization != nil {
		default_anonymizationMap := make(map[string]interface{})
		apiResource.Spec["default_anonymization"] = default_anonymizationMap
	}
	if data.DefaultBotSetting != nil {
		default_bot_settingMap := make(map[string]interface{})
		apiResource.Spec["default_bot_setting"] = default_bot_settingMap
	}
	if data.DefaultDetectionSettings != nil {
		default_detection_settingsMap := make(map[string]interface{})
		apiResource.Spec["default_detection_settings"] = default_detection_settingsMap
	}
	if data.DetectionSettings != nil {
		detection_settingsMap := make(map[string]interface{})
		if data.DetectionSettings.BotProtectionSetting != nil {
			bot_protection_settingNestedMap := make(map[string]interface{})
			if !data.DetectionSettings.BotProtectionSetting.GoodBotAction.IsNull() && !data.DetectionSettings.BotProtectionSetting.GoodBotAction.IsUnknown() {
				bot_protection_settingNestedMap["good_bot_action"] = data.DetectionSettings.BotProtectionSetting.GoodBotAction.ValueString()
			}
			if !data.DetectionSettings.BotProtectionSetting.MaliciousBotAction.IsNull() && !data.DetectionSettings.BotProtectionSetting.MaliciousBotAction.IsUnknown() {
				bot_protection_settingNestedMap["malicious_bot_action"] = data.DetectionSettings.BotProtectionSetting.MaliciousBotAction.ValueString()
			}
			if !data.DetectionSettings.BotProtectionSetting.SuspiciousBotAction.IsNull() && !data.DetectionSettings.BotProtectionSetting.SuspiciousBotAction.IsUnknown() {
				bot_protection_settingNestedMap["suspicious_bot_action"] = data.DetectionSettings.BotProtectionSetting.SuspiciousBotAction.ValueString()
			}
			detection_settingsMap["bot_protection_setting"] = bot_protection_settingNestedMap
		}
		if data.DetectionSettings.DefaultBotSetting != nil {
			detection_settingsMap["default_bot_setting"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DefaultViolationSettings != nil {
			detection_settingsMap["default_violation_settings"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DisableStaging != nil {
			detection_settingsMap["disable_staging"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DisableSuppression != nil {
			detection_settingsMap["disable_suppression"] = map[string]interface{}{}
		}
		if data.DetectionSettings.DisableThreatCampaigns != nil {
			detection_settingsMap["disable_threat_campaigns"] = map[string]interface{}{}
		}
		if data.DetectionSettings.EnableSuppression != nil {
			detection_settingsMap["enable_suppression"] = map[string]interface{}{}
		}
		if data.DetectionSettings.EnableThreatCampaigns != nil {
			detection_settingsMap["enable_threat_campaigns"] = map[string]interface{}{}
		}
		if data.DetectionSettings.SignatureSelectionSetting != nil {
			signature_selection_settingNestedMap := make(map[string]interface{})
			detection_settingsMap["signature_selection_setting"] = signature_selection_settingNestedMap
		}
		if data.DetectionSettings.StageNewAndUpdatedSignatures != nil {
			stage_new_and_updated_signaturesNestedMap := make(map[string]interface{})
			if !data.DetectionSettings.StageNewAndUpdatedSignatures.StagingPeriod.IsNull() && !data.DetectionSettings.StageNewAndUpdatedSignatures.StagingPeriod.IsUnknown() {
				stage_new_and_updated_signaturesNestedMap["staging_period"] = data.DetectionSettings.StageNewAndUpdatedSignatures.StagingPeriod.ValueInt64()
			}
			detection_settingsMap["stage_new_and_updated_signatures"] = stage_new_and_updated_signaturesNestedMap
		}
		if data.DetectionSettings.StageNewSignatures != nil {
			stage_new_signaturesNestedMap := make(map[string]interface{})
			if !data.DetectionSettings.StageNewSignatures.StagingPeriod.IsNull() && !data.DetectionSettings.StageNewSignatures.StagingPeriod.IsUnknown() {
				stage_new_signaturesNestedMap["staging_period"] = data.DetectionSettings.StageNewSignatures.StagingPeriod.ValueInt64()
			}
			detection_settingsMap["stage_new_signatures"] = stage_new_signaturesNestedMap
		}
		if data.DetectionSettings.ViolationSettings != nil {
			violation_settingsNestedMap := make(map[string]interface{})
			detection_settingsMap["violation_settings"] = violation_settingsNestedMap
		}
		apiResource.Spec["detection_settings"] = detection_settingsMap
	}
	if data.DisableAnonymization != nil {
		disable_anonymizationMap := make(map[string]interface{})
		apiResource.Spec["disable_anonymization"] = disable_anonymizationMap
	}
	if data.Monitoring != nil {
		monitoringMap := make(map[string]interface{})
		apiResource.Spec["monitoring"] = monitoringMap
	}
	if data.UseDefaultBlockingPage != nil {
		use_default_blocking_pageMap := make(map[string]interface{})
		apiResource.Spec["use_default_blocking_page"] = use_default_blocking_pageMap
	}

	_, err := r.client.UpdateAppFirewall(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AppFirewall: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAppFirewall(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AppFirewall after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["ai_risk_based_blocking"].(map[string]interface{}); ok && (isImport || data.AiRiskBasedBlocking != nil) {
		data.AiRiskBasedBlocking = &AppFirewallAiRiskBasedBlockingModel{
			HighRiskAction: func() types.String {
				if v, ok := blockData["high_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LowRiskAction: func() types.String {
				if v, ok := blockData["low_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MediumRiskAction: func() types.String {
				if v, ok := blockData["medium_risk_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["allow_all_response_codes"].(map[string]interface{}); ok && isImport && data.AllowAllResponseCodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AllowAllResponseCodes = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["allowed_response_codes"].(map[string]interface{}); ok && (isImport || data.AllowedResponseCodes != nil) {
		data.AllowedResponseCodes = &AppFirewallAllowedResponseCodesModel{
			ResponseCode: func() types.List {
				if v, ok := blockData["response_code"].([]interface{}); ok && len(v) > 0 {
					var items []int64
					for _, item := range v {
						if n, ok := item.(float64); ok {
							items = append(items, int64(n))
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.Int64Type, items)
					return listVal
				}
				return types.ListNull(types.Int64Type)
			}(),
		}
	}
	if _, ok := apiResource.Spec["blocking"].(map[string]interface{}); ok && isImport && data.Blocking == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Blocking = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocking_page"].(map[string]interface{}); ok && (isImport || data.BlockingPage != nil) {
		data.BlockingPage = &AppFirewallBlockingPageModel{
			BlockingPage: func() types.String {
				if v, ok := blockData["blocking_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ResponseCode: func() types.String {
				if v, ok := blockData["response_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["bot_protection_setting"].(map[string]interface{}); ok && (isImport || data.BotProtectionSetting != nil) {
		data.BotProtectionSetting = &AppFirewallBotProtectionSettingModel{
			GoodBotAction: func() types.String {
				if v, ok := blockData["good_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaliciousBotAction: func() types.String {
				if v, ok := blockData["malicious_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SuspiciousBotAction: func() types.String {
				if v, ok := blockData["suspicious_bot_action"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_anonymization"].(map[string]interface{}); ok && (isImport || data.CustomAnonymization != nil) {
		data.CustomAnonymization = &AppFirewallCustomAnonymizationModel{
			AnonymizationConfig: func() []AppFirewallCustomAnonymizationAnonymizationConfigModel {
				if listData, ok := blockData["anonymization_config"].([]interface{}); ok && len(listData) > 0 {
					var result []AppFirewallCustomAnonymizationAnonymizationConfigModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AppFirewallCustomAnonymizationAnonymizationConfigModel{
								Cookie: func() *AppFirewallCustomAnonymizationAnonymizationConfigCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigCookieModel{
											CookieName: func() types.String {
												if v, ok := deepMap["cookie_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								HTTPHeader: func() *AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel {
									if deepMap, ok := itemMap["http_header"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigHTTPHeaderModel{
											HeaderName: func() types.String {
												if v, ok := deepMap["header_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								QueryParameter: func() *AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel {
									if deepMap, ok := itemMap["query_parameter"].(map[string]interface{}); ok {
										return &AppFirewallCustomAnonymizationAnonymizationConfigQueryParameterModel{
											QueryParamName: func() types.String {
												if v, ok := deepMap["query_param_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_anonymization"].(map[string]interface{}); ok && isImport && data.DefaultAnonymization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultAnonymization = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_bot_setting"].(map[string]interface{}); ok && isImport && data.DefaultBotSetting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBotSetting = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_detection_settings"].(map[string]interface{}); ok && isImport && data.DefaultDetectionSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultDetectionSettings = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["detection_settings"].(map[string]interface{}); ok && isImport && data.DetectionSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DetectionSettings = &AppFirewallDetectionSettingsModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_anonymization"].(map[string]interface{}); ok && isImport && data.DisableAnonymization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAnonymization = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["monitoring"].(map[string]interface{}); ok && isImport && data.Monitoring == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Monitoring = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["use_default_blocking_page"].(map[string]interface{}); ok && isImport && data.UseDefaultBlockingPage == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UseDefaultBlockingPage = &AppFirewallEmptyModel{}
	}
	// Normal Read: preserve existing state value

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppFirewallResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAppFirewall(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AppFirewall already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "AppFirewall delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AppFirewall: %s", err))
		return
	}
}

func (r *AppFirewallResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
