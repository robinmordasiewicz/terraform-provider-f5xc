// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
)

var (
	_ resource.Resource                = &AppFirewallResource{}
	_ resource.ResourceWithConfigure   = &AppFirewallResource{}
	_ resource.ResourceWithImportState = &AppFirewallResource{}
)

func NewAppFirewallResource() resource.Resource {
	return &AppFirewallResource{}
}

type AppFirewallResource struct {
	client *client.Client
}

type AppFirewallResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Labels types.Map `tfsdk:"labels"`
	Annotations types.Map `tfsdk:"annotations"`
	ID types.String `tfsdk:"id"`
}

func (r *AppFirewallResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_app_firewall"
}

func (r *AppFirewallResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages Application Firewall in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the AppFirewall. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the AppFirewall will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"ai_risk_based_blocking": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ai_risk_based_blocking, default_detection_settings, detection_settings] Risk-Based Blocking (Powered by AI) - Preview. All Attack Types, including high, medium, and low accuracy signatures, automatic Attack Signature tuning, Threat Campaigns, and all Violations will be enabled. AI and ML algorithms will assess request risk, and only high-risk requests will be blocked by default. This feature is in preview mode.",
				Attributes: map[string]schema.Attribute{
					"high_risk_action": schema.StringAttribute{
						MarkdownDescription: "Risk Based Blocking Action. Action to be performed on the request Log and block Log only",
						Optional: true,
					},
					"low_risk_action": schema.StringAttribute{
						MarkdownDescription: "Risk Based Blocking Action. Action to be performed on the request Log and block Log only",
						Optional: true,
					},
					"medium_risk_action": schema.StringAttribute{
						MarkdownDescription: "Risk Based Blocking Action. Action to be performed on the request Log and block Log only",
						Optional: true,
					},
				},

			},
			"allow_all_response_codes": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: allow_all_response_codes, allowed_response_codes] Empty. This can be used for messages where no values are needed",
			},
			"allowed_response_codes": schema.SingleNestedBlock{
				MarkdownDescription: "Allowed Response Codes. List of HTTP response status codes that are allowed",
				Attributes: map[string]schema.Attribute{
					"response_code": schema.ListAttribute{
						MarkdownDescription: "Response Code. List of HTTP response status codes that are allowed",
						Optional: true,
						ElementType: types.StringType,
					},
				},

			},
			"blocking": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: blocking, monitoring] Empty. This can be used for messages where no values are needed",
			},
			"blocking_page": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: blocking_page, use_default_blocking_page] Custom Blocking Response Page. Custom blocking response page body",
				Attributes: map[string]schema.Attribute{
					"blocking_page": schema.StringAttribute{
						MarkdownDescription: "Blocking Response Page Body. Define the content of the response page (e.g., an HTML document or a JSON object), use the {{request_id}} placeholder to provide users with a unique identifier to be able to trace the blocked request in the logs. The maximum allowed size of response body is 4096 bytes after base64 encoding, which would be about 3070 bytes in plain text.",
						Optional: true,
					},
					"response_code": schema.StringAttribute{
						MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code U...",
						Optional: true,
					},
				},

			},
			"bot_protection_setting": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: bot_protection_setting, default_bot_setting] Bot Protection. Configuration of WAF Bot Protection",
				Attributes: map[string]schema.Attribute{
					"good_bot_action": schema.StringAttribute{
						MarkdownDescription: "Bot Action. Action to be performed on the request Log and block Log only Disable detection",
						Optional: true,
					},
					"malicious_bot_action": schema.StringAttribute{
						MarkdownDescription: "Bot Action. Action to be performed on the request Log and block Log only Disable detection",
						Optional: true,
					},
					"suspicious_bot_action": schema.StringAttribute{
						MarkdownDescription: "Bot Action. Action to be performed on the request Log and block Log only Disable detection",
						Optional: true,
					},
				},

			},
			"custom_anonymization": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: custom_anonymization, default_anonymization, disable_anonymization] Anonymization Configuration. Anonymization settings which is a list of HTTP headers, parameters and cookies",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"anonymization_config": schema.ListNestedBlock{
						MarkdownDescription: "Configuration. List of HTTP headers, cookies and query parameters whose values will be masked",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"cookie": schema.SingleNestedBlock{
									MarkdownDescription: "Anonymize HTTP Cookie. Configure anonymization for HTTP Cookies",
									Attributes: map[string]schema.Attribute{
										"cookie_name": schema.StringAttribute{
											MarkdownDescription: "Cookie Name. Masks the cookie value. The setting does not mask the cookie name.",
											Optional: true,
										},
									},
								},
								"http_header": schema.SingleNestedBlock{
									MarkdownDescription: "Anonymize HTTP Header. Configure anonymization for HTTP Headers",
									Attributes: map[string]schema.Attribute{
										"header_name": schema.StringAttribute{
											MarkdownDescription: "Header Name. Masks the HTTP header value. The setting does not mask the HTTP header name.",
											Optional: true,
										},
									},
								},
								"query_parameter": schema.SingleNestedBlock{
									MarkdownDescription: "Anonymize HTTP Query Parameter. Configure anonymization for HTTP Parameters",
									Attributes: map[string]schema.Attribute{
										"query_param_name": schema.StringAttribute{
											MarkdownDescription: "Query Parameter Name. Masks the query parameter value. The setting does not mask the query parameter name.",
											Optional: true,
										},
									},
								},
							},
						},
					},
				},

			},
			"default_anonymization": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"default_bot_setting": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"default_detection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"detection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Detection Settings. Specifies detection settings to be used by WAF",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"bot_protection_setting": schema.SingleNestedBlock{
						MarkdownDescription: "Bot Protection. Configuration of WAF Bot Protection",
						Attributes: map[string]schema.Attribute{
							"good_bot_action": schema.StringAttribute{
								MarkdownDescription: "Bot Action. Action to be performed on the request Log and block Log only Disable detection",
								Optional: true,
							},
							"malicious_bot_action": schema.StringAttribute{
								MarkdownDescription: "Bot Action. Action to be performed on the request Log and block Log only Disable detection",
								Optional: true,
							},
							"suspicious_bot_action": schema.StringAttribute{
								MarkdownDescription: "Bot Action. Action to be performed on the request Log and block Log only Disable detection",
								Optional: true,
							},
						},
					},
					"default_bot_setting": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_violation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_staging": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_suppression": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_threat_campaigns": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_suppression": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_threat_campaigns": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"signature_selection_setting": schema.SingleNestedBlock{
						MarkdownDescription: "Attack Signatures. Attack Signatures are patterns that identify attacks on a web application and its components",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"attack_type_settings": schema.SingleNestedBlock{
								MarkdownDescription: "Attack Type Settings. Specifies attack-type settings to be used by WAF",
								Attributes: map[string]schema.Attribute{
									"disabled_attack_types": schema.ListAttribute{
										MarkdownDescription: "Disabled Attack Types. List of Attack Types that will be ignored and not trigger a detection",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
							"default_attack_type_settings": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"high_medium_accuracy_signatures": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"high_medium_low_accuracy_signatures": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"only_high_accuracy_signatures": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"stage_new_and_updated_signatures": schema.SingleNestedBlock{
						MarkdownDescription: "Attack Signatures Staging Settings. Attack Signatures staging configuration.",
						Attributes: map[string]schema.Attribute{
							"staging_period": schema.Int64Attribute{
								MarkdownDescription: "Staging Period. Define staging period in days. The default staging period is 7 days and the max supported staging period is 20 days.",
								Optional: true,
							},
						},
					},
					"stage_new_signatures": schema.SingleNestedBlock{
						MarkdownDescription: "Attack Signatures Staging Settings. Attack Signatures staging configuration.",
						Attributes: map[string]schema.Attribute{
							"staging_period": schema.Int64Attribute{
								MarkdownDescription: "Staging Period. Define staging period in days. The default staging period is 7 days and the max supported staging period is 20 days.",
								Optional: true,
							},
						},
					},
					"violation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Violation Settings. Specifies violation settings to be used by WAF",
						Attributes: map[string]schema.Attribute{
							"disabled_violation_types": schema.ListAttribute{
								MarkdownDescription: "Disabled Violations. List of violations to be excluded",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
				},

			},
			"disable_anonymization": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"monitoring": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"use_default_blocking_page": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
		},
	}
}

func (r *AppFirewallResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *AppFirewallResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.AppFirewall{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.AppFirewallSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateAppFirewall(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AppFirewall: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)
	tflog.Trace(ctx, "created AppFirewall resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppFirewallResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource, err := r.client.GetAppFirewall(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AppFirewall: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppFirewallResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.AppFirewall{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.AppFirewallSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateAppFirewall(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AppFirewall: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppFirewallResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AppFirewallResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteAppFirewall(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AppFirewall: %s", err))
		return
	}
}

func (r *AppFirewallResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
