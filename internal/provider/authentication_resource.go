// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AuthenticationResource{}
	_ resource.ResourceWithConfigure      = &AuthenticationResource{}
	_ resource.ResourceWithImportState    = &AuthenticationResource{}
	_ resource.ResourceWithModifyPlan     = &AuthenticationResource{}
	_ resource.ResourceWithValidateConfig = &AuthenticationResource{}
)

func NewAuthenticationResource() resource.Resource {
	return &AuthenticationResource{}
}

type AuthenticationResource struct {
	client *client.Client
}

// AuthenticationEmptyModel represents empty nested blocks
type AuthenticationEmptyModel struct {
}

// AuthenticationCookieParamsModel represents cookie_params block
type AuthenticationCookieParamsModel struct {
	CookieExpiry          types.Int64                              `tfsdk:"cookie_expiry"`
	CookieRefreshInterval types.Int64                              `tfsdk:"cookie_refresh_interval"`
	SessionExpiry         types.Int64                              `tfsdk:"session_expiry"`
	AuthHMAC              *AuthenticationCookieParamsAuthHMACModel `tfsdk:"auth_hmac"`
	KmsKeyHMAC            *AuthenticationEmptyModel                `tfsdk:"kms_key_hmac"`
}

// AuthenticationCookieParamsModelAttrTypes defines the attribute types for AuthenticationCookieParamsModel
var AuthenticationCookieParamsModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":           types.Int64Type,
	"cookie_refresh_interval": types.Int64Type,
	"session_expiry":          types.Int64Type,
	"auth_hmac":               types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACModelAttrTypes},
	"kms_key_hmac":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AuthenticationCookieParamsAuthHMACModel represents auth_hmac block
type AuthenticationCookieParamsAuthHMACModel struct {
	PrimKeyExpiry types.String                                    `tfsdk:"prim_key_expiry"`
	SecKeyExpiry  types.String                                    `tfsdk:"sec_key_expiry"`
	PrimKey       *AuthenticationCookieParamsAuthHMACPrimKeyModel `tfsdk:"prim_key"`
	SecKey        *AuthenticationCookieParamsAuthHMACSecKeyModel  `tfsdk:"sec_key"`
}

// AuthenticationCookieParamsAuthHMACModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACModel
var AuthenticationCookieParamsAuthHMACModelAttrTypes = map[string]attr.Type{
	"prim_key_expiry": types.StringType,
	"sec_key_expiry":  types.StringType,
	"prim_key":        types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACPrimKeyModelAttrTypes},
	"sec_key":         types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACSecKeyModelAttrTypes},
}

// AuthenticationCookieParamsAuthHMACPrimKeyModel represents prim_key block
type AuthenticationCookieParamsAuthHMACPrimKeyModel struct {
	BlindfoldSecretInfo *AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AuthenticationCookieParamsAuthHMACPrimKeyModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACPrimKeyModel
var AuthenticationCookieParamsAuthHMACPrimKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModelAttrTypes},
}

// AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModel
var AuthenticationCookieParamsAuthHMACPrimKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModel represents clear_secret_info block
type AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModel
var AuthenticationCookieParamsAuthHMACPrimKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AuthenticationCookieParamsAuthHMACSecKeyModel represents sec_key block
type AuthenticationCookieParamsAuthHMACSecKeyModel struct {
	BlindfoldSecretInfo *AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AuthenticationCookieParamsAuthHMACSecKeyModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACSecKeyModel
var AuthenticationCookieParamsAuthHMACSecKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModelAttrTypes},
}

// AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModel
var AuthenticationCookieParamsAuthHMACSecKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModel represents clear_secret_info block
type AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModelAttrTypes defines the attribute types for AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModel
var AuthenticationCookieParamsAuthHMACSecKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AuthenticationOIDCAuthModel represents oidc_auth block
type AuthenticationOIDCAuthModel struct {
	OIDCClientID           types.String                               `tfsdk:"oidc_client_id"`
	OIDCWellKnownConfigURL types.String                               `tfsdk:"oidc_well_known_config_url"`
	ClientSecret           *AuthenticationOIDCAuthClientSecretModel   `tfsdk:"client_secret"`
	OIDCAuthParams         *AuthenticationOIDCAuthOIDCAuthParamsModel `tfsdk:"oidc_auth_params"`
}

// AuthenticationOIDCAuthModelAttrTypes defines the attribute types for AuthenticationOIDCAuthModel
var AuthenticationOIDCAuthModelAttrTypes = map[string]attr.Type{
	"oidc_client_id":             types.StringType,
	"oidc_well_known_config_url": types.StringType,
	"client_secret":              types.ObjectType{AttrTypes: AuthenticationOIDCAuthClientSecretModelAttrTypes},
	"oidc_auth_params":           types.ObjectType{AttrTypes: AuthenticationOIDCAuthOIDCAuthParamsModelAttrTypes},
}

// AuthenticationOIDCAuthClientSecretModel represents client_secret block
type AuthenticationOIDCAuthClientSecretModel struct {
	BlindfoldSecretInfo *AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AuthenticationOIDCAuthClientSecretClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AuthenticationOIDCAuthClientSecretModelAttrTypes defines the attribute types for AuthenticationOIDCAuthClientSecretModel
var AuthenticationOIDCAuthClientSecretModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AuthenticationOIDCAuthClientSecretClearSecretInfoModelAttrTypes},
}

// AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModel represents blindfold_secret_info block
type AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModelAttrTypes defines the attribute types for AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModel
var AuthenticationOIDCAuthClientSecretBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AuthenticationOIDCAuthClientSecretClearSecretInfoModel represents clear_secret_info block
type AuthenticationOIDCAuthClientSecretClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AuthenticationOIDCAuthClientSecretClearSecretInfoModelAttrTypes defines the attribute types for AuthenticationOIDCAuthClientSecretClearSecretInfoModel
var AuthenticationOIDCAuthClientSecretClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AuthenticationOIDCAuthOIDCAuthParamsModel represents oidc_auth_params block
type AuthenticationOIDCAuthOIDCAuthParamsModel struct {
	AuthEndpointURL       types.String `tfsdk:"auth_endpoint_url"`
	EndSessionEndpointURL types.String `tfsdk:"end_session_endpoint_url"`
	TokenEndpointURL      types.String `tfsdk:"token_endpoint_url"`
}

// AuthenticationOIDCAuthOIDCAuthParamsModelAttrTypes defines the attribute types for AuthenticationOIDCAuthOIDCAuthParamsModel
var AuthenticationOIDCAuthOIDCAuthParamsModelAttrTypes = map[string]attr.Type{
	"auth_endpoint_url":        types.StringType,
	"end_session_endpoint_url": types.StringType,
	"token_endpoint_url":       types.StringType,
}

type AuthenticationResourceModel struct {
	Name         types.String                     `tfsdk:"name"`
	Namespace    types.String                     `tfsdk:"namespace"`
	Annotations  types.Map                        `tfsdk:"annotations"`
	Description  types.String                     `tfsdk:"description"`
	Disable      types.Bool                       `tfsdk:"disable"`
	Labels       types.Map                        `tfsdk:"labels"`
	ID           types.String                     `tfsdk:"id"`
	Timeouts     timeouts.Value                   `tfsdk:"timeouts"`
	CookieParams *AuthenticationCookieParamsModel `tfsdk:"cookie_params"`
	OIDCAuth     *AuthenticationOIDCAuthModel     `tfsdk:"oidc_auth"`
}

func (r *AuthenticationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_authentication"
}

func (r *AuthenticationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Authentication resource in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Authentication. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Authentication will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"cookie_params": schema.SingleNestedBlock{
				MarkdownDescription: "Specifies different cookie related config parameters for authentication.",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Specifies in seconds max duration of the allocated cookie. This maps to “Max-Age” attribute in the session cookie. This will act as an expiry duration on the client side after which client will not be setting the cookie as part of the request.",
						Optional:            true,
					},
					"cookie_refresh_interval": schema.Int64Attribute{
						MarkdownDescription: "Specifies in seconds refresh interval for session cookie. This is used to keep the active user active and reduce RE-login. When an incoming cookie's session expiry is still valid, and time to expire falls behind this interval, RE-issue a cookie with new expiry and with the same original session..",
						Optional:            true,
					},
					"session_expiry": schema.Int64Attribute{
						MarkdownDescription: "Specifies in seconds max lifetime of an authenticated session after which the user will be forced to login again. Default session expiry is 86400 seconds(24 hours).",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auth_hmac": schema.SingleNestedBlock{
						MarkdownDescription: "HMAC primary and secondary keys to be used for hashing the Cookie. Each key also have an associated expiry timestamp, beyond which key is invalid.",
						Attributes: map[string]schema.Attribute{
							"prim_key_expiry": schema.StringAttribute{
								MarkdownDescription: "Primary HMAC Key Expiry time .",
								Optional:            true,
							},
							"sec_key_expiry": schema.StringAttribute{
								MarkdownDescription: "Secondary HMAC Key Expiry time .",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"prim_key": schema.SingleNestedBlock{
								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"sec_key": schema.SingleNestedBlock{
								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"kms_key_hmac": schema.SingleNestedBlock{
						MarkdownDescription: "KMS Key Reference. Reference to KMS Key Object.",
					},
				},
			},
			"oidc_auth": schema.SingleNestedBlock{
				MarkdownDescription: "OIDCAuthType.",
				Attributes: map[string]schema.Attribute{
					"oidc_client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID used while sending the Authorization Request to OIDC server .",
						Optional:            true,
					},
					"oidc_well_known_config_url": schema.StringAttribute{
						MarkdownDescription: "An OIDC well-known configuration URL that will be used to fetch authentication related endpoints.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"client_secret": schema.SingleNestedBlock{
						MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional:            true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
										Optional:            true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
										Optional:            true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
										Optional:            true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
										Optional:            true,
									},
								},
							},
						},
					},
					"oidc_auth_params": schema.SingleNestedBlock{
						MarkdownDescription: "OIDCAuthParams.",
						Attributes: map[string]schema.Attribute{
							"auth_endpoint_url": schema.StringAttribute{
								MarkdownDescription: "URL of the authorization server's authorization endpoint.",
								Optional:            true,
							},
							"end_session_endpoint_url": schema.StringAttribute{
								MarkdownDescription: "URL of the authorization server's Logout endpoint.",
								Optional:            true,
							},
							"token_endpoint_url": schema.StringAttribute{
								MarkdownDescription: "URL of the authorization server's Token endpoint.",
								Optional:            true,
							},
						},
					},
				},
			},
		},
	}
}

func (r *AuthenticationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AuthenticationResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AuthenticationResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the authentication from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AuthenticationResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *AuthenticationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating authentication", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Authentication{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.CookieParams != nil {
		cookie_paramsMap := make(map[string]interface{})
		if data.CookieParams.AuthHMAC != nil {
			auth_hmacNestedMap := make(map[string]interface{})
			if !data.CookieParams.AuthHMAC.PrimKeyExpiry.IsNull() && !data.CookieParams.AuthHMAC.PrimKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["prim_key_expiry"] = data.CookieParams.AuthHMAC.PrimKeyExpiry.ValueString()
			}
			if !data.CookieParams.AuthHMAC.SecKeyExpiry.IsNull() && !data.CookieParams.AuthHMAC.SecKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["sec_key_expiry"] = data.CookieParams.AuthHMAC.SecKeyExpiry.ValueString()
			}
			cookie_paramsMap["auth_hmac"] = auth_hmacNestedMap
		}
		if !data.CookieParams.CookieExpiry.IsNull() && !data.CookieParams.CookieExpiry.IsUnknown() {
			cookie_paramsMap["cookie_expiry"] = data.CookieParams.CookieExpiry.ValueInt64()
		}
		if !data.CookieParams.CookieRefreshInterval.IsNull() && !data.CookieParams.CookieRefreshInterval.IsUnknown() {
			cookie_paramsMap["cookie_refresh_interval"] = data.CookieParams.CookieRefreshInterval.ValueInt64()
		}
		if data.CookieParams.KmsKeyHMAC != nil {
			cookie_paramsMap["kms_key_hmac"] = map[string]interface{}{}
		}
		if !data.CookieParams.SessionExpiry.IsNull() && !data.CookieParams.SessionExpiry.IsUnknown() {
			cookie_paramsMap["session_expiry"] = data.CookieParams.SessionExpiry.ValueInt64()
		}
		createReq.Spec["cookie_params"] = cookie_paramsMap
	}
	if data.OIDCAuth != nil {
		oidc_authMap := make(map[string]interface{})
		if data.OIDCAuth.ClientSecret != nil {
			client_secretNestedMap := make(map[string]interface{})
			oidc_authMap["client_secret"] = client_secretNestedMap
		}
		if data.OIDCAuth.OIDCAuthParams != nil {
			oidc_auth_paramsNestedMap := make(map[string]interface{})
			if !data.OIDCAuth.OIDCAuthParams.AuthEndpointURL.IsNull() && !data.OIDCAuth.OIDCAuthParams.AuthEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["auth_endpoint_url"] = data.OIDCAuth.OIDCAuthParams.AuthEndpointURL.ValueString()
			}
			if !data.OIDCAuth.OIDCAuthParams.EndSessionEndpointURL.IsNull() && !data.OIDCAuth.OIDCAuthParams.EndSessionEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["end_session_endpoint_url"] = data.OIDCAuth.OIDCAuthParams.EndSessionEndpointURL.ValueString()
			}
			if !data.OIDCAuth.OIDCAuthParams.TokenEndpointURL.IsNull() && !data.OIDCAuth.OIDCAuthParams.TokenEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["token_endpoint_url"] = data.OIDCAuth.OIDCAuthParams.TokenEndpointURL.ValueString()
			}
			oidc_authMap["oidc_auth_params"] = oidc_auth_paramsNestedMap
		}
		if !data.OIDCAuth.OIDCClientID.IsNull() && !data.OIDCAuth.OIDCClientID.IsUnknown() {
			oidc_authMap["oidc_client_id"] = data.OIDCAuth.OIDCClientID.ValueString()
		}
		if !data.OIDCAuth.OIDCWellKnownConfigURL.IsNull() && !data.OIDCAuth.OIDCWellKnownConfigURL.IsUnknown() {
			oidc_authMap["oidc_well_known_config_url"] = data.OIDCAuth.OIDCWellKnownConfigURL.ValueString()
		}
		createReq.Spec["oidc_auth"] = oidc_authMap
	}

	apiResource, err := r.client.CreateAuthentication(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Authentication: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["cookie_params"].(map[string]interface{}); ok && (isImport || data.CookieParams != nil) {
		data.CookieParams = &AuthenticationCookieParamsModel{
			AuthHMAC: func() *AuthenticationCookieParamsAuthHMACModel {
				if !isImport && data.CookieParams != nil && data.CookieParams.AuthHMAC != nil {
					// Normal Read: preserve existing state value
					return data.CookieParams.AuthHMAC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auth_hmac"].(map[string]interface{}); ok {
					return &AuthenticationCookieParamsAuthHMACModel{
						PrimKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["prim_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						SecKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["sec_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CookieRefreshInterval: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.CookieRefreshInterval
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_refresh_interval"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			KmsKeyHMAC: func() *AuthenticationEmptyModel {
				if !isImport && data.CookieParams != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieParams.KmsKeyHMAC
				}
				// Import case: read from API
				if _, ok := blockData["kms_key_hmac"].(map[string]interface{}); ok {
					return &AuthenticationEmptyModel{}
				}
				return nil
			}(),
			SessionExpiry: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.SessionExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["session_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_auth"].(map[string]interface{}); ok && (isImport || data.OIDCAuth != nil) {
		data.OIDCAuth = &AuthenticationOIDCAuthModel{
			ClientSecret: func() *AuthenticationOIDCAuthClientSecretModel {
				if !isImport && data.OIDCAuth != nil && data.OIDCAuth.ClientSecret != nil {
					// Normal Read: preserve existing state value
					return data.OIDCAuth.ClientSecret
				}
				// Import case: read from API
				if _, ok := blockData["client_secret"].(map[string]interface{}); ok {
					return &AuthenticationOIDCAuthClientSecretModel{}
				}
				return nil
			}(),
			OIDCAuthParams: func() *AuthenticationOIDCAuthOIDCAuthParamsModel {
				if !isImport && data.OIDCAuth != nil && data.OIDCAuth.OIDCAuthParams != nil {
					// Normal Read: preserve existing state value
					return data.OIDCAuth.OIDCAuthParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["oidc_auth_params"].(map[string]interface{}); ok {
					return &AuthenticationOIDCAuthOIDCAuthParamsModel{
						AuthEndpointURL: func() types.String {
							if v, ok := nestedBlockData["auth_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						EndSessionEndpointURL: func() types.String {
							if v, ok := nestedBlockData["end_session_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TokenEndpointURL: func() types.String {
							if v, ok := nestedBlockData["token_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			OIDCClientID: func() types.String {
				if v, ok := blockData["oidc_client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OIDCWellKnownConfigURL: func() types.String {
				if v, ok := blockData["oidc_well_known_config_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	tflog.Trace(ctx, "created Authentication resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AuthenticationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetAuthentication(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Authentication not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Authentication: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["cookie_params"].(map[string]interface{}); ok && (isImport || data.CookieParams != nil) {
		data.CookieParams = &AuthenticationCookieParamsModel{
			AuthHMAC: func() *AuthenticationCookieParamsAuthHMACModel {
				if !isImport && data.CookieParams != nil && data.CookieParams.AuthHMAC != nil {
					// Normal Read: preserve existing state value
					return data.CookieParams.AuthHMAC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auth_hmac"].(map[string]interface{}); ok {
					return &AuthenticationCookieParamsAuthHMACModel{
						PrimKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["prim_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						SecKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["sec_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CookieRefreshInterval: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.CookieRefreshInterval
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_refresh_interval"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			KmsKeyHMAC: func() *AuthenticationEmptyModel {
				if !isImport && data.CookieParams != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieParams.KmsKeyHMAC
				}
				// Import case: read from API
				if _, ok := blockData["kms_key_hmac"].(map[string]interface{}); ok {
					return &AuthenticationEmptyModel{}
				}
				return nil
			}(),
			SessionExpiry: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.SessionExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["session_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_auth"].(map[string]interface{}); ok && (isImport || data.OIDCAuth != nil) {
		data.OIDCAuth = &AuthenticationOIDCAuthModel{
			ClientSecret: func() *AuthenticationOIDCAuthClientSecretModel {
				if !isImport && data.OIDCAuth != nil && data.OIDCAuth.ClientSecret != nil {
					// Normal Read: preserve existing state value
					return data.OIDCAuth.ClientSecret
				}
				// Import case: read from API
				if _, ok := blockData["client_secret"].(map[string]interface{}); ok {
					return &AuthenticationOIDCAuthClientSecretModel{}
				}
				return nil
			}(),
			OIDCAuthParams: func() *AuthenticationOIDCAuthOIDCAuthParamsModel {
				if !isImport && data.OIDCAuth != nil && data.OIDCAuth.OIDCAuthParams != nil {
					// Normal Read: preserve existing state value
					return data.OIDCAuth.OIDCAuthParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["oidc_auth_params"].(map[string]interface{}); ok {
					return &AuthenticationOIDCAuthOIDCAuthParamsModel{
						AuthEndpointURL: func() types.String {
							if v, ok := nestedBlockData["auth_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						EndSessionEndpointURL: func() types.String {
							if v, ok := nestedBlockData["end_session_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TokenEndpointURL: func() types.String {
							if v, ok := nestedBlockData["token_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			OIDCClientID: func() types.String {
				if v, ok := blockData["oidc_client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OIDCWellKnownConfigURL: func() types.String {
				if v, ok := blockData["oidc_well_known_config_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AuthenticationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Authentication{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.CookieParams != nil {
		cookie_paramsMap := make(map[string]interface{})
		if data.CookieParams.AuthHMAC != nil {
			auth_hmacNestedMap := make(map[string]interface{})
			if !data.CookieParams.AuthHMAC.PrimKeyExpiry.IsNull() && !data.CookieParams.AuthHMAC.PrimKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["prim_key_expiry"] = data.CookieParams.AuthHMAC.PrimKeyExpiry.ValueString()
			}
			if !data.CookieParams.AuthHMAC.SecKeyExpiry.IsNull() && !data.CookieParams.AuthHMAC.SecKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["sec_key_expiry"] = data.CookieParams.AuthHMAC.SecKeyExpiry.ValueString()
			}
			cookie_paramsMap["auth_hmac"] = auth_hmacNestedMap
		}
		if !data.CookieParams.CookieExpiry.IsNull() && !data.CookieParams.CookieExpiry.IsUnknown() {
			cookie_paramsMap["cookie_expiry"] = data.CookieParams.CookieExpiry.ValueInt64()
		}
		if !data.CookieParams.CookieRefreshInterval.IsNull() && !data.CookieParams.CookieRefreshInterval.IsUnknown() {
			cookie_paramsMap["cookie_refresh_interval"] = data.CookieParams.CookieRefreshInterval.ValueInt64()
		}
		if data.CookieParams.KmsKeyHMAC != nil {
			cookie_paramsMap["kms_key_hmac"] = map[string]interface{}{}
		}
		if !data.CookieParams.SessionExpiry.IsNull() && !data.CookieParams.SessionExpiry.IsUnknown() {
			cookie_paramsMap["session_expiry"] = data.CookieParams.SessionExpiry.ValueInt64()
		}
		apiResource.Spec["cookie_params"] = cookie_paramsMap
	}
	if data.OIDCAuth != nil {
		oidc_authMap := make(map[string]interface{})
		if data.OIDCAuth.ClientSecret != nil {
			client_secretNestedMap := make(map[string]interface{})
			oidc_authMap["client_secret"] = client_secretNestedMap
		}
		if data.OIDCAuth.OIDCAuthParams != nil {
			oidc_auth_paramsNestedMap := make(map[string]interface{})
			if !data.OIDCAuth.OIDCAuthParams.AuthEndpointURL.IsNull() && !data.OIDCAuth.OIDCAuthParams.AuthEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["auth_endpoint_url"] = data.OIDCAuth.OIDCAuthParams.AuthEndpointURL.ValueString()
			}
			if !data.OIDCAuth.OIDCAuthParams.EndSessionEndpointURL.IsNull() && !data.OIDCAuth.OIDCAuthParams.EndSessionEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["end_session_endpoint_url"] = data.OIDCAuth.OIDCAuthParams.EndSessionEndpointURL.ValueString()
			}
			if !data.OIDCAuth.OIDCAuthParams.TokenEndpointURL.IsNull() && !data.OIDCAuth.OIDCAuthParams.TokenEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["token_endpoint_url"] = data.OIDCAuth.OIDCAuthParams.TokenEndpointURL.ValueString()
			}
			oidc_authMap["oidc_auth_params"] = oidc_auth_paramsNestedMap
		}
		if !data.OIDCAuth.OIDCClientID.IsNull() && !data.OIDCAuth.OIDCClientID.IsUnknown() {
			oidc_authMap["oidc_client_id"] = data.OIDCAuth.OIDCClientID.ValueString()
		}
		if !data.OIDCAuth.OIDCWellKnownConfigURL.IsNull() && !data.OIDCAuth.OIDCWellKnownConfigURL.IsUnknown() {
			oidc_authMap["oidc_well_known_config_url"] = data.OIDCAuth.OIDCWellKnownConfigURL.ValueString()
		}
		apiResource.Spec["oidc_auth"] = oidc_authMap
	}

	_, err := r.client.UpdateAuthentication(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Authentication: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAuthentication(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Authentication after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["cookie_params"].(map[string]interface{}); ok && (isImport || data.CookieParams != nil) {
		data.CookieParams = &AuthenticationCookieParamsModel{
			AuthHMAC: func() *AuthenticationCookieParamsAuthHMACModel {
				if !isImport && data.CookieParams != nil && data.CookieParams.AuthHMAC != nil {
					// Normal Read: preserve existing state value
					return data.CookieParams.AuthHMAC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auth_hmac"].(map[string]interface{}); ok {
					return &AuthenticationCookieParamsAuthHMACModel{
						PrimKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["prim_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						SecKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["sec_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CookieRefreshInterval: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.CookieRefreshInterval
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_refresh_interval"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			KmsKeyHMAC: func() *AuthenticationEmptyModel {
				if !isImport && data.CookieParams != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieParams.KmsKeyHMAC
				}
				// Import case: read from API
				if _, ok := blockData["kms_key_hmac"].(map[string]interface{}); ok {
					return &AuthenticationEmptyModel{}
				}
				return nil
			}(),
			SessionExpiry: func() types.Int64 {
				if !isImport && data.CookieParams != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieParams.SessionExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["session_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_auth"].(map[string]interface{}); ok && (isImport || data.OIDCAuth != nil) {
		data.OIDCAuth = &AuthenticationOIDCAuthModel{
			ClientSecret: func() *AuthenticationOIDCAuthClientSecretModel {
				if !isImport && data.OIDCAuth != nil && data.OIDCAuth.ClientSecret != nil {
					// Normal Read: preserve existing state value
					return data.OIDCAuth.ClientSecret
				}
				// Import case: read from API
				if _, ok := blockData["client_secret"].(map[string]interface{}); ok {
					return &AuthenticationOIDCAuthClientSecretModel{}
				}
				return nil
			}(),
			OIDCAuthParams: func() *AuthenticationOIDCAuthOIDCAuthParamsModel {
				if !isImport && data.OIDCAuth != nil && data.OIDCAuth.OIDCAuthParams != nil {
					// Normal Read: preserve existing state value
					return data.OIDCAuth.OIDCAuthParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["oidc_auth_params"].(map[string]interface{}); ok {
					return &AuthenticationOIDCAuthOIDCAuthParamsModel{
						AuthEndpointURL: func() types.String {
							if v, ok := nestedBlockData["auth_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						EndSessionEndpointURL: func() types.String {
							if v, ok := nestedBlockData["end_session_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TokenEndpointURL: func() types.String {
							if v, ok := nestedBlockData["token_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			OIDCClientID: func() types.String {
				if v, ok := blockData["oidc_client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OIDCWellKnownConfigURL: func() types.String {
				if v, ok := blockData["oidc_well_known_config_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AuthenticationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAuthentication(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Authentication already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Authentication delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Authentication: %s", err))
		return
	}
}

func (r *AuthenticationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
