// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AuthenticationResource{}
	_ resource.ResourceWithConfigure      = &AuthenticationResource{}
	_ resource.ResourceWithImportState    = &AuthenticationResource{}
	_ resource.ResourceWithModifyPlan     = &AuthenticationResource{}
	_ resource.ResourceWithUpgradeState   = &AuthenticationResource{}
	_ resource.ResourceWithValidateConfig = &AuthenticationResource{}
)

// authenticationSchemaVersion is the schema version for state upgrades
const authenticationSchemaVersion int64 = 1

func NewAuthenticationResource() resource.Resource {
	return &AuthenticationResource{}
}

type AuthenticationResource struct {
	client *client.Client
}

// AuthenticationEmptyModel represents empty nested blocks
type AuthenticationEmptyModel struct {
}

// AuthenticationCookieParamsModel represents cookie_params block
type AuthenticationCookieParamsModel struct {
	CookieExpiry          types.Int64                              `tfsdk:"cookie_expiry"`
	CookieRefreshInterval types.Int64                              `tfsdk:"cookie_refresh_interval"`
	SessionExpiry         types.Int64                              `tfsdk:"session_expiry"`
	AuthHmac              *AuthenticationCookieParamsAuthHmacModel `tfsdk:"auth_hmac"`
	KmsKeyHmac            *AuthenticationEmptyModel                `tfsdk:"kms_key_hmac"`
}

// AuthenticationCookieParamsAuthHmacModel represents auth_hmac block
type AuthenticationCookieParamsAuthHmacModel struct {
	PrimKeyExpiry types.String                                    `tfsdk:"prim_key_expiry"`
	SecKeyExpiry  types.String                                    `tfsdk:"sec_key_expiry"`
	PrimKey       *AuthenticationCookieParamsAuthHmacPrimKeyModel `tfsdk:"prim_key"`
	SecKey        *AuthenticationCookieParamsAuthHmacSecKeyModel  `tfsdk:"sec_key"`
}

// AuthenticationCookieParamsAuthHmacPrimKeyModel represents prim_key block
type AuthenticationCookieParamsAuthHmacPrimKeyModel struct {
	BlindfoldSecretInfo *AuthenticationCookieParamsAuthHmacPrimKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AuthenticationCookieParamsAuthHmacPrimKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AuthenticationCookieParamsAuthHmacPrimKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AuthenticationCookieParamsAuthHmacPrimKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AuthenticationCookieParamsAuthHmacPrimKeyClearSecretInfoModel represents clear_secret_info block
type AuthenticationCookieParamsAuthHmacPrimKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AuthenticationCookieParamsAuthHmacSecKeyModel represents sec_key block
type AuthenticationCookieParamsAuthHmacSecKeyModel struct {
	BlindfoldSecretInfo *AuthenticationCookieParamsAuthHmacSecKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AuthenticationCookieParamsAuthHmacSecKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AuthenticationCookieParamsAuthHmacSecKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AuthenticationCookieParamsAuthHmacSecKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AuthenticationCookieParamsAuthHmacSecKeyClearSecretInfoModel represents clear_secret_info block
type AuthenticationCookieParamsAuthHmacSecKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AuthenticationOidcAuthModel represents oidc_auth block
type AuthenticationOidcAuthModel struct {
	OidcClientID           types.String                               `tfsdk:"oidc_client_id"`
	OidcWellKnownConfigURL types.String                               `tfsdk:"oidc_well_known_config_url"`
	ClientSecret           *AuthenticationOidcAuthClientSecretModel   `tfsdk:"client_secret"`
	OidcAuthParams         *AuthenticationOidcAuthOidcAuthParamsModel `tfsdk:"oidc_auth_params"`
}

// AuthenticationOidcAuthClientSecretModel represents client_secret block
type AuthenticationOidcAuthClientSecretModel struct {
	BlindfoldSecretInfo *AuthenticationOidcAuthClientSecretBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AuthenticationOidcAuthClientSecretClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AuthenticationOidcAuthClientSecretBlindfoldSecretInfoModel represents blindfold_secret_info block
type AuthenticationOidcAuthClientSecretBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AuthenticationOidcAuthClientSecretClearSecretInfoModel represents clear_secret_info block
type AuthenticationOidcAuthClientSecretClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AuthenticationOidcAuthOidcAuthParamsModel represents oidc_auth_params block
type AuthenticationOidcAuthOidcAuthParamsModel struct {
	AuthEndpointURL       types.String `tfsdk:"auth_endpoint_url"`
	EndSessionEndpointURL types.String `tfsdk:"end_session_endpoint_url"`
	TokenEndpointURL      types.String `tfsdk:"token_endpoint_url"`
}

type AuthenticationResourceModel struct {
	Name         types.String                     `tfsdk:"name"`
	Namespace    types.String                     `tfsdk:"namespace"`
	Annotations  types.Map                        `tfsdk:"annotations"`
	Description  types.String                     `tfsdk:"description"`
	Disable      types.Bool                       `tfsdk:"disable"`
	Labels       types.Map                        `tfsdk:"labels"`
	ID           types.String                     `tfsdk:"id"`
	Timeouts     timeouts.Value                   `tfsdk:"timeouts"`
	CookieParams *AuthenticationCookieParamsModel `tfsdk:"cookie_params"`
	OidcAuth     *AuthenticationOidcAuthModel     `tfsdk:"oidc_auth"`
}

func (r *AuthenticationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_authentication"
}

func (r *AuthenticationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             authenticationSchemaVersion,
		MarkdownDescription: "Manages a Authentication resource in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Authentication. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Authentication will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"cookie_params": schema.SingleNestedBlock{
				MarkdownDescription: "Cookie Parameters. Specifies different cookie related config parameters for authentication",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiry duration. specifies in seconds max duration of the allocated cookie. This maps to “Max-Age” attribute in the session cookie. This will act as an expiry duration on the client side after which client will not be setting the cookie as part of the request. Default cookie expiry is 3600 seconds",
						Optional:            true,
					},
					"cookie_refresh_interval": schema.Int64Attribute{
						MarkdownDescription: "Cookie Refresh Interval. Specifies in seconds refresh interval for session cookie. This is used to keep the active user active and reduce re-login. When an incoming cookie's session expiry is still valid, and time to expire falls behind this interval, re-issue a cookie with new expiry and with the same original session expiry. Default refresh interval is 3000 seconds",
						Optional:            true,
					},
					"session_expiry": schema.Int64Attribute{
						MarkdownDescription: "Session Expiry duration. specifies in seconds max lifetime of an authenticated session after which the user will be forced to login again. Default session expiry is 86400 seconds(24 hours).",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auth_hmac": schema.SingleNestedBlock{
						MarkdownDescription: "HMAC Key Pair. HMAC primary and secondary keys to be used for hashing the Cookie. Each key also have an associated expiry timestamp, beyond which key is invalid.",
						Attributes: map[string]schema.Attribute{
							"prim_key_expiry": schema.StringAttribute{
								MarkdownDescription: "HMAC Primary Key Expiry. Primary HMAC Key Expiry time",
								Optional:            true,
							},
							"sec_key_expiry": schema.StringAttribute{
								MarkdownDescription: "HMAC Secondary Key Expiry. Secondary HMAC Key Expiry time",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"prim_key": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"sec_key": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"kms_key_hmac": schema.SingleNestedBlock{
						MarkdownDescription: "KMS Key Reference. Reference to KMS Key Object",
					},
				},
			},
			"oidc_auth": schema.SingleNestedBlock{
				MarkdownDescription: "OIDCAuthType.",
				Attributes: map[string]schema.Attribute{
					"oidc_client_id": schema.StringAttribute{
						MarkdownDescription: "OIDC Client ID. Client ID used while sending the Authorization Request to OIDC server",
						Optional:            true,
					},
					"oidc_well_known_config_url": schema.StringAttribute{
						MarkdownDescription: "Well-known Configuration URL. An OIDC well-known configuration URL that will be used to fetch authentication related endpoints",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"client_secret": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional:            true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional:            true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional:            true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional:            true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional:            true,
									},
								},
							},
						},
					},
					"oidc_auth_params": schema.SingleNestedBlock{
						MarkdownDescription: "OIDCAuthParams.",
						Attributes: map[string]schema.Attribute{
							"auth_endpoint_url": schema.StringAttribute{
								MarkdownDescription: "Authorization Endpoint. URL of the authorization server's authorization endpoint.",
								Optional:            true,
							},
							"end_session_endpoint_url": schema.StringAttribute{
								MarkdownDescription: "Logout Endpoint. URL of the authorization server's Logout endpoint.",
								Optional:            true,
							},
							"token_endpoint_url": schema.StringAttribute{
								MarkdownDescription: "Token Endpoint. URL of the authorization server's Token endpoint.",
								Optional:            true,
							},
						},
					},
				},
			},
		},
	}
}

func (r *AuthenticationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AuthenticationResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AuthenticationResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the authentication from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AuthenticationResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AuthenticationResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AuthenticationResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AuthenticationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating authentication", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Authentication{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.CookieParams != nil {
		cookie_paramsMap := make(map[string]interface{})
		if data.CookieParams.AuthHmac != nil {
			auth_hmacNestedMap := make(map[string]interface{})
			if !data.CookieParams.AuthHmac.PrimKeyExpiry.IsNull() && !data.CookieParams.AuthHmac.PrimKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["prim_key_expiry"] = data.CookieParams.AuthHmac.PrimKeyExpiry.ValueString()
			}
			if !data.CookieParams.AuthHmac.SecKeyExpiry.IsNull() && !data.CookieParams.AuthHmac.SecKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["sec_key_expiry"] = data.CookieParams.AuthHmac.SecKeyExpiry.ValueString()
			}
			cookie_paramsMap["auth_hmac"] = auth_hmacNestedMap
		}
		if !data.CookieParams.CookieExpiry.IsNull() && !data.CookieParams.CookieExpiry.IsUnknown() {
			cookie_paramsMap["cookie_expiry"] = data.CookieParams.CookieExpiry.ValueInt64()
		}
		if !data.CookieParams.CookieRefreshInterval.IsNull() && !data.CookieParams.CookieRefreshInterval.IsUnknown() {
			cookie_paramsMap["cookie_refresh_interval"] = data.CookieParams.CookieRefreshInterval.ValueInt64()
		}
		if data.CookieParams.KmsKeyHmac != nil {
			cookie_paramsMap["kms_key_hmac"] = map[string]interface{}{}
		}
		if !data.CookieParams.SessionExpiry.IsNull() && !data.CookieParams.SessionExpiry.IsUnknown() {
			cookie_paramsMap["session_expiry"] = data.CookieParams.SessionExpiry.ValueInt64()
		}
		createReq.Spec["cookie_params"] = cookie_paramsMap
	}
	if data.OidcAuth != nil {
		oidc_authMap := make(map[string]interface{})
		if data.OidcAuth.ClientSecret != nil {
			client_secretNestedMap := make(map[string]interface{})
			oidc_authMap["client_secret"] = client_secretNestedMap
		}
		if data.OidcAuth.OidcAuthParams != nil {
			oidc_auth_paramsNestedMap := make(map[string]interface{})
			if !data.OidcAuth.OidcAuthParams.AuthEndpointURL.IsNull() && !data.OidcAuth.OidcAuthParams.AuthEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["auth_endpoint_url"] = data.OidcAuth.OidcAuthParams.AuthEndpointURL.ValueString()
			}
			if !data.OidcAuth.OidcAuthParams.EndSessionEndpointURL.IsNull() && !data.OidcAuth.OidcAuthParams.EndSessionEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["end_session_endpoint_url"] = data.OidcAuth.OidcAuthParams.EndSessionEndpointURL.ValueString()
			}
			if !data.OidcAuth.OidcAuthParams.TokenEndpointURL.IsNull() && !data.OidcAuth.OidcAuthParams.TokenEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["token_endpoint_url"] = data.OidcAuth.OidcAuthParams.TokenEndpointURL.ValueString()
			}
			oidc_authMap["oidc_auth_params"] = oidc_auth_paramsNestedMap
		}
		if !data.OidcAuth.OidcClientID.IsNull() && !data.OidcAuth.OidcClientID.IsUnknown() {
			oidc_authMap["oidc_client_id"] = data.OidcAuth.OidcClientID.ValueString()
		}
		if !data.OidcAuth.OidcWellKnownConfigURL.IsNull() && !data.OidcAuth.OidcWellKnownConfigURL.IsUnknown() {
			oidc_authMap["oidc_well_known_config_url"] = data.OidcAuth.OidcWellKnownConfigURL.ValueString()
		}
		createReq.Spec["oidc_auth"] = oidc_authMap
	}

	apiResource, err := r.client.CreateAuthentication(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Authentication: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["cookie_params"].(map[string]interface{}); ok && (isImport || data.CookieParams != nil) {
		data.CookieParams = &AuthenticationCookieParamsModel{
			AuthHmac: func() *AuthenticationCookieParamsAuthHmacModel {
				if !isImport && data.CookieParams != nil && data.CookieParams.AuthHmac != nil {
					// Normal Read: preserve existing state value
					return data.CookieParams.AuthHmac
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auth_hmac"].(map[string]interface{}); ok {
					return &AuthenticationCookieParamsAuthHmacModel{
						PrimKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["prim_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						SecKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["sec_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CookieRefreshInterval: func() types.Int64 {
				if v, ok := blockData["cookie_refresh_interval"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			KmsKeyHmac: func() *AuthenticationEmptyModel {
				if !isImport && data.CookieParams != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieParams.KmsKeyHmac
				}
				// Import case: read from API
				if _, ok := blockData["kms_key_hmac"].(map[string]interface{}); ok {
					return &AuthenticationEmptyModel{}
				}
				return nil
			}(),
			SessionExpiry: func() types.Int64 {
				if v, ok := blockData["session_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_auth"].(map[string]interface{}); ok && (isImport || data.OidcAuth != nil) {
		data.OidcAuth = &AuthenticationOidcAuthModel{
			ClientSecret: func() *AuthenticationOidcAuthClientSecretModel {
				if !isImport && data.OidcAuth != nil && data.OidcAuth.ClientSecret != nil {
					// Normal Read: preserve existing state value
					return data.OidcAuth.ClientSecret
				}
				// Import case: read from API
				if _, ok := blockData["client_secret"].(map[string]interface{}); ok {
					return &AuthenticationOidcAuthClientSecretModel{}
				}
				return nil
			}(),
			OidcAuthParams: func() *AuthenticationOidcAuthOidcAuthParamsModel {
				if !isImport && data.OidcAuth != nil && data.OidcAuth.OidcAuthParams != nil {
					// Normal Read: preserve existing state value
					return data.OidcAuth.OidcAuthParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["oidc_auth_params"].(map[string]interface{}); ok {
					return &AuthenticationOidcAuthOidcAuthParamsModel{
						AuthEndpointURL: func() types.String {
							if v, ok := nestedBlockData["auth_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						EndSessionEndpointURL: func() types.String {
							if v, ok := nestedBlockData["end_session_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TokenEndpointURL: func() types.String {
							if v, ok := nestedBlockData["token_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			OidcClientID: func() types.String {
				if v, ok := blockData["oidc_client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OidcWellKnownConfigURL: func() types.String {
				if v, ok := blockData["oidc_well_known_config_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Authentication resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AuthenticationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAuthentication(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Authentication not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Authentication: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The authentication may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["cookie_params"].(map[string]interface{}); ok && (isImport || data.CookieParams != nil) {
		data.CookieParams = &AuthenticationCookieParamsModel{
			AuthHmac: func() *AuthenticationCookieParamsAuthHmacModel {
				if !isImport && data.CookieParams != nil && data.CookieParams.AuthHmac != nil {
					// Normal Read: preserve existing state value
					return data.CookieParams.AuthHmac
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auth_hmac"].(map[string]interface{}); ok {
					return &AuthenticationCookieParamsAuthHmacModel{
						PrimKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["prim_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						SecKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["sec_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CookieRefreshInterval: func() types.Int64 {
				if v, ok := blockData["cookie_refresh_interval"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			KmsKeyHmac: func() *AuthenticationEmptyModel {
				if !isImport && data.CookieParams != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieParams.KmsKeyHmac
				}
				// Import case: read from API
				if _, ok := blockData["kms_key_hmac"].(map[string]interface{}); ok {
					return &AuthenticationEmptyModel{}
				}
				return nil
			}(),
			SessionExpiry: func() types.Int64 {
				if v, ok := blockData["session_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_auth"].(map[string]interface{}); ok && (isImport || data.OidcAuth != nil) {
		data.OidcAuth = &AuthenticationOidcAuthModel{
			ClientSecret: func() *AuthenticationOidcAuthClientSecretModel {
				if !isImport && data.OidcAuth != nil && data.OidcAuth.ClientSecret != nil {
					// Normal Read: preserve existing state value
					return data.OidcAuth.ClientSecret
				}
				// Import case: read from API
				if _, ok := blockData["client_secret"].(map[string]interface{}); ok {
					return &AuthenticationOidcAuthClientSecretModel{}
				}
				return nil
			}(),
			OidcAuthParams: func() *AuthenticationOidcAuthOidcAuthParamsModel {
				if !isImport && data.OidcAuth != nil && data.OidcAuth.OidcAuthParams != nil {
					// Normal Read: preserve existing state value
					return data.OidcAuth.OidcAuthParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["oidc_auth_params"].(map[string]interface{}); ok {
					return &AuthenticationOidcAuthOidcAuthParamsModel{
						AuthEndpointURL: func() types.String {
							if v, ok := nestedBlockData["auth_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						EndSessionEndpointURL: func() types.String {
							if v, ok := nestedBlockData["end_session_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TokenEndpointURL: func() types.String {
							if v, ok := nestedBlockData["token_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			OidcClientID: func() types.String {
				if v, ok := blockData["oidc_client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OidcWellKnownConfigURL: func() types.String {
				if v, ok := blockData["oidc_well_known_config_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AuthenticationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Authentication{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.CookieParams != nil {
		cookie_paramsMap := make(map[string]interface{})
		if data.CookieParams.AuthHmac != nil {
			auth_hmacNestedMap := make(map[string]interface{})
			if !data.CookieParams.AuthHmac.PrimKeyExpiry.IsNull() && !data.CookieParams.AuthHmac.PrimKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["prim_key_expiry"] = data.CookieParams.AuthHmac.PrimKeyExpiry.ValueString()
			}
			if !data.CookieParams.AuthHmac.SecKeyExpiry.IsNull() && !data.CookieParams.AuthHmac.SecKeyExpiry.IsUnknown() {
				auth_hmacNestedMap["sec_key_expiry"] = data.CookieParams.AuthHmac.SecKeyExpiry.ValueString()
			}
			cookie_paramsMap["auth_hmac"] = auth_hmacNestedMap
		}
		if !data.CookieParams.CookieExpiry.IsNull() && !data.CookieParams.CookieExpiry.IsUnknown() {
			cookie_paramsMap["cookie_expiry"] = data.CookieParams.CookieExpiry.ValueInt64()
		}
		if !data.CookieParams.CookieRefreshInterval.IsNull() && !data.CookieParams.CookieRefreshInterval.IsUnknown() {
			cookie_paramsMap["cookie_refresh_interval"] = data.CookieParams.CookieRefreshInterval.ValueInt64()
		}
		if data.CookieParams.KmsKeyHmac != nil {
			cookie_paramsMap["kms_key_hmac"] = map[string]interface{}{}
		}
		if !data.CookieParams.SessionExpiry.IsNull() && !data.CookieParams.SessionExpiry.IsUnknown() {
			cookie_paramsMap["session_expiry"] = data.CookieParams.SessionExpiry.ValueInt64()
		}
		apiResource.Spec["cookie_params"] = cookie_paramsMap
	}
	if data.OidcAuth != nil {
		oidc_authMap := make(map[string]interface{})
		if data.OidcAuth.ClientSecret != nil {
			client_secretNestedMap := make(map[string]interface{})
			oidc_authMap["client_secret"] = client_secretNestedMap
		}
		if data.OidcAuth.OidcAuthParams != nil {
			oidc_auth_paramsNestedMap := make(map[string]interface{})
			if !data.OidcAuth.OidcAuthParams.AuthEndpointURL.IsNull() && !data.OidcAuth.OidcAuthParams.AuthEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["auth_endpoint_url"] = data.OidcAuth.OidcAuthParams.AuthEndpointURL.ValueString()
			}
			if !data.OidcAuth.OidcAuthParams.EndSessionEndpointURL.IsNull() && !data.OidcAuth.OidcAuthParams.EndSessionEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["end_session_endpoint_url"] = data.OidcAuth.OidcAuthParams.EndSessionEndpointURL.ValueString()
			}
			if !data.OidcAuth.OidcAuthParams.TokenEndpointURL.IsNull() && !data.OidcAuth.OidcAuthParams.TokenEndpointURL.IsUnknown() {
				oidc_auth_paramsNestedMap["token_endpoint_url"] = data.OidcAuth.OidcAuthParams.TokenEndpointURL.ValueString()
			}
			oidc_authMap["oidc_auth_params"] = oidc_auth_paramsNestedMap
		}
		if !data.OidcAuth.OidcClientID.IsNull() && !data.OidcAuth.OidcClientID.IsUnknown() {
			oidc_authMap["oidc_client_id"] = data.OidcAuth.OidcClientID.ValueString()
		}
		if !data.OidcAuth.OidcWellKnownConfigURL.IsNull() && !data.OidcAuth.OidcWellKnownConfigURL.IsUnknown() {
			oidc_authMap["oidc_well_known_config_url"] = data.OidcAuth.OidcWellKnownConfigURL.ValueString()
		}
		apiResource.Spec["oidc_auth"] = oidc_authMap
	}

	_, err := r.client.UpdateAuthentication(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Authentication: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAuthentication(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Authentication after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["cookie_params"].(map[string]interface{}); ok && (isImport || data.CookieParams != nil) {
		data.CookieParams = &AuthenticationCookieParamsModel{
			AuthHmac: func() *AuthenticationCookieParamsAuthHmacModel {
				if !isImport && data.CookieParams != nil && data.CookieParams.AuthHmac != nil {
					// Normal Read: preserve existing state value
					return data.CookieParams.AuthHmac
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auth_hmac"].(map[string]interface{}); ok {
					return &AuthenticationCookieParamsAuthHmacModel{
						PrimKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["prim_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						SecKeyExpiry: func() types.String {
							if v, ok := nestedBlockData["sec_key_expiry"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CookieRefreshInterval: func() types.Int64 {
				if v, ok := blockData["cookie_refresh_interval"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			KmsKeyHmac: func() *AuthenticationEmptyModel {
				if !isImport && data.CookieParams != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieParams.KmsKeyHmac
				}
				// Import case: read from API
				if _, ok := blockData["kms_key_hmac"].(map[string]interface{}); ok {
					return &AuthenticationEmptyModel{}
				}
				return nil
			}(),
			SessionExpiry: func() types.Int64 {
				if v, ok := blockData["session_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_auth"].(map[string]interface{}); ok && (isImport || data.OidcAuth != nil) {
		data.OidcAuth = &AuthenticationOidcAuthModel{
			ClientSecret: func() *AuthenticationOidcAuthClientSecretModel {
				if !isImport && data.OidcAuth != nil && data.OidcAuth.ClientSecret != nil {
					// Normal Read: preserve existing state value
					return data.OidcAuth.ClientSecret
				}
				// Import case: read from API
				if _, ok := blockData["client_secret"].(map[string]interface{}); ok {
					return &AuthenticationOidcAuthClientSecretModel{}
				}
				return nil
			}(),
			OidcAuthParams: func() *AuthenticationOidcAuthOidcAuthParamsModel {
				if !isImport && data.OidcAuth != nil && data.OidcAuth.OidcAuthParams != nil {
					// Normal Read: preserve existing state value
					return data.OidcAuth.OidcAuthParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["oidc_auth_params"].(map[string]interface{}); ok {
					return &AuthenticationOidcAuthOidcAuthParamsModel{
						AuthEndpointURL: func() types.String {
							if v, ok := nestedBlockData["auth_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						EndSessionEndpointURL: func() types.String {
							if v, ok := nestedBlockData["end_session_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TokenEndpointURL: func() types.String {
							if v, ok := nestedBlockData["token_endpoint_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			OidcClientID: func() types.String {
				if v, ok := blockData["oidc_client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OidcWellKnownConfigURL: func() types.String {
				if v, ok := blockData["oidc_well_known_config_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AuthenticationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AuthenticationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAuthentication(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Authentication already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Authentication delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Authentication: %s", err))
		return
	}
}

func (r *AuthenticationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
