// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AWSVPCSiteResource{}
	_ resource.ResourceWithConfigure      = &AWSVPCSiteResource{}
	_ resource.ResourceWithImportState    = &AWSVPCSiteResource{}
	_ resource.ResourceWithModifyPlan     = &AWSVPCSiteResource{}
	_ resource.ResourceWithUpgradeState   = &AWSVPCSiteResource{}
	_ resource.ResourceWithValidateConfig = &AWSVPCSiteResource{}
)

// aws_vpc_siteSchemaVersion is the schema version for state upgrades
const aws_vpc_siteSchemaVersion int64 = 1

func NewAWSVPCSiteResource() resource.Resource {
	return &AWSVPCSiteResource{}
}

type AWSVPCSiteResource struct {
	client *client.Client
}

// AWSVPCSiteEmptyModel represents empty nested blocks
type AWSVPCSiteEmptyModel struct {
}

// AWSVPCSiteAdminPasswordModel represents admin_password block
type AWSVPCSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AWSVPCSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AWSVPCSiteAdminPasswordModelAttrTypes defines the attribute types for AWSVPCSiteAdminPasswordModel
var AWSVPCSiteAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AWSVPCSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AWSVPCSiteAdminPasswordClearSecretInfoModelAttrTypes},
}

// AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AWSVPCSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel
var AWSVPCSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AWSVPCSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type AWSVPCSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AWSVPCSiteAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for AWSVPCSiteAdminPasswordClearSecretInfoModel
var AWSVPCSiteAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AWSVPCSiteAWSCredModel represents aws_cred block
type AWSVPCSiteAWSCredModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteAWSCredModelAttrTypes defines the attribute types for AWSVPCSiteAWSCredModel
var AWSVPCSiteAWSCredModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteBlockedServicesModel represents blocked_services block
type AWSVPCSiteBlockedServicesModel struct {
	BlockedSevice []AWSVPCSiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// AWSVPCSiteBlockedServicesModelAttrTypes defines the attribute types for AWSVPCSiteBlockedServicesModel
var AWSVPCSiteBlockedServicesModelAttrTypes = map[string]attr.Type{
	"blocked_sevice": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteBlockedServicesBlockedSeviceModelAttrTypes}},
}

// AWSVPCSiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type AWSVPCSiteBlockedServicesBlockedSeviceModel struct {
	NetworkType      types.String          `tfsdk:"network_type"`
	DNS              *AWSVPCSiteEmptyModel `tfsdk:"dns"`
	SSH              *AWSVPCSiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *AWSVPCSiteEmptyModel `tfsdk:"web_user_interface"`
}

// AWSVPCSiteBlockedServicesBlockedSeviceModelAttrTypes defines the attribute types for AWSVPCSiteBlockedServicesBlockedSeviceModel
var AWSVPCSiteBlockedServicesBlockedSeviceModelAttrTypes = map[string]attr.Type{
	"network_type":       types.StringType,
	"dns":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ssh":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web_user_interface": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteCoordinatesModel represents coordinates block
type AWSVPCSiteCoordinatesModel struct {
	Latitude  types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// AWSVPCSiteCoordinatesModelAttrTypes defines the attribute types for AWSVPCSiteCoordinatesModel
var AWSVPCSiteCoordinatesModelAttrTypes = map[string]attr.Type{
	"latitude":  types.Int64Type,
	"longitude": types.Int64Type,
}

// AWSVPCSiteCustomDNSModel represents custom_dns block
type AWSVPCSiteCustomDNSModel struct {
	InsideNameserver  types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// AWSVPCSiteCustomDNSModelAttrTypes defines the attribute types for AWSVPCSiteCustomDNSModel
var AWSVPCSiteCustomDNSModelAttrTypes = map[string]attr.Type{
	"inside_nameserver":  types.StringType,
	"outside_nameserver": types.StringType,
}

// AWSVPCSiteCustomSecurityGroupModel represents custom_security_group block
type AWSVPCSiteCustomSecurityGroupModel struct {
	InsideSecurityGroupID  types.String `tfsdk:"inside_security_group_id"`
	OutsideSecurityGroupID types.String `tfsdk:"outside_security_group_id"`
}

// AWSVPCSiteCustomSecurityGroupModelAttrTypes defines the attribute types for AWSVPCSiteCustomSecurityGroupModel
var AWSVPCSiteCustomSecurityGroupModelAttrTypes = map[string]attr.Type{
	"inside_security_group_id":  types.StringType,
	"outside_security_group_id": types.StringType,
}

// AWSVPCSiteDirectConnectEnabledModel represents direct_connect_enabled block
type AWSVPCSiteDirectConnectEnabledModel struct {
	CustomAsn    types.Int64                                    `tfsdk:"custom_asn"`
	AutoAsn      *AWSVPCSiteEmptyModel                          `tfsdk:"auto_asn"`
	HostedVifs   *AWSVPCSiteDirectConnectEnabledHostedVifsModel `tfsdk:"hosted_vifs"`
	StandardVifs *AWSVPCSiteEmptyModel                          `tfsdk:"standard_vifs"`
}

// AWSVPCSiteDirectConnectEnabledModelAttrTypes defines the attribute types for AWSVPCSiteDirectConnectEnabledModel
var AWSVPCSiteDirectConnectEnabledModelAttrTypes = map[string]attr.Type{
	"custom_asn":    types.Int64Type,
	"auto_asn":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"hosted_vifs":   types.ObjectType{AttrTypes: AWSVPCSiteDirectConnectEnabledHostedVifsModelAttrTypes},
	"standard_vifs": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteDirectConnectEnabledHostedVifsModel represents hosted_vifs block
type AWSVPCSiteDirectConnectEnabledHostedVifsModel struct {
	SiteRegistrationOverDirectConnect *AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel `tfsdk:"site_registration_over_direct_connect"`
	SiteRegistrationOverInternet      *AWSVPCSiteEmptyModel                                                           `tfsdk:"site_registration_over_internet"`
	VifList                           []AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel                          `tfsdk:"vif_list"`
}

// AWSVPCSiteDirectConnectEnabledHostedVifsModelAttrTypes defines the attribute types for AWSVPCSiteDirectConnectEnabledHostedVifsModel
var AWSVPCSiteDirectConnectEnabledHostedVifsModelAttrTypes = map[string]attr.Type{
	"site_registration_over_direct_connect": types.ObjectType{AttrTypes: AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModelAttrTypes},
	"site_registration_over_internet":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"vif_list":                              types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteDirectConnectEnabledHostedVifsVifListModelAttrTypes}},
}

// AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel represents site_registration_over_direct_connect block
type AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModelAttrTypes defines the attribute types for AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel
var AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModelAttrTypes = map[string]attr.Type{
	"cloudlink_network_name": types.StringType,
}

// AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel represents vif_list block
type AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel struct {
	OtherRegion      types.String          `tfsdk:"other_region"`
	VifID            types.String          `tfsdk:"vif_id"`
	SameAsSiteRegion *AWSVPCSiteEmptyModel `tfsdk:"same_as_site_region"`
}

// AWSVPCSiteDirectConnectEnabledHostedVifsVifListModelAttrTypes defines the attribute types for AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel
var AWSVPCSiteDirectConnectEnabledHostedVifsVifListModelAttrTypes = map[string]attr.Type{
	"other_region":        types.StringType,
	"vif_id":              types.StringType,
	"same_as_site_region": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteEgressNATGwModel represents egress_nat_gw block
type AWSVPCSiteEgressNATGwModel struct {
	NATGwID types.String `tfsdk:"nat_gw_id"`
}

// AWSVPCSiteEgressNATGwModelAttrTypes defines the attribute types for AWSVPCSiteEgressNATGwModel
var AWSVPCSiteEgressNATGwModelAttrTypes = map[string]attr.Type{
	"nat_gw_id": types.StringType,
}

// AWSVPCSiteEgressVirtualPrivateGatewayModel represents egress_virtual_private_gateway block
type AWSVPCSiteEgressVirtualPrivateGatewayModel struct {
	VgwID types.String `tfsdk:"vgw_id"`
}

// AWSVPCSiteEgressVirtualPrivateGatewayModelAttrTypes defines the attribute types for AWSVPCSiteEgressVirtualPrivateGatewayModel
var AWSVPCSiteEgressVirtualPrivateGatewayModelAttrTypes = map[string]attr.Type{
	"vgw_id": types.StringType,
}

// AWSVPCSiteIngressEgressGwModel represents ingress_egress_gw block
type AWSVPCSiteIngressEgressGwModel struct {
	AWSCertifiedHw                 types.String                                                  `tfsdk:"aws_certified_hw"`
	ActiveEnhancedFirewallPolicies *AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	AllowedVIPPort                 *AWSVPCSiteIngressEgressGwAllowedVIPPortModel                 `tfsdk:"allowed_vip_port"`
	AllowedVIPPortSLI              *AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel              `tfsdk:"allowed_vip_port_sli"`
	AzNodes                        []AWSVPCSiteIngressEgressGwAzNodesModel                       `tfsdk:"az_nodes"`
	DcClusterGroupInsideVn         *AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel         `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn        *AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel        `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll           *AWSVPCSiteEmptyModel                                         `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AWSVPCSiteIngressEgressGwGlobalNetworkListModel              `tfsdk:"global_network_list"`
	InsideStaticRoutes             *AWSVPCSiteIngressEgressGwInsideStaticRoutesModel             `tfsdk:"inside_static_routes"`
	NoDcClusterGroup               *AWSVPCSiteEmptyModel                                         `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AWSVPCSiteEmptyModel                                         `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AWSVPCSiteEmptyModel                                         `tfsdk:"no_global_network"`
	NoInsideStaticRoutes           *AWSVPCSiteEmptyModel                                         `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy                *AWSVPCSiteEmptyModel                                         `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AWSVPCSiteEmptyModel                                         `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes            *AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	PerformanceEnhancementMode     *AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel     `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP           *AWSVPCSiteEmptyModel                                         `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AWSVPCSiteEmptyModel                                         `tfsdk:"sm_connection_pvt_ip"`
}

// AWSVPCSiteIngressEgressGwModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwModel
var AWSVPCSiteIngressEgressGwModelAttrTypes = map[string]attr.Type{
	"aws_certified_hw":                  types.StringType,
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes},
	"allowed_vip_port":                  types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAllowedVIPPortModelAttrTypes},
	"allowed_vip_port_sli":              types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModelAttrTypes},
	"az_nodes":                          types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesModelAttrTypes}},
	"dc_cluster_group_inside_vn":        types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes},
	"dc_cluster_group_outside_vn":       types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwGlobalNetworkListModelAttrTypes},
	"inside_static_routes":              types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_inside_static_routes":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":             types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes},
	"performance_enhancement_mode":      types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel
var AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel
var AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel
var AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel represents active_network_policies block
type AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel struct {
	NetworkPolicies []AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel
var AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel
var AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortModel represents allowed_vip_port block
type AWSVPCSiteIngressEgressGwAllowedVIPPortModel struct {
	CustomPorts           *AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVIPPort *AWSVPCSiteEmptyModel                                    `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort      *AWSVPCSiteEmptyModel                                    `tfsdk:"use_http_https_port"`
	UseHTTPPort           *AWSVPCSiteEmptyModel                                    `tfsdk:"use_http_port"`
	UseHTTPSPort          *AWSVPCSiteEmptyModel                                    `tfsdk:"use_https_port"`
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAllowedVIPPortModel
var AWSVPCSiteIngressEgressGwAllowedVIPPortModelAttrTypes = map[string]attr.Type{
	"custom_ports":             types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModelAttrTypes},
	"disable_allowed_vip_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_https_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_port":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_https_port":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModel represents custom_ports block
type AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModel
var AWSVPCSiteIngressEgressGwAllowedVIPPortCustomPortsModelAttrTypes = map[string]attr.Type{
	"port_ranges": types.StringType,
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel represents allowed_vip_port_sli block
type AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel struct {
	CustomPorts           *AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVIPPort *AWSVPCSiteEmptyModel                                       `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort      *AWSVPCSiteEmptyModel                                       `tfsdk:"use_http_https_port"`
	UseHTTPPort           *AWSVPCSiteEmptyModel                                       `tfsdk:"use_http_port"`
	UseHTTPSPort          *AWSVPCSiteEmptyModel                                       `tfsdk:"use_https_port"`
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel
var AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModelAttrTypes = map[string]attr.Type{
	"custom_ports":             types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModelAttrTypes},
	"disable_allowed_vip_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_https_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_port":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_https_port":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModel represents custom_ports block
type AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModel
var AWSVPCSiteIngressEgressGwAllowedVIPPortSLICustomPortsModelAttrTypes = map[string]attr.Type{
	"port_ranges": types.StringType,
}

// AWSVPCSiteIngressEgressGwAzNodesModel represents az_nodes block
type AWSVPCSiteIngressEgressGwAzNodesModel struct {
	AWSAzName            types.String                                         `tfsdk:"aws_az_name"`
	InsideSubnet         *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel   `tfsdk:"inside_subnet"`
	OutsideSubnet        *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel  `tfsdk:"outside_subnet"`
	ReservedInsideSubnet *AWSVPCSiteEmptyModel                                `tfsdk:"reserved_inside_subnet"`
	WorkloadSubnet       *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel `tfsdk:"workload_subnet"`
}

// AWSVPCSiteIngressEgressGwAzNodesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesModel
var AWSVPCSiteIngressEgressGwAzNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":            types.StringType,
	"inside_subnet":          types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModelAttrTypes},
	"outside_subnet":         types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModelAttrTypes},
	"reserved_inside_subnet": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"workload_subnet":        types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel represents inside_subnet block
type AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel struct {
	ExistingSubnetID types.String                                                  `tfsdk:"existing_subnet_id"`
	SubnetParam      *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel
var AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel
var AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel represents outside_subnet block
type AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel struct {
	ExistingSubnetID types.String                                                   `tfsdk:"existing_subnet_id"`
	SubnetParam      *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel
var AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel
var AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel represents workload_subnet block
type AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel struct {
	ExistingSubnetID types.String                                                    `tfsdk:"existing_subnet_id"`
	SubnetParam      *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel
var AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel
var AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel
var AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel
var AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListModel represents global_network_list block
type AWSVPCSiteIngressEgressGwGlobalNetworkListModel struct {
	GlobalNetworkConnections []AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwGlobalNetworkListModel
var AWSVPCSiteIngressEgressGwGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel
var AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesModel represents inside_static_routes block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesModel struct {
	StaticRouteList []AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel represents static_route_list block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                      `tfsdk:"simple_static_route"`
	CustomStaticRoute *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                `tfsdk:"attrs"`
	Labels  *AWSVPCSiteEmptyModel                                                                     `tfsdk:"labels"`
	Nexthop *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                           `tfsdk:"type"`
	Interface      []AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel represents outside_static_routes block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel struct {
	StaticRouteList []AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                       `tfsdk:"simple_static_route"`
	CustomStaticRoute *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                 `tfsdk:"attrs"`
	Labels  *AWSVPCSiteEmptyModel                                                                      `tfsdk:"labels"`
	Nexthop *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                            `tfsdk:"type"`
	Interface      []AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AWSVPCSiteEmptyModel                                                       `tfsdk:"perf_mode_l7_enhanced"`
}

// AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel
var AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AWSVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AWSVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel
var AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressGwModel represents ingress_gw block
type AWSVPCSiteIngressGwModel struct {
	AWSCertifiedHw             types.String                                        `tfsdk:"aws_certified_hw"`
	AllowedVIPPort             *AWSVPCSiteIngressGwAllowedVIPPortModel             `tfsdk:"allowed_vip_port"`
	AzNodes                    []AWSVPCSiteIngressGwAzNodesModel                   `tfsdk:"az_nodes"`
	PerformanceEnhancementMode *AWSVPCSiteIngressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// AWSVPCSiteIngressGwModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwModel
var AWSVPCSiteIngressGwModelAttrTypes = map[string]attr.Type{
	"aws_certified_hw":             types.StringType,
	"allowed_vip_port":             types.ObjectType{AttrTypes: AWSVPCSiteIngressGwAllowedVIPPortModelAttrTypes},
	"az_nodes":                     types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteIngressGwAzNodesModelAttrTypes}},
	"performance_enhancement_mode": types.ObjectType{AttrTypes: AWSVPCSiteIngressGwPerformanceEnhancementModeModelAttrTypes},
}

// AWSVPCSiteIngressGwAllowedVIPPortModel represents allowed_vip_port block
type AWSVPCSiteIngressGwAllowedVIPPortModel struct {
	CustomPorts           *AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVIPPort *AWSVPCSiteEmptyModel                              `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort      *AWSVPCSiteEmptyModel                              `tfsdk:"use_http_https_port"`
	UseHTTPPort           *AWSVPCSiteEmptyModel                              `tfsdk:"use_http_port"`
	UseHTTPSPort          *AWSVPCSiteEmptyModel                              `tfsdk:"use_https_port"`
}

// AWSVPCSiteIngressGwAllowedVIPPortModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwAllowedVIPPortModel
var AWSVPCSiteIngressGwAllowedVIPPortModelAttrTypes = map[string]attr.Type{
	"custom_ports":             types.ObjectType{AttrTypes: AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModelAttrTypes},
	"disable_allowed_vip_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_https_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_port":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_https_port":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModel represents custom_ports block
type AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModel
var AWSVPCSiteIngressGwAllowedVIPPortCustomPortsModelAttrTypes = map[string]attr.Type{
	"port_ranges": types.StringType,
}

// AWSVPCSiteIngressGwAzNodesModel represents az_nodes block
type AWSVPCSiteIngressGwAzNodesModel struct {
	AWSAzName   types.String                                `tfsdk:"aws_az_name"`
	LocalSubnet *AWSVPCSiteIngressGwAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AWSVPCSiteIngressGwAzNodesModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwAzNodesModel
var AWSVPCSiteIngressGwAzNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":  types.StringType,
	"local_subnet": types.ObjectType{AttrTypes: AWSVPCSiteIngressGwAzNodesLocalSubnetModelAttrTypes},
}

// AWSVPCSiteIngressGwAzNodesLocalSubnetModel represents local_subnet block
type AWSVPCSiteIngressGwAzNodesLocalSubnetModel struct {
	ExistingSubnetID types.String                                           `tfsdk:"existing_subnet_id"`
	SubnetParam      *AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressGwAzNodesLocalSubnetModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwAzNodesLocalSubnetModel
var AWSVPCSiteIngressGwAzNodesLocalSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModelAttrTypes},
}

// AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel
var AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AWSVPCSiteIngressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AWSVPCSiteIngressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AWSVPCSiteEmptyModel                                                 `tfsdk:"perf_mode_l7_enhanced"`
}

// AWSVPCSiteIngressGwPerformanceEnhancementModeModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwPerformanceEnhancementModeModel
var AWSVPCSiteIngressGwPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AWSVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AWSVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel
var AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type AWSVPCSiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *AWSVPCSiteEmptyModel                                    `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain  *AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// AWSVPCSiteKubernetesUpgradeDrainModelAttrTypes defines the attribute types for AWSVPCSiteKubernetesUpgradeDrainModel
var AWSVPCSiteKubernetesUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"disable_upgrade_drain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_upgrade_drain":  types.ObjectType{AttrTypes: AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes},
}

// AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64           `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout             types.Int64           `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode       *AWSVPCSiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode        *AWSVPCSiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes defines the attribute types for AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel
var AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"drain_max_unavailable_node_count": types.Int64Type,
	"drain_node_timeout":               types.Int64Type,
	"disable_vega_upgrade_mode":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_vega_upgrade_mode":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteLogReceiverModel represents log_receiver block
type AWSVPCSiteLogReceiverModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteLogReceiverModelAttrTypes defines the attribute types for AWSVPCSiteLogReceiverModel
var AWSVPCSiteLogReceiverModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type AWSVPCSiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *AWSVPCSiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode     *AWSVPCSiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// AWSVPCSiteOfflineSurvivabilityModeModelAttrTypes defines the attribute types for AWSVPCSiteOfflineSurvivabilityModeModel
var AWSVPCSiteOfflineSurvivabilityModeModelAttrTypes = map[string]attr.Type{
	"enable_offline_survivability_mode": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_offline_survivability_mode":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteOSModel represents os block
type AWSVPCSiteOSModel struct {
	OperatingSystemVersion types.String          `tfsdk:"operating_system_version"`
	DefaultOSVersion       *AWSVPCSiteEmptyModel `tfsdk:"default_os_version"`
}

// AWSVPCSiteOSModelAttrTypes defines the attribute types for AWSVPCSiteOSModel
var AWSVPCSiteOSModelAttrTypes = map[string]attr.Type{
	"operating_system_version": types.StringType,
	"default_os_version":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSitePrivateConnectivityModel represents private_connectivity block
type AWSVPCSitePrivateConnectivityModel struct {
	CloudLink *AWSVPCSitePrivateConnectivityCloudLinkModel `tfsdk:"cloud_link"`
	Inside    *AWSVPCSiteEmptyModel                        `tfsdk:"inside"`
	Outside   *AWSVPCSiteEmptyModel                        `tfsdk:"outside"`
}

// AWSVPCSitePrivateConnectivityModelAttrTypes defines the attribute types for AWSVPCSitePrivateConnectivityModel
var AWSVPCSitePrivateConnectivityModelAttrTypes = map[string]attr.Type{
	"cloud_link": types.ObjectType{AttrTypes: AWSVPCSitePrivateConnectivityCloudLinkModelAttrTypes},
	"inside":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSitePrivateConnectivityCloudLinkModel represents cloud_link block
type AWSVPCSitePrivateConnectivityCloudLinkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSitePrivateConnectivityCloudLinkModelAttrTypes defines the attribute types for AWSVPCSitePrivateConnectivityCloudLinkModel
var AWSVPCSitePrivateConnectivityCloudLinkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteSwModel represents sw block
type AWSVPCSiteSwModel struct {
	VolterraSoftwareVersion types.String          `tfsdk:"volterra_software_version"`
	DefaultSwVersion        *AWSVPCSiteEmptyModel `tfsdk:"default_sw_version"`
}

// AWSVPCSiteSwModelAttrTypes defines the attribute types for AWSVPCSiteSwModel
var AWSVPCSiteSwModelAttrTypes = map[string]attr.Type{
	"volterra_software_version": types.StringType,
	"default_sw_version":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteVoltstackClusterModel represents voltstack_cluster block
type AWSVPCSiteVoltstackClusterModel struct {
	AWSCertifiedHw                 types.String                                                   `tfsdk:"aws_certified_hw"`
	ActiveEnhancedFirewallPolicies *AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	AllowedVIPPort                 *AWSVPCSiteVoltstackClusterAllowedVIPPortModel                 `tfsdk:"allowed_vip_port"`
	AzNodes                        []AWSVPCSiteVoltstackClusterAzNodesModel                       `tfsdk:"az_nodes"`
	DcClusterGroup                 *AWSVPCSiteVoltstackClusterDcClusterGroupModel                 `tfsdk:"dc_cluster_group"`
	DefaultStorage                 *AWSVPCSiteEmptyModel                                          `tfsdk:"default_storage"`
	ForwardProxyAllowAll           *AWSVPCSiteEmptyModel                                          `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AWSVPCSiteVoltstackClusterGlobalNetworkListModel              `tfsdk:"global_network_list"`
	K8SCluster                     *AWSVPCSiteVoltstackClusterK8SClusterModel                     `tfsdk:"k8s_cluster"`
	NoDcClusterGroup               *AWSVPCSiteEmptyModel                                          `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AWSVPCSiteEmptyModel                                          `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AWSVPCSiteEmptyModel                                          `tfsdk:"no_global_network"`
	NoK8SCluster                   *AWSVPCSiteEmptyModel                                          `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy                *AWSVPCSiteEmptyModel                                          `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AWSVPCSiteEmptyModel                                          `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes            *AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP           *AWSVPCSiteEmptyModel                                          `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AWSVPCSiteEmptyModel                                          `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList               *AWSVPCSiteVoltstackClusterStorageClassListModel               `tfsdk:"storage_class_list"`
}

// AWSVPCSiteVoltstackClusterModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterModel
var AWSVPCSiteVoltstackClusterModelAttrTypes = map[string]attr.Type{
	"aws_certified_hw":                  types.StringType,
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes},
	"allowed_vip_port":                  types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterAllowedVIPPortModelAttrTypes},
	"az_nodes":                          types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterAzNodesModelAttrTypes}},
	"dc_cluster_group":                  types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterDcClusterGroupModelAttrTypes},
	"default_storage":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterGlobalNetworkListModelAttrTypes},
	"k8s_cluster":                       types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterK8SClusterModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_k8s_cluster":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":             types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"storage_class_list":                types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterStorageClassListModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel
var AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel
var AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel
var AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel represents active_network_policies block
type AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel struct {
	NetworkPolicies []AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel
var AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel
var AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterAllowedVIPPortModel represents allowed_vip_port block
type AWSVPCSiteVoltstackClusterAllowedVIPPortModel struct {
	CustomPorts           *AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVIPPort *AWSVPCSiteEmptyModel                                     `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort      *AWSVPCSiteEmptyModel                                     `tfsdk:"use_http_https_port"`
	UseHTTPPort           *AWSVPCSiteEmptyModel                                     `tfsdk:"use_http_port"`
	UseHTTPSPort          *AWSVPCSiteEmptyModel                                     `tfsdk:"use_https_port"`
}

// AWSVPCSiteVoltstackClusterAllowedVIPPortModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterAllowedVIPPortModel
var AWSVPCSiteVoltstackClusterAllowedVIPPortModelAttrTypes = map[string]attr.Type{
	"custom_ports":             types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModelAttrTypes},
	"disable_allowed_vip_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_https_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_port":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_https_port":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModel represents custom_ports block
type AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModel
var AWSVPCSiteVoltstackClusterAllowedVIPPortCustomPortsModelAttrTypes = map[string]attr.Type{
	"port_ranges": types.StringType,
}

// AWSVPCSiteVoltstackClusterAzNodesModel represents az_nodes block
type AWSVPCSiteVoltstackClusterAzNodesModel struct {
	AWSAzName   types.String                                       `tfsdk:"aws_az_name"`
	LocalSubnet *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AWSVPCSiteVoltstackClusterAzNodesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterAzNodesModel
var AWSVPCSiteVoltstackClusterAzNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":  types.StringType,
	"local_subnet": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel represents local_subnet block
type AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel struct {
	ExistingSubnetID types.String                                                  `tfsdk:"existing_subnet_id"`
	SubnetParam      *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel
var AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel
var AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AWSVPCSiteVoltstackClusterDcClusterGroupModel represents dc_cluster_group block
type AWSVPCSiteVoltstackClusterDcClusterGroupModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterDcClusterGroupModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterDcClusterGroupModel
var AWSVPCSiteVoltstackClusterDcClusterGroupModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListModel represents global_network_list block
type AWSVPCSiteVoltstackClusterGlobalNetworkListModel struct {
	GlobalNetworkConnections []AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterGlobalNetworkListModel
var AWSVPCSiteVoltstackClusterGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel
var AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterK8SClusterModel represents k8s_cluster block
type AWSVPCSiteVoltstackClusterK8SClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterK8SClusterModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterK8SClusterModel
var AWSVPCSiteVoltstackClusterK8SClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel represents outside_static_routes block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel struct {
	StaticRouteList []AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                        `tfsdk:"simple_static_route"`
	CustomStaticRoute *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                  `tfsdk:"attrs"`
	Labels  *AWSVPCSiteEmptyModel                                                                       `tfsdk:"labels"`
	Nexthop *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                             `tfsdk:"type"`
	Interface      []AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AWSVPCSiteVoltstackClusterStorageClassListModel represents storage_class_list block
type AWSVPCSiteVoltstackClusterStorageClassListModel struct {
	StorageClasses []AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// AWSVPCSiteVoltstackClusterStorageClassListModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterStorageClassListModel
var AWSVPCSiteVoltstackClusterStorageClassListModelAttrTypes = map[string]attr.Type{
	"storage_classes": types.ListType{ElemType: types.ObjectType{AttrTypes: AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes}},
}

// AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel represents storage_classes block
type AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool   `tfsdk:"default_storage_class"`
	StorageClassName    types.String `tfsdk:"storage_class_name"`
}

// AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes defines the attribute types for AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel
var AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes = map[string]attr.Type{
	"default_storage_class": types.BoolType,
	"storage_class_name":    types.StringType,
}

// AWSVPCSiteVPCModel represents vpc block
type AWSVPCSiteVPCModel struct {
	VPCID  types.String              `tfsdk:"vpc_id"`
	NewVPC *AWSVPCSiteVPCNewVPCModel `tfsdk:"new_vpc"`
}

// AWSVPCSiteVPCModelAttrTypes defines the attribute types for AWSVPCSiteVPCModel
var AWSVPCSiteVPCModelAttrTypes = map[string]attr.Type{
	"vpc_id":  types.StringType,
	"new_vpc": types.ObjectType{AttrTypes: AWSVPCSiteVPCNewVPCModelAttrTypes},
}

// AWSVPCSiteVPCNewVPCModel represents new_vpc block
type AWSVPCSiteVPCNewVPCModel struct {
	NameTag      types.String          `tfsdk:"name_tag"`
	PrimaryIpv4  types.String          `tfsdk:"primary_ipv4"`
	Autogenerate *AWSVPCSiteEmptyModel `tfsdk:"autogenerate"`
}

// AWSVPCSiteVPCNewVPCModelAttrTypes defines the attribute types for AWSVPCSiteVPCNewVPCModel
var AWSVPCSiteVPCNewVPCModelAttrTypes = map[string]attr.Type{
	"name_tag":     types.StringType,
	"primary_ipv4": types.StringType,
	"autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

type AWSVPCSiteResourceModel struct {
	Name                        types.String                                `tfsdk:"name"`
	Namespace                   types.String                                `tfsdk:"namespace"`
	Annotations                 types.Map                                   `tfsdk:"annotations"`
	Description                 types.String                                `tfsdk:"description"`
	Disable                     types.Bool                                  `tfsdk:"disable"`
	Labels                      types.Map                                   `tfsdk:"labels"`
	ID                          types.String                                `tfsdk:"id"`
	Address                     types.String                                `tfsdk:"address"`
	AWSRegion                   types.String                                `tfsdk:"aws_region"`
	DiskSize                    types.Int64                                 `tfsdk:"disk_size"`
	InstanceType                types.String                                `tfsdk:"instance_type"`
	NodesPerAz                  types.Int64                                 `tfsdk:"nodes_per_az"`
	SSHKey                      types.String                                `tfsdk:"ssh_key"`
	TotalNodes                  types.Int64                                 `tfsdk:"total_nodes"`
	Timeouts                    timeouts.Value                              `tfsdk:"timeouts"`
	AdminPassword               *AWSVPCSiteAdminPasswordModel               `tfsdk:"admin_password"`
	AWSCred                     *AWSVPCSiteAWSCredModel                     `tfsdk:"aws_cred"`
	BlockAllServices            *AWSVPCSiteEmptyModel                       `tfsdk:"block_all_services"`
	BlockedServices             *AWSVPCSiteBlockedServicesModel             `tfsdk:"blocked_services"`
	Coordinates                 *AWSVPCSiteCoordinatesModel                 `tfsdk:"coordinates"`
	CustomDNS                   *AWSVPCSiteCustomDNSModel                   `tfsdk:"custom_dns"`
	CustomSecurityGroup         *AWSVPCSiteCustomSecurityGroupModel         `tfsdk:"custom_security_group"`
	DefaultBlockedServices      *AWSVPCSiteEmptyModel                       `tfsdk:"default_blocked_services"`
	DirectConnectDisabled       *AWSVPCSiteEmptyModel                       `tfsdk:"direct_connect_disabled"`
	DirectConnectEnabled        *AWSVPCSiteDirectConnectEnabledModel        `tfsdk:"direct_connect_enabled"`
	DisableInternetVIP          *AWSVPCSiteEmptyModel                       `tfsdk:"disable_internet_vip"`
	EgressGatewayDefault        *AWSVPCSiteEmptyModel                       `tfsdk:"egress_gateway_default"`
	EgressNATGw                 *AWSVPCSiteEgressNATGwModel                 `tfsdk:"egress_nat_gw"`
	EgressVirtualPrivateGateway *AWSVPCSiteEgressVirtualPrivateGatewayModel `tfsdk:"egress_virtual_private_gateway"`
	EnableInternetVIP           *AWSVPCSiteEmptyModel                       `tfsdk:"enable_internet_vip"`
	F5OrchestratedRouting       *AWSVPCSiteEmptyModel                       `tfsdk:"f5_orchestrated_routing"`
	F5xcSecurityGroup           *AWSVPCSiteEmptyModel                       `tfsdk:"f5xc_security_group"`
	IngressEgressGw             *AWSVPCSiteIngressEgressGwModel             `tfsdk:"ingress_egress_gw"`
	IngressGw                   *AWSVPCSiteIngressGwModel                   `tfsdk:"ingress_gw"`
	KubernetesUpgradeDrain      *AWSVPCSiteKubernetesUpgradeDrainModel      `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver                 *AWSVPCSiteLogReceiverModel                 `tfsdk:"log_receiver"`
	LogsStreamingDisabled       *AWSVPCSiteEmptyModel                       `tfsdk:"logs_streaming_disabled"`
	ManualRouting               *AWSVPCSiteEmptyModel                       `tfsdk:"manual_routing"`
	NoWorkerNodes               *AWSVPCSiteEmptyModel                       `tfsdk:"no_worker_nodes"`
	OfflineSurvivabilityMode    *AWSVPCSiteOfflineSurvivabilityModeModel    `tfsdk:"offline_survivability_mode"`
	OS                          *AWSVPCSiteOSModel                          `tfsdk:"os"`
	PrivateConnectivity         *AWSVPCSitePrivateConnectivityModel         `tfsdk:"private_connectivity"`
	Sw                          *AWSVPCSiteSwModel                          `tfsdk:"sw"`
	Tags                        *AWSVPCSiteEmptyModel                       `tfsdk:"tags"`
	VoltstackCluster            *AWSVPCSiteVoltstackClusterModel            `tfsdk:"voltstack_cluster"`
	VPC                         *AWSVPCSiteVPCModel                         `tfsdk:"vpc"`
}

func (r *AWSVPCSiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aws_vpc_site"
}

func (r *AWSVPCSiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             aws_vpc_siteSchemaVersion,
		MarkdownDescription: "Manages a AWS VPC Site resource in F5 Distributed Cloud for deploying F5 sites within AWS VPC environments.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the AWS VPC Site. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the AWS VPC Site will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "Site's geographical address that can be used to determine its latitude and longitude.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"aws_region": schema.StringAttribute{
				MarkdownDescription: "AWS Region. Name for AWS Region.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"disk_size": schema.Int64Attribute{
				MarkdownDescription: "Disk size to be used for this instance in GiB. 80 is 80 GiB.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"instance_type": schema.StringAttribute{
				MarkdownDescription: "Select Instance size based on performance needed .",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"nodes_per_az": schema.Int64Attribute{
				MarkdownDescription: "Desired Worker Nodes Per AZ. Max limit is up to 21.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"ssh_key": schema.StringAttribute{
				MarkdownDescription: "Public SSH key for accessing the site.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"total_nodes": schema.Int64Attribute{
				MarkdownDescription: "Total number of worker nodes to be deployed across all AZ's used in the Site.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"admin_password": schema.SingleNestedBlock{
				MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blindfold_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
						Attributes: map[string]schema.Attribute{
							"decryption_provider": schema.StringAttribute{
								MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
								Optional:            true,
							},
							"location": schema.StringAttribute{
								MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
								Optional:            true,
							},
							"store_provider": schema.StringAttribute{
								MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
								Optional:            true,
							},
						},
					},
					"clear_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
						Attributes: map[string]schema.Attribute{
							"provider_ref": schema.StringAttribute{
								MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
								Optional:            true,
							},
							"url": schema.StringAttribute{
								MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
								Optional:            true,
							},
						},
					},
				},
			},
			"aws_cred": schema.SingleNestedBlock{
				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services; Default: default_blocked_services] Enable this option",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable node local services on this site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services. Blocking or denial configuration",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "[Enum: VIRTUAL_NETWORK_SITE_LOCAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE|VIRTUAL_NETWORK_PER_SITE|VIRTUAL_NETWORK_PUBLIC|VIRTUAL_NETWORK_GLOBAL|VIRTUAL_NETWORK_SITE_SERVICE|VIRTUAL_NETWORK_VER_INTERNAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE|VIRTUAL_NETWORK_IP_AUTO|VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK|VIRTUAL_NETWORK_SRV6_NETWORK|VIRTUAL_NETWORK_IP_FABRIC|VIRTUAL_NETWORK_SEGMENT] Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to.. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
				},
			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Coordinates of the site which provides the site physical location.",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location.",
						Optional:            true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. Longitude of site location.",
						Optional:            true,
					},
				},
			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS is the configured for specify CE site.",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "Optional DNS server IP to be used for name resolution in inside network.",
						Optional:            true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "Optional DNS server IP to be used for name resolution in outside network.",
						Optional:            true,
					},
				},
			},
			"custom_security_group": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: custom_security_group, f5xc_security_group] Enter pre created security groups for slo(Site Local Outside) and sli(Site Local Inside) interface. Supported only for sites deployed on existing VPC.",
				Attributes: map[string]schema.Attribute{
					"inside_security_group_id": schema.StringAttribute{
						MarkdownDescription: "Security Group ID to be attached to SLI(Site Local Inside) Interface.",
						Optional:            true,
					},
					"outside_security_group_id": schema.StringAttribute{
						MarkdownDescription: "Security Group ID to be attached to SLO(Site Local Outside) Interface.",
						Optional:            true,
					},
				},
			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"direct_connect_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: direct_connect_disabled, direct_connect_enabled, private_connectivity] Enable this option",
			},
			"direct_connect_enabled": schema.SingleNestedBlock{
				MarkdownDescription: "Direct Connect Configuration. Direct Connect Configuration.",
				Attributes: map[string]schema.Attribute{
					"custom_asn": schema.Int64Attribute{
						MarkdownDescription: "Custom Autonomous System Number.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auto_asn": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"hosted_vifs": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Direct Connect Hosted VIF Configuration.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"site_registration_over_direct_connect": schema.SingleNestedBlock{
								MarkdownDescription: "CloudLink ADN Network Config.",
								Attributes: map[string]schema.Attribute{
									"cloudlink_network_name": schema.StringAttribute{
										MarkdownDescription: "Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
										Optional:            true,
									},
								},
							},
							"site_registration_over_internet": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"vif_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Hosted VIF Config. List of Hosted VIF Config.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"other_region": schema.StringAttribute{
											MarkdownDescription: "Other Region.",
											Optional:            true,
										},
										"vif_id": schema.StringAttribute{
											MarkdownDescription: "AWS Direct Connect VIF ID that needs to be connected to the site .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"same_as_site_region": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"standard_vifs": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"disable_internet_vip": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_internet_vip, enable_internet_vip; Default: disable_internet_vip] Enable this option",
			},
			"egress_gateway_default": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: egress_gateway_default, egress_nat_gw, egress_virtual_private_gateway; Default: egress_gateway_default] Enable this option",
			},
			"egress_nat_gw": schema.SingleNestedBlock{
				MarkdownDescription: "With this option, egress site traffic will be routed through an Network Address Translation(NAT) Gateway.",
				Attributes: map[string]schema.Attribute{
					"nat_gw_id": schema.StringAttribute{
						MarkdownDescription: "Existing NAT Gateway ID.",
						Optional:            true,
					},
				},
			},
			"egress_virtual_private_gateway": schema.SingleNestedBlock{
				MarkdownDescription: "With this option, egress site traffic will be routed through an Virtual Private Gateway.",
				Attributes: map[string]schema.Attribute{
					"vgw_id": schema.StringAttribute{
						MarkdownDescription: "Existing Virtual Private Gateway ID.",
						Optional:            true,
					},
				},
			},
			"enable_internet_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"f5_orchestrated_routing": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: f5_orchestrated_routing, manual_routing] Enable this option",
			},
			"f5xc_security_group": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"ingress_egress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ingress_egress_gw, ingress_gw, voltstack_cluster] AWS Ingress/Egress Gateway. Two interface AWS ingress/egress site.",
				Attributes: map[string]schema.Attribute{
					"aws_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Name for AWS certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP LB configured on the F5XC Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port.",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges .",
										Optional:            true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"allowed_vip_port_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP LB configured on the F5XC Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port.",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges .",
										Optional:            true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS availability zone, must be consistent with the selected AWS region.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
								"outside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
								"reserved_inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"workload_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"ingress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Ingress Gateway. Single interface AWS ingress site.",
				Attributes: map[string]schema.Attribute{
					"aws_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Name for AWS certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP LB configured on the F5XC Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port.",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges .",
										Optional:            true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS availability zone, must be consistent with the selected AWS region.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Specify how worker nodes within a site will be upgraded.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional:            true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is..",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"manual_routing": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_worker_nodes": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_worker_nodes, nodes_per_az, total_nodes; Default: no_worker_nodes] Enable this option",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7..",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Specify a OS version to be used e.g. 9.2024.6.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"private_connectivity": schema.SingleNestedBlock{
				MarkdownDescription: "Private Connect Configuration. Private Connect Configuration.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"cloud_link": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"inside": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "Specify a F5XC Software Version to be used e.g. Crt-20210329-1002.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"tags": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
			},
			"voltstack_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "App Stack cluster of single interface AWS nodes.",
				Attributes: map[string]schema.Attribute{
					"aws_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Name for AWS certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP LB configured on the F5XC Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port.",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges .",
										Optional:            true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS availability zone, must be consistent with the selected AWS region.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Add additional custom storage classes in Kubernetes for this site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Make this storage class default storage class for the K8s cluster.",
											Optional:            true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Name of the storage class as it will appear in K8s.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
			"vpc": schema.SingleNestedBlock{
				MarkdownDescription: "Defines choice about AWS VPC for a view.",
				Attributes: map[string]schema.Attribute{
					"vpc_id": schema.StringAttribute{
						MarkdownDescription: "Information about existing VPC ID.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"new_vpc": schema.SingleNestedBlock{
						MarkdownDescription: "AWS VPC Parameters. Parameters to create new AWS VPC.",
						Attributes: map[string]schema.Attribute{
							"name_tag": schema.StringAttribute{
								MarkdownDescription: "Specify the VPC Name.",
								Optional:            true,
							},
							"primary_ipv4": schema.StringAttribute{
								MarkdownDescription: "IPv4 CIDR block for this VPC. It has to be private address space. The Primary IPv4 block cannot be modified. All subnets prefixes in this VPC must be part of this CIDR block.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
		},
	}
}

func (r *AWSVPCSiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AWSVPCSiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AWSVPCSiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the aws_vpc_site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AWSVPCSiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AWSVPCSiteResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AWSVPCSiteResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AWSVPCSiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating aws_vpc_site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.AWSVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		createReq.Spec["admin_password"] = admin_passwordMap
	}
	if data.AWSCred != nil {
		aws_credMap := make(map[string]interface{})
		if !data.AWSCred.Name.IsNull() && !data.AWSCred.Name.IsUnknown() {
			aws_credMap["name"] = data.AWSCred.Name.ValueString()
		}
		if !data.AWSCred.Namespace.IsNull() && !data.AWSCred.Namespace.IsUnknown() {
			aws_credMap["namespace"] = data.AWSCred.Namespace.ValueString()
		}
		if !data.AWSCred.Tenant.IsNull() && !data.AWSCred.Tenant.IsUnknown() {
			aws_credMap["tenant"] = data.AWSCred.Tenant.ValueString()
		}
		createReq.Spec["aws_cred"] = aws_credMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		createReq.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		createReq.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		createReq.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		createReq.Spec["custom_dns"] = custom_dnsMap
	}
	if data.CustomSecurityGroup != nil {
		custom_security_groupMap := make(map[string]interface{})
		if !data.CustomSecurityGroup.InsideSecurityGroupID.IsNull() && !data.CustomSecurityGroup.InsideSecurityGroupID.IsUnknown() {
			custom_security_groupMap["inside_security_group_id"] = data.CustomSecurityGroup.InsideSecurityGroupID.ValueString()
		}
		if !data.CustomSecurityGroup.OutsideSecurityGroupID.IsNull() && !data.CustomSecurityGroup.OutsideSecurityGroupID.IsUnknown() {
			custom_security_groupMap["outside_security_group_id"] = data.CustomSecurityGroup.OutsideSecurityGroupID.ValueString()
		}
		createReq.Spec["custom_security_group"] = custom_security_groupMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		createReq.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.DirectConnectDisabled != nil {
		direct_connect_disabledMap := make(map[string]interface{})
		createReq.Spec["direct_connect_disabled"] = direct_connect_disabledMap
	}
	if data.DirectConnectEnabled != nil {
		direct_connect_enabledMap := make(map[string]interface{})
		if data.DirectConnectEnabled.AutoAsn != nil {
			direct_connect_enabledMap["auto_asn"] = map[string]interface{}{}
		}
		if !data.DirectConnectEnabled.CustomAsn.IsNull() && !data.DirectConnectEnabled.CustomAsn.IsUnknown() {
			direct_connect_enabledMap["custom_asn"] = data.DirectConnectEnabled.CustomAsn.ValueInt64()
		}
		if data.DirectConnectEnabled.HostedVifs != nil {
			hosted_vifsNestedMap := make(map[string]interface{})
			direct_connect_enabledMap["hosted_vifs"] = hosted_vifsNestedMap
		}
		if data.DirectConnectEnabled.StandardVifs != nil {
			direct_connect_enabledMap["standard_vifs"] = map[string]interface{}{}
		}
		createReq.Spec["direct_connect_enabled"] = direct_connect_enabledMap
	}
	if data.DisableInternetVIP != nil {
		disable_internet_vipMap := make(map[string]interface{})
		createReq.Spec["disable_internet_vip"] = disable_internet_vipMap
	}
	if data.EgressGatewayDefault != nil {
		egress_gateway_defaultMap := make(map[string]interface{})
		createReq.Spec["egress_gateway_default"] = egress_gateway_defaultMap
	}
	if data.EgressNATGw != nil {
		egress_nat_gwMap := make(map[string]interface{})
		if !data.EgressNATGw.NATGwID.IsNull() && !data.EgressNATGw.NATGwID.IsUnknown() {
			egress_nat_gwMap["nat_gw_id"] = data.EgressNATGw.NATGwID.ValueString()
		}
		createReq.Spec["egress_nat_gw"] = egress_nat_gwMap
	}
	if data.EgressVirtualPrivateGateway != nil {
		egress_virtual_private_gatewayMap := make(map[string]interface{})
		if !data.EgressVirtualPrivateGateway.VgwID.IsNull() && !data.EgressVirtualPrivateGateway.VgwID.IsUnknown() {
			egress_virtual_private_gatewayMap["vgw_id"] = data.EgressVirtualPrivateGateway.VgwID.ValueString()
		}
		createReq.Spec["egress_virtual_private_gateway"] = egress_virtual_private_gatewayMap
	}
	if data.EnableInternetVIP != nil {
		enable_internet_vipMap := make(map[string]interface{})
		createReq.Spec["enable_internet_vip"] = enable_internet_vipMap
	}
	if data.F5OrchestratedRouting != nil {
		f5_orchestrated_routingMap := make(map[string]interface{})
		createReq.Spec["f5_orchestrated_routing"] = f5_orchestrated_routingMap
	}
	if data.F5xcSecurityGroup != nil {
		f5xc_security_groupMap := make(map[string]interface{})
		createReq.Spec["f5xc_security_group"] = f5xc_security_groupMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.IngressEgressGw.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if data.IngressEgressGw.AllowedVIPPortSLI != nil {
			allowed_vip_port_sliNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["allowed_vip_port_sli"] = allowed_vip_port_sliNestedMap
		}
		if !data.IngressEgressGw.AWSCertifiedHw.IsNull() && !data.IngressEgressGw.AWSCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["aws_certified_hw"] = data.IngressEgressGw.AWSCertifiedHw.ValueString()
		}
		if len(data.IngressEgressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressEgressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					if !listItem.InsideSubnet.ExistingSubnetID.IsNull() && !listItem.InsideSubnet.ExistingSubnetID.IsUnknown() {
						inside_subnetDeepMap["existing_subnet_id"] = listItem.InsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					if !listItem.OutsideSubnet.ExistingSubnetID.IsNull() && !listItem.OutsideSubnet.ExistingSubnetID.IsUnknown() {
						outside_subnetDeepMap["existing_subnet_id"] = listItem.OutsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				if listItem.ReservedInsideSubnet != nil {
					listItemMap["reserved_inside_subnet"] = map[string]interface{}{}
				}
				if listItem.WorkloadSubnet != nil {
					workload_subnetDeepMap := make(map[string]interface{})
					if !listItem.WorkloadSubnet.ExistingSubnetID.IsNull() && !listItem.WorkloadSubnet.ExistingSubnetID.IsUnknown() {
						workload_subnetDeepMap["existing_subnet_id"] = listItem.WorkloadSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["workload_subnet"] = workload_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_egress_gwMap["az_nodes"] = az_nodesList
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if data.IngressGw.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			ingress_gwMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if !data.IngressGw.AWSCertifiedHw.IsNull() && !data.IngressGw.AWSCertifiedHw.IsUnknown() {
			ingress_gwMap["aws_certified_hw"] = data.IngressGw.AWSCertifiedHw.ValueString()
		}
		if len(data.IngressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					if !listItem.LocalSubnet.ExistingSubnetID.IsNull() && !listItem.LocalSubnet.ExistingSubnetID.IsUnknown() {
						local_subnetDeepMap["existing_subnet_id"] = listItem.LocalSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_gwMap["az_nodes"] = az_nodesList
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		createReq.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		createReq.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		createReq.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		createReq.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.ManualRouting != nil {
		manual_routingMap := make(map[string]interface{})
		createReq.Spec["manual_routing"] = manual_routingMap
	}
	if data.NoWorkerNodes != nil {
		no_worker_nodesMap := make(map[string]interface{})
		createReq.Spec["no_worker_nodes"] = no_worker_nodesMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		createReq.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		createReq.Spec["os"] = osMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		createReq.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		createReq.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		createReq.Spec["tags"] = tagsMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.VoltstackCluster.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			voltstack_clusterMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if !data.VoltstackCluster.AWSCertifiedHw.IsNull() && !data.VoltstackCluster.AWSCertifiedHw.IsUnknown() {
			voltstack_clusterMap["aws_certified_hw"] = data.VoltstackCluster.AWSCertifiedHw.ValueString()
		}
		if len(data.VoltstackCluster.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.VoltstackCluster.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					if !listItem.LocalSubnet.ExistingSubnetID.IsNull() && !listItem.LocalSubnet.ExistingSubnetID.IsUnknown() {
						local_subnetDeepMap["existing_subnet_id"] = listItem.LocalSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			voltstack_clusterMap["az_nodes"] = az_nodesList
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		createReq.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if data.VPC != nil {
		vpcMap := make(map[string]interface{})
		if data.VPC.NewVPC != nil {
			new_vpcNestedMap := make(map[string]interface{})
			if !data.VPC.NewVPC.NameTag.IsNull() && !data.VPC.NewVPC.NameTag.IsUnknown() {
				new_vpcNestedMap["name_tag"] = data.VPC.NewVPC.NameTag.ValueString()
			}
			if !data.VPC.NewVPC.PrimaryIpv4.IsNull() && !data.VPC.NewVPC.PrimaryIpv4.IsUnknown() {
				new_vpcNestedMap["primary_ipv4"] = data.VPC.NewVPC.PrimaryIpv4.ValueString()
			}
			vpcMap["new_vpc"] = new_vpcNestedMap
		}
		if !data.VPC.VPCID.IsNull() && !data.VPC.VPCID.IsUnknown() {
			vpcMap["vpc_id"] = data.VPC.VPCID.ValueString()
		}
		createReq.Spec["vpc"] = vpcMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		createReq.Spec["address"] = data.Address.ValueString()
	}
	if !data.AWSRegion.IsNull() && !data.AWSRegion.IsUnknown() {
		createReq.Spec["aws_region"] = data.AWSRegion.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		createReq.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.InstanceType.IsNull() && !data.InstanceType.IsUnknown() {
		createReq.Spec["instance_type"] = data.InstanceType.ValueString()
	}
	if !data.NodesPerAz.IsNull() && !data.NodesPerAz.IsUnknown() {
		createReq.Spec["nodes_per_az"] = data.NodesPerAz.ValueInt64()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		createReq.Spec["ssh_key"] = data.SSHKey.ValueString()
	}
	if !data.TotalNodes.IsNull() && !data.TotalNodes.IsUnknown() {
		createReq.Spec["total_nodes"] = data.TotalNodes.ValueInt64()
	}

	apiResource, err := r.client.CreateAWSVPCSite(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AWSVPCSite: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AWSVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["aws_cred"].(map[string]interface{}); ok && (isImport || data.AWSCred != nil) {
		data.AWSCred = &AWSVPCSiteAWSCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AWSVPCSiteBlockedServicesModel{
			BlockedSevice: func() []AWSVPCSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AWSVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AWSVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_security_group"].(map[string]interface{}); ok && (isImport || data.CustomSecurityGroup != nil) {
		data.CustomSecurityGroup = &AWSVPCSiteCustomSecurityGroupModel{
			InsideSecurityGroupID: func() types.String {
				if v, ok := blockData["inside_security_group_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideSecurityGroupID: func() types.String {
				if v, ok := blockData["outside_security_group_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["direct_connect_disabled"].(map[string]interface{}); ok && isImport && data.DirectConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DirectConnectDisabled = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["direct_connect_enabled"].(map[string]interface{}); ok && (isImport || data.DirectConnectEnabled != nil) {
		data.DirectConnectEnabled = &AWSVPCSiteDirectConnectEnabledModel{
			AutoAsn: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.AutoAsn
				}
				// Import case: read from API
				if _, ok := blockData["auto_asn"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			CustomAsn: func() types.Int64 {
				if v, ok := blockData["custom_asn"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			HostedVifs: func() *AWSVPCSiteDirectConnectEnabledHostedVifsModel {
				if !isImport && data.DirectConnectEnabled != nil && data.DirectConnectEnabled.HostedVifs != nil {
					// Normal Read: preserve existing state value
					return data.DirectConnectEnabled.HostedVifs
				}
				// Import case: read from API
				if _, ok := blockData["hosted_vifs"].(map[string]interface{}); ok {
					return &AWSVPCSiteDirectConnectEnabledHostedVifsModel{}
				}
				return nil
			}(),
			StandardVifs: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.StandardVifs
				}
				// Import case: read from API
				if _, ok := blockData["standard_vifs"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["disable_internet_vip"].(map[string]interface{}); ok && isImport && data.DisableInternetVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableInternetVIP = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["egress_gateway_default"].(map[string]interface{}); ok && isImport && data.EgressGatewayDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EgressGatewayDefault = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["egress_nat_gw"].(map[string]interface{}); ok && (isImport || data.EgressNATGw != nil) {
		data.EgressNATGw = &AWSVPCSiteEgressNATGwModel{
			NATGwID: func() types.String {
				if v, ok := blockData["nat_gw_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["egress_virtual_private_gateway"].(map[string]interface{}); ok && (isImport || data.EgressVirtualPrivateGateway != nil) {
		data.EgressVirtualPrivateGateway = &AWSVPCSiteEgressVirtualPrivateGatewayModel{
			VgwID: func() types.String {
				if v, ok := blockData["vgw_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_internet_vip"].(map[string]interface{}); ok && isImport && data.EnableInternetVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableInternetVIP = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5_orchestrated_routing"].(map[string]interface{}); ok && isImport && data.F5OrchestratedRouting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5OrchestratedRouting = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5xc_security_group"].(map[string]interface{}); ok && isImport && data.F5xcSecurityGroup == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5xcSecurityGroup = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AWSVPCSiteIngressEgressGwModel{
			ActiveEnhancedFirewallPolicies: func() *AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AllowedVIPPort: func() *AWSVPCSiteIngressEgressGwAllowedVIPPortModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwAllowedVIPPortModel{}
				}
				return nil
			}(),
			AllowedVIPPortSLI: func() *AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AllowedVIPPortSLI != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AllowedVIPPortSLI
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port_sli"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteIngressEgressGwAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel {
									if deepMap, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								OutsideSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if deepMap, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ReservedInsideSubnet: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["reserved_inside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WorkloadSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel {
									if deepMap, ok := itemMap["workload_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DcClusterGroupInsideVn: func() *AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AWSVPCSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AWSVPCSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AWSVPCSiteIngressGwModel{
			AllowedVIPPort: func() *AWSVPCSiteIngressGwAllowedVIPPortModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressGwAllowedVIPPortModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteIngressGwAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AWSVPCSiteIngressGwAzNodesLocalSubnetModel {
									if deepMap, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressGwAzNodesLocalSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AWSVPCSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AWSVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AWSVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["manual_routing"].(map[string]interface{}); ok && isImport && data.ManualRouting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ManualRouting = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AWSVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AWSVPCSiteOSModel{
			DefaultOSVersion: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &AWSVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AWSVPCSiteSwModel{
			DefaultSwVersion: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AWSVPCSiteVoltstackClusterModel{
			ActiveEnhancedFirewallPolicies: func() *AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AllowedVIPPort: func() *AWSVPCSiteVoltstackClusterAllowedVIPPortModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterAllowedVIPPortModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteVoltstackClusterAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel {
									if deepMap, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DcClusterGroup: func() *AWSVPCSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AWSVPCSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AWSVPCSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AWSVPCSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["vpc"].(map[string]interface{}); ok && (isImport || data.VPC != nil) {
		data.VPC = &AWSVPCSiteVPCModel{
			NewVPC: func() *AWSVPCSiteVPCNewVPCModel {
				if !isImport && data.VPC != nil && data.VPC.NewVPC != nil {
					// Normal Read: preserve existing state value
					return data.VPC.NewVPC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["new_vpc"].(map[string]interface{}); ok {
					return &AWSVPCSiteVPCNewVPCModel{
						NameTag: func() types.String {
							if v, ok := nestedBlockData["name_tag"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						PrimaryIpv4: func() types.String {
							if v, ok := nestedBlockData["primary_ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			VPCID: func() types.String {
				if v, ok := blockData["vpc_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["aws_region"].(string); ok && v != "" {
		data.AWSRegion = types.StringValue(v)
	} else {
		data.AWSRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created AWSVPCSite resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AWSVPCSiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAWSVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AWSVPCSite not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AWSVPCSite: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The aws_vpc_site may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AWSVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["aws_cred"].(map[string]interface{}); ok && (isImport || data.AWSCred != nil) {
		data.AWSCred = &AWSVPCSiteAWSCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AWSVPCSiteBlockedServicesModel{
			BlockedSevice: func() []AWSVPCSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AWSVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AWSVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_security_group"].(map[string]interface{}); ok && (isImport || data.CustomSecurityGroup != nil) {
		data.CustomSecurityGroup = &AWSVPCSiteCustomSecurityGroupModel{
			InsideSecurityGroupID: func() types.String {
				if v, ok := blockData["inside_security_group_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideSecurityGroupID: func() types.String {
				if v, ok := blockData["outside_security_group_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["direct_connect_disabled"].(map[string]interface{}); ok && isImport && data.DirectConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DirectConnectDisabled = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["direct_connect_enabled"].(map[string]interface{}); ok && (isImport || data.DirectConnectEnabled != nil) {
		data.DirectConnectEnabled = &AWSVPCSiteDirectConnectEnabledModel{
			AutoAsn: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.AutoAsn
				}
				// Import case: read from API
				if _, ok := blockData["auto_asn"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			CustomAsn: func() types.Int64 {
				if v, ok := blockData["custom_asn"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			HostedVifs: func() *AWSVPCSiteDirectConnectEnabledHostedVifsModel {
				if !isImport && data.DirectConnectEnabled != nil && data.DirectConnectEnabled.HostedVifs != nil {
					// Normal Read: preserve existing state value
					return data.DirectConnectEnabled.HostedVifs
				}
				// Import case: read from API
				if _, ok := blockData["hosted_vifs"].(map[string]interface{}); ok {
					return &AWSVPCSiteDirectConnectEnabledHostedVifsModel{}
				}
				return nil
			}(),
			StandardVifs: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.StandardVifs
				}
				// Import case: read from API
				if _, ok := blockData["standard_vifs"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["disable_internet_vip"].(map[string]interface{}); ok && isImport && data.DisableInternetVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableInternetVIP = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["egress_gateway_default"].(map[string]interface{}); ok && isImport && data.EgressGatewayDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EgressGatewayDefault = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["egress_nat_gw"].(map[string]interface{}); ok && (isImport || data.EgressNATGw != nil) {
		data.EgressNATGw = &AWSVPCSiteEgressNATGwModel{
			NATGwID: func() types.String {
				if v, ok := blockData["nat_gw_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["egress_virtual_private_gateway"].(map[string]interface{}); ok && (isImport || data.EgressVirtualPrivateGateway != nil) {
		data.EgressVirtualPrivateGateway = &AWSVPCSiteEgressVirtualPrivateGatewayModel{
			VgwID: func() types.String {
				if v, ok := blockData["vgw_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_internet_vip"].(map[string]interface{}); ok && isImport && data.EnableInternetVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableInternetVIP = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5_orchestrated_routing"].(map[string]interface{}); ok && isImport && data.F5OrchestratedRouting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5OrchestratedRouting = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5xc_security_group"].(map[string]interface{}); ok && isImport && data.F5xcSecurityGroup == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5xcSecurityGroup = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AWSVPCSiteIngressEgressGwModel{
			ActiveEnhancedFirewallPolicies: func() *AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AllowedVIPPort: func() *AWSVPCSiteIngressEgressGwAllowedVIPPortModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwAllowedVIPPortModel{}
				}
				return nil
			}(),
			AllowedVIPPortSLI: func() *AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AllowedVIPPortSLI != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AllowedVIPPortSLI
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port_sli"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteIngressEgressGwAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel {
									if deepMap, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								OutsideSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if deepMap, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ReservedInsideSubnet: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["reserved_inside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WorkloadSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel {
									if deepMap, ok := itemMap["workload_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DcClusterGroupInsideVn: func() *AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AWSVPCSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AWSVPCSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AWSVPCSiteIngressGwModel{
			AllowedVIPPort: func() *AWSVPCSiteIngressGwAllowedVIPPortModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressGwAllowedVIPPortModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteIngressGwAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AWSVPCSiteIngressGwAzNodesLocalSubnetModel {
									if deepMap, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressGwAzNodesLocalSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AWSVPCSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AWSVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AWSVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["manual_routing"].(map[string]interface{}); ok && isImport && data.ManualRouting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ManualRouting = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AWSVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AWSVPCSiteOSModel{
			DefaultOSVersion: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &AWSVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AWSVPCSiteSwModel{
			DefaultSwVersion: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AWSVPCSiteVoltstackClusterModel{
			ActiveEnhancedFirewallPolicies: func() *AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AllowedVIPPort: func() *AWSVPCSiteVoltstackClusterAllowedVIPPortModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterAllowedVIPPortModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteVoltstackClusterAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel {
									if deepMap, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DcClusterGroup: func() *AWSVPCSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AWSVPCSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AWSVPCSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AWSVPCSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["vpc"].(map[string]interface{}); ok && (isImport || data.VPC != nil) {
		data.VPC = &AWSVPCSiteVPCModel{
			NewVPC: func() *AWSVPCSiteVPCNewVPCModel {
				if !isImport && data.VPC != nil && data.VPC.NewVPC != nil {
					// Normal Read: preserve existing state value
					return data.VPC.NewVPC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["new_vpc"].(map[string]interface{}); ok {
					return &AWSVPCSiteVPCNewVPCModel{
						NameTag: func() types.String {
							if v, ok := nestedBlockData["name_tag"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						PrimaryIpv4: func() types.String {
							if v, ok := nestedBlockData["primary_ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			VPCID: func() types.String {
				if v, ok := blockData["vpc_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["aws_region"].(string); ok && v != "" {
		data.AWSRegion = types.StringValue(v)
	} else {
		data.AWSRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AWSVPCSiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.AWSVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		apiResource.Spec["admin_password"] = admin_passwordMap
	}
	if data.AWSCred != nil {
		aws_credMap := make(map[string]interface{})
		if !data.AWSCred.Name.IsNull() && !data.AWSCred.Name.IsUnknown() {
			aws_credMap["name"] = data.AWSCred.Name.ValueString()
		}
		if !data.AWSCred.Namespace.IsNull() && !data.AWSCred.Namespace.IsUnknown() {
			aws_credMap["namespace"] = data.AWSCred.Namespace.ValueString()
		}
		if !data.AWSCred.Tenant.IsNull() && !data.AWSCred.Tenant.IsUnknown() {
			aws_credMap["tenant"] = data.AWSCred.Tenant.ValueString()
		}
		apiResource.Spec["aws_cred"] = aws_credMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.CustomSecurityGroup != nil {
		custom_security_groupMap := make(map[string]interface{})
		if !data.CustomSecurityGroup.InsideSecurityGroupID.IsNull() && !data.CustomSecurityGroup.InsideSecurityGroupID.IsUnknown() {
			custom_security_groupMap["inside_security_group_id"] = data.CustomSecurityGroup.InsideSecurityGroupID.ValueString()
		}
		if !data.CustomSecurityGroup.OutsideSecurityGroupID.IsNull() && !data.CustomSecurityGroup.OutsideSecurityGroupID.IsUnknown() {
			custom_security_groupMap["outside_security_group_id"] = data.CustomSecurityGroup.OutsideSecurityGroupID.ValueString()
		}
		apiResource.Spec["custom_security_group"] = custom_security_groupMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.DirectConnectDisabled != nil {
		direct_connect_disabledMap := make(map[string]interface{})
		apiResource.Spec["direct_connect_disabled"] = direct_connect_disabledMap
	}
	if data.DirectConnectEnabled != nil {
		direct_connect_enabledMap := make(map[string]interface{})
		if data.DirectConnectEnabled.AutoAsn != nil {
			direct_connect_enabledMap["auto_asn"] = map[string]interface{}{}
		}
		if !data.DirectConnectEnabled.CustomAsn.IsNull() && !data.DirectConnectEnabled.CustomAsn.IsUnknown() {
			direct_connect_enabledMap["custom_asn"] = data.DirectConnectEnabled.CustomAsn.ValueInt64()
		}
		if data.DirectConnectEnabled.HostedVifs != nil {
			hosted_vifsNestedMap := make(map[string]interface{})
			direct_connect_enabledMap["hosted_vifs"] = hosted_vifsNestedMap
		}
		if data.DirectConnectEnabled.StandardVifs != nil {
			direct_connect_enabledMap["standard_vifs"] = map[string]interface{}{}
		}
		apiResource.Spec["direct_connect_enabled"] = direct_connect_enabledMap
	}
	if data.DisableInternetVIP != nil {
		disable_internet_vipMap := make(map[string]interface{})
		apiResource.Spec["disable_internet_vip"] = disable_internet_vipMap
	}
	if data.EgressGatewayDefault != nil {
		egress_gateway_defaultMap := make(map[string]interface{})
		apiResource.Spec["egress_gateway_default"] = egress_gateway_defaultMap
	}
	if data.EgressNATGw != nil {
		egress_nat_gwMap := make(map[string]interface{})
		if !data.EgressNATGw.NATGwID.IsNull() && !data.EgressNATGw.NATGwID.IsUnknown() {
			egress_nat_gwMap["nat_gw_id"] = data.EgressNATGw.NATGwID.ValueString()
		}
		apiResource.Spec["egress_nat_gw"] = egress_nat_gwMap
	}
	if data.EgressVirtualPrivateGateway != nil {
		egress_virtual_private_gatewayMap := make(map[string]interface{})
		if !data.EgressVirtualPrivateGateway.VgwID.IsNull() && !data.EgressVirtualPrivateGateway.VgwID.IsUnknown() {
			egress_virtual_private_gatewayMap["vgw_id"] = data.EgressVirtualPrivateGateway.VgwID.ValueString()
		}
		apiResource.Spec["egress_virtual_private_gateway"] = egress_virtual_private_gatewayMap
	}
	if data.EnableInternetVIP != nil {
		enable_internet_vipMap := make(map[string]interface{})
		apiResource.Spec["enable_internet_vip"] = enable_internet_vipMap
	}
	if data.F5OrchestratedRouting != nil {
		f5_orchestrated_routingMap := make(map[string]interface{})
		apiResource.Spec["f5_orchestrated_routing"] = f5_orchestrated_routingMap
	}
	if data.F5xcSecurityGroup != nil {
		f5xc_security_groupMap := make(map[string]interface{})
		apiResource.Spec["f5xc_security_group"] = f5xc_security_groupMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.IngressEgressGw.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if data.IngressEgressGw.AllowedVIPPortSLI != nil {
			allowed_vip_port_sliNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["allowed_vip_port_sli"] = allowed_vip_port_sliNestedMap
		}
		if !data.IngressEgressGw.AWSCertifiedHw.IsNull() && !data.IngressEgressGw.AWSCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["aws_certified_hw"] = data.IngressEgressGw.AWSCertifiedHw.ValueString()
		}
		if len(data.IngressEgressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressEgressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					if !listItem.InsideSubnet.ExistingSubnetID.IsNull() && !listItem.InsideSubnet.ExistingSubnetID.IsUnknown() {
						inside_subnetDeepMap["existing_subnet_id"] = listItem.InsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					if !listItem.OutsideSubnet.ExistingSubnetID.IsNull() && !listItem.OutsideSubnet.ExistingSubnetID.IsUnknown() {
						outside_subnetDeepMap["existing_subnet_id"] = listItem.OutsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				if listItem.ReservedInsideSubnet != nil {
					listItemMap["reserved_inside_subnet"] = map[string]interface{}{}
				}
				if listItem.WorkloadSubnet != nil {
					workload_subnetDeepMap := make(map[string]interface{})
					if !listItem.WorkloadSubnet.ExistingSubnetID.IsNull() && !listItem.WorkloadSubnet.ExistingSubnetID.IsUnknown() {
						workload_subnetDeepMap["existing_subnet_id"] = listItem.WorkloadSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["workload_subnet"] = workload_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_egress_gwMap["az_nodes"] = az_nodesList
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if data.IngressGw.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			ingress_gwMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if !data.IngressGw.AWSCertifiedHw.IsNull() && !data.IngressGw.AWSCertifiedHw.IsUnknown() {
			ingress_gwMap["aws_certified_hw"] = data.IngressGw.AWSCertifiedHw.ValueString()
		}
		if len(data.IngressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					if !listItem.LocalSubnet.ExistingSubnetID.IsNull() && !listItem.LocalSubnet.ExistingSubnetID.IsUnknown() {
						local_subnetDeepMap["existing_subnet_id"] = listItem.LocalSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_gwMap["az_nodes"] = az_nodesList
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.ManualRouting != nil {
		manual_routingMap := make(map[string]interface{})
		apiResource.Spec["manual_routing"] = manual_routingMap
	}
	if data.NoWorkerNodes != nil {
		no_worker_nodesMap := make(map[string]interface{})
		apiResource.Spec["no_worker_nodes"] = no_worker_nodesMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		apiResource.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		apiResource.Spec["tags"] = tagsMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.VoltstackCluster.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			voltstack_clusterMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if !data.VoltstackCluster.AWSCertifiedHw.IsNull() && !data.VoltstackCluster.AWSCertifiedHw.IsUnknown() {
			voltstack_clusterMap["aws_certified_hw"] = data.VoltstackCluster.AWSCertifiedHw.ValueString()
		}
		if len(data.VoltstackCluster.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.VoltstackCluster.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					if !listItem.LocalSubnet.ExistingSubnetID.IsNull() && !listItem.LocalSubnet.ExistingSubnetID.IsUnknown() {
						local_subnetDeepMap["existing_subnet_id"] = listItem.LocalSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			voltstack_clusterMap["az_nodes"] = az_nodesList
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if data.VPC != nil {
		vpcMap := make(map[string]interface{})
		if data.VPC.NewVPC != nil {
			new_vpcNestedMap := make(map[string]interface{})
			if !data.VPC.NewVPC.NameTag.IsNull() && !data.VPC.NewVPC.NameTag.IsUnknown() {
				new_vpcNestedMap["name_tag"] = data.VPC.NewVPC.NameTag.ValueString()
			}
			if !data.VPC.NewVPC.PrimaryIpv4.IsNull() && !data.VPC.NewVPC.PrimaryIpv4.IsUnknown() {
				new_vpcNestedMap["primary_ipv4"] = data.VPC.NewVPC.PrimaryIpv4.ValueString()
			}
			vpcMap["new_vpc"] = new_vpcNestedMap
		}
		if !data.VPC.VPCID.IsNull() && !data.VPC.VPCID.IsUnknown() {
			vpcMap["vpc_id"] = data.VPC.VPCID.ValueString()
		}
		apiResource.Spec["vpc"] = vpcMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		apiResource.Spec["address"] = data.Address.ValueString()
	}
	if !data.AWSRegion.IsNull() && !data.AWSRegion.IsUnknown() {
		apiResource.Spec["aws_region"] = data.AWSRegion.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		apiResource.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.InstanceType.IsNull() && !data.InstanceType.IsUnknown() {
		apiResource.Spec["instance_type"] = data.InstanceType.ValueString()
	}
	if !data.NodesPerAz.IsNull() && !data.NodesPerAz.IsUnknown() {
		apiResource.Spec["nodes_per_az"] = data.NodesPerAz.ValueInt64()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		apiResource.Spec["ssh_key"] = data.SSHKey.ValueString()
	}
	if !data.TotalNodes.IsNull() && !data.TotalNodes.IsUnknown() {
		apiResource.Spec["total_nodes"] = data.TotalNodes.ValueInt64()
	}

	_, err := r.client.UpdateAWSVPCSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AWSVPCSite: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAWSVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AWSVPCSite after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else if data.Address.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Address = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["aws_region"].(string); ok && v != "" {
		data.AWSRegion = types.StringValue(v)
	} else if data.AWSRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AWSRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else if data.DiskSize.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DiskSize = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else if data.InstanceType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.InstanceType = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else if data.NodesPerAz.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.NodesPerAz = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else if data.SSHKey.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.SSHKey = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else if data.TotalNodes.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TotalNodes = types.Int64Null()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AWSVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["aws_cred"].(map[string]interface{}); ok && (isImport || data.AWSCred != nil) {
		data.AWSCred = &AWSVPCSiteAWSCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AWSVPCSiteBlockedServicesModel{
			BlockedSevice: func() []AWSVPCSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AWSVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AWSVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_security_group"].(map[string]interface{}); ok && (isImport || data.CustomSecurityGroup != nil) {
		data.CustomSecurityGroup = &AWSVPCSiteCustomSecurityGroupModel{
			InsideSecurityGroupID: func() types.String {
				if v, ok := blockData["inside_security_group_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideSecurityGroupID: func() types.String {
				if v, ok := blockData["outside_security_group_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["direct_connect_disabled"].(map[string]interface{}); ok && isImport && data.DirectConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DirectConnectDisabled = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["direct_connect_enabled"].(map[string]interface{}); ok && (isImport || data.DirectConnectEnabled != nil) {
		data.DirectConnectEnabled = &AWSVPCSiteDirectConnectEnabledModel{
			AutoAsn: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.AutoAsn
				}
				// Import case: read from API
				if _, ok := blockData["auto_asn"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			CustomAsn: func() types.Int64 {
				if v, ok := blockData["custom_asn"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			HostedVifs: func() *AWSVPCSiteDirectConnectEnabledHostedVifsModel {
				if !isImport && data.DirectConnectEnabled != nil && data.DirectConnectEnabled.HostedVifs != nil {
					// Normal Read: preserve existing state value
					return data.DirectConnectEnabled.HostedVifs
				}
				// Import case: read from API
				if _, ok := blockData["hosted_vifs"].(map[string]interface{}); ok {
					return &AWSVPCSiteDirectConnectEnabledHostedVifsModel{}
				}
				return nil
			}(),
			StandardVifs: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.StandardVifs
				}
				// Import case: read from API
				if _, ok := blockData["standard_vifs"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["disable_internet_vip"].(map[string]interface{}); ok && isImport && data.DisableInternetVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableInternetVIP = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["egress_gateway_default"].(map[string]interface{}); ok && isImport && data.EgressGatewayDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EgressGatewayDefault = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["egress_nat_gw"].(map[string]interface{}); ok && (isImport || data.EgressNATGw != nil) {
		data.EgressNATGw = &AWSVPCSiteEgressNATGwModel{
			NATGwID: func() types.String {
				if v, ok := blockData["nat_gw_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["egress_virtual_private_gateway"].(map[string]interface{}); ok && (isImport || data.EgressVirtualPrivateGateway != nil) {
		data.EgressVirtualPrivateGateway = &AWSVPCSiteEgressVirtualPrivateGatewayModel{
			VgwID: func() types.String {
				if v, ok := blockData["vgw_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_internet_vip"].(map[string]interface{}); ok && isImport && data.EnableInternetVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableInternetVIP = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5_orchestrated_routing"].(map[string]interface{}); ok && isImport && data.F5OrchestratedRouting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5OrchestratedRouting = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5xc_security_group"].(map[string]interface{}); ok && isImport && data.F5xcSecurityGroup == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5xcSecurityGroup = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AWSVPCSiteIngressEgressGwModel{
			ActiveEnhancedFirewallPolicies: func() *AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AllowedVIPPort: func() *AWSVPCSiteIngressEgressGwAllowedVIPPortModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwAllowedVIPPortModel{}
				}
				return nil
			}(),
			AllowedVIPPortSLI: func() *AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AllowedVIPPortSLI != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AllowedVIPPortSLI
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port_sli"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwAllowedVIPPortSLIModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteIngressEgressGwAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel {
									if deepMap, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								OutsideSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if deepMap, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ReservedInsideSubnet: func() *AWSVPCSiteEmptyModel {
									if _, ok := itemMap["reserved_inside_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WorkloadSubnet: func() *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel {
									if deepMap, ok := itemMap["workload_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DcClusterGroupInsideVn: func() *AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AWSVPCSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AWSVPCSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AWSVPCSiteIngressGwModel{
			AllowedVIPPort: func() *AWSVPCSiteIngressGwAllowedVIPPortModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressGwAllowedVIPPortModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteIngressGwAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AWSVPCSiteIngressGwAzNodesLocalSubnetModel {
									if deepMap, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteIngressGwAzNodesLocalSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AWSVPCSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AWSVPCSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AWSVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AWSVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["manual_routing"].(map[string]interface{}); ok && isImport && data.ManualRouting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ManualRouting = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AWSVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AWSVPCSiteOSModel{
			DefaultOSVersion: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &AWSVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AWSVPCSiteSwModel{
			DefaultSwVersion: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AWSVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AWSVPCSiteVoltstackClusterModel{
			ActiveEnhancedFirewallPolicies: func() *AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AllowedVIPPort: func() *AWSVPCSiteVoltstackClusterAllowedVIPPortModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AllowedVIPPort != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AllowedVIPPort
				}
				// Import case: read from API
				if _, ok := blockData["allowed_vip_port"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterAllowedVIPPortModel{}
				}
				return nil
			}(),
			AWSCertifiedHw: func() types.String {
				if v, ok := blockData["aws_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []AWSVPCSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AWSVPCSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AWSVPCSiteVoltstackClusterAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel {
									if deepMap, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DcClusterGroup: func() *AWSVPCSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AWSVPCSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AWSVPCSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AWSVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AWSVPCSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AWSVPCSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AWSVPCSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["vpc"].(map[string]interface{}); ok && (isImport || data.VPC != nil) {
		data.VPC = &AWSVPCSiteVPCModel{
			NewVPC: func() *AWSVPCSiteVPCNewVPCModel {
				if !isImport && data.VPC != nil && data.VPC.NewVPC != nil {
					// Normal Read: preserve existing state value
					return data.VPC.NewVPC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["new_vpc"].(map[string]interface{}); ok {
					return &AWSVPCSiteVPCNewVPCModel{
						NameTag: func() types.String {
							if v, ok := nestedBlockData["name_tag"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						PrimaryIpv4: func() types.String {
							if v, ok := nestedBlockData["primary_ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			VPCID: func() types.String {
				if v, ok := blockData["vpc_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["aws_region"].(string); ok && v != "" {
		data.AWSRegion = types.StringValue(v)
	} else {
		data.AWSRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AWSVPCSiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAWSVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AWSVPCSite already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "AWSVPCSite delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AWSVPCSite: %s", err))
		return
	}
}

func (r *AWSVPCSiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
