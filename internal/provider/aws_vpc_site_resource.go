// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AWSVPCSiteResource{}
	_ resource.ResourceWithConfigure      = &AWSVPCSiteResource{}
	_ resource.ResourceWithImportState    = &AWSVPCSiteResource{}
	_ resource.ResourceWithModifyPlan     = &AWSVPCSiteResource{}
	_ resource.ResourceWithUpgradeState   = &AWSVPCSiteResource{}
	_ resource.ResourceWithValidateConfig = &AWSVPCSiteResource{}
)

// aws_vpc_siteSchemaVersion is the schema version for state upgrades
const aws_vpc_siteSchemaVersion int64 = 1

func NewAWSVPCSiteResource() resource.Resource {
	return &AWSVPCSiteResource{}
}

type AWSVPCSiteResource struct {
	client *client.Client
}

// AWSVPCSiteEmptyModel represents empty nested blocks
type AWSVPCSiteEmptyModel struct {
}

// AWSVPCSiteAdminPasswordModel represents admin_password block
type AWSVPCSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *AWSVPCSiteAdminPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type AWSVPCSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// AWSVPCSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type AWSVPCSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// AWSVPCSiteAWSCredModel represents aws_cred block
type AWSVPCSiteAWSCredModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteBlockedServicesModel represents blocked_services block
type AWSVPCSiteBlockedServicesModel struct {
	BlockedSevice []AWSVPCSiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// AWSVPCSiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type AWSVPCSiteBlockedServicesBlockedSeviceModel struct {
	NetworkType types.String `tfsdk:"network_type"`
	DNS *AWSVPCSiteEmptyModel `tfsdk:"dns"`
	SSH *AWSVPCSiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *AWSVPCSiteEmptyModel `tfsdk:"web_user_interface"`
}

// AWSVPCSiteCoordinatesModel represents coordinates block
type AWSVPCSiteCoordinatesModel struct {
	Latitude types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// AWSVPCSiteCustomDNSModel represents custom_dns block
type AWSVPCSiteCustomDNSModel struct {
	InsideNameserver types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// AWSVPCSiteCustomSecurityGroupModel represents custom_security_group block
type AWSVPCSiteCustomSecurityGroupModel struct {
	InsideSecurityGroupID types.String `tfsdk:"inside_security_group_id"`
	OutsideSecurityGroupID types.String `tfsdk:"outside_security_group_id"`
}

// AWSVPCSiteDirectConnectEnabledModel represents direct_connect_enabled block
type AWSVPCSiteDirectConnectEnabledModel struct {
	CustomAsn types.Int64 `tfsdk:"custom_asn"`
	AutoAsn *AWSVPCSiteEmptyModel `tfsdk:"auto_asn"`
	HostedVifs *AWSVPCSiteDirectConnectEnabledHostedVifsModel `tfsdk:"hosted_vifs"`
	StandardVifs *AWSVPCSiteEmptyModel `tfsdk:"standard_vifs"`
}

// AWSVPCSiteDirectConnectEnabledHostedVifsModel represents hosted_vifs block
type AWSVPCSiteDirectConnectEnabledHostedVifsModel struct {
	SiteRegistrationOverDirectConnect *AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel `tfsdk:"site_registration_over_direct_connect"`
	SiteRegistrationOverInternet *AWSVPCSiteEmptyModel `tfsdk:"site_registration_over_internet"`
	VifList []AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel `tfsdk:"vif_list"`
}

// AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel represents site_registration_over_direct_connect block
type AWSVPCSiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel represents vif_list block
type AWSVPCSiteDirectConnectEnabledHostedVifsVifListModel struct {
	OtherRegion types.String `tfsdk:"other_region"`
	VifID types.String `tfsdk:"vif_id"`
	SameAsSiteRegion *AWSVPCSiteEmptyModel `tfsdk:"same_as_site_region"`
}

// AWSVPCSiteEgressNatGwModel represents egress_nat_gw block
type AWSVPCSiteEgressNatGwModel struct {
	NatGwID types.String `tfsdk:"nat_gw_id"`
}

// AWSVPCSiteEgressVirtualPrivateGatewayModel represents egress_virtual_private_gateway block
type AWSVPCSiteEgressVirtualPrivateGatewayModel struct {
	VgwID types.String `tfsdk:"vgw_id"`
}

// AWSVPCSiteIngressEgressGwModel represents ingress_egress_gw block
type AWSVPCSiteIngressEgressGwModel struct {
	AWSCertifiedHw types.String `tfsdk:"aws_certified_hw"`
	ActiveEnhancedFirewallPolicies *AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies *AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies *AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel `tfsdk:"active_network_policies"`
	AllowedVipPort *AWSVPCSiteIngressEgressGwAllowedVipPortModel `tfsdk:"allowed_vip_port"`
	AllowedVipPortSLI *AWSVPCSiteIngressEgressGwAllowedVipPortSLIModel `tfsdk:"allowed_vip_port_sli"`
	AzNodes []AWSVPCSiteIngressEgressGwAzNodesModel `tfsdk:"az_nodes"`
	DcClusterGroupInsideVn *AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn *AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll *AWSVPCSiteEmptyModel `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList *AWSVPCSiteIngressEgressGwGlobalNetworkListModel `tfsdk:"global_network_list"`
	InsideStaticRoutes *AWSVPCSiteIngressEgressGwInsideStaticRoutesModel `tfsdk:"inside_static_routes"`
	NoDcClusterGroup *AWSVPCSiteEmptyModel `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy *AWSVPCSiteEmptyModel `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork *AWSVPCSiteEmptyModel `tfsdk:"no_global_network"`
	NoInsideStaticRoutes *AWSVPCSiteEmptyModel `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy *AWSVPCSiteEmptyModel `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes *AWSVPCSiteEmptyModel `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes *AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel `tfsdk:"outside_static_routes"`
	PerformanceEnhancementMode *AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP *AWSVPCSiteEmptyModel `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP *AWSVPCSiteEmptyModel `tfsdk:"sm_connection_pvt_ip"`
}

// AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AWSVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AWSVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel represents active_network_policies block
type AWSVPCSiteIngressEgressGwActiveNetworkPoliciesModel struct {
	NetworkPolicies []AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AWSVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwAllowedVipPortModel represents allowed_vip_port block
type AWSVPCSiteIngressEgressGwAllowedVipPortModel struct {
	CustomPorts *AWSVPCSiteIngressEgressGwAllowedVipPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVipPort *AWSVPCSiteEmptyModel `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_https_port"`
	UseHTTPPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_port"`
	UseHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_https_port"`
}

// AWSVPCSiteIngressEgressGwAllowedVipPortCustomPortsModel represents custom_ports block
type AWSVPCSiteIngressEgressGwAllowedVipPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteIngressEgressGwAllowedVipPortSLIModel represents allowed_vip_port_sli block
type AWSVPCSiteIngressEgressGwAllowedVipPortSLIModel struct {
	CustomPorts *AWSVPCSiteIngressEgressGwAllowedVipPortSLICustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVipPort *AWSVPCSiteEmptyModel `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_https_port"`
	UseHTTPPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_port"`
	UseHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_https_port"`
}

// AWSVPCSiteIngressEgressGwAllowedVipPortSLICustomPortsModel represents custom_ports block
type AWSVPCSiteIngressEgressGwAllowedVipPortSLICustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteIngressEgressGwAzNodesModel represents az_nodes block
type AWSVPCSiteIngressEgressGwAzNodesModel struct {
	AWSAzName types.String `tfsdk:"aws_az_name"`
	InsideSubnet *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel `tfsdk:"inside_subnet"`
	OutsideSubnet *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel `tfsdk:"outside_subnet"`
	ReservedInsideSubnet *AWSVPCSiteEmptyModel `tfsdk:"reserved_inside_subnet"`
	WorkloadSubnet *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel `tfsdk:"workload_subnet"`
}

// AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel represents inside_subnet block
type AWSVPCSiteIngressEgressGwAzNodesInsideSubnetModel struct {
	ExistingSubnetID types.String `tfsdk:"existing_subnet_id"`
	SubnetParam *AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel struct {
	IPV4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel represents outside_subnet block
type AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetModel struct {
	ExistingSubnetID types.String `tfsdk:"existing_subnet_id"`
	SubnetParam *AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel struct {
	IPV4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel represents workload_subnet block
type AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetModel struct {
	ExistingSubnetID types.String `tfsdk:"existing_subnet_id"`
	SubnetParam *AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressEgressGwAzNodesWorkloadSubnetSubnetParamModel struct {
	IPV4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type AWSVPCSiteIngressEgressGwDcClusterGroupInsideVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type AWSVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListModel represents global_network_list block
type AWSVPCSiteIngressEgressGwGlobalNetworkListModel struct {
	GlobalNetworkConnections []AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDr *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel `tfsdk:"sli_to_global_dr"`
	SLOToGlobalDr *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel `tfsdk:"slo_to_global_dr"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel represents sli_to_global_dr block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel struct {
	GlobalVn *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel represents global_vn block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel represents slo_to_global_dr block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel struct {
	GlobalVn *AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel represents global_vn block
type AWSVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesModel represents inside_static_routes block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesModel struct {
	StaticRouteList []AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel represents static_route_list block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String `tfsdk:"simple_static_route"`
	CustomStaticRoute *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs types.List `tfsdk:"attrs"`
	Labels *AWSVPCSiteEmptyModel `tfsdk:"labels"`
	Nexthop *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel `tfsdk:"nexthop"`
	Subnets []AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type types.String `tfsdk:"type"`
	Interface []AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel `tfsdk:"interface"`
	NexthopAddress *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	IPV4 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model `tfsdk:"ipv4"`
	IPV6 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	IPV4 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model `tfsdk:"ipv4"`
	IPV6 *AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel represents outside_static_routes block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesModel struct {
	StaticRouteList []AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String `tfsdk:"simple_static_route"`
	CustomStaticRoute *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs types.List `tfsdk:"attrs"`
	Labels *AWSVPCSiteEmptyModel `tfsdk:"labels"`
	Nexthop *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel `tfsdk:"nexthop"`
	Subnets []AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type types.String `tfsdk:"type"`
	Interface []AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel `tfsdk:"interface"`
	NexthopAddress *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	IPV4 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model `tfsdk:"ipv4"`
	IPV6 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	IPV4 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model `tfsdk:"ipv4"`
	IPV6 *AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model represents ipv4 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model represents ipv6 block
type AWSVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AWSVPCSiteIngressEgressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AWSVPCSiteEmptyModel `tfsdk:"perf_mode_l7_enhanced"`
}

// AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AWSVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo *AWSVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AWSVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AWSVPCSiteIngressGwModel represents ingress_gw block
type AWSVPCSiteIngressGwModel struct {
	AWSCertifiedHw types.String `tfsdk:"aws_certified_hw"`
	AllowedVipPort *AWSVPCSiteIngressGwAllowedVipPortModel `tfsdk:"allowed_vip_port"`
	AzNodes []AWSVPCSiteIngressGwAzNodesModel `tfsdk:"az_nodes"`
	PerformanceEnhancementMode *AWSVPCSiteIngressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// AWSVPCSiteIngressGwAllowedVipPortModel represents allowed_vip_port block
type AWSVPCSiteIngressGwAllowedVipPortModel struct {
	CustomPorts *AWSVPCSiteIngressGwAllowedVipPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVipPort *AWSVPCSiteEmptyModel `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_https_port"`
	UseHTTPPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_port"`
	UseHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_https_port"`
}

// AWSVPCSiteIngressGwAllowedVipPortCustomPortsModel represents custom_ports block
type AWSVPCSiteIngressGwAllowedVipPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteIngressGwAzNodesModel represents az_nodes block
type AWSVPCSiteIngressGwAzNodesModel struct {
	AWSAzName types.String `tfsdk:"aws_az_name"`
	LocalSubnet *AWSVPCSiteIngressGwAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AWSVPCSiteIngressGwAzNodesLocalSubnetModel represents local_subnet block
type AWSVPCSiteIngressGwAzNodesLocalSubnetModel struct {
	ExistingSubnetID types.String `tfsdk:"existing_subnet_id"`
	SubnetParam *AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteIngressGwAzNodesLocalSubnetSubnetParamModel struct {
	IPV4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteIngressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AWSVPCSiteIngressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AWSVPCSiteEmptyModel `tfsdk:"perf_mode_l7_enhanced"`
}

// AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AWSVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo *AWSVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AWSVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AWSVPCSiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type AWSVPCSiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *AWSVPCSiteEmptyModel `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain *AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type AWSVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64 `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout types.Int64 `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode *AWSVPCSiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode *AWSVPCSiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// AWSVPCSiteLogReceiverModel represents log_receiver block
type AWSVPCSiteLogReceiverModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type AWSVPCSiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *AWSVPCSiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode *AWSVPCSiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// AWSVPCSiteOsModel represents os block
type AWSVPCSiteOsModel struct {
	OperatingSystemVersion types.String `tfsdk:"operating_system_version"`
	DefaultOsVersion *AWSVPCSiteEmptyModel `tfsdk:"default_os_version"`
}

// AWSVPCSitePrivateConnectivityModel represents private_connectivity block
type AWSVPCSitePrivateConnectivityModel struct {
	CloudLink *AWSVPCSitePrivateConnectivityCloudLinkModel `tfsdk:"cloud_link"`
	Inside *AWSVPCSiteEmptyModel `tfsdk:"inside"`
	Outside *AWSVPCSiteEmptyModel `tfsdk:"outside"`
}

// AWSVPCSitePrivateConnectivityCloudLinkModel represents cloud_link block
type AWSVPCSitePrivateConnectivityCloudLinkModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteSwModel represents sw block
type AWSVPCSiteSwModel struct {
	VolterraSoftwareVersion types.String `tfsdk:"volterra_software_version"`
	DefaultSwVersion *AWSVPCSiteEmptyModel `tfsdk:"default_sw_version"`
}

// AWSVPCSiteVoltstackClusterModel represents voltstack_cluster block
type AWSVPCSiteVoltstackClusterModel struct {
	AWSCertifiedHw types.String `tfsdk:"aws_certified_hw"`
	ActiveEnhancedFirewallPolicies *AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies *AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies *AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel `tfsdk:"active_network_policies"`
	AllowedVipPort *AWSVPCSiteVoltstackClusterAllowedVipPortModel `tfsdk:"allowed_vip_port"`
	AzNodes []AWSVPCSiteVoltstackClusterAzNodesModel `tfsdk:"az_nodes"`
	DcClusterGroup *AWSVPCSiteVoltstackClusterDcClusterGroupModel `tfsdk:"dc_cluster_group"`
	DefaultStorage *AWSVPCSiteEmptyModel `tfsdk:"default_storage"`
	ForwardProxyAllowAll *AWSVPCSiteEmptyModel `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList *AWSVPCSiteVoltstackClusterGlobalNetworkListModel `tfsdk:"global_network_list"`
	K8SCluster *AWSVPCSiteVoltstackClusterK8SClusterModel `tfsdk:"k8s_cluster"`
	NoDcClusterGroup *AWSVPCSiteEmptyModel `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy *AWSVPCSiteEmptyModel `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork *AWSVPCSiteEmptyModel `tfsdk:"no_global_network"`
	NoK8SCluster *AWSVPCSiteEmptyModel `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy *AWSVPCSiteEmptyModel `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes *AWSVPCSiteEmptyModel `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes *AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP *AWSVPCSiteEmptyModel `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP *AWSVPCSiteEmptyModel `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList *AWSVPCSiteVoltstackClusterStorageClassListModel `tfsdk:"storage_class_list"`
}

// AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AWSVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AWSVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel represents active_network_policies block
type AWSVPCSiteVoltstackClusterActiveNetworkPoliciesModel struct {
	NetworkPolicies []AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AWSVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterAllowedVipPortModel represents allowed_vip_port block
type AWSVPCSiteVoltstackClusterAllowedVipPortModel struct {
	CustomPorts *AWSVPCSiteVoltstackClusterAllowedVipPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVipPort *AWSVPCSiteEmptyModel `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_https_port"`
	UseHTTPPort *AWSVPCSiteEmptyModel `tfsdk:"use_http_port"`
	UseHTTPSPort *AWSVPCSiteEmptyModel `tfsdk:"use_https_port"`
}

// AWSVPCSiteVoltstackClusterAllowedVipPortCustomPortsModel represents custom_ports block
type AWSVPCSiteVoltstackClusterAllowedVipPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// AWSVPCSiteVoltstackClusterAzNodesModel represents az_nodes block
type AWSVPCSiteVoltstackClusterAzNodesModel struct {
	AWSAzName types.String `tfsdk:"aws_az_name"`
	LocalSubnet *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel represents local_subnet block
type AWSVPCSiteVoltstackClusterAzNodesLocalSubnetModel struct {
	ExistingSubnetID types.String `tfsdk:"existing_subnet_id"`
	SubnetParam *AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AWSVPCSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel struct {
	IPV4 types.String `tfsdk:"ipv4"`
}

// AWSVPCSiteVoltstackClusterDcClusterGroupModel represents dc_cluster_group block
type AWSVPCSiteVoltstackClusterDcClusterGroupModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListModel represents global_network_list block
type AWSVPCSiteVoltstackClusterGlobalNetworkListModel struct {
	GlobalNetworkConnections []AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDr *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel `tfsdk:"sli_to_global_dr"`
	SLOToGlobalDr *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel `tfsdk:"slo_to_global_dr"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel represents sli_to_global_dr block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel struct {
	GlobalVn *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel represents global_vn block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel represents slo_to_global_dr block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel struct {
	GlobalVn *AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel represents global_vn block
type AWSVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterK8SClusterModel represents k8s_cluster block
type AWSVPCSiteVoltstackClusterK8SClusterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel represents outside_static_routes block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesModel struct {
	StaticRouteList []AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String `tfsdk:"simple_static_route"`
	CustomStaticRoute *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs types.List `tfsdk:"attrs"`
	Labels *AWSVPCSiteEmptyModel `tfsdk:"labels"`
	Nexthop *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel `tfsdk:"nexthop"`
	Subnets []AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type types.String `tfsdk:"type"`
	Interface []AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel `tfsdk:"interface"`
	NexthopAddress *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	IPV4 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model `tfsdk:"ipv4"`
	IPV6 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model represents ipv4 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model represents ipv6 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	IPV4 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model `tfsdk:"ipv4"`
	IPV6 *AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model `tfsdk:"ipv6"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model represents ipv4 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model represents ipv6 block
type AWSVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AWSVPCSiteVoltstackClusterStorageClassListModel represents storage_class_list block
type AWSVPCSiteVoltstackClusterStorageClassListModel struct {
	StorageClasses []AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel represents storage_classes block
type AWSVPCSiteVoltstackClusterStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool `tfsdk:"default_storage_class"`
	StorageClassName types.String `tfsdk:"storage_class_name"`
}

// AWSVPCSiteVPCModel represents vpc block
type AWSVPCSiteVPCModel struct {
	VPCID types.String `tfsdk:"vpc_id"`
	NewVPC *AWSVPCSiteVPCNewVPCModel `tfsdk:"new_vpc"`
}

// AWSVPCSiteVPCNewVPCModel represents new_vpc block
type AWSVPCSiteVPCNewVPCModel struct {
	NameTag types.String `tfsdk:"name_tag"`
	PrimaryIPV4 types.String `tfsdk:"primary_ipv4"`
	Autogenerate *AWSVPCSiteEmptyModel `tfsdk:"autogenerate"`
}

type AWSVPCSiteResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Address types.String `tfsdk:"address"`
	Annotations types.Map `tfsdk:"annotations"`
	AWSRegion types.String `tfsdk:"aws_region"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	DiskSize types.Int64 `tfsdk:"disk_size"`
	InstanceType types.String `tfsdk:"instance_type"`
	Labels types.Map `tfsdk:"labels"`
	NodesPerAz types.Int64 `tfsdk:"nodes_per_az"`
	SSHKey types.String `tfsdk:"ssh_key"`
	TotalNodes types.Int64 `tfsdk:"total_nodes"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	AdminPassword *AWSVPCSiteAdminPasswordModel `tfsdk:"admin_password"`
	AWSCred *AWSVPCSiteAWSCredModel `tfsdk:"aws_cred"`
	BlockAllServices *AWSVPCSiteEmptyModel `tfsdk:"block_all_services"`
	BlockedServices *AWSVPCSiteBlockedServicesModel `tfsdk:"blocked_services"`
	Coordinates *AWSVPCSiteCoordinatesModel `tfsdk:"coordinates"`
	CustomDNS *AWSVPCSiteCustomDNSModel `tfsdk:"custom_dns"`
	CustomSecurityGroup *AWSVPCSiteCustomSecurityGroupModel `tfsdk:"custom_security_group"`
	DefaultBlockedServices *AWSVPCSiteEmptyModel `tfsdk:"default_blocked_services"`
	DirectConnectDisabled *AWSVPCSiteEmptyModel `tfsdk:"direct_connect_disabled"`
	DirectConnectEnabled *AWSVPCSiteDirectConnectEnabledModel `tfsdk:"direct_connect_enabled"`
	DisableInternetVip *AWSVPCSiteEmptyModel `tfsdk:"disable_internet_vip"`
	EgressGatewayDefault *AWSVPCSiteEmptyModel `tfsdk:"egress_gateway_default"`
	EgressNatGw *AWSVPCSiteEgressNatGwModel `tfsdk:"egress_nat_gw"`
	EgressVirtualPrivateGateway *AWSVPCSiteEgressVirtualPrivateGatewayModel `tfsdk:"egress_virtual_private_gateway"`
	EnableInternetVip *AWSVPCSiteEmptyModel `tfsdk:"enable_internet_vip"`
	F5OrchestratedRouting *AWSVPCSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	F5xcSecurityGroup *AWSVPCSiteEmptyModel `tfsdk:"f5xc_security_group"`
	IngressEgressGw *AWSVPCSiteIngressEgressGwModel `tfsdk:"ingress_egress_gw"`
	IngressGw *AWSVPCSiteIngressGwModel `tfsdk:"ingress_gw"`
	KubernetesUpgradeDrain *AWSVPCSiteKubernetesUpgradeDrainModel `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver *AWSVPCSiteLogReceiverModel `tfsdk:"log_receiver"`
	LogsStreamingDisabled *AWSVPCSiteEmptyModel `tfsdk:"logs_streaming_disabled"`
	ManualRouting *AWSVPCSiteEmptyModel `tfsdk:"manual_routing"`
	NoWorkerNodes *AWSVPCSiteEmptyModel `tfsdk:"no_worker_nodes"`
	OfflineSurvivabilityMode *AWSVPCSiteOfflineSurvivabilityModeModel `tfsdk:"offline_survivability_mode"`
	Os *AWSVPCSiteOsModel `tfsdk:"os"`
	PrivateConnectivity *AWSVPCSitePrivateConnectivityModel `tfsdk:"private_connectivity"`
	Sw *AWSVPCSiteSwModel `tfsdk:"sw"`
	Tags *AWSVPCSiteEmptyModel `tfsdk:"tags"`
	VoltstackCluster *AWSVPCSiteVoltstackClusterModel `tfsdk:"voltstack_cluster"`
	VPC *AWSVPCSiteVPCModel `tfsdk:"vpc"`
}

func (r *AWSVPCSiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aws_vpc_site"
}

func (r *AWSVPCSiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             aws_vpc_siteSchemaVersion,
		MarkdownDescription: "Manages a AWSVPCSite resource in F5 Distributed Cloud for deploying F5 sites within AWS VPC environments.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the AWSVPCSite. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the AWSVPCSite will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "Geographical Address. Site's geographical address that can be used to determine its latitude and longitude.",
				Optional: true,
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"aws_region": schema.StringAttribute{
				MarkdownDescription: "AWS Region. Name for AWS Region.",
				Optional: true,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"disk_size": schema.Int64Attribute{
				MarkdownDescription: "Cloud Disk Size. Disk size to be used for this instance in GiB. 80 is 80 GiB",
				Optional: true,
			},
			"instance_type": schema.StringAttribute{
				MarkdownDescription: "AWS Instance Type for Node. Select Instance size based on performance needed",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"nodes_per_az": schema.Int64Attribute{
				MarkdownDescription: "Desired Worker Nodes Per AZ. Desired Worker Nodes Per AZ. Max limit is up to 21",
				Optional: true,
			},
			"ssh_key": schema.StringAttribute{
				MarkdownDescription: "Public SSH key. Public SSH key for accessing the site.",
				Optional: true,
			},
			"total_nodes": schema.Int64Attribute{
				MarkdownDescription: "Total Number of Worker Nodes for a Site. Total number of worker nodes to be deployed across all AZ's used in the Site",
				Optional: true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"admin_password": schema.SingleNestedBlock{
				MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"blindfold_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
						Attributes: map[string]schema.Attribute{
							"decryption_provider": schema.StringAttribute{
								MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
								Optional: true,
							},
							"location": schema.StringAttribute{
								MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
								Optional: true,
							},
							"store_provider": schema.StringAttribute{
								MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
								Optional: true,
							},
						},
					},
					"clear_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
						Attributes: map[string]schema.Attribute{
							"provider_ref": schema.StringAttribute{
								MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
								Optional: true,
							},
							"url": schema.StringAttribute{
								MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
								Optional: true,
							},
						},
					},
				},

			},
			"aws_cred": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services] Empty. This can be used for messages where no values are needed",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable Node Local Services. Disable node local services on this site. Note: The chosen services will get disabled on all nodes in the site.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "Virtual Network Type. Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created automatically and present on all sites Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site. It is a secure network and is not connected to public network. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created during provisioning of site User defined per-site virtual network. Scope of this virtual network is limited to the site. This is not yet supported Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on RE sites only It is an internally created by the system. They must not be created by user Virtual Neworks with global scope across different sites in F5XC domain. An example global virtual-network called 'AIN Network' is created for every tenant. for volterra fabric Constraints: It is currently only supported as internally created by the system. vK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant Constraints: It is an internally created by the system. Must not be created by user VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy Constraints: It is an internally created by the system. Must not be created by user Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE Constraints: This network type is only meaningful in an advertise policy When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for an endpoint, VER will try to determine the network based on the provided IP address Constraints: This network type is only meaningful in an endpoint VoltADN Private Network is used on volterra RE(s) to connect to customer private networks This network is created by opening a support ticket This network is per site srv6 network VER IP Fabric network for the site. This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network Constraints: It is an internally created by the system. Must not be created by user Network internally created for a segment Constraints: It is an internally created by the system. Must not be created by user. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
					},
				},

			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Site Coordinates. Coordinates of the site which provides the site physical location",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location",
						Optional: true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. longitude of site location",
						Optional: true,
					},
				},

			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS. Custom DNS is the configured for specify CE site",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Inside Network. Optional DNS server IP to be used for name resolution in inside network",
						Optional: true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Outside Network. Optional DNS server IP to be used for name resolution in outside network",
						Optional: true,
					},
				},

			},
			"custom_security_group": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: custom_security_group, f5xc_security_group] Security Group IDS. Enter pre created security groups for slo(Site Local Outside) and sli(Site Local Inside) interface. Supported only for sites deployed on existing VPC",
				Attributes: map[string]schema.Attribute{
					"inside_security_group_id": schema.StringAttribute{
						MarkdownDescription: "Inside Security Group ID. Security Group ID to be attached to SLI(Site Local Inside) Interface",
						Optional: true,
					},
					"outside_security_group_id": schema.StringAttribute{
						MarkdownDescription: "Outside Security Group ID. Security Group ID to be attached to SLO(Site Local Outside) Interface",
						Optional: true,
					},
				},

			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"direct_connect_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: direct_connect_disabled, direct_connect_enabled, private_connectivity] Empty. This can be used for messages where no values are needed",
			},
			"direct_connect_enabled": schema.SingleNestedBlock{
				MarkdownDescription: "Direct Connect Configuration. Direct Connect Configuration",
				Attributes: map[string]schema.Attribute{
					"custom_asn": schema.Int64Attribute{
						MarkdownDescription: "Custom ASN. Custom Autonomous System Number",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"auto_asn": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"hosted_vifs": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Direct Connect Hosted VIF Config. x-example: 'value' AWS Direct Connect Hosted VIF Configuration",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"site_registration_over_direct_connect": schema.SingleNestedBlock{
								MarkdownDescription: "CloudLink ADN Network Config.",
								Attributes: map[string]schema.Attribute{
									"cloudlink_network_name": schema.StringAttribute{
										MarkdownDescription: "Private ADN Network. Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
										Optional: true,
									},
								},
							},
							"site_registration_over_internet": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"vif_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Hosted VIF Config. List of Hosted VIF Config",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"other_region": schema.StringAttribute{
											MarkdownDescription: "Other Region. Other Region",
											Optional: true,
										},
										"vif_id": schema.StringAttribute{
											MarkdownDescription: "VIF ID. AWS Direct Connect VIF ID that needs to be connected to the site",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"same_as_site_region": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
					},
					"standard_vifs": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"disable_internet_vip": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_internet_vip, enable_internet_vip] Empty. This can be used for messages where no values are needed",
			},
			"egress_gateway_default": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: egress_gateway_default, egress_nat_gw, egress_virtual_private_gateway] Empty. This can be used for messages where no values are needed",
			},
			"egress_nat_gw": schema.SingleNestedBlock{
				MarkdownDescription: "AWS NAT Gateway choice. With this option, egress site traffic will be routed through an Network Address Translation(NAT) Gateway.",
				Attributes: map[string]schema.Attribute{
					"nat_gw_id": schema.StringAttribute{
						MarkdownDescription: "Existing NAT Gateway ID.",
						Optional: true,
					},
				},

			},
			"egress_virtual_private_gateway": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Virtual Private Gateway choice. With this option, egress site traffic will be routed through an Virtual Private Gateway.",
				Attributes: map[string]schema.Attribute{
					"vgw_id": schema.StringAttribute{
						MarkdownDescription: "Existing Virtual Private Gateway ID.",
						Optional: true,
					},
				},

			},
			"enable_internet_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"f5_orchestrated_routing": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: f5_orchestrated_routing, manual_routing] Empty. This can be used for messages where no values are needed",
			},
			"f5xc_security_group": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"ingress_egress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ingress_egress_gw, ingress_gw, voltstack_cluster] AWS Ingress/Egress Gateway. Two interface AWS ingress/egress site",
				Attributes: map[string]schema.Attribute{
					"aws_certified_hw": schema.StringAttribute{
						MarkdownDescription: "AWS Certified Hardware. Name for AWS certified hardware.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Allowed VIP Ports. This defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP lb configured on the F5XC Site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges",
										Optional: true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"allowed_vip_port_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Allowed VIP Ports. This defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP lb configured on the F5XC Site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges",
										Optional: true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Ingress/Egress Gateway (two Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS AZ Name. AWS availability zone, must be consistent with the selected AWS region.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional: true,
												},
											},
										},
									},
								},
								"outside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional: true,
												},
											},
										},
									},
								},
								"reserved_inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"workload_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional: true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional: true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional: true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional: true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"ingress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Ingress Gateway. Single interface AWS ingress site",
				Attributes: map[string]schema.Attribute{
					"aws_certified_hw": schema.StringAttribute{
						MarkdownDescription: "AWS Certified Hardware. Name for AWS certified hardware.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Allowed VIP Ports. This defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP lb configured on the F5XC Site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges",
										Optional: true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Ingress Gateway (One Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS AZ Name. AWS availability zone, must be consistent with the selected AWS region.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Node by Node Upgrade. Specify how worker nodes within a site will be upgraded.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable Node by Node Upgrade. Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional: true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Upgrade Wait Time. Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is recommended to use the default value).",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"manual_routing": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_worker_nodes": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_worker_nodes, nodes_per_az, total_nodes] Empty. This can be used for messages where no values are needed",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability Mode. Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7 days, even when the site is offline. The certificates needed to keep the services running on this site are signed using a local CA. Secrets would also be cached locally to handle the connectivity loss. When the mode is toggled, services will restart and traffic disruption will be seen.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Operating System Version. Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Operating System Version. Specify a OS version to be used e.g. 9.2024.6.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"private_connectivity": schema.SingleNestedBlock{
				MarkdownDescription: "Private Connect Configuration. Private Connect Configuration",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"cloud_link": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"inside": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "F5XC Software Version. Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "F5XC Software Version. Specify a F5XC Software Version to be used e.g. crt-20210329-1002.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"tags": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
			},
			"voltstack_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "AWS App Stack Cluster. App Stack cluster of single interface AWS nodes",
				Attributes: map[string]schema.Attribute{
					"aws_certified_hw": schema.StringAttribute{
						MarkdownDescription: "AWS Certified Hardware. Name for AWS certified hardware.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Allowed VIP Ports. This defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP lb configured on the F5XC Site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges",
										Optional: true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "App Stack Cluster (One Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS AZ Name. AWS availability zone, must be consistent with the selected AWS region.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional: true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional: true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Storage Class List. Add additional custom storage classes in kubernetes for this site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Default Storage Class. Make this storage class default storage class for the K8s cluster",
											Optional: true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Storage Class Name. Name of the storage class as it will appear in K8s.",
											Optional: true,
										},
									},
								},
							},
						},
					},
				},

			},
			"vpc": schema.SingleNestedBlock{
				MarkdownDescription: "AWS VPC choice. This defines choice about AWS VPC for a view",
				Attributes: map[string]schema.Attribute{
					"vpc_id": schema.StringAttribute{
						MarkdownDescription: "Existing VPC ID. Information about existing VPC ID",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"new_vpc": schema.SingleNestedBlock{
						MarkdownDescription: "AWS VPC Parameters. Parameters to create new AWS VPC",
						Attributes: map[string]schema.Attribute{
							"name_tag": schema.StringAttribute{
								MarkdownDescription: "Choose VPC Name. Specify the VPC Name",
								Optional: true,
							},
							"primary_ipv4": schema.StringAttribute{
								MarkdownDescription: "Primary IPv4 CIDR block. IPv4 CIDR block for this VPC. It has to be private address space. The Primary IPv4 block cannot be modified. All subnets prefixes in this VPC must be part of this CIDR block.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
		},
	}
}

func (r *AWSVPCSiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AWSVPCSiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AWSVPCSiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the aws_vpc_site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AWSVPCSiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AWSVPCSiteResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AWSVPCSiteResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AWSVPCSiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating aws_vpc_site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.AWSVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.AWSVPCSiteSpec{},
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateAWSVPCSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AWSVPCSite: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(created.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created AWSVPCSite resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AWSVPCSiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAWSVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AWSVPCSite not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AWSVPCSite: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The aws_vpc_site may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	psd = privatestate.NewPrivateStateData()
	psd.SetUID(apiResource.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AWSVPCSiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.AWSVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.AWSVPCSiteSpec{},
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateAWSVPCSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AWSVPCSite: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetAWSVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AWSVPCSiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AWSVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()

	err := r.client.DeleteAWSVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AWSVPCSite already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AWSVPCSite: %s", err))
		return
	}
}

func (r *AWSVPCSiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
