// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AzureVNETSiteResource{}
	_ resource.ResourceWithConfigure      = &AzureVNETSiteResource{}
	_ resource.ResourceWithImportState    = &AzureVNETSiteResource{}
	_ resource.ResourceWithModifyPlan     = &AzureVNETSiteResource{}
	_ resource.ResourceWithUpgradeState   = &AzureVNETSiteResource{}
	_ resource.ResourceWithValidateConfig = &AzureVNETSiteResource{}
)

// azure_vnet_siteSchemaVersion is the schema version for state upgrades
const azure_vnet_siteSchemaVersion int64 = 1

func NewAzureVNETSiteResource() resource.Resource {
	return &AzureVNETSiteResource{}
}

type AzureVNETSiteResource struct {
	client *client.Client
}

// AzureVNETSiteEmptyModel represents empty nested blocks
type AzureVNETSiteEmptyModel struct {
}

// AzureVNETSiteAdminPasswordModel represents admin_password block
type AzureVNETSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AzureVNETSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AzureVNETSiteAdminPasswordModelAttrTypes defines the attribute types for AzureVNETSiteAdminPasswordModel
var AzureVNETSiteAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AzureVNETSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AzureVNETSiteAdminPasswordClearSecretInfoModelAttrTypes},
}

// AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AzureVNETSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel
var AzureVNETSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AzureVNETSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type AzureVNETSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AzureVNETSiteAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for AzureVNETSiteAdminPasswordClearSecretInfoModel
var AzureVNETSiteAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AzureVNETSiteAzureCredModel represents azure_cred block
type AzureVNETSiteAzureCredModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteAzureCredModelAttrTypes defines the attribute types for AzureVNETSiteAzureCredModel
var AzureVNETSiteAzureCredModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteBlockedServicesModel represents blocked_services block
type AzureVNETSiteBlockedServicesModel struct {
	BlockedSevice []AzureVNETSiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// AzureVNETSiteBlockedServicesModelAttrTypes defines the attribute types for AzureVNETSiteBlockedServicesModel
var AzureVNETSiteBlockedServicesModelAttrTypes = map[string]attr.Type{
	"blocked_sevice": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteBlockedServicesBlockedSeviceModelAttrTypes}},
}

// AzureVNETSiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type AzureVNETSiteBlockedServicesBlockedSeviceModel struct {
	NetworkType      types.String             `tfsdk:"network_type"`
	DNS              *AzureVNETSiteEmptyModel `tfsdk:"dns"`
	SSH              *AzureVNETSiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *AzureVNETSiteEmptyModel `tfsdk:"web_user_interface"`
}

// AzureVNETSiteBlockedServicesBlockedSeviceModelAttrTypes defines the attribute types for AzureVNETSiteBlockedServicesBlockedSeviceModel
var AzureVNETSiteBlockedServicesBlockedSeviceModelAttrTypes = map[string]attr.Type{
	"network_type":       types.StringType,
	"dns":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ssh":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web_user_interface": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteCoordinatesModel represents coordinates block
type AzureVNETSiteCoordinatesModel struct {
	Latitude  types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// AzureVNETSiteCoordinatesModelAttrTypes defines the attribute types for AzureVNETSiteCoordinatesModel
var AzureVNETSiteCoordinatesModelAttrTypes = map[string]attr.Type{
	"latitude":  types.Int64Type,
	"longitude": types.Int64Type,
}

// AzureVNETSiteCustomDNSModel represents custom_dns block
type AzureVNETSiteCustomDNSModel struct {
	InsideNameserver  types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// AzureVNETSiteCustomDNSModelAttrTypes defines the attribute types for AzureVNETSiteCustomDNSModel
var AzureVNETSiteCustomDNSModelAttrTypes = map[string]attr.Type{
	"inside_nameserver":  types.StringType,
	"outside_nameserver": types.StringType,
}

// AzureVNETSiteIngressEgressGwModel represents ingress_egress_gw block
type AzureVNETSiteIngressEgressGwModel struct {
	AzureCertifiedHw               types.String                                                     `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	AzNodes                        []AzureVNETSiteIngressEgressGwAzNodesModel                       `tfsdk:"az_nodes"`
	DcClusterGroupInsideVn         *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel         `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn        *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel        `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                         `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteIngressEgressGwGlobalNetworkListModel              `tfsdk:"global_network_list"`
	Hub                            *AzureVNETSiteIngressEgressGwHubModel                            `tfsdk:"hub"`
	InsideStaticRoutes             *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel             `tfsdk:"inside_static_routes"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                         `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                         `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                         `tfsdk:"no_global_network"`
	NoInsideStaticRoutes           *AzureVNETSiteEmptyModel                                         `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                         `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                         `tfsdk:"no_outside_static_routes"`
	NotHub                         *AzureVNETSiteEmptyModel                                         `tfsdk:"not_hub"`
	OutsideStaticRoutes            *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	PerformanceEnhancementMode     *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel     `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                         `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                         `tfsdk:"sm_connection_pvt_ip"`
}

// AzureVNETSiteIngressEgressGwModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwModel
var AzureVNETSiteIngressEgressGwModelAttrTypes = map[string]attr.Type{
	"azure_certified_hw":                types.StringType,
	"accelerated_networking":            types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAcceleratedNetworkingModelAttrTypes},
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes},
	"az_nodes":                          types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesModelAttrTypes}},
	"dc_cluster_group_inside_vn":        types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes},
	"dc_cluster_group_outside_vn":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwGlobalNetworkListModelAttrTypes},
	"hub":                               types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubModelAttrTypes},
	"inside_static_routes":              types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_inside_static_routes":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"not_hub":                           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":             types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes},
	"performance_enhancement_mode":      types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressEgressGwAcceleratedNetworkingModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel
var AzureVNETSiteIngressEgressGwAcceleratedNetworkingModelAttrTypes = map[string]attr.Type{
	"disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel
var AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel
var AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel
var AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel
var AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel
var AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwAzNodesModel represents az_nodes block
type AzureVNETSiteIngressEgressGwAzNodesModel struct {
	AzureAz       types.String                                           `tfsdk:"azure_az"`
	InsideSubnet  *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel  `tfsdk:"inside_subnet"`
	OutsideSubnet *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel `tfsdk:"outside_subnet"`
}

// AzureVNETSiteIngressEgressGwAzNodesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesModel
var AzureVNETSiteIngressEgressGwAzNodesModelAttrTypes = map[string]attr.Type{
	"azure_az":       types.StringType,
	"inside_subnet":  types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModelAttrTypes},
	"outside_subnet": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel represents inside_subnet block
type AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel
var AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel
var AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel represents outside_subnet block
type AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel
var AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel
var AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel
var AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel
var AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteIngressEgressGwGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwGlobalNetworkListModel
var AzureVNETSiteIngressEgressGwGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel
var AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwHubModel represents hub block
type AzureVNETSiteIngressEgressGwHubModel struct {
	ExpressRouteDisabled *AzureVNETSiteEmptyModel                                 `tfsdk:"express_route_disabled"`
	ExpressRouteEnabled  *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel `tfsdk:"express_route_enabled"`
	SpokeVnets           []AzureVNETSiteIngressEgressGwHubSpokeVnetsModel         `tfsdk:"spoke_vnets"`
}

// AzureVNETSiteIngressEgressGwHubModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubModel
var AzureVNETSiteIngressEgressGwHubModelAttrTypes = map[string]attr.Type{
	"express_route_disabled": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"express_route_enabled":  types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModelAttrTypes},
	"spoke_vnets":            types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubSpokeVnetsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel represents express_route_enabled block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel struct {
	CustomAsn                        types.Int64                                                                              `tfsdk:"custom_asn"`
	AdvertiseToRouteServer           *AzureVNETSiteEmptyModel                                                                 `tfsdk:"advertise_to_route_server"`
	AutoAsn                          *AzureVNETSiteEmptyModel                                                                 `tfsdk:"auto_asn"`
	Connections                      []AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel                     `tfsdk:"connections"`
	DoNotAdvertiseToRouteServer      *AzureVNETSiteEmptyModel                                                                 `tfsdk:"do_not_advertise_to_route_server"`
	GatewaySubnet                    *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel                    `tfsdk:"gateway_subnet"`
	RouteServerSubnet                *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel                `tfsdk:"route_server_subnet"`
	SiteRegistrationOverExpressRoute *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel `tfsdk:"site_registration_over_express_route"`
	SiteRegistrationOverInternet     *AzureVNETSiteEmptyModel                                                                 `tfsdk:"site_registration_over_internet"`
	SkuErgw1az                       *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_ergw1az"`
	SkuErgw2az                       *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_ergw2az"`
	SkuHighPerf                      *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_high_perf"`
	SkuStandard                      *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_standard"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModelAttrTypes = map[string]attr.Type{
	"custom_asn":                           types.Int64Type,
	"advertise_to_route_server":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"auto_asn":                             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"connections":                          types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModelAttrTypes}},
	"do_not_advertise_to_route_server":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"gateway_subnet":                       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModelAttrTypes},
	"route_server_subnet":                  types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModelAttrTypes},
	"site_registration_over_express_route": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModelAttrTypes},
	"site_registration_over_internet":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_ergw1az":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_ergw2az":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_high_perf":                        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_standard":                         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel represents connections block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel struct {
	CircuitID         types.String                                                                         `tfsdk:"circuit_id"`
	Weight            types.Int64                                                                          `tfsdk:"weight"`
	Metadata          *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel          `tfsdk:"metadata"`
	OtherSubscription *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel `tfsdk:"other_subscription"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModelAttrTypes = map[string]attr.Type{
	"circuit_id":         types.StringType,
	"weight":             types.Int64Type,
	"metadata":           types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModelAttrTypes},
	"other_subscription": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel represents metadata block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel represents other_subscription block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel struct {
	CircuitID     types.String                                                                                      `tfsdk:"circuit_id"`
	AuthorizedKey *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel `tfsdk:"authorized_key"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModelAttrTypes = map[string]attr.Type{
	"circuit_id":     types.StringType,
	"authorized_key": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel represents authorized_key block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel struct {
	BlindfoldSecretInfo *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel represents clear_secret_info block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel represents gateway_subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                         `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModelAttrTypes = map[string]attr.Type{
	"auto":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel represents route_server_subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                             `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModelAttrTypes = map[string]attr.Type{
	"auto":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel represents site_registration_over_express_route block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel
var AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModelAttrTypes = map[string]attr.Type{
	"cloudlink_network_name": types.StringType,
}

// AzureVNETSiteIngressEgressGwHubSpokeVnetsModel represents spoke_vnets block
type AzureVNETSiteIngressEgressGwHubSpokeVnetsModel struct {
	Auto   *AzureVNETSiteEmptyModel                            `tfsdk:"auto"`
	Labels *AzureVNETSiteEmptyModel                            `tfsdk:"labels"`
	Manual *AzureVNETSiteEmptyModel                            `tfsdk:"manual"`
	VNET   *AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel `tfsdk:"vnet"`
}

// AzureVNETSiteIngressEgressGwHubSpokeVnetsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubSpokeVnetsModel
var AzureVNETSiteIngressEgressGwHubSpokeVnetsModelAttrTypes = map[string]attr.Type{
	"auto":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"labels": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"manual": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"vnet":   types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel represents vnet block
type AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel struct {
	ResourceGroup         types.String             `tfsdk:"resource_group"`
	VNETName              types.String             `tfsdk:"vnet_name"`
	F5OrchestratedRouting *AzureVNETSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	ManualRouting         *AzureVNETSiteEmptyModel `tfsdk:"manual_routing"`
}

// AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel
var AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModelAttrTypes = map[string]attr.Type{
	"resource_group":          types.StringType,
	"vnet_name":               types.StringType,
	"f5_orchestrated_routing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"manual_routing":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesModel represents inside_static_routes block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                         `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                   `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                     `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                              `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                          `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                    `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                      `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                               `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                       `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel
var AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel
var AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArModel represents ingress_egress_gw_ar block
type AzureVNETSiteIngressEgressGwArModel struct {
	AzureCertifiedHw               types.String                                                       `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	DcClusterGroupInsideVn         *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel         `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn        *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel        `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                           `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel              `tfsdk:"global_network_list"`
	Hub                            *AzureVNETSiteIngressEgressGwArHubModel                            `tfsdk:"hub"`
	InsideStaticRoutes             *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel             `tfsdk:"inside_static_routes"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                           `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                           `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                           `tfsdk:"no_global_network"`
	NoInsideStaticRoutes           *AzureVNETSiteEmptyModel                                           `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                           `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                           `tfsdk:"no_outside_static_routes"`
	Node                           *AzureVNETSiteIngressEgressGwArNodeModel                           `tfsdk:"node"`
	NotHub                         *AzureVNETSiteEmptyModel                                           `tfsdk:"not_hub"`
	OutsideStaticRoutes            *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	PerformanceEnhancementMode     *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel     `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                           `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                           `tfsdk:"sm_connection_pvt_ip"`
}

// AzureVNETSiteIngressEgressGwArModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArModel
var AzureVNETSiteIngressEgressGwArModelAttrTypes = map[string]attr.Type{
	"azure_certified_hw":                types.StringType,
	"accelerated_networking":            types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModelAttrTypes},
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModelAttrTypes},
	"dc_cluster_group_inside_vn":        types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModelAttrTypes},
	"dc_cluster_group_outside_vn":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModelAttrTypes},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArGlobalNetworkListModelAttrTypes},
	"hub":                               types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubModelAttrTypes},
	"inside_static_routes":              types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_inside_static_routes":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"node":                              types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeModelAttrTypes},
	"not_hub":                           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":             types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModelAttrTypes},
	"performance_enhancement_mode":      types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel
var AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModelAttrTypes = map[string]attr.Type{
	"disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel
var AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel
var AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel
var AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel
var AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel
var AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel
var AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel
var AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArGlobalNetworkListModel
var AzureVNETSiteIngressEgressGwArGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel
var AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubModel represents hub block
type AzureVNETSiteIngressEgressGwArHubModel struct {
	ExpressRouteDisabled *AzureVNETSiteEmptyModel                                   `tfsdk:"express_route_disabled"`
	ExpressRouteEnabled  *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel `tfsdk:"express_route_enabled"`
	SpokeVnets           []AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel         `tfsdk:"spoke_vnets"`
}

// AzureVNETSiteIngressEgressGwArHubModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubModel
var AzureVNETSiteIngressEgressGwArHubModelAttrTypes = map[string]attr.Type{
	"express_route_disabled": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"express_route_enabled":  types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModelAttrTypes},
	"spoke_vnets":            types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubSpokeVnetsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel represents express_route_enabled block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel struct {
	CustomAsn                        types.Int64                                                                                `tfsdk:"custom_asn"`
	AdvertiseToRouteServer           *AzureVNETSiteEmptyModel                                                                   `tfsdk:"advertise_to_route_server"`
	AutoAsn                          *AzureVNETSiteEmptyModel                                                                   `tfsdk:"auto_asn"`
	Connections                      []AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel                     `tfsdk:"connections"`
	DoNotAdvertiseToRouteServer      *AzureVNETSiteEmptyModel                                                                   `tfsdk:"do_not_advertise_to_route_server"`
	GatewaySubnet                    *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel                    `tfsdk:"gateway_subnet"`
	RouteServerSubnet                *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel                `tfsdk:"route_server_subnet"`
	SiteRegistrationOverExpressRoute *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel `tfsdk:"site_registration_over_express_route"`
	SiteRegistrationOverInternet     *AzureVNETSiteEmptyModel                                                                   `tfsdk:"site_registration_over_internet"`
	SkuErgw1az                       *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_ergw1az"`
	SkuErgw2az                       *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_ergw2az"`
	SkuHighPerf                      *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_high_perf"`
	SkuStandard                      *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_standard"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModelAttrTypes = map[string]attr.Type{
	"custom_asn":                           types.Int64Type,
	"advertise_to_route_server":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"auto_asn":                             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"connections":                          types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModelAttrTypes}},
	"do_not_advertise_to_route_server":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"gateway_subnet":                       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModelAttrTypes},
	"route_server_subnet":                  types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModelAttrTypes},
	"site_registration_over_express_route": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModelAttrTypes},
	"site_registration_over_internet":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_ergw1az":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_ergw2az":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_high_perf":                        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sku_standard":                         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel represents connections block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel struct {
	CircuitID         types.String                                                                           `tfsdk:"circuit_id"`
	Weight            types.Int64                                                                            `tfsdk:"weight"`
	Metadata          *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel          `tfsdk:"metadata"`
	OtherSubscription *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel `tfsdk:"other_subscription"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModelAttrTypes = map[string]attr.Type{
	"circuit_id":         types.StringType,
	"weight":             types.Int64Type,
	"metadata":           types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModelAttrTypes},
	"other_subscription": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel represents metadata block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel represents other_subscription block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel struct {
	CircuitID     types.String                                                                                        `tfsdk:"circuit_id"`
	AuthorizedKey *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel `tfsdk:"authorized_key"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModelAttrTypes = map[string]attr.Type{
	"circuit_id":     types.StringType,
	"authorized_key": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel represents authorized_key block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel struct {
	BlindfoldSecretInfo *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel represents clear_secret_info block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel represents gateway_subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                           `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModelAttrTypes = map[string]attr.Type{
	"auto":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel represents route_server_subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                               `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModelAttrTypes = map[string]attr.Type{
	"auto":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel represents site_registration_over_express_route block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel
var AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModelAttrTypes = map[string]attr.Type{
	"cloudlink_network_name": types.StringType,
}

// AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel represents spoke_vnets block
type AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel struct {
	Auto   *AzureVNETSiteEmptyModel                              `tfsdk:"auto"`
	Labels *AzureVNETSiteEmptyModel                              `tfsdk:"labels"`
	Manual *AzureVNETSiteEmptyModel                              `tfsdk:"manual"`
	VNET   *AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel `tfsdk:"vnet"`
}

// AzureVNETSiteIngressEgressGwArHubSpokeVnetsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel
var AzureVNETSiteIngressEgressGwArHubSpokeVnetsModelAttrTypes = map[string]attr.Type{
	"auto":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"labels": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"manual": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"vnet":   types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel represents vnet block
type AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel struct {
	ResourceGroup         types.String             `tfsdk:"resource_group"`
	VNETName              types.String             `tfsdk:"vnet_name"`
	F5OrchestratedRouting *AzureVNETSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	ManualRouting         *AzureVNETSiteEmptyModel `tfsdk:"manual_routing"`
}

// AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel
var AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModelAttrTypes = map[string]attr.Type{
	"resource_group":          types.StringType,
	"vnet_name":               types.StringType,
	"f5_orchestrated_routing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"manual_routing":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel represents inside_static_routes block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                           `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                     `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                       `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwArNodeModel represents node block
type AzureVNETSiteIngressEgressGwArNodeModel struct {
	FaultDomain   types.Int64                                           `tfsdk:"fault_domain"`
	NodeNumber    types.Int64                                           `tfsdk:"node_number"`
	UpdateDomain  types.Int64                                           `tfsdk:"update_domain"`
	InsideSubnet  *AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel  `tfsdk:"inside_subnet"`
	OutsideSubnet *AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel `tfsdk:"outside_subnet"`
}

// AzureVNETSiteIngressEgressGwArNodeModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeModel
var AzureVNETSiteIngressEgressGwArNodeModelAttrTypes = map[string]attr.Type{
	"fault_domain":   types.Int64Type,
	"node_number":    types.Int64Type,
	"update_domain":  types.Int64Type,
	"inside_subnet":  types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeInsideSubnetModelAttrTypes},
	"outside_subnet": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel represents inside_subnet block
type AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel
var AzureVNETSiteIngressEgressGwArNodeInsideSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel
var AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel represents outside_subnet block
type AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel
var AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel
var AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel
var AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                            `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                      `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                        `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                 `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                         `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel
var AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel
var AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwModel represents ingress_gw block
type AzureVNETSiteIngressGwModel struct {
	AzureCertifiedHw           types.String                                           `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking      *AzureVNETSiteIngressGwAcceleratedNetworkingModel      `tfsdk:"accelerated_networking"`
	AzNodes                    []AzureVNETSiteIngressGwAzNodesModel                   `tfsdk:"az_nodes"`
	PerformanceEnhancementMode *AzureVNETSiteIngressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// AzureVNETSiteIngressGwModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwModel
var AzureVNETSiteIngressGwModelAttrTypes = map[string]attr.Type{
	"azure_certified_hw":           types.StringType,
	"accelerated_networking":       types.ObjectType{AttrTypes: AzureVNETSiteIngressGwAcceleratedNetworkingModelAttrTypes},
	"az_nodes":                     types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteIngressGwAzNodesModelAttrTypes}},
	"performance_enhancement_mode": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwPerformanceEnhancementModeModelAttrTypes},
}

// AzureVNETSiteIngressGwAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressGwAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressGwAcceleratedNetworkingModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwAcceleratedNetworkingModel
var AzureVNETSiteIngressGwAcceleratedNetworkingModelAttrTypes = map[string]attr.Type{
	"disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwAzNodesModel represents az_nodes block
type AzureVNETSiteIngressGwAzNodesModel struct {
	AzureAz     types.String                                   `tfsdk:"azure_az"`
	LocalSubnet *AzureVNETSiteIngressGwAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteIngressGwAzNodesModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwAzNodesModel
var AzureVNETSiteIngressGwAzNodesModelAttrTypes = map[string]attr.Type{
	"azure_az":     types.StringType,
	"local_subnet": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwAzNodesLocalSubnetModelAttrTypes},
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetModel represents local_subnet block
type AzureVNETSiteIngressGwAzNodesLocalSubnetModel struct {
	Subnet      *AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwAzNodesLocalSubnetModel
var AzureVNETSiteIngressGwAzNodesLocalSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel
var AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel
var AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                 `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressGwPerformanceEnhancementModeModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwPerformanceEnhancementModeModel
var AzureVNETSiteIngressGwPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel
var AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwArModel represents ingress_gw_ar block
type AzureVNETSiteIngressGwArModel struct {
	AzureCertifiedHw           types.String                                             `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking      *AzureVNETSiteIngressGwArAcceleratedNetworkingModel      `tfsdk:"accelerated_networking"`
	Node                       *AzureVNETSiteIngressGwArNodeModel                       `tfsdk:"node"`
	PerformanceEnhancementMode *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// AzureVNETSiteIngressGwArModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArModel
var AzureVNETSiteIngressGwArModelAttrTypes = map[string]attr.Type{
	"azure_certified_hw":           types.StringType,
	"accelerated_networking":       types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArAcceleratedNetworkingModelAttrTypes},
	"node":                         types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArNodeModelAttrTypes},
	"performance_enhancement_mode": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArPerformanceEnhancementModeModelAttrTypes},
}

// AzureVNETSiteIngressGwArAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressGwArAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressGwArAcceleratedNetworkingModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArAcceleratedNetworkingModel
var AzureVNETSiteIngressGwArAcceleratedNetworkingModelAttrTypes = map[string]attr.Type{
	"disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwArNodeModel represents node block
type AzureVNETSiteIngressGwArNodeModel struct {
	FaultDomain  types.Int64                                   `tfsdk:"fault_domain"`
	NodeNumber   types.Int64                                   `tfsdk:"node_number"`
	UpdateDomain types.Int64                                   `tfsdk:"update_domain"`
	LocalSubnet  *AzureVNETSiteIngressGwArNodeLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteIngressGwArNodeModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArNodeModel
var AzureVNETSiteIngressGwArNodeModelAttrTypes = map[string]attr.Type{
	"fault_domain":  types.Int64Type,
	"node_number":   types.Int64Type,
	"update_domain": types.Int64Type,
	"local_subnet":  types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArNodeLocalSubnetModelAttrTypes},
}

// AzureVNETSiteIngressGwArNodeLocalSubnetModel represents local_subnet block
type AzureVNETSiteIngressGwArNodeLocalSubnetModel struct {
	Subnet      *AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressGwArNodeLocalSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArNodeLocalSubnetModel
var AzureVNETSiteIngressGwArNodeLocalSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel
var AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel
var AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteIngressGwArPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressGwArPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                   `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressGwArPerformanceEnhancementModeModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArPerformanceEnhancementModeModel
var AzureVNETSiteIngressGwArPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel
var AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type AzureVNETSiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *AzureVNETSiteEmptyModel                                    `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain  *AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// AzureVNETSiteKubernetesUpgradeDrainModelAttrTypes defines the attribute types for AzureVNETSiteKubernetesUpgradeDrainModel
var AzureVNETSiteKubernetesUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"disable_upgrade_drain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_upgrade_drain":  types.ObjectType{AttrTypes: AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes},
}

// AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64              `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout             types.Int64              `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode       *AzureVNETSiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode        *AzureVNETSiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes defines the attribute types for AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel
var AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"drain_max_unavailable_node_count": types.Int64Type,
	"drain_node_timeout":               types.Int64Type,
	"disable_vega_upgrade_mode":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_vega_upgrade_mode":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteLogReceiverModel represents log_receiver block
type AzureVNETSiteLogReceiverModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteLogReceiverModelAttrTypes defines the attribute types for AzureVNETSiteLogReceiverModel
var AzureVNETSiteLogReceiverModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type AzureVNETSiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *AzureVNETSiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode     *AzureVNETSiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// AzureVNETSiteOfflineSurvivabilityModeModelAttrTypes defines the attribute types for AzureVNETSiteOfflineSurvivabilityModeModel
var AzureVNETSiteOfflineSurvivabilityModeModelAttrTypes = map[string]attr.Type{
	"enable_offline_survivability_mode": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_offline_survivability_mode":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteOSModel represents os block
type AzureVNETSiteOSModel struct {
	OperatingSystemVersion types.String             `tfsdk:"operating_system_version"`
	DefaultOSVersion       *AzureVNETSiteEmptyModel `tfsdk:"default_os_version"`
}

// AzureVNETSiteOSModelAttrTypes defines the attribute types for AzureVNETSiteOSModel
var AzureVNETSiteOSModelAttrTypes = map[string]attr.Type{
	"operating_system_version": types.StringType,
	"default_os_version":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteSwModel represents sw block
type AzureVNETSiteSwModel struct {
	VolterraSoftwareVersion types.String             `tfsdk:"volterra_software_version"`
	DefaultSwVersion        *AzureVNETSiteEmptyModel `tfsdk:"default_sw_version"`
}

// AzureVNETSiteSwModelAttrTypes defines the attribute types for AzureVNETSiteSwModel
var AzureVNETSiteSwModelAttrTypes = map[string]attr.Type{
	"volterra_software_version": types.StringType,
	"default_sw_version":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVNETModel represents vnet block
type AzureVNETSiteVNETModel struct {
	ExistingVNET *AzureVNETSiteVNETExistingVNETModel `tfsdk:"existing_vnet"`
	NewVNET      *AzureVNETSiteVNETNewVNETModel      `tfsdk:"new_vnet"`
}

// AzureVNETSiteVNETModelAttrTypes defines the attribute types for AzureVNETSiteVNETModel
var AzureVNETSiteVNETModelAttrTypes = map[string]attr.Type{
	"existing_vnet": types.ObjectType{AttrTypes: AzureVNETSiteVNETExistingVNETModelAttrTypes},
	"new_vnet":      types.ObjectType{AttrTypes: AzureVNETSiteVNETNewVNETModelAttrTypes},
}

// AzureVNETSiteVNETExistingVNETModel represents existing_vnet block
type AzureVNETSiteVNETExistingVNETModel struct {
	ResourceGroup         types.String             `tfsdk:"resource_group"`
	VNETName              types.String             `tfsdk:"vnet_name"`
	F5OrchestratedRouting *AzureVNETSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	ManualRouting         *AzureVNETSiteEmptyModel `tfsdk:"manual_routing"`
}

// AzureVNETSiteVNETExistingVNETModelAttrTypes defines the attribute types for AzureVNETSiteVNETExistingVNETModel
var AzureVNETSiteVNETExistingVNETModelAttrTypes = map[string]attr.Type{
	"resource_group":          types.StringType,
	"vnet_name":               types.StringType,
	"f5_orchestrated_routing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"manual_routing":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVNETNewVNETModel represents new_vnet block
type AzureVNETSiteVNETNewVNETModel struct {
	Name         types.String             `tfsdk:"name"`
	PrimaryIpv4  types.String             `tfsdk:"primary_ipv4"`
	Autogenerate *AzureVNETSiteEmptyModel `tfsdk:"autogenerate"`
}

// AzureVNETSiteVNETNewVNETModelAttrTypes defines the attribute types for AzureVNETSiteVNETNewVNETModel
var AzureVNETSiteVNETNewVNETModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"primary_ipv4": types.StringType,
	"autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVoltstackClusterModel represents voltstack_cluster block
type AzureVNETSiteVoltstackClusterModel struct {
	AzureCertifiedHw               types.String                                                      `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	AzNodes                        []AzureVNETSiteVoltstackClusterAzNodesModel                       `tfsdk:"az_nodes"`
	DcClusterGroup                 *AzureVNETSiteVoltstackClusterDcClusterGroupModel                 `tfsdk:"dc_cluster_group"`
	DefaultStorage                 *AzureVNETSiteEmptyModel                                          `tfsdk:"default_storage"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                          `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteVoltstackClusterGlobalNetworkListModel              `tfsdk:"global_network_list"`
	K8SCluster                     *AzureVNETSiteVoltstackClusterK8SClusterModel                     `tfsdk:"k8s_cluster"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                          `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                          `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                          `tfsdk:"no_global_network"`
	NoK8SCluster                   *AzureVNETSiteEmptyModel                                          `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                          `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                          `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes            *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                          `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                          `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList               *AzureVNETSiteVoltstackClusterStorageClassListModel               `tfsdk:"storage_class_list"`
}

// AzureVNETSiteVoltstackClusterModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterModel
var AzureVNETSiteVoltstackClusterModelAttrTypes = map[string]attr.Type{
	"azure_certified_hw":                types.StringType,
	"accelerated_networking":            types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterAcceleratedNetworkingModelAttrTypes},
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes},
	"az_nodes":                          types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterAzNodesModelAttrTypes}},
	"dc_cluster_group":                  types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterDcClusterGroupModelAttrTypes},
	"default_storage":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterGlobalNetworkListModelAttrTypes},
	"k8s_cluster":                       types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterK8SClusterModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_k8s_cluster":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":             types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"storage_class_list":                types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterStorageClassListModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteVoltstackClusterAcceleratedNetworkingModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel
var AzureVNETSiteVoltstackClusterAcceleratedNetworkingModelAttrTypes = map[string]attr.Type{
	"disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel
var AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel
var AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel
var AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel
var AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel
var AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterAzNodesModel represents az_nodes block
type AzureVNETSiteVoltstackClusterAzNodesModel struct {
	AzureAz     types.String                                          `tfsdk:"azure_az"`
	LocalSubnet *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteVoltstackClusterAzNodesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterAzNodesModel
var AzureVNETSiteVoltstackClusterAzNodesModelAttrTypes = map[string]attr.Type{
	"azure_az":     types.StringType,
	"local_subnet": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel represents local_subnet block
type AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel struct {
	Subnet      *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel
var AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel
var AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel
var AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteVoltstackClusterDcClusterGroupModel represents dc_cluster_group block
type AzureVNETSiteVoltstackClusterDcClusterGroupModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterDcClusterGroupModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterDcClusterGroupModel
var AzureVNETSiteVoltstackClusterDcClusterGroupModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteVoltstackClusterGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterGlobalNetworkListModel
var AzureVNETSiteVoltstackClusterGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel
var AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterK8SClusterModel represents k8s_cluster block
type AzureVNETSiteVoltstackClusterK8SClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterK8SClusterModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterK8SClusterModel
var AzureVNETSiteVoltstackClusterK8SClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                           `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                     `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                       `tfsdk:"labels"`
	Nexthop *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                `tfsdk:"type"`
	Interface      []AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteVoltstackClusterStorageClassListModel represents storage_class_list block
type AzureVNETSiteVoltstackClusterStorageClassListModel struct {
	StorageClasses []AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// AzureVNETSiteVoltstackClusterStorageClassListModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterStorageClassListModel
var AzureVNETSiteVoltstackClusterStorageClassListModelAttrTypes = map[string]attr.Type{
	"storage_classes": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel represents storage_classes block
type AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool   `tfsdk:"default_storage_class"`
	StorageClassName    types.String `tfsdk:"storage_class_name"`
}

// AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel
var AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes = map[string]attr.Type{
	"default_storage_class": types.BoolType,
	"storage_class_name":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArModel represents voltstack_cluster_ar block
type AzureVNETSiteVoltstackClusterArModel struct {
	AzureCertifiedHw               types.String                                                        `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	DcClusterGroup                 *AzureVNETSiteVoltstackClusterArDcClusterGroupModel                 `tfsdk:"dc_cluster_group"`
	DefaultStorage                 *AzureVNETSiteEmptyModel                                            `tfsdk:"default_storage"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                            `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel              `tfsdk:"global_network_list"`
	K8SCluster                     *AzureVNETSiteVoltstackClusterArK8SClusterModel                     `tfsdk:"k8s_cluster"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                            `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                            `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                            `tfsdk:"no_global_network"`
	NoK8SCluster                   *AzureVNETSiteEmptyModel                                            `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                            `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                            `tfsdk:"no_outside_static_routes"`
	Node                           *AzureVNETSiteVoltstackClusterArNodeModel                           `tfsdk:"node"`
	OutsideStaticRoutes            *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                            `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                            `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList               *AzureVNETSiteVoltstackClusterArStorageClassListModel               `tfsdk:"storage_class_list"`
}

// AzureVNETSiteVoltstackClusterArModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArModel
var AzureVNETSiteVoltstackClusterArModelAttrTypes = map[string]attr.Type{
	"azure_certified_hw":                types.StringType,
	"accelerated_networking":            types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModelAttrTypes},
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModelAttrTypes},
	"dc_cluster_group":                  types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArDcClusterGroupModelAttrTypes},
	"default_storage":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArGlobalNetworkListModelAttrTypes},
	"k8s_cluster":                       types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArK8SClusterModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_k8s_cluster":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"node":                              types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArNodeModelAttrTypes},
	"outside_static_routes":             types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"storage_class_list":                types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArStorageClassListModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel
var AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModelAttrTypes = map[string]attr.Type{
	"disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel
var AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel
var AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel
var AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel
var AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel
var AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArDcClusterGroupModel represents dc_cluster_group block
type AzureVNETSiteVoltstackClusterArDcClusterGroupModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArDcClusterGroupModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArDcClusterGroupModel
var AzureVNETSiteVoltstackClusterArDcClusterGroupModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArGlobalNetworkListModel
var AzureVNETSiteVoltstackClusterArGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel
var AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArK8SClusterModel represents k8s_cluster block
type AzureVNETSiteVoltstackClusterArK8SClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArK8SClusterModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArK8SClusterModel
var AzureVNETSiteVoltstackClusterArK8SClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// AzureVNETSiteVoltstackClusterArNodeModel represents node block
type AzureVNETSiteVoltstackClusterArNodeModel struct {
	FaultDomain  types.Int64                                          `tfsdk:"fault_domain"`
	NodeNumber   types.Int64                                          `tfsdk:"node_number"`
	UpdateDomain types.Int64                                          `tfsdk:"update_domain"`
	LocalSubnet  *AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteVoltstackClusterArNodeModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArNodeModel
var AzureVNETSiteVoltstackClusterArNodeModelAttrTypes = map[string]attr.Type{
	"fault_domain":  types.Int64Type,
	"node_number":   types.Int64Type,
	"update_domain": types.Int64Type,
	"local_subnet":  types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArNodeLocalSubnetModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel represents local_subnet block
type AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel struct {
	Subnet      *AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel
var AzureVNETSiteVoltstackClusterArNodeLocalSubnetModelAttrTypes = map[string]attr.Type{
	"subnet":       types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModelAttrTypes},
	"subnet_param": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel
var AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name":         types.StringType,
	"subnet_resource_grp": types.StringType,
	"vnet_resource_group": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel
var AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                             `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                       `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                         `tfsdk:"labels"`
	Nexthop *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                  `tfsdk:"type"`
	Interface      []AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// AzureVNETSiteVoltstackClusterArStorageClassListModel represents storage_class_list block
type AzureVNETSiteVoltstackClusterArStorageClassListModel struct {
	StorageClasses []AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// AzureVNETSiteVoltstackClusterArStorageClassListModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArStorageClassListModel
var AzureVNETSiteVoltstackClusterArStorageClassListModelAttrTypes = map[string]attr.Type{
	"storage_classes": types.ListType{ElemType: types.ObjectType{AttrTypes: AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModelAttrTypes}},
}

// AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel represents storage_classes block
type AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool   `tfsdk:"default_storage_class"`
	StorageClassName    types.String `tfsdk:"storage_class_name"`
}

// AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModelAttrTypes defines the attribute types for AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel
var AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModelAttrTypes = map[string]attr.Type{
	"default_storage_class": types.BoolType,
	"storage_class_name":    types.StringType,
}

type AzureVNETSiteResourceModel struct {
	Name                     types.String                                `tfsdk:"name"`
	Namespace                types.String                                `tfsdk:"namespace"`
	Annotations              types.Map                                   `tfsdk:"annotations"`
	Description              types.String                                `tfsdk:"description"`
	Disable                  types.Bool                                  `tfsdk:"disable"`
	Labels                   types.Map                                   `tfsdk:"labels"`
	ID                       types.String                                `tfsdk:"id"`
	Address                  types.String                                `tfsdk:"address"`
	AlternateRegion          types.String                                `tfsdk:"alternate_region"`
	AzureRegion              types.String                                `tfsdk:"azure_region"`
	DiskSize                 types.Int64                                 `tfsdk:"disk_size"`
	MachineType              types.String                                `tfsdk:"machine_type"`
	NodesPerAz               types.Int64                                 `tfsdk:"nodes_per_az"`
	ResourceGroup            types.String                                `tfsdk:"resource_group"`
	SSHKey                   types.String                                `tfsdk:"ssh_key"`
	TotalNodes               types.Int64                                 `tfsdk:"total_nodes"`
	Timeouts                 timeouts.Value                              `tfsdk:"timeouts"`
	AdminPassword            *AzureVNETSiteAdminPasswordModel            `tfsdk:"admin_password"`
	AzureCred                *AzureVNETSiteAzureCredModel                `tfsdk:"azure_cred"`
	BlockAllServices         *AzureVNETSiteEmptyModel                    `tfsdk:"block_all_services"`
	BlockedServices          *AzureVNETSiteBlockedServicesModel          `tfsdk:"blocked_services"`
	Coordinates              *AzureVNETSiteCoordinatesModel              `tfsdk:"coordinates"`
	CustomDNS                *AzureVNETSiteCustomDNSModel                `tfsdk:"custom_dns"`
	DefaultBlockedServices   *AzureVNETSiteEmptyModel                    `tfsdk:"default_blocked_services"`
	IngressEgressGw          *AzureVNETSiteIngressEgressGwModel          `tfsdk:"ingress_egress_gw"`
	IngressEgressGwAr        *AzureVNETSiteIngressEgressGwArModel        `tfsdk:"ingress_egress_gw_ar"`
	IngressGw                *AzureVNETSiteIngressGwModel                `tfsdk:"ingress_gw"`
	IngressGwAr              *AzureVNETSiteIngressGwArModel              `tfsdk:"ingress_gw_ar"`
	KubernetesUpgradeDrain   *AzureVNETSiteKubernetesUpgradeDrainModel   `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver              *AzureVNETSiteLogReceiverModel              `tfsdk:"log_receiver"`
	LogsStreamingDisabled    *AzureVNETSiteEmptyModel                    `tfsdk:"logs_streaming_disabled"`
	NoWorkerNodes            *AzureVNETSiteEmptyModel                    `tfsdk:"no_worker_nodes"`
	OfflineSurvivabilityMode *AzureVNETSiteOfflineSurvivabilityModeModel `tfsdk:"offline_survivability_mode"`
	OS                       *AzureVNETSiteOSModel                       `tfsdk:"os"`
	Sw                       *AzureVNETSiteSwModel                       `tfsdk:"sw"`
	Tags                     *AzureVNETSiteEmptyModel                    `tfsdk:"tags"`
	VNET                     *AzureVNETSiteVNETModel                     `tfsdk:"vnet"`
	VoltstackCluster         *AzureVNETSiteVoltstackClusterModel         `tfsdk:"voltstack_cluster"`
	VoltstackClusterAr       *AzureVNETSiteVoltstackClusterArModel       `tfsdk:"voltstack_cluster_ar"`
}

func (r *AzureVNETSiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_azure_vnet_site"
}

func (r *AzureVNETSiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             azure_vnet_siteSchemaVersion,
		MarkdownDescription: "Manages a Azure VNET Site resource in F5 Distributed Cloud for deploying F5 sites within Azure Virtual Network environments.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Azure VNET Site. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Azure VNET Site will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "Geographical Address. Site's geographical address that can be used to determine its latitude and longitude.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"alternate_region": schema.StringAttribute{
				MarkdownDescription: "[OneOf: alternate_region, azure_region] Alternate Azure Region Name. Name of the Azure region which does not support availability zones.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"azure_region": schema.StringAttribute{
				MarkdownDescription: "Recommended Azure Region Name. Name of the Azure region which supports availability zones.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"disk_size": schema.Int64Attribute{
				MarkdownDescription: "Cloud Disk Size. Disk size to be used for this instance in GiB. 80 is 80 GiB.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"machine_type": schema.StringAttribute{
				MarkdownDescription: "Azure Machine Type for Node. Select Instance size based on performance needed. The default setting for Accelerated Networking is enabled, thus make sure you select a Virtual Machine that supports accelerated networking or disable the setting under, Select Ingress Gateway or Ingress/Egress Gateway > advanced OPTIONS.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"nodes_per_az": schema.Int64Attribute{
				MarkdownDescription: "Desired Worker Nodes Per AZ. Desired Worker Nodes Per AZ. Max limit is up to 21.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"resource_group": schema.StringAttribute{
				MarkdownDescription: "Resource Group. Azure resource group for resources that will be created .",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ssh_key": schema.StringAttribute{
				MarkdownDescription: "Public SSH key. Public SSH key for accessing the site.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"total_nodes": schema.Int64Attribute{
				MarkdownDescription: "Total Number of Worker Nodes for a Site. Total number of worker nodes to be deployed across all AZ's used in the Site.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"admin_password": schema.SingleNestedBlock{
				MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blindfold_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
						Attributes: map[string]schema.Attribute{
							"decryption_provider": schema.StringAttribute{
								MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
								Optional:            true,
							},
							"location": schema.StringAttribute{
								MarkdownDescription: "Location. Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
								Optional:            true,
							},
							"store_provider": schema.StringAttribute{
								MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
								Optional:            true,
							},
						},
					},
					"clear_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
						Attributes: map[string]schema.Attribute{
							"provider_ref": schema.StringAttribute{
								MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
								Optional:            true,
							},
							"url": schema.StringAttribute{
								MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
								Optional:            true,
							},
						},
					},
				},
			},
			"azure_cred": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services; Default: default_blocked_services] Enable this option",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable Node Local Services. Disable node local services on this site. Note: The chosen services will GET disabled on all nodes in the site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services. Blocking or denial configuration",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "[Enum: VIRTUAL_NETWORK_SITE_LOCAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE|VIRTUAL_NETWORK_PER_SITE|VIRTUAL_NETWORK_PUBLIC|VIRTUAL_NETWORK_GLOBAL|VIRTUAL_NETWORK_SITE_SERVICE|VIRTUAL_NETWORK_VER_INTERNAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE|VIRTUAL_NETWORK_IP_AUTO|VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK|VIRTUAL_NETWORK_SRV6_NETWORK|VIRTUAL_NETWORK_IP_FABRIC|VIRTUAL_NETWORK_SEGMENT] Virtual Network Type. Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created automatically and present on all sites Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site. It is a secure network and is not connected to public network. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created during provisioning of site User defined per-site virtual network. Scope of this virtual network is limited to the site. This is not yet supported Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on RE sites only It is an internally created by the system. They must not be created by user Virtual Neworks with global scope across different sites in F5XC domain. An example global virtual-network called 'AIN Network' is created for every tenant. For F5 Distributed Cloud fabric Constraints: It is currently only supported as internally created by the system. VK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant Constraints: It is an internally created by the system. Must not be created by user VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy Constraints: It is an internally created by the system. Must not be created by user Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE Constraints: This network type is only meaningful in an advertise policy When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for an endpoint, VER will try to determine the network based on the provided IP address Constraints: This network type is only meaningful in an endpoint VoltADN Private Network is used on F5 Distributed Cloud RE(s) to connect to customer private networks This network is created by opening a support ticket This network is per site srv6 network VER IP Fabric network for the site. This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network Constraints: It is an internally created by the system. Must not be created by user Network internally created for a segment Constraints: It is an internally created by the system. Must not be created by user. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
				},
			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Site Coordinates. Coordinates of the site which provides the site physical location.",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location.",
						Optional:            true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. Longitude of site location.",
						Optional:            true,
					},
				},
			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS. Custom DNS is the configured for specify CE site.",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Inside Network. Optional DNS server IP to be used for name resolution in inside network.",
						Optional:            true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Outside Network. Optional DNS server IP to be used for name resolution in outside network.",
						Optional:            true,
					},
				},
			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"ingress_egress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ingress_egress_gw, ingress_egress_gw_ar, ingress_gw, ingress_gw_ar, voltstack_cluster, voltstack_cluster_ar] Azure Ingress/Egress Gateway on Recommended Region. Two interface Azure ingress/egress site.",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Ingress/Egress Gateway (two Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"azure_az": schema.StringAttribute{
									MarkdownDescription: "Azure Availability Zone. A zone depicting a grouping of datacenters within an Azure region. Expecting numeric input .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
								"outside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"hub": schema.SingleNestedBlock{
						MarkdownDescription: "Hub VNet type. Hub VNet type.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"express_route_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"express_route_enabled": schema.SingleNestedBlock{
								MarkdownDescription: "Express Route Configuration. Express Route Configuration.",
								Attributes: map[string]schema.Attribute{
									"custom_asn": schema.Int64Attribute{
										MarkdownDescription: "Custom ASN. Set custom ASN for F5XC Site.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"auto_asn": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"connections": schema.ListNestedBlock{
										MarkdownDescription: "Connections. Add the ExpressRoute Circuit Connections to this site .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"circuit_id": schema.StringAttribute{
													MarkdownDescription: "Circuit in same subscription. ExpressRoute Circuit is in same subscription as the site.",
													Optional:            true,
												},
												"weight": schema.Int64Attribute{
													MarkdownDescription: "Routing Weight. The weight (or priority) for the routes received from this connection. The. Defaults to `10`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"other_subscription": schema.SingleNestedBlock{
													MarkdownDescription: "Express Route Circuit Config From Other Subscription. Express Route Circuit Config From Other Subscription.",
													Attributes: map[string]schema.Attribute{
														"circuit_id": schema.StringAttribute{
															MarkdownDescription: "Circuit ID. Circuit ID.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"authorized_key": schema.SingleNestedBlock{
															MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional:            true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location. Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																			Optional:            true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"do_not_advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"gateway_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
														Optional:            true,
													},
												},
											},
										},
									},
									"route_server_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
														Optional:            true,
													},
												},
											},
										},
									},
									"site_registration_over_express_route": schema.SingleNestedBlock{
										MarkdownDescription: "CloudLink ADN Network Config.",
										Attributes: map[string]schema.Attribute{
											"cloudlink_network_name": schema.StringAttribute{
												MarkdownDescription: "Private ADN Network. Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
												Optional:            true,
											},
										},
									},
									"site_registration_over_internet": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_ergw1az": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_ergw2az": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_high_perf": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_standard": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"spoke_vnets": schema.ListNestedBlock{
								MarkdownDescription: "Spoke VNet Peering (Legacy). Spoke VNet Peering.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"auto": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"labels": schema.SingleNestedBlock{
											MarkdownDescription: "Labels For VNets Peering. Add Labels for each of the VNets peered with transit VNet, these labels can be used in firewall policy These labels used must be from known key and label defined in shared namespace.",
										},
										"manual": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"vnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Existing VNet Type. Resource group and name of existing Azure VNet.",
											Attributes: map[string]schema.Attribute{
												"resource_group": schema.StringAttribute{
													MarkdownDescription: "Existing VNet Resource Group. Resource group of existing VNet .",
													Optional:            true,
												},
												"vnet_name": schema.StringAttribute{
													MarkdownDescription: "Existing VNet Name. Name of existing VNet .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"f5_orchestrated_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"manual_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"not_hub": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"ingress_egress_gw_ar": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Ingress/Egress Gateway on Alternate Region. Two interface Azure ingress/egress site on Alternate Region with no support for zones.",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"hub": schema.SingleNestedBlock{
						MarkdownDescription: "Hub VNet type. Hub VNet type.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"express_route_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"express_route_enabled": schema.SingleNestedBlock{
								MarkdownDescription: "Express Route Configuration. Express Route Configuration.",
								Attributes: map[string]schema.Attribute{
									"custom_asn": schema.Int64Attribute{
										MarkdownDescription: "Custom ASN. Set custom ASN for F5XC Site.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"auto_asn": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"connections": schema.ListNestedBlock{
										MarkdownDescription: "Connections. Add the ExpressRoute Circuit Connections to this site .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"circuit_id": schema.StringAttribute{
													MarkdownDescription: "Circuit in same subscription. ExpressRoute Circuit is in same subscription as the site.",
													Optional:            true,
												},
												"weight": schema.Int64Attribute{
													MarkdownDescription: "Routing Weight. The weight (or priority) for the routes received from this connection. The. Defaults to `10`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"other_subscription": schema.SingleNestedBlock{
													MarkdownDescription: "Express Route Circuit Config From Other Subscription. Express Route Circuit Config From Other Subscription.",
													Attributes: map[string]schema.Attribute{
														"circuit_id": schema.StringAttribute{
															MarkdownDescription: "Circuit ID. Circuit ID.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"authorized_key": schema.SingleNestedBlock{
															MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional:            true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location. Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																			Optional:            true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"do_not_advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"gateway_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
														Optional:            true,
													},
												},
											},
										},
									},
									"route_server_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
														Optional:            true,
													},
												},
											},
										},
									},
									"site_registration_over_express_route": schema.SingleNestedBlock{
										MarkdownDescription: "CloudLink ADN Network Config.",
										Attributes: map[string]schema.Attribute{
											"cloudlink_network_name": schema.StringAttribute{
												MarkdownDescription: "Private ADN Network. Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
												Optional:            true,
											},
										},
									},
									"site_registration_over_internet": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_ergw1az": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_ergw2az": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_high_perf": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"sku_standard": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"spoke_vnets": schema.ListNestedBlock{
								MarkdownDescription: "Spoke VNet Peering (Legacy). Spoke VNet Peering.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"auto": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"labels": schema.SingleNestedBlock{
											MarkdownDescription: "Labels For VNets Peering. Add Labels for each of the VNets peered with transit VNet, these labels can be used in firewall policy These labels used must be from known key and label defined in shared namespace.",
										},
										"manual": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"vnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Existing VNet Type. Resource group and name of existing Azure VNet.",
											Attributes: map[string]schema.Attribute{
												"resource_group": schema.StringAttribute{
													MarkdownDescription: "Existing VNet Resource Group. Resource group of existing VNet .",
													Optional:            true,
												},
												"vnet_name": schema.StringAttribute{
													MarkdownDescription: "Existing VNet Name. Name of existing VNet .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"f5_orchestrated_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"manual_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"node": schema.SingleNestedBlock{
						MarkdownDescription: "Two Interface Node. Parameters for creating two interface Node in one AZ.",
						Attributes: map[string]schema.Attribute{
							"fault_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of fault domains. Namuber of fault domains to be used while creating the availability set.",
								Optional:            true,
							},
							"node_number": schema.Int64Attribute{
								MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
								Optional:            true,
							},
							"update_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of update domains. Namuber of update domains to be used while creating the availability set.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"inside_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
												Optional:            true,
											},
										},
									},
								},
							},
							"outside_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"not_hub": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"ingress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Ingress Gateway on Recommended Region. Single interface Azure ingress site on on Recommended Region.",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Ingress Gateway (One Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"azure_az": schema.StringAttribute{
									MarkdownDescription: "Azure Availability Zone. A zone depicting a grouping of datacenters within an Azure region. Expecting numeric input .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"ingress_gw_ar": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Ingress Gateway on Alternate Region. Single interface Azure ingress site.",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"node": schema.SingleNestedBlock{
						MarkdownDescription: "Single Interface Node for Alternate Region. Parameters for creating Single interface Node for Alternate Region.",
						Attributes: map[string]schema.Attribute{
							"fault_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of fault domains. Namuber of fault domains to be used while creating the availability set.",
								Optional:            true,
							},
							"node_number": schema.Int64Attribute{
								MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
								Optional:            true,
							},
							"update_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of update domains. Namuber of update domains to be used while creating the availability set.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"local_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Node by Node Upgrade. Specify how worker nodes within a site will be upgraded.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable Node by Node Upgrade. Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional:            true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Upgrade Wait Time. Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is recommended to use the default value).",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_worker_nodes": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_worker_nodes, nodes_per_az, total_nodes; Default: no_worker_nodes] Enable this option",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability Mode. Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7 days, even when the site is offline. The certificates needed to keep the services running on this site are signed using a local CA. Secrets would also be cached locally to handle the connectivity loss. When the mode is toggled, services will restart and traffic disruption will be seen.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Operating System Version. Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Operating System Version. Specify a OS version to be used e.g. 9.2024.6.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "F5XC Software Version. Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "F5XC Software Version. Specify a F5XC Software Version to be used e.g. Crt-20210329-1002.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"tags": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Tags. Azure Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in Azure console.",
			},
			"vnet": schema.SingleNestedBlock{
				MarkdownDescription: "Azure VNet choice. This defines choice about Azure VNet for a view.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"existing_vnet": schema.SingleNestedBlock{
						MarkdownDescription: "Azure Existing VNet Type. Resource group and name of existing Azure VNet.",
						Attributes: map[string]schema.Attribute{
							"resource_group": schema.StringAttribute{
								MarkdownDescription: "Existing VNet Resource Group. Resource group of existing VNet .",
								Optional:            true,
							},
							"vnet_name": schema.StringAttribute{
								MarkdownDescription: "Existing VNet Name. Name of existing VNet .",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"f5_orchestrated_routing": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"manual_routing": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"new_vnet": schema.SingleNestedBlock{
						MarkdownDescription: "Azure VNet Parameters. Parameters to create a new Azure VNet.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Choose VNet Name. Specify the VNet Name.",
								Optional:            true,
							},
							"primary_ipv4": schema.StringAttribute{
								MarkdownDescription: "IPv4 CIDR block. IPv4 CIDR block for this VNet. It has to be private address space.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"voltstack_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "Azure App Stack Cluster on Recommended Region. App Stack Cluster of single interface Azure nodes.",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "App Stack Cluster (One Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"azure_az": schema.StringAttribute{
									MarkdownDescription: "Azure Availability Zone. A zone depicting a grouping of datacenters within an Azure region. Expecting numeric input .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Storage Class List. Add additional custom storage classes in Kubernetes for this site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Default Storage Class. Make this storage class default storage class for the K8s cluster.",
											Optional:            true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Storage Class Name. Name of the storage class as it will appear in K8s.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
			"voltstack_cluster_ar": schema.SingleNestedBlock{
				MarkdownDescription: "Azure App Stack Cluster on Alternate Region. App Stack Cluster of single interface Azure nodes.",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"node": schema.SingleNestedBlock{
						MarkdownDescription: "Single Interface Node for Alternate Region. Parameters for creating Single interface Node for Alternate Region.",
						Attributes: map[string]schema.Attribute{
							"fault_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of fault domains. Namuber of fault domains to be used while creating the availability set.",
								Optional:            true,
							},
							"node_number": schema.Int64Attribute{
								MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
								Optional:            true,
							},
							"update_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of update domains. Namuber of update domains to be used while creating the availability set.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"local_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet.",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet.",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet .",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Storage Class List. Add additional custom storage classes in Kubernetes for this site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Default Storage Class. Make this storage class default storage class for the K8s cluster.",
											Optional:            true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Storage Class Name. Name of the storage class as it will appear in K8s.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *AzureVNETSiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AzureVNETSiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AzureVNETSiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the azure_vnet_site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AzureVNETSiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AzureVNETSiteResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AzureVNETSiteResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AzureVNETSiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating azure_vnet_site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.AzureVNETSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		createReq.Spec["admin_password"] = admin_passwordMap
	}
	if data.AzureCred != nil {
		azure_credMap := make(map[string]interface{})
		if !data.AzureCred.Name.IsNull() && !data.AzureCred.Name.IsUnknown() {
			azure_credMap["name"] = data.AzureCred.Name.ValueString()
		}
		if !data.AzureCred.Namespace.IsNull() && !data.AzureCred.Namespace.IsUnknown() {
			azure_credMap["namespace"] = data.AzureCred.Namespace.ValueString()
		}
		if !data.AzureCred.Tenant.IsNull() && !data.AzureCred.Tenant.IsUnknown() {
			azure_credMap["tenant"] = data.AzureCred.Tenant.ValueString()
		}
		createReq.Spec["azure_cred"] = azure_credMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		createReq.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		createReq.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		createReq.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		createReq.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		createReq.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.IngressEgressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressEgressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_egress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressEgressGw.AzureCertifiedHw.IsNull() && !data.IngressEgressGw.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["azure_certified_hw"] = data.IngressEgressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NotHub != nil {
			ingress_egress_gwMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressEgressGwAr != nil {
		ingress_egress_gw_arMap := make(map[string]interface{})
		if data.IngressEgressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.IngressEgressGwAr.AzureCertifiedHw.IsNull() && !data.IngressEgressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gw_arMap["azure_certified_hw"] = data.IngressEgressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGwAr.ForwardProxyAllowAll != nil {
			ingress_egress_gw_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGwAr.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGwAr.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.NoDcClusterGroup != nil {
			ingress_egress_gw_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoForwardProxy != nil {
			ingress_egress_gw_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoGlobalNetwork != nil {
			ingress_egress_gw_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoInsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoNetworkPolicy != nil {
			ingress_egress_gw_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoOutsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.Node.FaultDomain.IsNull() && !data.IngressEgressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressEgressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.NodeNumber.IsNull() && !data.IngressEgressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressEgressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.UpdateDomain.IsNull() && !data.IngressEgressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressEgressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_egress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressEgressGwAr.NotHub != nil {
			ingress_egress_gw_arMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGwAr.SmConnectionPublicIP != nil {
			ingress_egress_gw_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.SmConnectionPvtIP != nil {
			ingress_egress_gw_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["ingress_egress_gw_ar"] = ingress_egress_gw_arMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if data.IngressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if len(data.IngressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressGw.AzureCertifiedHw.IsNull() && !data.IngressGw.AzureCertifiedHw.IsUnknown() {
			ingress_gwMap["azure_certified_hw"] = data.IngressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		createReq.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.IngressGwAr != nil {
		ingress_gw_arMap := make(map[string]interface{})
		if data.IngressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if !data.IngressGwAr.AzureCertifiedHw.IsNull() && !data.IngressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_gw_arMap["azure_certified_hw"] = data.IngressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressGwAr.Node.FaultDomain.IsNull() && !data.IngressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressGwAr.Node.NodeNumber.IsNull() && !data.IngressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressGwAr.Node.UpdateDomain.IsNull() && !data.IngressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		createReq.Spec["ingress_gw_ar"] = ingress_gw_arMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		createReq.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		createReq.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		createReq.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.NoWorkerNodes != nil {
		no_worker_nodesMap := make(map[string]interface{})
		createReq.Spec["no_worker_nodes"] = no_worker_nodesMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		createReq.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		createReq.Spec["os"] = osMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		createReq.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		createReq.Spec["tags"] = tagsMap
	}
	if data.VNET != nil {
		vnetMap := make(map[string]interface{})
		if data.VNET.ExistingVNET != nil {
			existing_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.ExistingVNET.ResourceGroup.IsNull() && !data.VNET.ExistingVNET.ResourceGroup.IsUnknown() {
				existing_vnetNestedMap["resource_group"] = data.VNET.ExistingVNET.ResourceGroup.ValueString()
			}
			if !data.VNET.ExistingVNET.VNETName.IsNull() && !data.VNET.ExistingVNET.VNETName.IsUnknown() {
				existing_vnetNestedMap["vnet_name"] = data.VNET.ExistingVNET.VNETName.ValueString()
			}
			vnetMap["existing_vnet"] = existing_vnetNestedMap
		}
		if data.VNET.NewVNET != nil {
			new_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.NewVNET.Name.IsNull() && !data.VNET.NewVNET.Name.IsUnknown() {
				new_vnetNestedMap["name"] = data.VNET.NewVNET.Name.ValueString()
			}
			if !data.VNET.NewVNET.PrimaryIpv4.IsNull() && !data.VNET.NewVNET.PrimaryIpv4.IsUnknown() {
				new_vnetNestedMap["primary_ipv4"] = data.VNET.NewVNET.PrimaryIpv4.ValueString()
			}
			vnetMap["new_vnet"] = new_vnetNestedMap
		}
		createReq.Spec["vnet"] = vnetMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_clusterMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.VoltstackCluster.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.VoltstackCluster.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			voltstack_clusterMap["az_nodes"] = az_nodesList
		}
		if !data.VoltstackCluster.AzureCertifiedHw.IsNull() && !data.VoltstackCluster.AzureCertifiedHw.IsUnknown() {
			voltstack_clusterMap["azure_certified_hw"] = data.VoltstackCluster.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		createReq.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if data.VoltstackClusterAr != nil {
		voltstack_cluster_arMap := make(map[string]interface{})
		if data.VoltstackClusterAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.VoltstackClusterAr.AzureCertifiedHw.IsNull() && !data.VoltstackClusterAr.AzureCertifiedHw.IsUnknown() {
			voltstack_cluster_arMap["azure_certified_hw"] = data.VoltstackClusterAr.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackClusterAr.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.DcClusterGroup.Name.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackClusterAr.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackClusterAr.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackClusterAr.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_cluster_arMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackClusterAr.DefaultStorage != nil {
			voltstack_cluster_arMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.ForwardProxyAllowAll != nil {
			voltstack_cluster_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackClusterAr.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.K8SCluster.Name.IsNull() && !data.VoltstackClusterAr.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackClusterAr.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Namespace.IsNull() && !data.VoltstackClusterAr.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackClusterAr.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Tenant.IsNull() && !data.VoltstackClusterAr.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackClusterAr.K8SCluster.Tenant.ValueString()
			}
			voltstack_cluster_arMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackClusterAr.NoDcClusterGroup != nil {
			voltstack_cluster_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoForwardProxy != nil {
			voltstack_cluster_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoGlobalNetwork != nil {
			voltstack_cluster_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoK8SCluster != nil {
			voltstack_cluster_arMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoNetworkPolicy != nil {
			voltstack_cluster_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoOutsideStaticRoutes != nil {
			voltstack_cluster_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.Node.FaultDomain.IsNull() && !data.VoltstackClusterAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.VoltstackClusterAr.Node.FaultDomain.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.NodeNumber.IsNull() && !data.VoltstackClusterAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.VoltstackClusterAr.Node.NodeNumber.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.UpdateDomain.IsNull() && !data.VoltstackClusterAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.VoltstackClusterAr.Node.UpdateDomain.ValueInt64()
			}
			voltstack_cluster_arMap["node"] = nodeNestedMap
		}
		if data.VoltstackClusterAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackClusterAr.SmConnectionPublicIP != nil {
			voltstack_cluster_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.SmConnectionPvtIP != nil {
			voltstack_cluster_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["storage_class_list"] = storage_class_listNestedMap
		}
		createReq.Spec["voltstack_cluster_ar"] = voltstack_cluster_arMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		createReq.Spec["address"] = data.Address.ValueString()
	}
	if !data.AlternateRegion.IsNull() && !data.AlternateRegion.IsUnknown() {
		createReq.Spec["alternate_region"] = data.AlternateRegion.ValueString()
	}
	if !data.AzureRegion.IsNull() && !data.AzureRegion.IsUnknown() {
		createReq.Spec["azure_region"] = data.AzureRegion.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		createReq.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.MachineType.IsNull() && !data.MachineType.IsUnknown() {
		createReq.Spec["machine_type"] = data.MachineType.ValueString()
	}
	if !data.NodesPerAz.IsNull() && !data.NodesPerAz.IsUnknown() {
		createReq.Spec["nodes_per_az"] = data.NodesPerAz.ValueInt64()
	}
	if !data.ResourceGroup.IsNull() && !data.ResourceGroup.IsUnknown() {
		createReq.Spec["resource_group"] = data.ResourceGroup.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		createReq.Spec["ssh_key"] = data.SSHKey.ValueString()
	}
	if !data.TotalNodes.IsNull() && !data.TotalNodes.IsUnknown() {
		createReq.Spec["total_nodes"] = data.TotalNodes.ValueInt64()
	}

	apiResource, err := r.client.CreateAzureVNETSite(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AzureVNETSite: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AzureVNETSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["azure_cred"].(map[string]interface{}); ok && (isImport || data.AzureCred != nil) {
		data.AzureCred = &AzureVNETSiteAzureCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AzureVNETSiteBlockedServicesModel{
			BlockedSevice: func() []AzureVNETSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AzureVNETSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AzureVNETSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AzureVNETSiteIngressEgressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressEgressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel {
									if _, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel{}
									}
									return nil
								}(),
								OutsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if _, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwHubModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_egress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressEgressGwAr != nil) {
		data.IngressEgressGwAr = &AzureVNETSiteIngressEgressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwArHubModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteIngressEgressGwArNodeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AzureVNETSiteIngressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteIngressGwAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressGwAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressGwAr != nil) {
		data.IngressGwAr = &AzureVNETSiteIngressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Node: func() *AzureVNETSiteIngressGwArNodeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AzureVNETSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AzureVNETSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AzureVNETSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AzureVNETSiteOSModel{
			DefaultOSVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AzureVNETSiteSwModel{
			DefaultSwVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vnet"].(map[string]interface{}); ok && isImport && data.VNET == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VNET = &AzureVNETSiteVNETModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AzureVNETSiteVoltstackClusterModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteVoltstackClusterAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster_ar"].(map[string]interface{}); ok && (isImport || data.VoltstackClusterAr != nil) {
		data.VoltstackClusterAr = &AzureVNETSiteVoltstackClusterArModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterArDcClusterGroupModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterArK8SClusterModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteVoltstackClusterArNodeModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterArStorageClassListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else {
		data.AlternateRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else {
		data.AzureRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else {
		data.MachineType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else {
		data.ResourceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created AzureVNETSite resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureVNETSiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAzureVNETSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AzureVNETSite not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AzureVNETSite: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The azure_vnet_site may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AzureVNETSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["azure_cred"].(map[string]interface{}); ok && (isImport || data.AzureCred != nil) {
		data.AzureCred = &AzureVNETSiteAzureCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AzureVNETSiteBlockedServicesModel{
			BlockedSevice: func() []AzureVNETSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AzureVNETSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AzureVNETSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AzureVNETSiteIngressEgressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressEgressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel {
									if _, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel{}
									}
									return nil
								}(),
								OutsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if _, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwHubModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_egress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressEgressGwAr != nil) {
		data.IngressEgressGwAr = &AzureVNETSiteIngressEgressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwArHubModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteIngressEgressGwArNodeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AzureVNETSiteIngressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteIngressGwAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressGwAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressGwAr != nil) {
		data.IngressGwAr = &AzureVNETSiteIngressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Node: func() *AzureVNETSiteIngressGwArNodeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AzureVNETSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AzureVNETSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AzureVNETSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AzureVNETSiteOSModel{
			DefaultOSVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AzureVNETSiteSwModel{
			DefaultSwVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vnet"].(map[string]interface{}); ok && isImport && data.VNET == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VNET = &AzureVNETSiteVNETModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AzureVNETSiteVoltstackClusterModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteVoltstackClusterAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster_ar"].(map[string]interface{}); ok && (isImport || data.VoltstackClusterAr != nil) {
		data.VoltstackClusterAr = &AzureVNETSiteVoltstackClusterArModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterArDcClusterGroupModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterArK8SClusterModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteVoltstackClusterArNodeModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterArStorageClassListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else {
		data.AlternateRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else {
		data.AzureRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else {
		data.MachineType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else {
		data.ResourceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureVNETSiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.AzureVNETSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		apiResource.Spec["admin_password"] = admin_passwordMap
	}
	if data.AzureCred != nil {
		azure_credMap := make(map[string]interface{})
		if !data.AzureCred.Name.IsNull() && !data.AzureCred.Name.IsUnknown() {
			azure_credMap["name"] = data.AzureCred.Name.ValueString()
		}
		if !data.AzureCred.Namespace.IsNull() && !data.AzureCred.Namespace.IsUnknown() {
			azure_credMap["namespace"] = data.AzureCred.Namespace.ValueString()
		}
		if !data.AzureCred.Tenant.IsNull() && !data.AzureCred.Tenant.IsUnknown() {
			azure_credMap["tenant"] = data.AzureCred.Tenant.ValueString()
		}
		apiResource.Spec["azure_cred"] = azure_credMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.IngressEgressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressEgressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_egress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressEgressGw.AzureCertifiedHw.IsNull() && !data.IngressEgressGw.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["azure_certified_hw"] = data.IngressEgressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NotHub != nil {
			ingress_egress_gwMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressEgressGwAr != nil {
		ingress_egress_gw_arMap := make(map[string]interface{})
		if data.IngressEgressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.IngressEgressGwAr.AzureCertifiedHw.IsNull() && !data.IngressEgressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gw_arMap["azure_certified_hw"] = data.IngressEgressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGwAr.ForwardProxyAllowAll != nil {
			ingress_egress_gw_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGwAr.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGwAr.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.NoDcClusterGroup != nil {
			ingress_egress_gw_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoForwardProxy != nil {
			ingress_egress_gw_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoGlobalNetwork != nil {
			ingress_egress_gw_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoInsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoNetworkPolicy != nil {
			ingress_egress_gw_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoOutsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.Node.FaultDomain.IsNull() && !data.IngressEgressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressEgressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.NodeNumber.IsNull() && !data.IngressEgressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressEgressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.UpdateDomain.IsNull() && !data.IngressEgressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressEgressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_egress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressEgressGwAr.NotHub != nil {
			ingress_egress_gw_arMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGwAr.SmConnectionPublicIP != nil {
			ingress_egress_gw_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.SmConnectionPvtIP != nil {
			ingress_egress_gw_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw_ar"] = ingress_egress_gw_arMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if data.IngressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if len(data.IngressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressGw.AzureCertifiedHw.IsNull() && !data.IngressGw.AzureCertifiedHw.IsUnknown() {
			ingress_gwMap["azure_certified_hw"] = data.IngressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.IngressGwAr != nil {
		ingress_gw_arMap := make(map[string]interface{})
		if data.IngressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if !data.IngressGwAr.AzureCertifiedHw.IsNull() && !data.IngressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_gw_arMap["azure_certified_hw"] = data.IngressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressGwAr.Node.FaultDomain.IsNull() && !data.IngressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressGwAr.Node.NodeNumber.IsNull() && !data.IngressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressGwAr.Node.UpdateDomain.IsNull() && !data.IngressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw_ar"] = ingress_gw_arMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.NoWorkerNodes != nil {
		no_worker_nodesMap := make(map[string]interface{})
		apiResource.Spec["no_worker_nodes"] = no_worker_nodesMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		apiResource.Spec["tags"] = tagsMap
	}
	if data.VNET != nil {
		vnetMap := make(map[string]interface{})
		if data.VNET.ExistingVNET != nil {
			existing_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.ExistingVNET.ResourceGroup.IsNull() && !data.VNET.ExistingVNET.ResourceGroup.IsUnknown() {
				existing_vnetNestedMap["resource_group"] = data.VNET.ExistingVNET.ResourceGroup.ValueString()
			}
			if !data.VNET.ExistingVNET.VNETName.IsNull() && !data.VNET.ExistingVNET.VNETName.IsUnknown() {
				existing_vnetNestedMap["vnet_name"] = data.VNET.ExistingVNET.VNETName.ValueString()
			}
			vnetMap["existing_vnet"] = existing_vnetNestedMap
		}
		if data.VNET.NewVNET != nil {
			new_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.NewVNET.Name.IsNull() && !data.VNET.NewVNET.Name.IsUnknown() {
				new_vnetNestedMap["name"] = data.VNET.NewVNET.Name.ValueString()
			}
			if !data.VNET.NewVNET.PrimaryIpv4.IsNull() && !data.VNET.NewVNET.PrimaryIpv4.IsUnknown() {
				new_vnetNestedMap["primary_ipv4"] = data.VNET.NewVNET.PrimaryIpv4.ValueString()
			}
			vnetMap["new_vnet"] = new_vnetNestedMap
		}
		apiResource.Spec["vnet"] = vnetMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_clusterMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.VoltstackCluster.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.VoltstackCluster.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			voltstack_clusterMap["az_nodes"] = az_nodesList
		}
		if !data.VoltstackCluster.AzureCertifiedHw.IsNull() && !data.VoltstackCluster.AzureCertifiedHw.IsUnknown() {
			voltstack_clusterMap["azure_certified_hw"] = data.VoltstackCluster.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if data.VoltstackClusterAr != nil {
		voltstack_cluster_arMap := make(map[string]interface{})
		if data.VoltstackClusterAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.VoltstackClusterAr.AzureCertifiedHw.IsNull() && !data.VoltstackClusterAr.AzureCertifiedHw.IsUnknown() {
			voltstack_cluster_arMap["azure_certified_hw"] = data.VoltstackClusterAr.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackClusterAr.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.DcClusterGroup.Name.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackClusterAr.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackClusterAr.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackClusterAr.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_cluster_arMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackClusterAr.DefaultStorage != nil {
			voltstack_cluster_arMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.ForwardProxyAllowAll != nil {
			voltstack_cluster_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackClusterAr.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.K8SCluster.Name.IsNull() && !data.VoltstackClusterAr.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackClusterAr.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Namespace.IsNull() && !data.VoltstackClusterAr.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackClusterAr.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Tenant.IsNull() && !data.VoltstackClusterAr.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackClusterAr.K8SCluster.Tenant.ValueString()
			}
			voltstack_cluster_arMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackClusterAr.NoDcClusterGroup != nil {
			voltstack_cluster_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoForwardProxy != nil {
			voltstack_cluster_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoGlobalNetwork != nil {
			voltstack_cluster_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoK8SCluster != nil {
			voltstack_cluster_arMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoNetworkPolicy != nil {
			voltstack_cluster_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoOutsideStaticRoutes != nil {
			voltstack_cluster_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.Node.FaultDomain.IsNull() && !data.VoltstackClusterAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.VoltstackClusterAr.Node.FaultDomain.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.NodeNumber.IsNull() && !data.VoltstackClusterAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.VoltstackClusterAr.Node.NodeNumber.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.UpdateDomain.IsNull() && !data.VoltstackClusterAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.VoltstackClusterAr.Node.UpdateDomain.ValueInt64()
			}
			voltstack_cluster_arMap["node"] = nodeNestedMap
		}
		if data.VoltstackClusterAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackClusterAr.SmConnectionPublicIP != nil {
			voltstack_cluster_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.SmConnectionPvtIP != nil {
			voltstack_cluster_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster_ar"] = voltstack_cluster_arMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		apiResource.Spec["address"] = data.Address.ValueString()
	}
	if !data.AlternateRegion.IsNull() && !data.AlternateRegion.IsUnknown() {
		apiResource.Spec["alternate_region"] = data.AlternateRegion.ValueString()
	}
	if !data.AzureRegion.IsNull() && !data.AzureRegion.IsUnknown() {
		apiResource.Spec["azure_region"] = data.AzureRegion.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		apiResource.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.MachineType.IsNull() && !data.MachineType.IsUnknown() {
		apiResource.Spec["machine_type"] = data.MachineType.ValueString()
	}
	if !data.NodesPerAz.IsNull() && !data.NodesPerAz.IsUnknown() {
		apiResource.Spec["nodes_per_az"] = data.NodesPerAz.ValueInt64()
	}
	if !data.ResourceGroup.IsNull() && !data.ResourceGroup.IsUnknown() {
		apiResource.Spec["resource_group"] = data.ResourceGroup.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		apiResource.Spec["ssh_key"] = data.SSHKey.ValueString()
	}
	if !data.TotalNodes.IsNull() && !data.TotalNodes.IsUnknown() {
		apiResource.Spec["total_nodes"] = data.TotalNodes.ValueInt64()
	}

	_, err := r.client.UpdateAzureVNETSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AzureVNETSite: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAzureVNETSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AzureVNETSite after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else if data.Address.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Address = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else if data.AlternateRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AlternateRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else if data.AzureRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AzureRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else if data.DiskSize.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DiskSize = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else if data.MachineType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.MachineType = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else if data.NodesPerAz.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.NodesPerAz = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else if data.ResourceGroup.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ResourceGroup = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else if data.SSHKey.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.SSHKey = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else if data.TotalNodes.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TotalNodes = types.Int64Null()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AzureVNETSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["azure_cred"].(map[string]interface{}); ok && (isImport || data.AzureCred != nil) {
		data.AzureCred = &AzureVNETSiteAzureCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AzureVNETSiteBlockedServicesModel{
			BlockedSevice: func() []AzureVNETSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AzureVNETSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AzureVNETSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AzureVNETSiteIngressEgressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressEgressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel {
									if _, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel{}
									}
									return nil
								}(),
								OutsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if _, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwHubModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_egress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressEgressGwAr != nil) {
		data.IngressEgressGwAr = &AzureVNETSiteIngressEgressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwArHubModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteIngressEgressGwArNodeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AzureVNETSiteIngressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteIngressGwAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressGwAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressGwAr != nil) {
		data.IngressGwAr = &AzureVNETSiteIngressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Node: func() *AzureVNETSiteIngressGwArNodeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AzureVNETSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AzureVNETSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AzureVNETSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AzureVNETSiteOSModel{
			DefaultOSVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AzureVNETSiteSwModel{
			DefaultSwVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vnet"].(map[string]interface{}); ok && isImport && data.VNET == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VNET = &AzureVNETSiteVNETModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AzureVNETSiteVoltstackClusterModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteVoltstackClusterAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster_ar"].(map[string]interface{}); ok && (isImport || data.VoltstackClusterAr != nil) {
		data.VoltstackClusterAr = &AzureVNETSiteVoltstackClusterArModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterArDcClusterGroupModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterArK8SClusterModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteVoltstackClusterArNodeModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterArStorageClassListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else {
		data.AlternateRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else {
		data.AzureRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else {
		data.MachineType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else {
		data.ResourceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureVNETSiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAzureVNETSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AzureVNETSite already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "AzureVNETSite delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AzureVNETSite: %s", err))
		return
	}
}

func (r *AzureVNETSiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
