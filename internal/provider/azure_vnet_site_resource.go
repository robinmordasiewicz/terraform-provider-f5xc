// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &AzureVNETSiteResource{}
	_ resource.ResourceWithConfigure      = &AzureVNETSiteResource{}
	_ resource.ResourceWithImportState    = &AzureVNETSiteResource{}
	_ resource.ResourceWithModifyPlan     = &AzureVNETSiteResource{}
	_ resource.ResourceWithUpgradeState   = &AzureVNETSiteResource{}
	_ resource.ResourceWithValidateConfig = &AzureVNETSiteResource{}
)

// azure_vnet_siteSchemaVersion is the schema version for state upgrades
const azure_vnet_siteSchemaVersion int64 = 1

func NewAzureVNETSiteResource() resource.Resource {
	return &AzureVNETSiteResource{}
}

type AzureVNETSiteResource struct {
	client *client.Client
}

// AzureVNETSiteEmptyModel represents empty nested blocks
type AzureVNETSiteEmptyModel struct {
}

// AzureVNETSiteAdminPasswordModel represents admin_password block
type AzureVNETSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AzureVNETSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type AzureVNETSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AzureVNETSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type AzureVNETSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AzureVNETSiteAzureCredModel represents azure_cred block
type AzureVNETSiteAzureCredModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteBlockedServicesModel represents blocked_services block
type AzureVNETSiteBlockedServicesModel struct {
	BlockedSevice []AzureVNETSiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// AzureVNETSiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type AzureVNETSiteBlockedServicesBlockedSeviceModel struct {
	NetworkType      types.String             `tfsdk:"network_type"`
	DNS              *AzureVNETSiteEmptyModel `tfsdk:"dns"`
	SSH              *AzureVNETSiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *AzureVNETSiteEmptyModel `tfsdk:"web_user_interface"`
}

// AzureVNETSiteCoordinatesModel represents coordinates block
type AzureVNETSiteCoordinatesModel struct {
	Latitude  types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// AzureVNETSiteCustomDNSModel represents custom_dns block
type AzureVNETSiteCustomDNSModel struct {
	InsideNameserver  types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// AzureVNETSiteIngressEgressGwModel represents ingress_egress_gw block
type AzureVNETSiteIngressEgressGwModel struct {
	AzureCertifiedHw               types.String                                                     `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	AzNodes                        []AzureVNETSiteIngressEgressGwAzNodesModel                       `tfsdk:"az_nodes"`
	DcClusterGroupInsideVn         *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel         `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn        *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel        `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                         `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteIngressEgressGwGlobalNetworkListModel              `tfsdk:"global_network_list"`
	Hub                            *AzureVNETSiteIngressEgressGwHubModel                            `tfsdk:"hub"`
	InsideStaticRoutes             *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel             `tfsdk:"inside_static_routes"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                         `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                         `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                         `tfsdk:"no_global_network"`
	NoInsideStaticRoutes           *AzureVNETSiteEmptyModel                                         `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                         `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                         `tfsdk:"no_outside_static_routes"`
	NotHub                         *AzureVNETSiteEmptyModel                                         `tfsdk:"not_hub"`
	OutsideStaticRoutes            *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	PerformanceEnhancementMode     *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel     `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                         `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                         `tfsdk:"sm_connection_pvt_ip"`
}

// AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwAzNodesModel represents az_nodes block
type AzureVNETSiteIngressEgressGwAzNodesModel struct {
	AzureAz       types.String                                           `tfsdk:"azure_az"`
	InsideSubnet  *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel  `tfsdk:"inside_subnet"`
	OutsideSubnet *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel `tfsdk:"outside_subnet"`
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel represents inside_subnet block
type AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwAzNodesInsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel represents outside_subnet block
type AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteIngressEgressGwGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwHubModel represents hub block
type AzureVNETSiteIngressEgressGwHubModel struct {
	ExpressRouteDisabled *AzureVNETSiteEmptyModel                                 `tfsdk:"express_route_disabled"`
	ExpressRouteEnabled  *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel `tfsdk:"express_route_enabled"`
	SpokeVnets           []AzureVNETSiteIngressEgressGwHubSpokeVnetsModel         `tfsdk:"spoke_vnets"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel represents express_route_enabled block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledModel struct {
	CustomAsn                        types.Int64                                                                              `tfsdk:"custom_asn"`
	AdvertiseToRouteServer           *AzureVNETSiteEmptyModel                                                                 `tfsdk:"advertise_to_route_server"`
	AutoAsn                          *AzureVNETSiteEmptyModel                                                                 `tfsdk:"auto_asn"`
	Connections                      []AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel                     `tfsdk:"connections"`
	DoNotAdvertiseToRouteServer      *AzureVNETSiteEmptyModel                                                                 `tfsdk:"do_not_advertise_to_route_server"`
	GatewaySubnet                    *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel                    `tfsdk:"gateway_subnet"`
	RouteServerSubnet                *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel                `tfsdk:"route_server_subnet"`
	SiteRegistrationOverExpressRoute *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel `tfsdk:"site_registration_over_express_route"`
	SiteRegistrationOverInternet     *AzureVNETSiteEmptyModel                                                                 `tfsdk:"site_registration_over_internet"`
	SkuErgw1az                       *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_ergw1az"`
	SkuErgw2az                       *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_ergw2az"`
	SkuHighPerf                      *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_high_perf"`
	SkuStandard                      *AzureVNETSiteEmptyModel                                                                 `tfsdk:"sku_standard"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel represents connections block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsModel struct {
	CircuitID         types.String                                                                         `tfsdk:"circuit_id"`
	Weight            types.Int64                                                                          `tfsdk:"weight"`
	Metadata          *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel          `tfsdk:"metadata"`
	OtherSubscription *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel `tfsdk:"other_subscription"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel represents metadata block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel represents other_subscription block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionModel struct {
	CircuitID     types.String                                                                                      `tfsdk:"circuit_id"`
	AuthorizedKey *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel `tfsdk:"authorized_key"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel represents authorized_key block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel struct {
	BlindfoldSecretInfo *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel represents clear_secret_info block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel represents gateway_subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                         `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledGatewaySubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel represents route_server_subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                             `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledRouteServerSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel represents site_registration_over_express_route block
type AzureVNETSiteIngressEgressGwHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// AzureVNETSiteIngressEgressGwHubSpokeVnetsModel represents spoke_vnets block
type AzureVNETSiteIngressEgressGwHubSpokeVnetsModel struct {
	Auto   *AzureVNETSiteEmptyModel                            `tfsdk:"auto"`
	Labels *AzureVNETSiteEmptyModel                            `tfsdk:"labels"`
	Manual *AzureVNETSiteEmptyModel                            `tfsdk:"manual"`
	VNET   *AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel `tfsdk:"vnet"`
}

// AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel represents vnet block
type AzureVNETSiteIngressEgressGwHubSpokeVnetsVNETModel struct {
	ResourceGroup         types.String             `tfsdk:"resource_group"`
	VNETName              types.String             `tfsdk:"vnet_name"`
	F5OrchestratedRouting *AzureVNETSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	ManualRouting         *AzureVNETSiteEmptyModel `tfsdk:"manual_routing"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesModel represents inside_static_routes block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                         `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                   `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                     `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                              `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                          `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                    `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                      `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                               `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                       `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressEgressGwArModel represents ingress_egress_gw_ar block
type AzureVNETSiteIngressEgressGwArModel struct {
	AzureCertifiedHw               types.String                                                       `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	DcClusterGroupInsideVn         *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel         `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn        *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel        `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                           `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel              `tfsdk:"global_network_list"`
	Hub                            *AzureVNETSiteIngressEgressGwArHubModel                            `tfsdk:"hub"`
	InsideStaticRoutes             *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel             `tfsdk:"inside_static_routes"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                           `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                           `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                           `tfsdk:"no_global_network"`
	NoInsideStaticRoutes           *AzureVNETSiteEmptyModel                                           `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                           `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                           `tfsdk:"no_outside_static_routes"`
	Node                           *AzureVNETSiteIngressEgressGwArNodeModel                           `tfsdk:"node"`
	NotHub                         *AzureVNETSiteEmptyModel                                           `tfsdk:"not_hub"`
	OutsideStaticRoutes            *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	PerformanceEnhancementMode     *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel     `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                           `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                           `tfsdk:"sm_connection_pvt_ip"`
}

// AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteIngressEgressGwArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteIngressEgressGwArHubModel represents hub block
type AzureVNETSiteIngressEgressGwArHubModel struct {
	ExpressRouteDisabled *AzureVNETSiteEmptyModel                                   `tfsdk:"express_route_disabled"`
	ExpressRouteEnabled  *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel `tfsdk:"express_route_enabled"`
	SpokeVnets           []AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel         `tfsdk:"spoke_vnets"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel represents express_route_enabled block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledModel struct {
	CustomAsn                        types.Int64                                                                                `tfsdk:"custom_asn"`
	AdvertiseToRouteServer           *AzureVNETSiteEmptyModel                                                                   `tfsdk:"advertise_to_route_server"`
	AutoAsn                          *AzureVNETSiteEmptyModel                                                                   `tfsdk:"auto_asn"`
	Connections                      []AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel                     `tfsdk:"connections"`
	DoNotAdvertiseToRouteServer      *AzureVNETSiteEmptyModel                                                                   `tfsdk:"do_not_advertise_to_route_server"`
	GatewaySubnet                    *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel                    `tfsdk:"gateway_subnet"`
	RouteServerSubnet                *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel                `tfsdk:"route_server_subnet"`
	SiteRegistrationOverExpressRoute *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel `tfsdk:"site_registration_over_express_route"`
	SiteRegistrationOverInternet     *AzureVNETSiteEmptyModel                                                                   `tfsdk:"site_registration_over_internet"`
	SkuErgw1az                       *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_ergw1az"`
	SkuErgw2az                       *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_ergw2az"`
	SkuHighPerf                      *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_high_perf"`
	SkuStandard                      *AzureVNETSiteEmptyModel                                                                   `tfsdk:"sku_standard"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel represents connections block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsModel struct {
	CircuitID         types.String                                                                           `tfsdk:"circuit_id"`
	Weight            types.Int64                                                                            `tfsdk:"weight"`
	Metadata          *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel          `tfsdk:"metadata"`
	OtherSubscription *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel `tfsdk:"other_subscription"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel represents metadata block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel represents other_subscription block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionModel struct {
	CircuitID     types.String                                                                                        `tfsdk:"circuit_id"`
	AuthorizedKey *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel `tfsdk:"authorized_key"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel represents authorized_key block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyModel struct {
	BlindfoldSecretInfo *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel represents clear_secret_info block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledConnectionsOtherSubscriptionAuthorizedKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel represents gateway_subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                           `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledGatewaySubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel represents route_server_subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetModel struct {
	Auto        *AzureVNETSiteEmptyModel                                                               `tfsdk:"auto"`
	Subnet      *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetModel struct {
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledRouteServerSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel represents site_registration_over_express_route block
type AzureVNETSiteIngressEgressGwArHubExpressRouteEnabledSiteRegistrationOverExpressRouteModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel represents spoke_vnets block
type AzureVNETSiteIngressEgressGwArHubSpokeVnetsModel struct {
	Auto   *AzureVNETSiteEmptyModel                              `tfsdk:"auto"`
	Labels *AzureVNETSiteEmptyModel                              `tfsdk:"labels"`
	Manual *AzureVNETSiteEmptyModel                              `tfsdk:"manual"`
	VNET   *AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel `tfsdk:"vnet"`
}

// AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel represents vnet block
type AzureVNETSiteIngressEgressGwArHubSpokeVnetsVNETModel struct {
	ResourceGroup         types.String             `tfsdk:"resource_group"`
	VNETName              types.String             `tfsdk:"vnet_name"`
	F5OrchestratedRouting *AzureVNETSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	ManualRouting         *AzureVNETSiteEmptyModel `tfsdk:"manual_routing"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel represents inside_static_routes block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                           `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                     `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                       `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArNodeModel represents node block
type AzureVNETSiteIngressEgressGwArNodeModel struct {
	FaultDomain   types.Int64                                           `tfsdk:"fault_domain"`
	NodeNumber    types.Int64                                           `tfsdk:"node_number"`
	UpdateDomain  types.Int64                                           `tfsdk:"update_domain"`
	InsideSubnet  *AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel  `tfsdk:"inside_subnet"`
	OutsideSubnet *AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel `tfsdk:"outside_subnet"`
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel represents inside_subnet block
type AzureVNETSiteIngressEgressGwArNodeInsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArNodeInsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel represents outside_subnet block
type AzureVNETSiteIngressEgressGwArNodeOutsideSubnetModel struct {
	Subnet      *AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressEgressGwArNodeOutsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                            `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                      `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                        `tfsdk:"labels"`
	Nexthop *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                 `tfsdk:"type"`
	Interface      []AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteIngressEgressGwArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                         `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressEgressGwArPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressGwModel represents ingress_gw block
type AzureVNETSiteIngressGwModel struct {
	AzureCertifiedHw           types.String                                           `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking      *AzureVNETSiteIngressGwAcceleratedNetworkingModel      `tfsdk:"accelerated_networking"`
	AzNodes                    []AzureVNETSiteIngressGwAzNodesModel                   `tfsdk:"az_nodes"`
	PerformanceEnhancementMode *AzureVNETSiteIngressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// AzureVNETSiteIngressGwAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressGwAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressGwAzNodesModel represents az_nodes block
type AzureVNETSiteIngressGwAzNodesModel struct {
	AzureAz     types.String                                   `tfsdk:"azure_az"`
	LocalSubnet *AzureVNETSiteIngressGwAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetModel represents local_subnet block
type AzureVNETSiteIngressGwAzNodesLocalSubnetModel struct {
	Subnet      *AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressGwAzNodesLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                 `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteIngressGwArModel represents ingress_gw_ar block
type AzureVNETSiteIngressGwArModel struct {
	AzureCertifiedHw           types.String                                             `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking      *AzureVNETSiteIngressGwArAcceleratedNetworkingModel      `tfsdk:"accelerated_networking"`
	Node                       *AzureVNETSiteIngressGwArNodeModel                       `tfsdk:"node"`
	PerformanceEnhancementMode *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// AzureVNETSiteIngressGwArAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteIngressGwArAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteIngressGwArNodeModel represents node block
type AzureVNETSiteIngressGwArNodeModel struct {
	FaultDomain  types.Int64                                   `tfsdk:"fault_domain"`
	NodeNumber   types.Int64                                   `tfsdk:"node_number"`
	UpdateDomain types.Int64                                   `tfsdk:"update_domain"`
	LocalSubnet  *AzureVNETSiteIngressGwArNodeLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteIngressGwArNodeLocalSubnetModel represents local_subnet block
type AzureVNETSiteIngressGwArNodeLocalSubnetModel struct {
	Subnet      *AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteIngressGwArNodeLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteIngressGwArNodeLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteIngressGwArPerformanceEnhancementModeModel represents performance_enhancement_mode block
type AzureVNETSiteIngressGwArPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *AzureVNETSiteEmptyModel                                                   `tfsdk:"perf_mode_l7_enhanced"`
}

// AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type AzureVNETSiteIngressGwArPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *AzureVNETSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *AzureVNETSiteEmptyModel `tfsdk:"no_jumbo"`
}

// AzureVNETSiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type AzureVNETSiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *AzureVNETSiteEmptyModel                                    `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain  *AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type AzureVNETSiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64              `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout             types.Int64              `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode       *AzureVNETSiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode        *AzureVNETSiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// AzureVNETSiteLogReceiverModel represents log_receiver block
type AzureVNETSiteLogReceiverModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type AzureVNETSiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *AzureVNETSiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode     *AzureVNETSiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// AzureVNETSiteOSModel represents os block
type AzureVNETSiteOSModel struct {
	OperatingSystemVersion types.String             `tfsdk:"operating_system_version"`
	DefaultOSVersion       *AzureVNETSiteEmptyModel `tfsdk:"default_os_version"`
}

// AzureVNETSiteSwModel represents sw block
type AzureVNETSiteSwModel struct {
	VolterraSoftwareVersion types.String             `tfsdk:"volterra_software_version"`
	DefaultSwVersion        *AzureVNETSiteEmptyModel `tfsdk:"default_sw_version"`
}

// AzureVNETSiteVNETModel represents vnet block
type AzureVNETSiteVNETModel struct {
	ExistingVNET *AzureVNETSiteVNETExistingVNETModel `tfsdk:"existing_vnet"`
	NewVNET      *AzureVNETSiteVNETNewVNETModel      `tfsdk:"new_vnet"`
}

// AzureVNETSiteVNETExistingVNETModel represents existing_vnet block
type AzureVNETSiteVNETExistingVNETModel struct {
	ResourceGroup         types.String             `tfsdk:"resource_group"`
	VNETName              types.String             `tfsdk:"vnet_name"`
	F5OrchestratedRouting *AzureVNETSiteEmptyModel `tfsdk:"f5_orchestrated_routing"`
	ManualRouting         *AzureVNETSiteEmptyModel `tfsdk:"manual_routing"`
}

// AzureVNETSiteVNETNewVNETModel represents new_vnet block
type AzureVNETSiteVNETNewVNETModel struct {
	Name         types.String             `tfsdk:"name"`
	PrimaryIpv4  types.String             `tfsdk:"primary_ipv4"`
	Autogenerate *AzureVNETSiteEmptyModel `tfsdk:"autogenerate"`
}

// AzureVNETSiteVoltstackClusterModel represents voltstack_cluster block
type AzureVNETSiteVoltstackClusterModel struct {
	AzureCertifiedHw               types.String                                                      `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	AzNodes                        []AzureVNETSiteVoltstackClusterAzNodesModel                       `tfsdk:"az_nodes"`
	DcClusterGroup                 *AzureVNETSiteVoltstackClusterDcClusterGroupModel                 `tfsdk:"dc_cluster_group"`
	DefaultStorage                 *AzureVNETSiteEmptyModel                                          `tfsdk:"default_storage"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                          `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteVoltstackClusterGlobalNetworkListModel              `tfsdk:"global_network_list"`
	K8SCluster                     *AzureVNETSiteVoltstackClusterK8SClusterModel                     `tfsdk:"k8s_cluster"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                          `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                          `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                          `tfsdk:"no_global_network"`
	NoK8SCluster                   *AzureVNETSiteEmptyModel                                          `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                          `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                          `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes            *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                          `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                          `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList               *AzureVNETSiteVoltstackClusterStorageClassListModel               `tfsdk:"storage_class_list"`
}

// AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterAzNodesModel represents az_nodes block
type AzureVNETSiteVoltstackClusterAzNodesModel struct {
	AzureAz     types.String                                          `tfsdk:"azure_az"`
	LocalSubnet *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel represents local_subnet block
type AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel struct {
	Subnet      *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteVoltstackClusterAzNodesLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteVoltstackClusterDcClusterGroupModel represents dc_cluster_group block
type AzureVNETSiteVoltstackClusterDcClusterGroupModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteVoltstackClusterGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterK8SClusterModel represents k8s_cluster block
type AzureVNETSiteVoltstackClusterK8SClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                           `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                     `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                       `tfsdk:"labels"`
	Nexthop *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                `tfsdk:"type"`
	Interface      []AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterStorageClassListModel represents storage_class_list block
type AzureVNETSiteVoltstackClusterStorageClassListModel struct {
	StorageClasses []AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel represents storage_classes block
type AzureVNETSiteVoltstackClusterStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool   `tfsdk:"default_storage_class"`
	StorageClassName    types.String `tfsdk:"storage_class_name"`
}

// AzureVNETSiteVoltstackClusterArModel represents voltstack_cluster_ar block
type AzureVNETSiteVoltstackClusterArModel struct {
	AzureCertifiedHw               types.String                                                        `tfsdk:"azure_certified_hw"`
	AcceleratedNetworking          *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel          `tfsdk:"accelerated_networking"`
	ActiveEnhancedFirewallPolicies *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	DcClusterGroup                 *AzureVNETSiteVoltstackClusterArDcClusterGroupModel                 `tfsdk:"dc_cluster_group"`
	DefaultStorage                 *AzureVNETSiteEmptyModel                                            `tfsdk:"default_storage"`
	ForwardProxyAllowAll           *AzureVNETSiteEmptyModel                                            `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel              `tfsdk:"global_network_list"`
	K8SCluster                     *AzureVNETSiteVoltstackClusterArK8SClusterModel                     `tfsdk:"k8s_cluster"`
	NoDcClusterGroup               *AzureVNETSiteEmptyModel                                            `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *AzureVNETSiteEmptyModel                                            `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *AzureVNETSiteEmptyModel                                            `tfsdk:"no_global_network"`
	NoK8SCluster                   *AzureVNETSiteEmptyModel                                            `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy                *AzureVNETSiteEmptyModel                                            `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *AzureVNETSiteEmptyModel                                            `tfsdk:"no_outside_static_routes"`
	Node                           *AzureVNETSiteVoltstackClusterArNodeModel                           `tfsdk:"node"`
	OutsideStaticRoutes            *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP           *AzureVNETSiteEmptyModel                                            `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *AzureVNETSiteEmptyModel                                            `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList               *AzureVNETSiteVoltstackClusterArStorageClassListModel               `tfsdk:"storage_class_list"`
}

// AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel represents accelerated_networking block
type AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel struct {
	Disable *AzureVNETSiteEmptyModel `tfsdk:"disable"`
	Enable  *AzureVNETSiteEmptyModel `tfsdk:"enable"`
}

// AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel represents active_network_policies block
type AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel struct {
	NetworkPolicies []AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArDcClusterGroupModel represents dc_cluster_group block
type AzureVNETSiteVoltstackClusterArDcClusterGroupModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListModel represents global_network_list block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListModel struct {
	GlobalNetworkConnections []AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type AzureVNETSiteVoltstackClusterArGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArK8SClusterModel represents k8s_cluster block
type AzureVNETSiteVoltstackClusterArK8SClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// AzureVNETSiteVoltstackClusterArNodeModel represents node block
type AzureVNETSiteVoltstackClusterArNodeModel struct {
	FaultDomain  types.Int64                                          `tfsdk:"fault_domain"`
	NodeNumber   types.Int64                                          `tfsdk:"node_number"`
	UpdateDomain types.Int64                                          `tfsdk:"update_domain"`
	LocalSubnet  *AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel `tfsdk:"local_subnet"`
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel represents local_subnet block
type AzureVNETSiteVoltstackClusterArNodeLocalSubnetModel struct {
	Subnet      *AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel      `tfsdk:"subnet"`
	SubnetParam *AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel represents subnet block
type AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetModel struct {
	SubnetName        types.String             `tfsdk:"subnet_name"`
	SubnetResourceGrp types.String             `tfsdk:"subnet_resource_grp"`
	VNETResourceGroup *AzureVNETSiteEmptyModel `tfsdk:"vnet_resource_group"`
}

// AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel represents subnet_param block
type AzureVNETSiteVoltstackClusterArNodeLocalSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel represents outside_static_routes block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel struct {
	StaticRouteList []AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                             `tfsdk:"simple_static_route"`
	CustomStaticRoute *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                       `tfsdk:"attrs"`
	Labels  *AzureVNETSiteEmptyModel                                                                         `tfsdk:"labels"`
	Nexthop *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                                  `tfsdk:"type"`
	Interface      []AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type AzureVNETSiteVoltstackClusterArOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// AzureVNETSiteVoltstackClusterArStorageClassListModel represents storage_class_list block
type AzureVNETSiteVoltstackClusterArStorageClassListModel struct {
	StorageClasses []AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel represents storage_classes block
type AzureVNETSiteVoltstackClusterArStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool   `tfsdk:"default_storage_class"`
	StorageClassName    types.String `tfsdk:"storage_class_name"`
}

type AzureVNETSiteResourceModel struct {
	Name                     types.String                                `tfsdk:"name"`
	Namespace                types.String                                `tfsdk:"namespace"`
	Annotations              types.Map                                   `tfsdk:"annotations"`
	Description              types.String                                `tfsdk:"description"`
	Disable                  types.Bool                                  `tfsdk:"disable"`
	Labels                   types.Map                                   `tfsdk:"labels"`
	ID                       types.String                                `tfsdk:"id"`
	Address                  types.String                                `tfsdk:"address"`
	AlternateRegion          types.String                                `tfsdk:"alternate_region"`
	AzureRegion              types.String                                `tfsdk:"azure_region"`
	DiskSize                 types.Int64                                 `tfsdk:"disk_size"`
	MachineType              types.String                                `tfsdk:"machine_type"`
	NodesPerAz               types.Int64                                 `tfsdk:"nodes_per_az"`
	ResourceGroup            types.String                                `tfsdk:"resource_group"`
	SSHKey                   types.String                                `tfsdk:"ssh_key"`
	TotalNodes               types.Int64                                 `tfsdk:"total_nodes"`
	Timeouts                 timeouts.Value                              `tfsdk:"timeouts"`
	AdminPassword            *AzureVNETSiteAdminPasswordModel            `tfsdk:"admin_password"`
	AzureCred                *AzureVNETSiteAzureCredModel                `tfsdk:"azure_cred"`
	BlockAllServices         *AzureVNETSiteEmptyModel                    `tfsdk:"block_all_services"`
	BlockedServices          *AzureVNETSiteBlockedServicesModel          `tfsdk:"blocked_services"`
	Coordinates              *AzureVNETSiteCoordinatesModel              `tfsdk:"coordinates"`
	CustomDNS                *AzureVNETSiteCustomDNSModel                `tfsdk:"custom_dns"`
	DefaultBlockedServices   *AzureVNETSiteEmptyModel                    `tfsdk:"default_blocked_services"`
	IngressEgressGw          *AzureVNETSiteIngressEgressGwModel          `tfsdk:"ingress_egress_gw"`
	IngressEgressGwAr        *AzureVNETSiteIngressEgressGwArModel        `tfsdk:"ingress_egress_gw_ar"`
	IngressGw                *AzureVNETSiteIngressGwModel                `tfsdk:"ingress_gw"`
	IngressGwAr              *AzureVNETSiteIngressGwArModel              `tfsdk:"ingress_gw_ar"`
	KubernetesUpgradeDrain   *AzureVNETSiteKubernetesUpgradeDrainModel   `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver              *AzureVNETSiteLogReceiverModel              `tfsdk:"log_receiver"`
	LogsStreamingDisabled    *AzureVNETSiteEmptyModel                    `tfsdk:"logs_streaming_disabled"`
	NoWorkerNodes            *AzureVNETSiteEmptyModel                    `tfsdk:"no_worker_nodes"`
	OfflineSurvivabilityMode *AzureVNETSiteOfflineSurvivabilityModeModel `tfsdk:"offline_survivability_mode"`
	OS                       *AzureVNETSiteOSModel                       `tfsdk:"os"`
	Sw                       *AzureVNETSiteSwModel                       `tfsdk:"sw"`
	Tags                     *AzureVNETSiteEmptyModel                    `tfsdk:"tags"`
	VNET                     *AzureVNETSiteVNETModel                     `tfsdk:"vnet"`
	VoltstackCluster         *AzureVNETSiteVoltstackClusterModel         `tfsdk:"voltstack_cluster"`
	VoltstackClusterAr       *AzureVNETSiteVoltstackClusterArModel       `tfsdk:"voltstack_cluster_ar"`
}

func (r *AzureVNETSiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_azure_vnet_site"
}

func (r *AzureVNETSiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             azure_vnet_siteSchemaVersion,
		MarkdownDescription: "Manages a Azure VNET Site resource in F5 Distributed Cloud for deploying F5 sites within Azure Virtual Network environments.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Azure VNET Site. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Azure VNET Site will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "Geographical Address. Site's geographical address that can be used to determine its latitude and longitude.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"alternate_region": schema.StringAttribute{
				MarkdownDescription: "[OneOf: alternate_region, azure_region] Alternate Azure Region Name. Name of the azure region which does not support availability zones.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"azure_region": schema.StringAttribute{
				MarkdownDescription: "Recommended Azure Region Name. Name of the azure region which supports availability zones.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"disk_size": schema.Int64Attribute{
				MarkdownDescription: "Cloud Disk Size. Disk size to be used for this instance in GiB. 80 is 80 GiB",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"machine_type": schema.StringAttribute{
				MarkdownDescription: "Azure Machine Type for Node. Select Instance size based on performance needed. The default setting for Accelerated Networking is enabled, thus make sure you select a Virtual Machine that supports accelerated networking or disable the setting under, Select Ingress Gateway or Ingress/Egress Gateway > advanced options.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"nodes_per_az": schema.Int64Attribute{
				MarkdownDescription: "Desired Worker Nodes Per AZ. Desired Worker Nodes Per AZ. Max limit is up to 21",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"resource_group": schema.StringAttribute{
				MarkdownDescription: "Resource Group. Azure resource group for resources that will be created",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ssh_key": schema.StringAttribute{
				MarkdownDescription: "Public SSH key. Public SSH key for accessing the site.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"total_nodes": schema.Int64Attribute{
				MarkdownDescription: "Total Number of Worker Nodes for a Site. Total number of worker nodes to be deployed across all AZ's used in the Site",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"admin_password": schema.SingleNestedBlock{
				MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blindfold_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
						Attributes: map[string]schema.Attribute{
							"decryption_provider": schema.StringAttribute{
								MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
								Optional:            true,
							},
							"location": schema.StringAttribute{
								MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
								Optional:            true,
							},
							"store_provider": schema.StringAttribute{
								MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
								Optional:            true,
							},
						},
					},
					"clear_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
						Attributes: map[string]schema.Attribute{
							"provider_ref": schema.StringAttribute{
								MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
								Optional:            true,
							},
							"url": schema.StringAttribute{
								MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
								Optional:            true,
							},
						},
					},
				},
			},
			"azure_cred": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional:            true,
						Computed:            true,
					},
				},
			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services] Empty. This can be used for messages where no values are needed",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable Node Local Services. Disable node local services on this site. Note: The chosen services will get disabled on all nodes in the site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "Virtual Network Type. Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created automatically and present on all sites Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site. It is a secure network and is not connected to public network. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created during provisioning of site User defined per-site virtual network. Scope of this virtual network is limited to the site. This is not yet supported Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on RE sites only It is an internally created by the system. They must not be created by user Virtual Neworks with global scope across different sites in F5XC domain. An example global virtual-network called 'AIN Network' is created for every tenant. for volterra fabric Constraints: It is currently only supported as internally created by the system. vK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant Constraints: It is an internally created by the system. Must not be created by user VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy Constraints: It is an internally created by the system. Must not be created by user Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE Constraints: This network type is only meaningful in an advertise policy When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for an endpoint, VER will try to determine the network based on the provided IP address Constraints: This network type is only meaningful in an endpoint VoltADN Private Network is used on volterra RE(s) to connect to customer private networks This network is created by opening a support ticket This network is per site srv6 network VER IP Fabric network for the site. This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network Constraints: It is an internally created by the system. Must not be created by user Network internally created for a segment Constraints: It is an internally created by the system. Must not be created by user. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
					},
				},
			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Site Coordinates. Coordinates of the site which provides the site physical location",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location",
						Optional:            true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. longitude of site location",
						Optional:            true,
					},
				},
			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS. Custom DNS is the configured for specify CE site",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Inside Network. Optional DNS server IP to be used for name resolution in inside network",
						Optional:            true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Outside Network. Optional DNS server IP to be used for name resolution in outside network",
						Optional:            true,
					},
				},
			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"ingress_egress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ingress_egress_gw, ingress_egress_gw_ar, ingress_gw, ingress_gw_ar, voltstack_cluster, voltstack_cluster_ar] Azure Ingress/Egress Gateway on Recommended Region. Two interface Azure ingress/egress site",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. x-required Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Ingress/Egress Gateway (two Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"azure_az": schema.StringAttribute{
									MarkdownDescription: "Azure Availability Zone. A zone depicting a grouping of datacenters within an Azure region. Expecting numeric input",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional:            true,
												},
											},
										},
									},
								},
								"outside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"hub": schema.SingleNestedBlock{
						MarkdownDescription: "Hub VNet type. Hub VNet type",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"express_route_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"express_route_enabled": schema.SingleNestedBlock{
								MarkdownDescription: "Express Route Configuration. Express Route Configuration",
								Attributes: map[string]schema.Attribute{
									"custom_asn": schema.Int64Attribute{
										MarkdownDescription: "Custom ASN. Set custom ASN for F5XC Site",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"auto_asn": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"connections": schema.ListNestedBlock{
										MarkdownDescription: "Connections. Add the ExpressRoute Circuit Connections to this site",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"circuit_id": schema.StringAttribute{
													MarkdownDescription: "Circuit in same subscription. ExpressRoute Circuit is in same subscription as the site",
													Optional:            true,
												},
												"weight": schema.Int64Attribute{
													MarkdownDescription: "Routing Weight. The weight (or priority) for the routes received from this connection. The. Defaults to `10`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"other_subscription": schema.SingleNestedBlock{
													MarkdownDescription: "Express Route Circuit Config From Other Subscription. Express Route Circuit Config From Other Subscription",
													Attributes: map[string]schema.Attribute{
														"circuit_id": schema.StringAttribute{
															MarkdownDescription: "Circuit ID. Circuit ID",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"authorized_key": schema.SingleNestedBlock{
															MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional:            true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																			Optional:            true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional:            true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional:            true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"do_not_advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"gateway_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
														Optional:            true,
													},
												},
											},
										},
									},
									"route_server_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
														Optional:            true,
													},
												},
											},
										},
									},
									"site_registration_over_express_route": schema.SingleNestedBlock{
										MarkdownDescription: "CloudLink ADN Network Config.",
										Attributes: map[string]schema.Attribute{
											"cloudlink_network_name": schema.StringAttribute{
												MarkdownDescription: "Private ADN Network. Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
												Optional:            true,
											},
										},
									},
									"site_registration_over_internet": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_ergw1az": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_ergw2az": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_high_perf": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_standard": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"spoke_vnets": schema.ListNestedBlock{
								MarkdownDescription: "Spoke VNet Peering (Legacy). Spoke VNet Peering",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"auto": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"labels": schema.SingleNestedBlock{
											MarkdownDescription: "Labels For VNets Peering. Add Labels for each of the VNets peered with transit VNet, these labels can be used in firewall policy These labels used must be from known key and label defined in shared namespace",
										},
										"manual": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"vnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Existing Vnet Type. Resource group and name of existing Azure Vnet",
											Attributes: map[string]schema.Attribute{
												"resource_group": schema.StringAttribute{
													MarkdownDescription: "Existing Vnet Resource Group. Resource group of existing Vnet",
													Optional:            true,
												},
												"vnet_name": schema.StringAttribute{
													MarkdownDescription: "Existing Vnet Name. Name of existing Vnet",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"f5_orchestrated_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"manual_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional:            true,
																		Computed:            true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"not_hub": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional:            true,
																		Computed:            true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"ingress_egress_gw_ar": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Ingress/Egress Gateway on Alternate Region. Two interface Azure ingress/egress site on Alternate Region with no support for zones",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. x-required Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"hub": schema.SingleNestedBlock{
						MarkdownDescription: "Hub VNet type. Hub VNet type",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"express_route_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"express_route_enabled": schema.SingleNestedBlock{
								MarkdownDescription: "Express Route Configuration. Express Route Configuration",
								Attributes: map[string]schema.Attribute{
									"custom_asn": schema.Int64Attribute{
										MarkdownDescription: "Custom ASN. Set custom ASN for F5XC Site",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"auto_asn": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"connections": schema.ListNestedBlock{
										MarkdownDescription: "Connections. Add the ExpressRoute Circuit Connections to this site",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"circuit_id": schema.StringAttribute{
													MarkdownDescription: "Circuit in same subscription. ExpressRoute Circuit is in same subscription as the site",
													Optional:            true,
												},
												"weight": schema.Int64Attribute{
													MarkdownDescription: "Routing Weight. The weight (or priority) for the routes received from this connection. The. Defaults to `10`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"other_subscription": schema.SingleNestedBlock{
													MarkdownDescription: "Express Route Circuit Config From Other Subscription. Express Route Circuit Config From Other Subscription",
													Attributes: map[string]schema.Attribute{
														"circuit_id": schema.StringAttribute{
															MarkdownDescription: "Circuit ID. Circuit ID",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"authorized_key": schema.SingleNestedBlock{
															MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional:            true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																			Optional:            true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional:            true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional:            true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"do_not_advertise_to_route_server": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"gateway_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
														Optional:            true,
													},
												},
											},
										},
									},
									"route_server_subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"auto": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"subnet": schema.SingleNestedBlock{
												MarkdownDescription: "Azure Cloud Special Subnet. Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)",
												Attributes: map[string]schema.Attribute{
													"subnet_resource_grp": schema.StringAttribute{
														MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"vnet_resource_group": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
											"subnet_param": schema.SingleNestedBlock{
												MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
												Attributes: map[string]schema.Attribute{
													"ipv4": schema.StringAttribute{
														MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
														Optional:            true,
													},
												},
											},
										},
									},
									"site_registration_over_express_route": schema.SingleNestedBlock{
										MarkdownDescription: "CloudLink ADN Network Config.",
										Attributes: map[string]schema.Attribute{
											"cloudlink_network_name": schema.StringAttribute{
												MarkdownDescription: "Private ADN Network. Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
												Optional:            true,
											},
										},
									},
									"site_registration_over_internet": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_ergw1az": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_ergw2az": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_high_perf": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"sku_standard": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"spoke_vnets": schema.ListNestedBlock{
								MarkdownDescription: "Spoke VNet Peering (Legacy). Spoke VNet Peering",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"auto": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"labels": schema.SingleNestedBlock{
											MarkdownDescription: "Labels For VNets Peering. Add Labels for each of the VNets peered with transit VNet, these labels can be used in firewall policy These labels used must be from known key and label defined in shared namespace",
										},
										"manual": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"vnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Existing Vnet Type. Resource group and name of existing Azure Vnet",
											Attributes: map[string]schema.Attribute{
												"resource_group": schema.StringAttribute{
													MarkdownDescription: "Existing Vnet Resource Group. Resource group of existing Vnet",
													Optional:            true,
												},
												"vnet_name": schema.StringAttribute{
													MarkdownDescription: "Existing Vnet Name. Name of existing Vnet",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"f5_orchestrated_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"manual_routing": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional:            true,
																		Computed:            true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"node": schema.SingleNestedBlock{
						MarkdownDescription: "Two Interface Node. Parameters for creating two interface Node in one AZ",
						Attributes: map[string]schema.Attribute{
							"fault_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of fault domains. Namuber of fault domains to be used while creating the availability set",
								Optional:            true,
							},
							"node_number": schema.Int64Attribute{
								MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
								Optional:            true,
							},
							"update_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of update domains. Namuber of update domains to be used while creating the availability set",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"inside_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
												Optional:            true,
											},
										},
									},
								},
							},
							"outside_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"not_hub": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional:            true,
																		Computed:            true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"ingress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Ingress Gateway on Recommended Region. Single interface Azure ingress site on on Recommended Region",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. x-required Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Ingress Gateway (One Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"azure_az": schema.StringAttribute{
									MarkdownDescription: "Azure Availability Zone. A zone depicting a grouping of datacenters within an Azure region. Expecting numeric input",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},
			},
			"ingress_gw_ar": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Ingress Gateway on Alternate Region. Single interface Azure ingress site",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. x-required Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"node": schema.SingleNestedBlock{
						MarkdownDescription: "Single Interface Node for Alternate Region. Parameters for creating Single interface Node for Alternate Region",
						Attributes: map[string]schema.Attribute{
							"fault_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of fault domains. Namuber of fault domains to be used while creating the availability set",
								Optional:            true,
							},
							"node_number": schema.Int64Attribute{
								MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
								Optional:            true,
							},
							"update_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of update domains. Namuber of update domains to be used while creating the availability set",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"local_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},
			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Node by Node Upgrade. Specify how worker nodes within a site will be upgraded.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable Node by Node Upgrade. Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional:            true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Upgrade Wait Time. Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is recommended to use the default value).",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},
			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional:            true,
						Computed:            true,
					},
				},
			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_worker_nodes": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_worker_nodes, nodes_per_az, total_nodes] Empty. This can be used for messages where no values are needed",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability Mode. Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7 days, even when the site is offline. The certificates needed to keep the services running on this site are signed using a local CA. Secrets would also be cached locally to handle the connectivity loss. When the mode is toggled, services will restart and traffic disruption will be seen.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Operating System Version. Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Operating System Version. Specify a OS version to be used e.g. 9.2024.6.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "F5XC Software Version. Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "F5XC Software Version. Specify a F5XC Software Version to be used e.g. crt-20210329-1002.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"tags": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Tags. Azure Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in Azure console.",
			},
			"vnet": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Vnet choice. This defines choice about Azure Vnet for a view",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"existing_vnet": schema.SingleNestedBlock{
						MarkdownDescription: "Azure Existing Vnet Type. Resource group and name of existing Azure Vnet",
						Attributes: map[string]schema.Attribute{
							"resource_group": schema.StringAttribute{
								MarkdownDescription: "Existing Vnet Resource Group. Resource group of existing Vnet",
								Optional:            true,
							},
							"vnet_name": schema.StringAttribute{
								MarkdownDescription: "Existing Vnet Name. Name of existing Vnet",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"f5_orchestrated_routing": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"manual_routing": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"new_vnet": schema.SingleNestedBlock{
						MarkdownDescription: "Azure Vnet Parameters. Parameters to create a new Azure Vnet",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Choose Vnet Name. Specify the Vnet Name",
								Optional:            true,
							},
							"primary_ipv4": schema.StringAttribute{
								MarkdownDescription: "IPv4 CIDR block. IPv4 CIDR block for this Vnet. It has to be private address space.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},
			},
			"voltstack_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "Azure App Stack Cluster on Recommended Region. App Stack Cluster of single interface Azure nodes",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. x-required Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "App Stack Cluster (One Interface) Nodes in AZ. Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"azure_az": schema.StringAttribute{
									MarkdownDescription: "Azure Availability Zone. A zone depicting a grouping of datacenters within an Azure region. Expecting numeric input",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"local_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
											Attributes: map[string]schema.Attribute{
												"subnet_name": schema.StringAttribute{
													MarkdownDescription: "Subnet Name. Name of existing subnet.",
													Optional:            true,
												},
												"subnet_resource_grp": schema.StringAttribute{
													MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"vnet_resource_group": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional:            true,
																		Computed:            true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Storage Class List. Add additional custom storage classes in kubernetes for this site",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Default Storage Class. Make this storage class default storage class for the K8s cluster",
											Optional:            true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Storage Class Name. Name of the storage class as it will appear in K8s.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
			"voltstack_cluster_ar": schema.SingleNestedBlock{
				MarkdownDescription: "Azure App Stack Cluster on Alternate Region. App Stack Cluster of single interface Azure nodes",
				Attributes: map[string]schema.Attribute{
					"azure_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Azure Certified Hardware. Name for Azure certified hardware.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"accelerated_networking": schema.SingleNestedBlock{
						MarkdownDescription: "Accelerated Networking Type. x-required Accelerated Networking to reduce Latency, When Mode is toggled, traffic disruption will be seen",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional:            true,
															Computed:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"node": schema.SingleNestedBlock{
						MarkdownDescription: "Single Interface Node for Alternate Region. Parameters for creating Single interface Node for Alternate Region",
						Attributes: map[string]schema.Attribute{
							"fault_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of fault domains. Namuber of fault domains to be used while creating the availability set",
								Optional:            true,
							},
							"node_number": schema.Int64Attribute{
								MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
								Optional:            true,
							},
							"update_domain": schema.Int64Attribute{
								MarkdownDescription: "Number of update domains. Namuber of update domains to be used while creating the availability set",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"local_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"subnet": schema.SingleNestedBlock{
										MarkdownDescription: "Azure Subnet. Parameters for Azure subnet",
										Attributes: map[string]schema.Attribute{
											"subnet_name": schema.StringAttribute{
												MarkdownDescription: "Subnet Name. Name of existing subnet.",
												Optional:            true,
											},
											"subnet_resource_grp": schema.StringAttribute{
												MarkdownDescription: "Resource Group Name. Specify name of Resource Group",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"vnet_resource_group": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"subnet_param": schema.SingleNestedBlock{
										MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
										Attributes: map[string]schema.Attribute{
											"ipv4": schema.StringAttribute{
												MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional:            true,
																		Computed:            true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional:            true,
																		Computed:            true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Storage Class List. Add additional custom storage classes in kubernetes for this site",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Default Storage Class. Make this storage class default storage class for the K8s cluster",
											Optional:            true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Storage Class Name. Name of the storage class as it will appear in K8s.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *AzureVNETSiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *AzureVNETSiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *AzureVNETSiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the azure_vnet_site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan AzureVNETSiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *AzureVNETSiteResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := AzureVNETSiteResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *AzureVNETSiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating azure_vnet_site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.AzureVNETSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		createReq.Spec["admin_password"] = admin_passwordMap
	}
	if data.AzureCred != nil {
		azure_credMap := make(map[string]interface{})
		if !data.AzureCred.Name.IsNull() && !data.AzureCred.Name.IsUnknown() {
			azure_credMap["name"] = data.AzureCred.Name.ValueString()
		}
		if !data.AzureCred.Namespace.IsNull() && !data.AzureCred.Namespace.IsUnknown() {
			azure_credMap["namespace"] = data.AzureCred.Namespace.ValueString()
		}
		if !data.AzureCred.Tenant.IsNull() && !data.AzureCred.Tenant.IsUnknown() {
			azure_credMap["tenant"] = data.AzureCred.Tenant.ValueString()
		}
		createReq.Spec["azure_cred"] = azure_credMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		createReq.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		createReq.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		createReq.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		createReq.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		createReq.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.IngressEgressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressEgressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_egress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressEgressGw.AzureCertifiedHw.IsNull() && !data.IngressEgressGw.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["azure_certified_hw"] = data.IngressEgressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NotHub != nil {
			ingress_egress_gwMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressEgressGwAr != nil {
		ingress_egress_gw_arMap := make(map[string]interface{})
		if data.IngressEgressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.IngressEgressGwAr.AzureCertifiedHw.IsNull() && !data.IngressEgressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gw_arMap["azure_certified_hw"] = data.IngressEgressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGwAr.ForwardProxyAllowAll != nil {
			ingress_egress_gw_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGwAr.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGwAr.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.NoDcClusterGroup != nil {
			ingress_egress_gw_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoForwardProxy != nil {
			ingress_egress_gw_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoGlobalNetwork != nil {
			ingress_egress_gw_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoInsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoNetworkPolicy != nil {
			ingress_egress_gw_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoOutsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.Node.FaultDomain.IsNull() && !data.IngressEgressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressEgressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.NodeNumber.IsNull() && !data.IngressEgressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressEgressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.UpdateDomain.IsNull() && !data.IngressEgressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressEgressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_egress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressEgressGwAr.NotHub != nil {
			ingress_egress_gw_arMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGwAr.SmConnectionPublicIP != nil {
			ingress_egress_gw_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.SmConnectionPvtIP != nil {
			ingress_egress_gw_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["ingress_egress_gw_ar"] = ingress_egress_gw_arMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if data.IngressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if len(data.IngressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressGw.AzureCertifiedHw.IsNull() && !data.IngressGw.AzureCertifiedHw.IsUnknown() {
			ingress_gwMap["azure_certified_hw"] = data.IngressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		createReq.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.IngressGwAr != nil {
		ingress_gw_arMap := make(map[string]interface{})
		if data.IngressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if !data.IngressGwAr.AzureCertifiedHw.IsNull() && !data.IngressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_gw_arMap["azure_certified_hw"] = data.IngressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressGwAr.Node.FaultDomain.IsNull() && !data.IngressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressGwAr.Node.NodeNumber.IsNull() && !data.IngressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressGwAr.Node.UpdateDomain.IsNull() && !data.IngressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		createReq.Spec["ingress_gw_ar"] = ingress_gw_arMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		createReq.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		createReq.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		createReq.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.NoWorkerNodes != nil {
		no_worker_nodesMap := make(map[string]interface{})
		createReq.Spec["no_worker_nodes"] = no_worker_nodesMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		createReq.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		createReq.Spec["os"] = osMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		createReq.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		createReq.Spec["tags"] = tagsMap
	}
	if data.VNET != nil {
		vnetMap := make(map[string]interface{})
		if data.VNET.ExistingVNET != nil {
			existing_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.ExistingVNET.ResourceGroup.IsNull() && !data.VNET.ExistingVNET.ResourceGroup.IsUnknown() {
				existing_vnetNestedMap["resource_group"] = data.VNET.ExistingVNET.ResourceGroup.ValueString()
			}
			if !data.VNET.ExistingVNET.VNETName.IsNull() && !data.VNET.ExistingVNET.VNETName.IsUnknown() {
				existing_vnetNestedMap["vnet_name"] = data.VNET.ExistingVNET.VNETName.ValueString()
			}
			vnetMap["existing_vnet"] = existing_vnetNestedMap
		}
		if data.VNET.NewVNET != nil {
			new_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.NewVNET.Name.IsNull() && !data.VNET.NewVNET.Name.IsUnknown() {
				new_vnetNestedMap["name"] = data.VNET.NewVNET.Name.ValueString()
			}
			if !data.VNET.NewVNET.PrimaryIpv4.IsNull() && !data.VNET.NewVNET.PrimaryIpv4.IsUnknown() {
				new_vnetNestedMap["primary_ipv4"] = data.VNET.NewVNET.PrimaryIpv4.ValueString()
			}
			vnetMap["new_vnet"] = new_vnetNestedMap
		}
		createReq.Spec["vnet"] = vnetMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_clusterMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.VoltstackCluster.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.VoltstackCluster.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			voltstack_clusterMap["az_nodes"] = az_nodesList
		}
		if !data.VoltstackCluster.AzureCertifiedHw.IsNull() && !data.VoltstackCluster.AzureCertifiedHw.IsUnknown() {
			voltstack_clusterMap["azure_certified_hw"] = data.VoltstackCluster.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		createReq.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if data.VoltstackClusterAr != nil {
		voltstack_cluster_arMap := make(map[string]interface{})
		if data.VoltstackClusterAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.VoltstackClusterAr.AzureCertifiedHw.IsNull() && !data.VoltstackClusterAr.AzureCertifiedHw.IsUnknown() {
			voltstack_cluster_arMap["azure_certified_hw"] = data.VoltstackClusterAr.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackClusterAr.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.DcClusterGroup.Name.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackClusterAr.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackClusterAr.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackClusterAr.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_cluster_arMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackClusterAr.DefaultStorage != nil {
			voltstack_cluster_arMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.ForwardProxyAllowAll != nil {
			voltstack_cluster_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackClusterAr.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.K8SCluster.Name.IsNull() && !data.VoltstackClusterAr.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackClusterAr.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Namespace.IsNull() && !data.VoltstackClusterAr.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackClusterAr.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Tenant.IsNull() && !data.VoltstackClusterAr.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackClusterAr.K8SCluster.Tenant.ValueString()
			}
			voltstack_cluster_arMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackClusterAr.NoDcClusterGroup != nil {
			voltstack_cluster_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoForwardProxy != nil {
			voltstack_cluster_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoGlobalNetwork != nil {
			voltstack_cluster_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoK8SCluster != nil {
			voltstack_cluster_arMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoNetworkPolicy != nil {
			voltstack_cluster_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoOutsideStaticRoutes != nil {
			voltstack_cluster_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.Node.FaultDomain.IsNull() && !data.VoltstackClusterAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.VoltstackClusterAr.Node.FaultDomain.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.NodeNumber.IsNull() && !data.VoltstackClusterAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.VoltstackClusterAr.Node.NodeNumber.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.UpdateDomain.IsNull() && !data.VoltstackClusterAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.VoltstackClusterAr.Node.UpdateDomain.ValueInt64()
			}
			voltstack_cluster_arMap["node"] = nodeNestedMap
		}
		if data.VoltstackClusterAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackClusterAr.SmConnectionPublicIP != nil {
			voltstack_cluster_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.SmConnectionPvtIP != nil {
			voltstack_cluster_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["storage_class_list"] = storage_class_listNestedMap
		}
		createReq.Spec["voltstack_cluster_ar"] = voltstack_cluster_arMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		createReq.Spec["address"] = data.Address.ValueString()
	}
	if !data.AlternateRegion.IsNull() && !data.AlternateRegion.IsUnknown() {
		createReq.Spec["alternate_region"] = data.AlternateRegion.ValueString()
	}
	if !data.AzureRegion.IsNull() && !data.AzureRegion.IsUnknown() {
		createReq.Spec["azure_region"] = data.AzureRegion.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		createReq.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.MachineType.IsNull() && !data.MachineType.IsUnknown() {
		createReq.Spec["machine_type"] = data.MachineType.ValueString()
	}
	if !data.NodesPerAz.IsNull() && !data.NodesPerAz.IsUnknown() {
		createReq.Spec["nodes_per_az"] = data.NodesPerAz.ValueInt64()
	}
	if !data.ResourceGroup.IsNull() && !data.ResourceGroup.IsUnknown() {
		createReq.Spec["resource_group"] = data.ResourceGroup.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		createReq.Spec["ssh_key"] = data.SSHKey.ValueString()
	}
	if !data.TotalNodes.IsNull() && !data.TotalNodes.IsUnknown() {
		createReq.Spec["total_nodes"] = data.TotalNodes.ValueInt64()
	}

	apiResource, err := r.client.CreateAzureVNETSite(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create AzureVNETSite: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AzureVNETSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["azure_cred"].(map[string]interface{}); ok && (isImport || data.AzureCred != nil) {
		data.AzureCred = &AzureVNETSiteAzureCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AzureVNETSiteBlockedServicesModel{
			BlockedSevice: func() []AzureVNETSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AzureVNETSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AzureVNETSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AzureVNETSiteIngressEgressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressEgressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel {
									if _, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel{}
									}
									return nil
								}(),
								OutsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if _, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwHubModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_egress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressEgressGwAr != nil) {
		data.IngressEgressGwAr = &AzureVNETSiteIngressEgressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwArHubModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteIngressEgressGwArNodeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AzureVNETSiteIngressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteIngressGwAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressGwAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressGwAr != nil) {
		data.IngressGwAr = &AzureVNETSiteIngressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Node: func() *AzureVNETSiteIngressGwArNodeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AzureVNETSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AzureVNETSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AzureVNETSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AzureVNETSiteOSModel{
			DefaultOSVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AzureVNETSiteSwModel{
			DefaultSwVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vnet"].(map[string]interface{}); ok && isImport && data.VNET == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VNET = &AzureVNETSiteVNETModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AzureVNETSiteVoltstackClusterModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteVoltstackClusterAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster_ar"].(map[string]interface{}); ok && (isImport || data.VoltstackClusterAr != nil) {
		data.VoltstackClusterAr = &AzureVNETSiteVoltstackClusterArModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterArDcClusterGroupModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterArK8SClusterModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteVoltstackClusterArNodeModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterArStorageClassListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else {
		data.AlternateRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else {
		data.AzureRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else {
		data.MachineType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else {
		data.ResourceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created AzureVNETSite resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureVNETSiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetAzureVNETSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AzureVNETSite not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AzureVNETSite: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The azure_vnet_site may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AzureVNETSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["azure_cred"].(map[string]interface{}); ok && (isImport || data.AzureCred != nil) {
		data.AzureCred = &AzureVNETSiteAzureCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AzureVNETSiteBlockedServicesModel{
			BlockedSevice: func() []AzureVNETSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AzureVNETSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AzureVNETSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AzureVNETSiteIngressEgressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressEgressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel {
									if _, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel{}
									}
									return nil
								}(),
								OutsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if _, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwHubModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_egress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressEgressGwAr != nil) {
		data.IngressEgressGwAr = &AzureVNETSiteIngressEgressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwArHubModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteIngressEgressGwArNodeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AzureVNETSiteIngressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteIngressGwAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressGwAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressGwAr != nil) {
		data.IngressGwAr = &AzureVNETSiteIngressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Node: func() *AzureVNETSiteIngressGwArNodeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AzureVNETSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AzureVNETSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AzureVNETSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AzureVNETSiteOSModel{
			DefaultOSVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AzureVNETSiteSwModel{
			DefaultSwVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vnet"].(map[string]interface{}); ok && isImport && data.VNET == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VNET = &AzureVNETSiteVNETModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AzureVNETSiteVoltstackClusterModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteVoltstackClusterAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster_ar"].(map[string]interface{}); ok && (isImport || data.VoltstackClusterAr != nil) {
		data.VoltstackClusterAr = &AzureVNETSiteVoltstackClusterArModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterArDcClusterGroupModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterArK8SClusterModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteVoltstackClusterArNodeModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterArStorageClassListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else {
		data.AlternateRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else {
		data.AzureRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else {
		data.MachineType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else {
		data.ResourceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureVNETSiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.AzureVNETSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		apiResource.Spec["admin_password"] = admin_passwordMap
	}
	if data.AzureCred != nil {
		azure_credMap := make(map[string]interface{})
		if !data.AzureCred.Name.IsNull() && !data.AzureCred.Name.IsUnknown() {
			azure_credMap["name"] = data.AzureCred.Name.ValueString()
		}
		if !data.AzureCred.Namespace.IsNull() && !data.AzureCred.Namespace.IsUnknown() {
			azure_credMap["namespace"] = data.AzureCred.Namespace.ValueString()
		}
		if !data.AzureCred.Tenant.IsNull() && !data.AzureCred.Tenant.IsUnknown() {
			azure_credMap["tenant"] = data.AzureCred.Tenant.ValueString()
		}
		apiResource.Spec["azure_cred"] = azure_credMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.IngressEgressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressEgressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_egress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressEgressGw.AzureCertifiedHw.IsNull() && !data.IngressEgressGw.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["azure_certified_hw"] = data.IngressEgressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NotHub != nil {
			ingress_egress_gwMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressEgressGwAr != nil {
		ingress_egress_gw_arMap := make(map[string]interface{})
		if data.IngressEgressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.IngressEgressGwAr.AzureCertifiedHw.IsNull() && !data.IngressEgressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_egress_gw_arMap["azure_certified_hw"] = data.IngressEgressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGwAr.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gw_arMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGwAr.ForwardProxyAllowAll != nil {
			ingress_egress_gw_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGwAr.Hub != nil {
			hubNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["hub"] = hubNestedMap
		}
		if data.IngressEgressGwAr.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.NoDcClusterGroup != nil {
			ingress_egress_gw_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoForwardProxy != nil {
			ingress_egress_gw_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoGlobalNetwork != nil {
			ingress_egress_gw_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoInsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoNetworkPolicy != nil {
			ingress_egress_gw_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.NoOutsideStaticRoutes != nil {
			ingress_egress_gw_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressEgressGwAr.Node.FaultDomain.IsNull() && !data.IngressEgressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressEgressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.NodeNumber.IsNull() && !data.IngressEgressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressEgressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressEgressGwAr.Node.UpdateDomain.IsNull() && !data.IngressEgressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressEgressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_egress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressEgressGwAr.NotHub != nil {
			ingress_egress_gw_arMap["not_hub"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGwAr.SmConnectionPublicIP != nil {
			ingress_egress_gw_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGwAr.SmConnectionPvtIP != nil {
			ingress_egress_gw_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw_ar"] = ingress_egress_gw_arMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if data.IngressGw.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gwMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if len(data.IngressGw.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.IngressGw.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			ingress_gwMap["az_nodes"] = az_nodesList
		}
		if !data.IngressGw.AzureCertifiedHw.IsNull() && !data.IngressGw.AzureCertifiedHw.IsUnknown() {
			ingress_gwMap["azure_certified_hw"] = data.IngressGw.AzureCertifiedHw.ValueString()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.IngressGwAr != nil {
		ingress_gw_arMap := make(map[string]interface{})
		if data.IngressGwAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			ingress_gw_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if !data.IngressGwAr.AzureCertifiedHw.IsNull() && !data.IngressGwAr.AzureCertifiedHw.IsUnknown() {
			ingress_gw_arMap["azure_certified_hw"] = data.IngressGwAr.AzureCertifiedHw.ValueString()
		}
		if data.IngressGwAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.IngressGwAr.Node.FaultDomain.IsNull() && !data.IngressGwAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.IngressGwAr.Node.FaultDomain.ValueInt64()
			}
			if !data.IngressGwAr.Node.NodeNumber.IsNull() && !data.IngressGwAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.IngressGwAr.Node.NodeNumber.ValueInt64()
			}
			if !data.IngressGwAr.Node.UpdateDomain.IsNull() && !data.IngressGwAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.IngressGwAr.Node.UpdateDomain.ValueInt64()
			}
			ingress_gw_arMap["node"] = nodeNestedMap
		}
		if data.IngressGwAr.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gw_arMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw_ar"] = ingress_gw_arMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.NoWorkerNodes != nil {
		no_worker_nodesMap := make(map[string]interface{})
		apiResource.Spec["no_worker_nodes"] = no_worker_nodesMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		apiResource.Spec["tags"] = tagsMap
	}
	if data.VNET != nil {
		vnetMap := make(map[string]interface{})
		if data.VNET.ExistingVNET != nil {
			existing_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.ExistingVNET.ResourceGroup.IsNull() && !data.VNET.ExistingVNET.ResourceGroup.IsUnknown() {
				existing_vnetNestedMap["resource_group"] = data.VNET.ExistingVNET.ResourceGroup.ValueString()
			}
			if !data.VNET.ExistingVNET.VNETName.IsNull() && !data.VNET.ExistingVNET.VNETName.IsUnknown() {
				existing_vnetNestedMap["vnet_name"] = data.VNET.ExistingVNET.VNETName.ValueString()
			}
			vnetMap["existing_vnet"] = existing_vnetNestedMap
		}
		if data.VNET.NewVNET != nil {
			new_vnetNestedMap := make(map[string]interface{})
			if !data.VNET.NewVNET.Name.IsNull() && !data.VNET.NewVNET.Name.IsUnknown() {
				new_vnetNestedMap["name"] = data.VNET.NewVNET.Name.ValueString()
			}
			if !data.VNET.NewVNET.PrimaryIpv4.IsNull() && !data.VNET.NewVNET.PrimaryIpv4.IsUnknown() {
				new_vnetNestedMap["primary_ipv4"] = data.VNET.NewVNET.PrimaryIpv4.ValueString()
			}
			vnetMap["new_vnet"] = new_vnetNestedMap
		}
		apiResource.Spec["vnet"] = vnetMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_clusterMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if len(data.VoltstackCluster.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.VoltstackCluster.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AzureAz.IsNull() && !listItem.AzureAz.IsUnknown() {
					listItemMap["azure_az"] = listItem.AzureAz.ValueString()
				}
				if listItem.LocalSubnet != nil {
					local_subnetDeepMap := make(map[string]interface{})
					listItemMap["local_subnet"] = local_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			voltstack_clusterMap["az_nodes"] = az_nodesList
		}
		if !data.VoltstackCluster.AzureCertifiedHw.IsNull() && !data.VoltstackCluster.AzureCertifiedHw.IsUnknown() {
			voltstack_clusterMap["azure_certified_hw"] = data.VoltstackCluster.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if data.VoltstackClusterAr != nil {
		voltstack_cluster_arMap := make(map[string]interface{})
		if data.VoltstackClusterAr.AcceleratedNetworking != nil {
			accelerated_networkingNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["accelerated_networking"] = accelerated_networkingNestedMap
		}
		if data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if !data.VoltstackClusterAr.AzureCertifiedHw.IsNull() && !data.VoltstackClusterAr.AzureCertifiedHw.IsUnknown() {
			voltstack_cluster_arMap["azure_certified_hw"] = data.VoltstackClusterAr.AzureCertifiedHw.ValueString()
		}
		if data.VoltstackClusterAr.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.DcClusterGroup.Name.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackClusterAr.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackClusterAr.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsNull() && !data.VoltstackClusterAr.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackClusterAr.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_cluster_arMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackClusterAr.DefaultStorage != nil {
			voltstack_cluster_arMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.ForwardProxyAllowAll != nil {
			voltstack_cluster_arMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackClusterAr.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.K8SCluster.Name.IsNull() && !data.VoltstackClusterAr.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackClusterAr.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Namespace.IsNull() && !data.VoltstackClusterAr.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackClusterAr.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackClusterAr.K8SCluster.Tenant.IsNull() && !data.VoltstackClusterAr.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackClusterAr.K8SCluster.Tenant.ValueString()
			}
			voltstack_cluster_arMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackClusterAr.NoDcClusterGroup != nil {
			voltstack_cluster_arMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoForwardProxy != nil {
			voltstack_cluster_arMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoGlobalNetwork != nil {
			voltstack_cluster_arMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoK8SCluster != nil {
			voltstack_cluster_arMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoNetworkPolicy != nil {
			voltstack_cluster_arMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.NoOutsideStaticRoutes != nil {
			voltstack_cluster_arMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.Node != nil {
			nodeNestedMap := make(map[string]interface{})
			if !data.VoltstackClusterAr.Node.FaultDomain.IsNull() && !data.VoltstackClusterAr.Node.FaultDomain.IsUnknown() {
				nodeNestedMap["fault_domain"] = data.VoltstackClusterAr.Node.FaultDomain.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.NodeNumber.IsNull() && !data.VoltstackClusterAr.Node.NodeNumber.IsUnknown() {
				nodeNestedMap["node_number"] = data.VoltstackClusterAr.Node.NodeNumber.ValueInt64()
			}
			if !data.VoltstackClusterAr.Node.UpdateDomain.IsNull() && !data.VoltstackClusterAr.Node.UpdateDomain.IsUnknown() {
				nodeNestedMap["update_domain"] = data.VoltstackClusterAr.Node.UpdateDomain.ValueInt64()
			}
			voltstack_cluster_arMap["node"] = nodeNestedMap
		}
		if data.VoltstackClusterAr.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackClusterAr.SmConnectionPublicIP != nil {
			voltstack_cluster_arMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.SmConnectionPvtIP != nil {
			voltstack_cluster_arMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackClusterAr.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_cluster_arMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster_ar"] = voltstack_cluster_arMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		apiResource.Spec["address"] = data.Address.ValueString()
	}
	if !data.AlternateRegion.IsNull() && !data.AlternateRegion.IsUnknown() {
		apiResource.Spec["alternate_region"] = data.AlternateRegion.ValueString()
	}
	if !data.AzureRegion.IsNull() && !data.AzureRegion.IsUnknown() {
		apiResource.Spec["azure_region"] = data.AzureRegion.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		apiResource.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.MachineType.IsNull() && !data.MachineType.IsUnknown() {
		apiResource.Spec["machine_type"] = data.MachineType.ValueString()
	}
	if !data.NodesPerAz.IsNull() && !data.NodesPerAz.IsUnknown() {
		apiResource.Spec["nodes_per_az"] = data.NodesPerAz.ValueInt64()
	}
	if !data.ResourceGroup.IsNull() && !data.ResourceGroup.IsUnknown() {
		apiResource.Spec["resource_group"] = data.ResourceGroup.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		apiResource.Spec["ssh_key"] = data.SSHKey.ValueString()
	}
	if !data.TotalNodes.IsNull() && !data.TotalNodes.IsUnknown() {
		apiResource.Spec["total_nodes"] = data.TotalNodes.ValueInt64()
	}

	_, err := r.client.UpdateAzureVNETSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update AzureVNETSite: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetAzureVNETSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read AzureVNETSite after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else if data.Address.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Address = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else if data.AlternateRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AlternateRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else if data.AzureRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AzureRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else if data.DiskSize.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DiskSize = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else if data.MachineType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.MachineType = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else if data.NodesPerAz.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.NodesPerAz = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else if data.ResourceGroup.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ResourceGroup = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else if data.SSHKey.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.SSHKey = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else if data.TotalNodes.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TotalNodes = types.Int64Null()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &AzureVNETSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["azure_cred"].(map[string]interface{}); ok && (isImport || data.AzureCred != nil) {
		data.AzureCred = &AzureVNETSiteAzureCredModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &AzureVNETSiteBlockedServicesModel{
			BlockedSevice: func() []AzureVNETSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *AzureVNETSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &AzureVNETSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &AzureVNETSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &AzureVNETSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &AzureVNETSiteIngressEgressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressEgressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressEgressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressEgressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel {
									if _, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesInsideSubnetModel{}
									}
									return nil
								}(),
								OutsideSubnet: func() *AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel {
									if _, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressEgressGwAzNodesOutsideSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwHubModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_egress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressEgressGwAr != nil) {
		data.IngressEgressGwAr = &AzureVNETSiteIngressEgressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroupInsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteIngressEgressGwArGlobalNetworkListModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArGlobalNetworkListModel{}
				}
				return nil
			}(),
			Hub: func() *AzureVNETSiteIngressEgressGwArHubModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Hub != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Hub
				}
				// Import case: read from API
				if _, ok := blockData["hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArHubModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArInsideStaticRoutesModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteIngressEgressGwArNodeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			NotHub: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.NotHub
				}
				// Import case: read from API
				if _, ok := blockData["not_hub"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGwAr != nil && data.IngressEgressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressEgressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.IngressEgressGwAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGwAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &AzureVNETSiteIngressGwModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwAcceleratedNetworkingModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteIngressGwAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteIngressGwAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteIngressGwAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteIngressGwAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteIngressGwAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw_ar"].(map[string]interface{}); ok && (isImport || data.IngressGwAr != nil) {
		data.IngressGwAr = &AzureVNETSiteIngressGwArModel{
			AcceleratedNetworking: func() *AzureVNETSiteIngressGwArAcceleratedNetworkingModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Node: func() *AzureVNETSiteIngressGwArNodeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *AzureVNETSiteIngressGwArPerformanceEnhancementModeModel {
				if !isImport && data.IngressGwAr != nil && data.IngressGwAr.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGwAr.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &AzureVNETSiteIngressGwArPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &AzureVNETSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &AzureVNETSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_worker_nodes"].(map[string]interface{}); ok && isImport && data.NoWorkerNodes == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoWorkerNodes = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &AzureVNETSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &AzureVNETSiteOSModel{
			DefaultOSVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &AzureVNETSiteSwModel{
			DefaultSwVersion: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &AzureVNETSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vnet"].(map[string]interface{}); ok && isImport && data.VNET == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VNET = &AzureVNETSiteVNETModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &AzureVNETSiteVoltstackClusterModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzNodes: func() []AzureVNETSiteVoltstackClusterAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []AzureVNETSiteVoltstackClusterAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, AzureVNETSiteVoltstackClusterAzNodesModel{
								AzureAz: func() types.String {
									if v, ok := itemMap["azure_az"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								LocalSubnet: func() *AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel {
									if _, ok := itemMap["local_subnet"].(map[string]interface{}); ok {
										return &AzureVNETSiteVoltstackClusterAzNodesLocalSubnetModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster_ar"].(map[string]interface{}); ok && (isImport || data.VoltstackClusterAr != nil) {
		data.VoltstackClusterAr = &AzureVNETSiteVoltstackClusterArModel{
			AcceleratedNetworking: func() *AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.AcceleratedNetworking != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.AcceleratedNetworking
				}
				// Import case: read from API
				if _, ok := blockData["accelerated_networking"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArAcceleratedNetworkingModel{}
				}
				return nil
			}(),
			ActiveEnhancedFirewallPolicies: func() *AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			AzureCertifiedHw: func() types.String {
				if v, ok := blockData["azure_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DcClusterGroup: func() *AzureVNETSiteVoltstackClusterArDcClusterGroupModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			GlobalNetworkList: func() *AzureVNETSiteVoltstackClusterArGlobalNetworkListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *AzureVNETSiteVoltstackClusterArK8SClusterModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			Node: func() *AzureVNETSiteVoltstackClusterArNodeModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.Node != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.Node
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["node"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArNodeModel{
						FaultDomain: func() types.Int64 {
							if v, ok := nestedBlockData["fault_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						NodeNumber: func() types.Int64 {
							if v, ok := nestedBlockData["node_number"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						UpdateDomain: func() types.Int64 {
							if v, ok := nestedBlockData["update_domain"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *AzureVNETSiteEmptyModel {
				if !isImport && data.VoltstackClusterAr != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackClusterAr.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &AzureVNETSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *AzureVNETSiteVoltstackClusterArStorageClassListModel {
				if !isImport && data.VoltstackClusterAr != nil && data.VoltstackClusterAr.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackClusterAr.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &AzureVNETSiteVoltstackClusterArStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["alternate_region"].(string); ok && v != "" {
		data.AlternateRegion = types.StringValue(v)
	} else {
		data.AlternateRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["azure_region"].(string); ok && v != "" {
		data.AzureRegion = types.StringValue(v)
	} else {
		data.AzureRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["machine_type"].(string); ok && v != "" {
		data.MachineType = types.StringValue(v)
	} else {
		data.MachineType = types.StringNull()
	}
	if v, ok := apiResource.Spec["nodes_per_az"].(float64); ok {
		data.NodesPerAz = types.Int64Value(int64(v))
	} else {
		data.NodesPerAz = types.Int64Null()
	}
	if v, ok := apiResource.Spec["resource_group"].(string); ok && v != "" {
		data.ResourceGroup = types.StringValue(v)
	} else {
		data.ResourceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}
	if v, ok := apiResource.Spec["total_nodes"].(float64); ok {
		data.TotalNodes = types.Int64Value(int64(v))
	} else {
		data.TotalNodes = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureVNETSiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AzureVNETSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteAzureVNETSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "AzureVNETSite already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "AzureVNETSite delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete AzureVNETSite: %s", err))
		return
	}
}

func (r *AzureVNETSiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
