// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
)

var (
	_ resource.Resource                = &CDNCacheRuleResource{}
	_ resource.ResourceWithConfigure   = &CDNCacheRuleResource{}
	_ resource.ResourceWithImportState = &CDNCacheRuleResource{}
)

func NewCDNCacheRuleResource() resource.Resource {
	return &CDNCacheRuleResource{}
}

type CDNCacheRuleResource struct {
	client *client.Client
}

type CDNCacheRuleResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Labels types.Map `tfsdk:"labels"`
	Annotations types.Map `tfsdk:"annotations"`
	ID types.String `tfsdk:"id"`
}

func (r *CDNCacheRuleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cdn_cache_rule"
}

func (r *CDNCacheRuleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a CDNCacheRule resource in F5 Distributed Cloud for cdn loadbalancer configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the CDNCacheRule. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the CDNCacheRule will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"cache_rules": schema.SingleNestedBlock{
				MarkdownDescription: "Cache Rule. This defines a CDN Cache Rule",
				Attributes: map[string]schema.Attribute{
					"rule_name": schema.StringAttribute{
						MarkdownDescription: "Rule Name. Name of the Cache Rule",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"cache_bypass": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"eligible_for_cache": schema.SingleNestedBlock{
						MarkdownDescription: "Cache Action Options. List of options for Cache Action",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"scheme_proxy_host_request_uri": schema.SingleNestedBlock{
								MarkdownDescription: "Cache TTL Enable Props. Cache TTL Enable Values",
								Attributes: map[string]schema.Attribute{
									"cache_override": schema.BoolAttribute{
										MarkdownDescription: "Cache Override. Honour Cache Override",
										Optional: true,
									},
									"cache_ttl": schema.StringAttribute{
										MarkdownDescription: "Cache TTL. Cache TTL value is used to cache the resource/content for the specified amount of time Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
										Optional: true,
									},
									"ignore_response_cookie": schema.BoolAttribute{
										MarkdownDescription: "Ignore-Response-Cookie. By default, response will not be cached if set-cookie header is present. This option will override the behavior and cache response even with set-cookie header present.",
										Optional: true,
									},
								},
							},
							"scheme_proxy_host_uri": schema.SingleNestedBlock{
								MarkdownDescription: "Cache TTL Enable Props. Cache TTL Enable Values",
								Attributes: map[string]schema.Attribute{
									"cache_override": schema.BoolAttribute{
										MarkdownDescription: "Cache Override. Honour Cache Override",
										Optional: true,
									},
									"cache_ttl": schema.StringAttribute{
										MarkdownDescription: "Cache TTL. Cache TTL value is used to cache the resource/content for the specified amount of time Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
										Optional: true,
									},
									"ignore_response_cookie": schema.BoolAttribute{
										MarkdownDescription: "Ignore-Response-Cookie. By default, response will not be cached if set-cookie header is present. This option will override the behavior and cache response even with set-cookie header present.",
										Optional: true,
									},
								},
							},
						},
					},
					"rule_expression_list": schema.ListNestedBlock{
						MarkdownDescription: "Expressions. Expressions are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"expression_name": schema.StringAttribute{
									MarkdownDescription: "Expression Name. Name of the Expressions items that are ANDed",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"cache_rule_expression": schema.ListNestedBlock{
									MarkdownDescription: "Terms. The Cache Rule Expression Terms that are ANDed",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"cache_headers": schema.ListNestedBlock{
												MarkdownDescription: "Cache Headers. Configure cache rule headers to match the criteria",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{},
												},
											},
											"cookie_matcher": schema.ListNestedBlock{
												MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{},
												},
											},
											"path_match": schema.SingleNestedBlock{
												MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
											},
											"query_parameters": schema.ListNestedBlock{
												MarkdownDescription: "Query Parameters. List of (key, value) query parameters",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *CDNCacheRuleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *CDNCacheRuleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.CDNCacheRule{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.CDNCacheRuleSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateCDNCacheRule(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create CDNCacheRule: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)
	tflog.Trace(ctx, "created CDNCacheRule resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNCacheRuleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource, err := r.client.GetCDNCacheRule(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CDNCacheRule: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNCacheRuleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.CDNCacheRule{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.CDNCacheRuleSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateCDNCacheRule(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update CDNCacheRule: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNCacheRuleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteCDNCacheRule(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete CDNCacheRule: %s", err))
		return
	}
}

func (r *CDNCacheRuleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
