// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &CDNCacheRuleResource{}
	_ resource.ResourceWithConfigure      = &CDNCacheRuleResource{}
	_ resource.ResourceWithImportState    = &CDNCacheRuleResource{}
	_ resource.ResourceWithModifyPlan     = &CDNCacheRuleResource{}
	_ resource.ResourceWithUpgradeState   = &CDNCacheRuleResource{}
	_ resource.ResourceWithValidateConfig = &CDNCacheRuleResource{}
)

// cdn_cache_ruleSchemaVersion is the schema version for state upgrades
const cdn_cache_ruleSchemaVersion int64 = 1

func NewCDNCacheRuleResource() resource.Resource {
	return &CDNCacheRuleResource{}
}

type CDNCacheRuleResource struct {
	client *client.Client
}

// CDNCacheRuleEmptyModel represents empty nested blocks
type CDNCacheRuleEmptyModel struct {
}

// CDNCacheRuleCacheRulesModel represents cache_rules block
type CDNCacheRuleCacheRulesModel struct {
	RuleName types.String `tfsdk:"rule_name"`
	CacheBypass *CDNCacheRuleEmptyModel `tfsdk:"cache_bypass"`
	EligibleForCache *CDNCacheRuleCacheRulesEligibleForCacheModel `tfsdk:"eligible_for_cache"`
	RuleExpressionList []CDNCacheRuleCacheRulesRuleExpressionListModel `tfsdk:"rule_expression_list"`
}

// CDNCacheRuleCacheRulesEligibleForCacheModel represents eligible_for_cache block
type CDNCacheRuleCacheRulesEligibleForCacheModel struct {
	SchemeProxyHostRequestURI *CDNCacheRuleCacheRulesEligibleForCacheSchemeProxyHostRequestURIModel `tfsdk:"scheme_proxy_host_request_uri"`
	SchemeProxyHostURI *CDNCacheRuleCacheRulesEligibleForCacheSchemeProxyHostURIModel `tfsdk:"scheme_proxy_host_uri"`
}

// CDNCacheRuleCacheRulesEligibleForCacheSchemeProxyHostRequestURIModel represents scheme_proxy_host_request_uri block
type CDNCacheRuleCacheRulesEligibleForCacheSchemeProxyHostRequestURIModel struct {
	CacheOverride types.Bool `tfsdk:"cache_override"`
	CacheTtl types.String `tfsdk:"cache_ttl"`
	IgnoreResponseCookie types.Bool `tfsdk:"ignore_response_cookie"`
}

// CDNCacheRuleCacheRulesEligibleForCacheSchemeProxyHostURIModel represents scheme_proxy_host_uri block
type CDNCacheRuleCacheRulesEligibleForCacheSchemeProxyHostURIModel struct {
	CacheOverride types.Bool `tfsdk:"cache_override"`
	CacheTtl types.String `tfsdk:"cache_ttl"`
	IgnoreResponseCookie types.Bool `tfsdk:"ignore_response_cookie"`
}

// CDNCacheRuleCacheRulesRuleExpressionListModel represents rule_expression_list block
type CDNCacheRuleCacheRulesRuleExpressionListModel struct {
	ExpressionName types.String `tfsdk:"expression_name"`
	CacheRuleExpression []CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionModel `tfsdk:"cache_rule_expression"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionModel represents cache_rule_expression block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionModel struct {
	CacheHeaders []CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCacheHeadersModel `tfsdk:"cache_headers"`
	CookieMatcher []CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCookieMatcherModel `tfsdk:"cookie_matcher"`
	PathMatch *CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionPathMatchModel `tfsdk:"path_match"`
	QueryParameters []CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionQueryParametersModel `tfsdk:"query_parameters"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCacheHeadersModel represents cache_headers block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCacheHeadersModel struct {
	Name types.String `tfsdk:"name"`
	Operator *CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCacheHeadersOperatorModel `tfsdk:"operator"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCacheHeadersOperatorModel represents operator block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCacheHeadersOperatorModel struct {
	Contains types.String `tfsdk:"contains"`
	Doesnotcontain types.String `tfsdk:"does_not_contain"`
	Doesnotendwith types.String `tfsdk:"does_not_end_with"`
	Doesnotequal types.String `tfsdk:"does_not_equal"`
	Doesnotstartwith types.String `tfsdk:"does_not_start_with"`
	Endswith types.String `tfsdk:"endswith"`
	Equals types.String `tfsdk:"equals"`
	Matchregex types.String `tfsdk:"match_regex"`
	Startswith types.String `tfsdk:"startswith"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCookieMatcherModel represents cookie_matcher block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCookieMatcherModel struct {
	Name types.String `tfsdk:"name"`
	Operator *CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCookieMatcherOperatorModel `tfsdk:"operator"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCookieMatcherOperatorModel represents operator block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionCookieMatcherOperatorModel struct {
	Contains types.String `tfsdk:"contains"`
	Doesnotcontain types.String `tfsdk:"does_not_contain"`
	Doesnotendwith types.String `tfsdk:"does_not_end_with"`
	Doesnotequal types.String `tfsdk:"does_not_equal"`
	Doesnotstartwith types.String `tfsdk:"does_not_start_with"`
	Endswith types.String `tfsdk:"endswith"`
	Equals types.String `tfsdk:"equals"`
	Matchregex types.String `tfsdk:"match_regex"`
	Startswith types.String `tfsdk:"startswith"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionPathMatchModel represents path_match block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionPathMatchModel struct {
	Operator *CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionPathMatchOperatorModel `tfsdk:"operator"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionPathMatchOperatorModel represents operator block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionPathMatchOperatorModel struct {
	Contains types.String `tfsdk:"contains"`
	Doesnotcontain types.String `tfsdk:"does_not_contain"`
	Doesnotendwith types.String `tfsdk:"does_not_end_with"`
	Doesnotequal types.String `tfsdk:"does_not_equal"`
	Doesnotstartwith types.String `tfsdk:"does_not_start_with"`
	Endswith types.String `tfsdk:"endswith"`
	Equals types.String `tfsdk:"equals"`
	Matchregex types.String `tfsdk:"match_regex"`
	Startswith types.String `tfsdk:"startswith"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionQueryParametersModel represents query_parameters block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionQueryParametersModel struct {
	Key types.String `tfsdk:"key"`
	Operator *CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionQueryParametersOperatorModel `tfsdk:"operator"`
}

// CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionQueryParametersOperatorModel represents operator block
type CDNCacheRuleCacheRulesRuleExpressionListCacheRuleExpressionQueryParametersOperatorModel struct {
	Contains types.String `tfsdk:"contains"`
	Doesnotcontain types.String `tfsdk:"does_not_contain"`
	Doesnotendwith types.String `tfsdk:"does_not_end_with"`
	Doesnotequal types.String `tfsdk:"does_not_equal"`
	Doesnotstartwith types.String `tfsdk:"does_not_start_with"`
	Endswith types.String `tfsdk:"endswith"`
	Equals types.String `tfsdk:"equals"`
	Matchregex types.String `tfsdk:"match_regex"`
	Startswith types.String `tfsdk:"startswith"`
}

type CDNCacheRuleResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	CacheRules *CDNCacheRuleCacheRulesModel `tfsdk:"cache_rules"`
}

func (r *CDNCacheRuleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cdn_cache_rule"
}

func (r *CDNCacheRuleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             cdn_cache_ruleSchemaVersion,
		MarkdownDescription: "Manages a CDNCacheRule resource in F5 Distributed Cloud for cdn loadbalancer configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the CDNCacheRule. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the CDNCacheRule will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"cache_rules": schema.SingleNestedBlock{
				MarkdownDescription: "Cache Rule. This defines a CDN Cache Rule",
				Attributes: map[string]schema.Attribute{
					"rule_name": schema.StringAttribute{
						MarkdownDescription: "Rule Name. Name of the Cache Rule",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"cache_bypass": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"eligible_for_cache": schema.SingleNestedBlock{
						MarkdownDescription: "Cache Action Options. List of options for Cache Action",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"scheme_proxy_host_request_uri": schema.SingleNestedBlock{
								MarkdownDescription: "Cache TTL Enable Props. Cache TTL Enable Values",
								Attributes: map[string]schema.Attribute{
									"cache_override": schema.BoolAttribute{
										MarkdownDescription: "Cache Override. Honour Cache Override",
										Optional: true,
									},
									"cache_ttl": schema.StringAttribute{
										MarkdownDescription: "Cache TTL. Cache TTL value is used to cache the resource/content for the specified amount of time Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
										Optional: true,
									},
									"ignore_response_cookie": schema.BoolAttribute{
										MarkdownDescription: "Ignore-Response-Cookie. By default, response will not be cached if set-cookie header is present. This option will override the behavior and cache response even with set-cookie header present.",
										Optional: true,
									},
								},
							},
							"scheme_proxy_host_uri": schema.SingleNestedBlock{
								MarkdownDescription: "Cache TTL Enable Props. Cache TTL Enable Values",
								Attributes: map[string]schema.Attribute{
									"cache_override": schema.BoolAttribute{
										MarkdownDescription: "Cache Override. Honour Cache Override",
										Optional: true,
									},
									"cache_ttl": schema.StringAttribute{
										MarkdownDescription: "Cache TTL. Cache TTL value is used to cache the resource/content for the specified amount of time Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
										Optional: true,
									},
									"ignore_response_cookie": schema.BoolAttribute{
										MarkdownDescription: "Ignore-Response-Cookie. By default, response will not be cached if set-cookie header is present. This option will override the behavior and cache response even with set-cookie header present.",
										Optional: true,
									},
								},
							},
						},
					},
					"rule_expression_list": schema.ListNestedBlock{
						MarkdownDescription: "Expressions. Expressions are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"expression_name": schema.StringAttribute{
									MarkdownDescription: "Expression Name. Name of the Expressions items that are ANDed",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"cache_rule_expression": schema.ListNestedBlock{
									MarkdownDescription: "Terms. The Cache Rule Expression Terms that are ANDed",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"cache_headers": schema.ListNestedBlock{
												MarkdownDescription: "Cache Headers. Configure cache rule headers to match the criteria",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Header Options. - PROXY_HOST: Proxy Host Name of the proxied server - REFERER: Referer This is the address of the previous web page from which a link to the currently requested page was followed - SCHEME: Scheme The http scheme used: http or https - USER_AGENT: User Agent The user agent string of the user agent. Possible values are `PROXY_HOST`, `REFERER`, `SCHEME`, `USER_AGENT`. Defaults to `PROXY_HOST`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"operator": schema.SingleNestedBlock{
															MarkdownDescription: "Operator.",
															Attributes: map[string]schema.Attribute{
																"contains": schema.StringAttribute{
																	MarkdownDescription: "Contains. Field must contain",
																	Optional: true,
																},
																"does_not_contain": schema.StringAttribute{
																	MarkdownDescription: "Does Not Contain. Field must not contain",
																	Optional: true,
																},
																"does_not_end_with": schema.StringAttribute{
																	MarkdownDescription: "Does Not End With. Field must not end with",
																	Optional: true,
																},
																"does_not_equal": schema.StringAttribute{
																	MarkdownDescription: "Does Not Equal. Field must not equal",
																	Optional: true,
																},
																"does_not_start_with": schema.StringAttribute{
																	MarkdownDescription: "Does Not Start With. Field must not start with",
																	Optional: true,
																},
																"endswith": schema.StringAttribute{
																	MarkdownDescription: "Ends With. Field must end with",
																	Optional: true,
																},
																"equals": schema.StringAttribute{
																	MarkdownDescription: "Equals. Field must exactly match",
																	Optional: true,
																},
																"match_regex": schema.StringAttribute{
																	MarkdownDescription: "Matches Regex. Field matches PCRE 1 compliant regular expression",
																	Optional: true,
																},
																"startswith": schema.StringAttribute{
																	MarkdownDescription: "Starts With. Field must start with",
																	Optional: true,
																},
															},
														},
													},
												},
											},
											"cookie_matcher": schema.ListNestedBlock{
												MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"operator": schema.SingleNestedBlock{
															MarkdownDescription: "Operator.",
															Attributes: map[string]schema.Attribute{
																"contains": schema.StringAttribute{
																	MarkdownDescription: "Contains. Field must contain",
																	Optional: true,
																},
																"does_not_contain": schema.StringAttribute{
																	MarkdownDescription: "Does Not Contain. Field must not contain",
																	Optional: true,
																},
																"does_not_end_with": schema.StringAttribute{
																	MarkdownDescription: "Does Not End With. Field must not end with",
																	Optional: true,
																},
																"does_not_equal": schema.StringAttribute{
																	MarkdownDescription: "Does Not Equal. Field must not equal",
																	Optional: true,
																},
																"does_not_start_with": schema.StringAttribute{
																	MarkdownDescription: "Does Not Start With. Field must not start with",
																	Optional: true,
																},
																"endswith": schema.StringAttribute{
																	MarkdownDescription: "Ends With. Field must end with",
																	Optional: true,
																},
																"equals": schema.StringAttribute{
																	MarkdownDescription: "Equals. Field must exactly match",
																	Optional: true,
																},
																"match_regex": schema.StringAttribute{
																	MarkdownDescription: "Matches Regex. Field matches PCRE 1 compliant regular expression",
																	Optional: true,
																},
																"startswith": schema.StringAttribute{
																	MarkdownDescription: "Starts With. Field must start with",
																	Optional: true,
																},
															},
														},
													},
												},
											},
											"path_match": schema.SingleNestedBlock{
												MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"operator": schema.SingleNestedBlock{
														MarkdownDescription: "Operator.",
														Attributes: map[string]schema.Attribute{
															"contains": schema.StringAttribute{
																MarkdownDescription: "Contains. Field must contain",
																Optional: true,
															},
															"does_not_contain": schema.StringAttribute{
																MarkdownDescription: "Does Not Contain. Field must not contain",
																Optional: true,
															},
															"does_not_end_with": schema.StringAttribute{
																MarkdownDescription: "Does Not End With. Field must not end with",
																Optional: true,
															},
															"does_not_equal": schema.StringAttribute{
																MarkdownDescription: "Does Not Equal. Field must not equal",
																Optional: true,
															},
															"does_not_start_with": schema.StringAttribute{
																MarkdownDescription: "Does Not Start With. Field must not start with",
																Optional: true,
															},
															"endswith": schema.StringAttribute{
																MarkdownDescription: "Ends With. Field must end with",
																Optional: true,
															},
															"equals": schema.StringAttribute{
																MarkdownDescription: "Equals. Field must exactly match",
																Optional: true,
															},
															"match_regex": schema.StringAttribute{
																MarkdownDescription: "Matches Regex. Field matches PCRE 1 compliant regular expression",
																Optional: true,
															},
															"startswith": schema.StringAttribute{
																MarkdownDescription: "Starts With. Field must start with",
																Optional: true,
															},
														},
													},
												},
											},
											"query_parameters": schema.ListNestedBlock{
												MarkdownDescription: "Query Parameters. List of (key, value) query parameters",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"key": schema.StringAttribute{
															MarkdownDescription: "Key. Query parameter key In the above example, assignee_username is the key",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"operator": schema.SingleNestedBlock{
															MarkdownDescription: "Operator.",
															Attributes: map[string]schema.Attribute{
																"contains": schema.StringAttribute{
																	MarkdownDescription: "Contains. Field must contain",
																	Optional: true,
																},
																"does_not_contain": schema.StringAttribute{
																	MarkdownDescription: "Does Not Contain. Field must not contain",
																	Optional: true,
																},
																"does_not_end_with": schema.StringAttribute{
																	MarkdownDescription: "Does Not End With. Field must not end with",
																	Optional: true,
																},
																"does_not_equal": schema.StringAttribute{
																	MarkdownDescription: "Does Not Equal. Field must not equal",
																	Optional: true,
																},
																"does_not_start_with": schema.StringAttribute{
																	MarkdownDescription: "Does Not Start With. Field must not start with",
																	Optional: true,
																},
																"endswith": schema.StringAttribute{
																	MarkdownDescription: "Ends With. Field must end with",
																	Optional: true,
																},
																"equals": schema.StringAttribute{
																	MarkdownDescription: "Equals. Field must exactly match",
																	Optional: true,
																},
																"match_regex": schema.StringAttribute{
																	MarkdownDescription: "Matches Regex. Field matches PCRE 1 compliant regular expression",
																	Optional: true,
																},
																"startswith": schema.StringAttribute{
																	MarkdownDescription: "Starts With. Field must start with",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *CDNCacheRuleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *CDNCacheRuleResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *CDNCacheRuleResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the cdn_cache_rule from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan CDNCacheRuleResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *CDNCacheRuleResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := CDNCacheRuleResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *CDNCacheRuleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating cdn_cache_rule", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.CDNCacheRule{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.CacheRules != nil {
		cache_rulesMap := make(map[string]interface{})
		if data.CacheRules.CacheBypass != nil {
			cache_rulesMap["cache_bypass"] = map[string]interface{}{}
		}
		if data.CacheRules.EligibleForCache != nil {
			eligible_for_cacheNestedMap := make(map[string]interface{})
			cache_rulesMap["eligible_for_cache"] = eligible_for_cacheNestedMap
		}
		if !data.CacheRules.RuleName.IsNull() && !data.CacheRules.RuleName.IsUnknown() {
			cache_rulesMap["rule_name"] = data.CacheRules.RuleName.ValueString()
		}
		apiResource.Spec["cache_rules"] = cache_rulesMap
	}


	created, err := r.client.CreateCDNCacheRule(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create CDNCacheRule: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created CDNCacheRule resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNCacheRuleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetCDNCacheRule(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CDNCacheRule not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CDNCacheRule: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The cdn_cache_rule may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["cache_rules"].(map[string]interface{}); ok && (isImport || data.CacheRules != nil) {
		data.CacheRules = &CDNCacheRuleCacheRulesModel{
			RuleName: func() types.String {
				if v, ok := blockData["rule_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNCacheRuleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.CDNCacheRule{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.CacheRules != nil {
		cache_rulesMap := make(map[string]interface{})
		if data.CacheRules.CacheBypass != nil {
			cache_rulesMap["cache_bypass"] = map[string]interface{}{}
		}
		if data.CacheRules.EligibleForCache != nil {
			eligible_for_cacheNestedMap := make(map[string]interface{})
			cache_rulesMap["eligible_for_cache"] = eligible_for_cacheNestedMap
		}
		if !data.CacheRules.RuleName.IsNull() && !data.CacheRules.RuleName.IsUnknown() {
			cache_rulesMap["rule_name"] = data.CacheRules.RuleName.ValueString()
		}
		apiResource.Spec["cache_rules"] = cache_rulesMap
	}


	updated, err := r.client.UpdateCDNCacheRule(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update CDNCacheRule: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetCDNCacheRule(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNCacheRuleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CDNCacheRuleResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteCDNCacheRule(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CDNCacheRule already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "CDNCacheRule delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete CDNCacheRule: %s", err))
		return
	}
}

func (r *CDNCacheRuleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
