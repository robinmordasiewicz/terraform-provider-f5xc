// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &CDNLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &CDNLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &CDNLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &CDNLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &CDNLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &CDNLoadBalancerResource{}
)

// cdn_loadbalancerSchemaVersion is the schema version for state upgrades
const cdn_loadbalancerSchemaVersion int64 = 1

func NewCDNLoadBalancerResource() resource.Resource {
	return &CDNLoadBalancerResource{}
}

type CDNLoadBalancerResource struct {
	client *client.Client
}

// CDNLoadBalancerEmptyModel represents empty nested blocks
type CDNLoadBalancerEmptyModel struct {
}

// CDNLoadBalancerActiveServicePoliciesModel represents active_service_policies block
type CDNLoadBalancerActiveServicePoliciesModel struct {
	Policies []CDNLoadBalancerActiveServicePoliciesPoliciesModel `tfsdk:"policies"`
}

// CDNLoadBalancerActiveServicePoliciesModelAttrTypes defines the attribute types for CDNLoadBalancerActiveServicePoliciesModel
var CDNLoadBalancerActiveServicePoliciesModelAttrTypes = map[string]attr.Type{
	"policies": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes}},
}

// CDNLoadBalancerActiveServicePoliciesPoliciesModel represents policies block
type CDNLoadBalancerActiveServicePoliciesPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes defines the attribute types for CDNLoadBalancerActiveServicePoliciesPoliciesModel
var CDNLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitModel represents api_rate_limit block
type CDNLoadBalancerAPIRateLimitModel struct {
	APIEndpointRules        []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel       `tfsdk:"api_endpoint_rules"`
	BypassRateLimitingRules *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
	CustomIPAllowedList     *CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel     `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList           *CDNLoadBalancerAPIRateLimitIPAllowedListModel           `tfsdk:"ip_allowed_list"`
	NoIPAllowedList         *CDNLoadBalancerEmptyModel                               `tfsdk:"no_ip_allowed_list"`
	ServerURLRules          []CDNLoadBalancerAPIRateLimitServerURLRulesModel         `tfsdk:"server_url_rules"`
}

// CDNLoadBalancerAPIRateLimitModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitModel
var CDNLoadBalancerAPIRateLimitModelAttrTypes = map[string]attr.Type{
	"api_endpoint_rules":         types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesModelAttrTypes}},
	"bypass_rate_limiting_rules": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModelAttrTypes},
	"custom_ip_allowed_list":     types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitCustomIPAllowedListModelAttrTypes},
	"ip_allowed_list":            types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitIPAllowedListModelAttrTypes},
	"no_ip_allowed_list":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"server_url_rules":           types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel represents api_endpoint_rules block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel struct {
	APIEndpointPath   types.String                                                       `tfsdk:"api_endpoint_path"`
	SpecificDomain    types.String                                                       `tfsdk:"specific_domain"`
	AnyDomain         *CDNLoadBalancerEmptyModel                                         `tfsdk:"any_domain"`
	APIEndpointMethod *CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel `tfsdk:"api_endpoint_method"`
	ClientMatcher     *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel     `tfsdk:"client_matcher"`
	InlineRateLimiter *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter    *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel    `tfsdk:"ref_rate_limiter"`
	RequestMatcher    *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel    `tfsdk:"request_matcher"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesModelAttrTypes = map[string]attr.Type{
	"api_endpoint_path":   types.StringType,
	"specific_domain":     types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint_method": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModelAttrTypes},
	"client_matcher":      types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModelAttrTypes},
	"inline_rate_limiter": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModelAttrTypes},
	"ref_rate_limiter":    types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModelAttrTypes},
	"request_matcher":     types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel represents api_endpoint_method block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods       types.List `tfsdk:"methods"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"methods":        types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel represents client_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel struct {
	AnyClient             *CDNLoadBalancerEmptyModel                                                          `tfsdk:"any_client"`
	AnyIP                 *CDNLoadBalancerEmptyModel                                                          `tfsdk:"any_ip"`
	AsnList               *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel represents asn_list block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel represents client_selector block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel represents ip_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                         `tfsdk:"invert_matcher"`
	PrefixSets    []CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel represents inline_rate_limiter block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel struct {
	Threshold       types.Int64                                                                 `tfsdk:"threshold"`
	Unit            types.String                                                                `tfsdk:"unit"`
	RefUserID       *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLBUserID *CDNLoadBalancerEmptyModel                                                  `tfsdk:"use_http_lb_user_id"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModelAttrTypes = map[string]attr.Type{
	"threshold":           types.Int64Type,
	"unit":                types.StringType,
	"ref_user_id":         types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModelAttrTypes},
	"use_http_lb_user_id": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel represents ref_rate_limiter block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel represents request_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel struct {
	CookieMatchers []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                        `tfsdk:"invert_matcher"`
	Name            types.String                                                                      `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                        `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                        `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel represents headers block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                 `tfsdk:"invert_matcher"`
	Name            types.String                                                               `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                 `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                 `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                   `tfsdk:"invert_matcher"`
	Name            types.String                                                                 `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                   `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                   `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel represents query_params block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                     `tfsdk:"invert_matcher"`
	Key             types.String                                                                   `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                     `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                     `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel
var CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel struct {
	BypassRateLimitingRules []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModelAttrTypes = map[string]attr.Type{
	"bypass_rate_limiting_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel struct {
	BasePath       types.String                                                                                  `tfsdk:"base_path"`
	SpecificDomain types.String                                                                                  `tfsdk:"specific_domain"`
	AnyDomain      *CDNLoadBalancerEmptyModel                                                                    `tfsdk:"any_domain"`
	AnyURL         *CDNLoadBalancerEmptyModel                                                                    `tfsdk:"any_url"`
	APIEndpoint    *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel    `tfsdk:"api_endpoint"`
	APIGroups      *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel      `tfsdk:"api_groups"`
	ClientMatcher  *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel  `tfsdk:"client_matcher"`
	RequestMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModelAttrTypes = map[string]attr.Type{
	"base_path":       types.StringType,
	"specific_domain": types.StringType,
	"any_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_url":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":    types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModelAttrTypes},
	"api_groups":      types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModelAttrTypes},
	"client_matcher":  types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModelAttrTypes},
	"request_matcher": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel represents api_groups block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModelAttrTypes = map[string]attr.Type{
	"api_groups": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel represents client_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel struct {
	AnyClient             *CDNLoadBalancerEmptyModel                                                                                        `tfsdk:"any_client"`
	AnyIP                 *CDNLoadBalancerEmptyModel                                                                                        `tfsdk:"any_ip"`
	AsnList               *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel represents asn_list block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel represents client_selector block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel represents ip_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                                                       `tfsdk:"invert_matcher"`
	PrefixSets    []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel represents request_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel struct {
	CookieMatchers []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                                                      `tfsdk:"invert_matcher"`
	Name            types.String                                                                                                    `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                                                      `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                                                      `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel represents headers block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                                               `tfsdk:"invert_matcher"`
	Name            types.String                                                                                             `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                                               `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                                               `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                                                 `tfsdk:"invert_matcher"`
	Name            types.String                                                                                               `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                                                 `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                                                 `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel represents query_params block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                                                   `tfsdk:"invert_matcher"`
	Key             types.String                                                                                                 `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                                                   `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                                                   `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel
var CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// CDNLoadBalancerAPIRateLimitCustomIPAllowedListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel
var CDNLoadBalancerAPIRateLimitCustomIPAllowedListModelAttrTypes = map[string]attr.Type{
	"rate_limiter_allowed_prefixes": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel
var CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitIPAllowedListModel represents ip_allowed_list block
type CDNLoadBalancerAPIRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// CDNLoadBalancerAPIRateLimitIPAllowedListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitIPAllowedListModel
var CDNLoadBalancerAPIRateLimitIPAllowedListModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesModel represents server_url_rules block
type CDNLoadBalancerAPIRateLimitServerURLRulesModel struct {
	APIGroup          types.String                                                     `tfsdk:"api_group"`
	BasePath          types.String                                                     `tfsdk:"base_path"`
	SpecificDomain    types.String                                                     `tfsdk:"specific_domain"`
	AnyDomain         *CDNLoadBalancerEmptyModel                                       `tfsdk:"any_domain"`
	ClientMatcher     *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel     `tfsdk:"client_matcher"`
	InlineRateLimiter *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter    *CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel    `tfsdk:"ref_rate_limiter"`
	RequestMatcher    *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel    `tfsdk:"request_matcher"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesModel
var CDNLoadBalancerAPIRateLimitServerURLRulesModelAttrTypes = map[string]attr.Type{
	"api_group":           types.StringType,
	"base_path":           types.StringType,
	"specific_domain":     types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"client_matcher":      types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModelAttrTypes},
	"inline_rate_limiter": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModelAttrTypes},
	"ref_rate_limiter":    types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModelAttrTypes},
	"request_matcher":     types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel represents client_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel struct {
	AnyClient             *CDNLoadBalancerEmptyModel                                                        `tfsdk:"any_client"`
	AnyIP                 *CDNLoadBalancerEmptyModel                                                        `tfsdk:"any_ip"`
	AsnList               *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel represents asn_list block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel represents client_selector block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel represents ip_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                       `tfsdk:"invert_matcher"`
	PrefixSets    []CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel
var CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel represents inline_rate_limiter block
type CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel struct {
	Threshold       types.Int64                                                               `tfsdk:"threshold"`
	Unit            types.String                                                              `tfsdk:"unit"`
	RefUserID       *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLBUserID *CDNLoadBalancerEmptyModel                                                `tfsdk:"use_http_lb_user_id"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel
var CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModelAttrTypes = map[string]attr.Type{
	"threshold":           types.Int64Type,
	"unit":                types.StringType,
	"ref_user_id":         types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModelAttrTypes},
	"use_http_lb_user_id": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel
var CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel represents ref_rate_limiter block
type CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel represents request_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel struct {
	CookieMatchers []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                      `tfsdk:"invert_matcher"`
	Name            types.String                                                                    `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                      `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                      `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel represents headers block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                               `tfsdk:"invert_matcher"`
	Name            types.String                                                             `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                               `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                               `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                 `tfsdk:"invert_matcher"`
	Name            types.String                                                               `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                 `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                 `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel represents query_params block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                   `tfsdk:"invert_matcher"`
	Key             types.String                                                                 `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                   `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                   `tfsdk:"check_present"`
	Item            *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel
var CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerAPISpecificationModel represents api_specification block
type CDNLoadBalancerAPISpecificationModel struct {
	APIDefinition              *CDNLoadBalancerAPISpecificationAPIDefinitionModel              `tfsdk:"api_definition"`
	ValidationAllSpecEndpoints *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel `tfsdk:"validation_all_spec_endpoints"`
	ValidationCustomList       *CDNLoadBalancerAPISpecificationValidationCustomListModel       `tfsdk:"validation_custom_list"`
	ValidationDisabled         *CDNLoadBalancerEmptyModel                                      `tfsdk:"validation_disabled"`
}

// CDNLoadBalancerAPISpecificationModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationModel
var CDNLoadBalancerAPISpecificationModelAttrTypes = map[string]attr.Type{
	"api_definition":                types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationAPIDefinitionModelAttrTypes},
	"validation_all_spec_endpoints": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModelAttrTypes},
	"validation_custom_list":        types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListModelAttrTypes},
	"validation_disabled":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationAPIDefinitionModel represents api_definition block
type CDNLoadBalancerAPISpecificationAPIDefinitionModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPISpecificationAPIDefinitionModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationAPIDefinitionModel
var CDNLoadBalancerAPISpecificationAPIDefinitionModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel represents validation_all_spec_endpoints block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel struct {
	FallThroughMode *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel `tfsdk:"fall_through_mode"`
	Settings        *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel        `tfsdk:"settings"`
	ValidationMode  *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel  `tfsdk:"validation_mode"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModelAttrTypes = map[string]attr.Type{
	"fall_through_mode": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModelAttrTypes},
	"settings":          types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModelAttrTypes},
	"validation_mode":   types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel represents fall_through_mode block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel struct {
	FallThroughModeAllow  *CDNLoadBalancerEmptyModel                                                                          `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModelAttrTypes = map[string]attr.Type{
	"fall_through_mode_allow":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"fall_through_mode_custom": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModelAttrTypes = map[string]attr.Type{
	"open_api_validation_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes}},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup     types.String                                                                                                                         `tfsdk:"api_group"`
	BasePath     types.String                                                                                                                         `tfsdk:"base_path"`
	ActionBlock  *CDNLoadBalancerEmptyModel                                                                                                           `tfsdk:"action_block"`
	ActionReport *CDNLoadBalancerEmptyModel                                                                                                           `tfsdk:"action_report"`
	ActionSkip   *CDNLoadBalancerEmptyModel                                                                                                           `tfsdk:"action_skip"`
	APIEndpoint  *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata     *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel    `tfsdk:"metadata"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes = map[string]attr.Type{
	"api_group":     types.StringType,
	"base_path":     types.StringType,
	"action_block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_skip":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":  types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes},
	"metadata":      types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel represents settings block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel struct {
	OversizedBodyFailValidation       *CDNLoadBalancerEmptyModel                                                                              `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation       *CDNLoadBalancerEmptyModel                                                                              `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom  *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *CDNLoadBalancerEmptyModel                                                                              `tfsdk:"property_validation_settings_default"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModelAttrTypes = map[string]attr.Type{
	"oversized_body_fail_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"oversized_body_skip_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"property_validation_settings_custom":  types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModelAttrTypes},
	"property_validation_settings_default": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModelAttrTypes = map[string]attr.Type{
	"query_parameters": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters    *CDNLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *CDNLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes = map[string]attr.Type{
	"allow_additional_parameters":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disallow_additional_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel represents validation_mode block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel struct {
	ResponseValidationModeActive *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation       *CDNLoadBalancerEmptyModel                                                                                `tfsdk:"skip_response_validation"`
	SkipValidation               *CDNLoadBalancerEmptyModel                                                                                `tfsdk:"skip_validation"`
	ValidationModeActive         *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel         `tfsdk:"validation_mode_active"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModelAttrTypes = map[string]attr.Type{
	"response_validation_mode_active": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModelAttrTypes},
	"skip_response_validation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_validation":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validation_mode_active":          types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List                 `tfsdk:"response_validation_properties"`
	EnforcementBlock             *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport            *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"response_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel represents validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List                 `tfsdk:"request_validation_properties"`
	EnforcementBlock            *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport           *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel
var CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"request_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationCustomListModel represents validation_custom_list block
type CDNLoadBalancerAPISpecificationValidationCustomListModel struct {
	FallThroughMode        *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel         `tfsdk:"fall_through_mode"`
	OpenAPIValidationRules []CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
	Settings               *CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel                `tfsdk:"settings"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListModel
var CDNLoadBalancerAPISpecificationValidationCustomListModelAttrTypes = map[string]attr.Type{
	"fall_through_mode":         types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModelAttrTypes},
	"open_api_validation_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModelAttrTypes}},
	"settings":                  types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListSettingsModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel represents fall_through_mode block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel struct {
	FallThroughModeAllow  *CDNLoadBalancerEmptyModel                                                                    `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel
var CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModelAttrTypes = map[string]attr.Type{
	"fall_through_mode_allow":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"fall_through_mode_custom": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel
var CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModelAttrTypes = map[string]attr.Type{
	"open_api_validation_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes}},
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup     types.String                                                                                                                   `tfsdk:"api_group"`
	BasePath     types.String                                                                                                                   `tfsdk:"base_path"`
	ActionBlock  *CDNLoadBalancerEmptyModel                                                                                                     `tfsdk:"action_block"`
	ActionReport *CDNLoadBalancerEmptyModel                                                                                                     `tfsdk:"action_report"`
	ActionSkip   *CDNLoadBalancerEmptyModel                                                                                                     `tfsdk:"action_skip"`
	APIEndpoint  *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata     *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel    `tfsdk:"metadata"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel
var CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes = map[string]attr.Type{
	"api_group":     types.StringType,
	"base_path":     types.StringType,
	"action_block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_skip":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":  types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes},
	"metadata":      types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel
var CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel
var CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel represents open_api_validation_rules block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel struct {
	APIGroup       types.String                                                                                  `tfsdk:"api_group"`
	BasePath       types.String                                                                                  `tfsdk:"base_path"`
	SpecificDomain types.String                                                                                  `tfsdk:"specific_domain"`
	AnyDomain      *CDNLoadBalancerEmptyModel                                                                    `tfsdk:"any_domain"`
	APIEndpoint    *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel    `tfsdk:"api_endpoint"`
	Metadata       *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel       `tfsdk:"metadata"`
	ValidationMode *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel `tfsdk:"validation_mode"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel
var CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModelAttrTypes = map[string]attr.Type{
	"api_group":       types.StringType,
	"base_path":       types.StringType,
	"specific_domain": types.StringType,
	"any_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":    types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModelAttrTypes},
	"metadata":        types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModelAttrTypes},
	"validation_mode": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel
var CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel represents metadata block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel
var CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel represents validation_mode block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel struct {
	ResponseValidationModeActive *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation       *CDNLoadBalancerEmptyModel                                                                                                `tfsdk:"skip_response_validation"`
	SkipValidation               *CDNLoadBalancerEmptyModel                                                                                                `tfsdk:"skip_validation"`
	ValidationModeActive         *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel         `tfsdk:"validation_mode_active"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel
var CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModelAttrTypes = map[string]attr.Type{
	"response_validation_mode_active": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModelAttrTypes},
	"skip_response_validation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_validation":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validation_mode_active":          types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List                 `tfsdk:"response_validation_properties"`
	EnforcementBlock             *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport            *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel
var CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"response_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel represents validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List                 `tfsdk:"request_validation_properties"`
	EnforcementBlock            *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport           *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel
var CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"request_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel represents settings block
type CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel struct {
	OversizedBodyFailValidation       *CDNLoadBalancerEmptyModel                                                                        `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation       *CDNLoadBalancerEmptyModel                                                                        `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom  *CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *CDNLoadBalancerEmptyModel                                                                        `tfsdk:"property_validation_settings_default"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel
var CDNLoadBalancerAPISpecificationValidationCustomListSettingsModelAttrTypes = map[string]attr.Type{
	"oversized_body_fail_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"oversized_body_skip_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"property_validation_settings_custom":  types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModelAttrTypes},
	"property_validation_settings_default": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel
var CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModelAttrTypes = map[string]attr.Type{
	"query_parameters": types.ObjectType{AttrTypes: CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes},
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters    *CDNLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *CDNLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes defines the attribute types for CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel
var CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes = map[string]attr.Type{
	"allow_additional_parameters":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disallow_additional_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerAppFirewallModel represents app_firewall block
type CDNLoadBalancerAppFirewallModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAppFirewallModelAttrTypes defines the attribute types for CDNLoadBalancerAppFirewallModel
var CDNLoadBalancerAppFirewallModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerBlockedClientsModel represents blocked_clients block
type CDNLoadBalancerBlockedClientsModel struct {
	Actions             types.List                                    `tfsdk:"actions"`
	AsNumber            types.Int64                                   `tfsdk:"as_number"`
	ExpirationTimestamp types.String                                  `tfsdk:"expiration_timestamp"`
	IPPrefix            types.String                                  `tfsdk:"ip_prefix"`
	Ipv6Prefix          types.String                                  `tfsdk:"ipv6_prefix"`
	UserIdentifier      types.String                                  `tfsdk:"user_identifier"`
	BotSkipProcessing   *CDNLoadBalancerEmptyModel                    `tfsdk:"bot_skip_processing"`
	HTTPHeader          *CDNLoadBalancerBlockedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata            *CDNLoadBalancerBlockedClientsMetadataModel   `tfsdk:"metadata"`
	SkipProcessing      *CDNLoadBalancerEmptyModel                    `tfsdk:"skip_processing"`
	WAFSkipProcessing   *CDNLoadBalancerEmptyModel                    `tfsdk:"waf_skip_processing"`
}

// CDNLoadBalancerBlockedClientsModelAttrTypes defines the attribute types for CDNLoadBalancerBlockedClientsModel
var CDNLoadBalancerBlockedClientsModelAttrTypes = map[string]attr.Type{
	"actions":              types.ListType{ElemType: types.StringType},
	"as_number":            types.Int64Type,
	"expiration_timestamp": types.StringType,
	"ip_prefix":            types.StringType,
	"ipv6_prefix":          types.StringType,
	"user_identifier":      types.StringType,
	"bot_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_header":          types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsHTTPHeaderModelAttrTypes},
	"metadata":             types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsMetadataModelAttrTypes},
	"skip_processing":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"waf_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBlockedClientsHTTPHeaderModel represents http_header block
type CDNLoadBalancerBlockedClientsHTTPHeaderModel struct {
	Headers []CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// CDNLoadBalancerBlockedClientsHTTPHeaderModelAttrTypes defines the attribute types for CDNLoadBalancerBlockedClientsHTTPHeaderModel
var CDNLoadBalancerBlockedClientsHTTPHeaderModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModelAttrTypes}},
}

// CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel represents headers block
type CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel
var CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// CDNLoadBalancerBlockedClientsMetadataModel represents metadata block
type CDNLoadBalancerBlockedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerBlockedClientsMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerBlockedClientsMetadataModel
var CDNLoadBalancerBlockedClientsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerBotDefenseModel represents bot_defense block
type CDNLoadBalancerBotDefenseModel struct {
	RegionalEndpoint   types.String                          `tfsdk:"regional_endpoint"`
	Timeout            types.Int64                           `tfsdk:"timeout"`
	DisableCORSSupport *CDNLoadBalancerEmptyModel            `tfsdk:"disable_cors_support"`
	EnableCORSSupport  *CDNLoadBalancerEmptyModel            `tfsdk:"enable_cors_support"`
	Policy             *CDNLoadBalancerBotDefensePolicyModel `tfsdk:"policy"`
}

// CDNLoadBalancerBotDefenseModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefenseModel
var CDNLoadBalancerBotDefenseModelAttrTypes = map[string]attr.Type{
	"regional_endpoint":    types.StringType,
	"timeout":              types.Int64Type,
	"disable_cors_support": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_cors_support":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"policy":               types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyModel represents policy block
type CDNLoadBalancerBotDefensePolicyModel struct {
	JavascriptMode         types.String                                                `tfsdk:"javascript_mode"`
	JsDownloadPath         types.String                                                `tfsdk:"js_download_path"`
	DisableJsInsert        *CDNLoadBalancerEmptyModel                                  `tfsdk:"disable_js_insert"`
	DisableMobileSdk       *CDNLoadBalancerEmptyModel                                  `tfsdk:"disable_mobile_sdk"`
	JsInsertAllPages       *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel       `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules       *CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel       `tfsdk:"js_insertion_rules"`
	MobileSdkConfig        *CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel        `tfsdk:"mobile_sdk_config"`
	ProtectedAppEndpoints  []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel `tfsdk:"protected_app_endpoints"`
}

// CDNLoadBalancerBotDefensePolicyModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyModel
var CDNLoadBalancerBotDefensePolicyModelAttrTypes = map[string]attr.Type{
	"javascript_mode":            types.StringType,
	"js_download_path":           types.StringType,
	"disable_js_insert":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_mobile_sdk":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages":        types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModelAttrTypes},
	"js_insert_all_pages_except": types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModelAttrTypes},
	"js_insertion_rules":         types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesModelAttrTypes},
	"mobile_sdk_config":          types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyMobileSdkConfigModelAttrTypes},
	"protected_app_endpoints":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModelAttrTypes}},
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel represents js_insert_all_pages block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel
var CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel struct {
	JavascriptLocation types.String                                                            `tfsdk:"javascript_location"`
	ExcludeList        []CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel
var CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"exclude_list":        types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes}},
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel                                                     `tfsdk:"any_domain"`
	Domain    *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel     `tfsdk:"path"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel
var CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel
var CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel
var CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel
var CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules       []CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel       `tfsdk:"rules"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModelAttrTypes}},
	"rules":        types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModelAttrTypes}},
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel                                               `tfsdk:"any_domain"`
	Domain    *CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel     `tfsdk:"path"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel represents rules block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel struct {
	JavascriptLocation types.String                                                       `tfsdk:"javascript_location"`
	AnyDomain          *CDNLoadBalancerEmptyModel                                         `tfsdk:"any_domain"`
	Domain             *CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel   `tfsdk:"domain"`
	Metadata           *CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path               *CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel     `tfsdk:"path"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":              types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes},
	"metadata":            types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes},
	"path":                types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel represents path block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel
var CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel represents mobile_sdk_config block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel struct {
	MobileIdentifier *CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel `tfsdk:"mobile_identifier"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel
var CDNLoadBalancerBotDefensePolicyMobileSdkConfigModelAttrTypes = map[string]attr.Type{
	"mobile_identifier": types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel represents mobile_identifier block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel struct {
	Headers []CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel `tfsdk:"headers"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel
var CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModelAttrTypes}},
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel represents headers block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel struct {
	Name            types.String                                                                    `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                      `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                      `tfsdk:"check_present"`
	Item            *CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel
var CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel represents item block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel
var CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel represents protected_app_endpoints block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel struct {
	HTTPMethods        types.List                                                             `tfsdk:"http_methods"`
	Protocol           types.String                                                           `tfsdk:"protocol"`
	AllowGoodBots      *CDNLoadBalancerEmptyModel                                             `tfsdk:"allow_good_bots"`
	AnyDomain          *CDNLoadBalancerEmptyModel                                             `tfsdk:"any_domain"`
	Domain             *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel       `tfsdk:"domain"`
	FlowLabel          *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel    `tfsdk:"flow_label"`
	Headers            []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel     `tfsdk:"headers"`
	Metadata           *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel     `tfsdk:"metadata"`
	MitigateGoodBots   *CDNLoadBalancerEmptyModel                                             `tfsdk:"mitigate_good_bots"`
	Mitigation         *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel   `tfsdk:"mitigation"`
	Mobile             *CDNLoadBalancerEmptyModel                                             `tfsdk:"mobile"`
	Path               *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel         `tfsdk:"path"`
	QueryParams        []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel `tfsdk:"query_params"`
	UndefinedFlowLabel *CDNLoadBalancerEmptyModel                                             `tfsdk:"undefined_flow_label"`
	Web                *CDNLoadBalancerEmptyModel                                             `tfsdk:"web"`
	WebMobile          *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel    `tfsdk:"web_mobile"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModelAttrTypes = map[string]attr.Type{
	"http_methods":         types.ListType{ElemType: types.StringType},
	"protocol":             types.StringType,
	"allow_good_bots":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_domain":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":               types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModelAttrTypes},
	"flow_label":           types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModelAttrTypes},
	"headers":              types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModelAttrTypes}},
	"metadata":             types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModelAttrTypes},
	"mitigate_good_bots":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mitigation":           types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModelAttrTypes},
	"mobile":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModelAttrTypes},
	"query_params":         types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModelAttrTypes}},
	"undefined_flow_label": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web_mobile":           types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel represents flow_label block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel struct {
	AccountManagement *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel `tfsdk:"account_management"`
	Authentication    *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel    `tfsdk:"authentication"`
	FinancialServices *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel `tfsdk:"financial_services"`
	Flight            *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel            `tfsdk:"flight"`
	ProfileManagement *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel `tfsdk:"profile_management"`
	Search            *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel            `tfsdk:"search"`
	ShoppingGiftCards *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel `tfsdk:"shopping_gift_cards"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModelAttrTypes = map[string]attr.Type{
	"account_management":  types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModelAttrTypes},
	"authentication":      types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModelAttrTypes},
	"financial_services":  types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModelAttrTypes},
	"flight":              types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModelAttrTypes},
	"profile_management":  types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModelAttrTypes},
	"search":              types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModelAttrTypes},
	"shopping_gift_cards": types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel represents account_management block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel struct {
	Create        *CDNLoadBalancerEmptyModel `tfsdk:"create"`
	PasswordReset *CDNLoadBalancerEmptyModel `tfsdk:"password_reset"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModelAttrTypes = map[string]attr.Type{
	"create":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"password_reset": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel represents authentication block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel struct {
	Login        *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel `tfsdk:"login"`
	LoginMFA     *CDNLoadBalancerEmptyModel                                                             `tfsdk:"login_mfa"`
	LoginPartner *CDNLoadBalancerEmptyModel                                                             `tfsdk:"login_partner"`
	Logout       *CDNLoadBalancerEmptyModel                                                             `tfsdk:"logout"`
	TokenRefresh *CDNLoadBalancerEmptyModel                                                             `tfsdk:"token_refresh"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModelAttrTypes = map[string]attr.Type{
	"login":         types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModelAttrTypes},
	"login_mfa":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"login_partner": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"logout":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"token_refresh": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel represents login block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel struct {
	DisableTransactionResult *CDNLoadBalancerEmptyModel                                                                              `tfsdk:"disable_transaction_result"`
	TransactionResult        *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel `tfsdk:"transaction_result"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModelAttrTypes = map[string]attr.Type{
	"disable_transaction_result": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"transaction_result":         types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel represents transaction_result block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel struct {
	FailureConditions []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel `tfsdk:"failure_conditions"`
	SuccessConditions []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel `tfsdk:"success_conditions"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModelAttrTypes = map[string]attr.Type{
	"failure_conditions": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModelAttrTypes}},
	"success_conditions": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModelAttrTypes}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel represents failure_conditions block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel struct {
	Name        types.String `tfsdk:"name"`
	RegexValues types.List   `tfsdk:"regex_values"`
	Status      types.String `tfsdk:"status"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"regex_values": types.ListType{ElemType: types.StringType},
	"status":       types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel represents success_conditions block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel struct {
	Name        types.String `tfsdk:"name"`
	RegexValues types.List   `tfsdk:"regex_values"`
	Status      types.String `tfsdk:"status"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"regex_values": types.ListType{ElemType: types.StringType},
	"status":       types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel represents financial_services block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel struct {
	Apply         *CDNLoadBalancerEmptyModel `tfsdk:"apply"`
	MoneyTransfer *CDNLoadBalancerEmptyModel `tfsdk:"money_transfer"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModelAttrTypes = map[string]attr.Type{
	"apply":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"money_transfer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel represents flight block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel struct {
	Checkin *CDNLoadBalancerEmptyModel `tfsdk:"checkin"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModelAttrTypes = map[string]attr.Type{
	"checkin": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel represents profile_management block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel struct {
	Create *CDNLoadBalancerEmptyModel `tfsdk:"create"`
	Update *CDNLoadBalancerEmptyModel `tfsdk:"update"`
	View   *CDNLoadBalancerEmptyModel `tfsdk:"view"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModelAttrTypes = map[string]attr.Type{
	"create": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"update": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"view":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel represents search block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel struct {
	FlightSearch      *CDNLoadBalancerEmptyModel `tfsdk:"flight_search"`
	ProductSearch     *CDNLoadBalancerEmptyModel `tfsdk:"product_search"`
	ReservationSearch *CDNLoadBalancerEmptyModel `tfsdk:"reservation_search"`
	RoomSearch        *CDNLoadBalancerEmptyModel `tfsdk:"room_search"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModelAttrTypes = map[string]attr.Type{
	"flight_search":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"product_search":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"reservation_search": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"room_search":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel represents shopping_gift_cards block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel struct {
	GiftCardMakePurchaseWithGiftCard *CDNLoadBalancerEmptyModel `tfsdk:"gift_card_make_purchase_with_gift_card"`
	GiftCardValidation               *CDNLoadBalancerEmptyModel `tfsdk:"gift_card_validation"`
	ShopAddToCart                    *CDNLoadBalancerEmptyModel `tfsdk:"shop_add_to_cart"`
	ShopCheckout                     *CDNLoadBalancerEmptyModel `tfsdk:"shop_checkout"`
	ShopChooseSeat                   *CDNLoadBalancerEmptyModel `tfsdk:"shop_choose_seat"`
	ShopEnterDrawingSubmission       *CDNLoadBalancerEmptyModel `tfsdk:"shop_enter_drawing_submission"`
	ShopMakePayment                  *CDNLoadBalancerEmptyModel `tfsdk:"shop_make_payment"`
	ShopOrder                        *CDNLoadBalancerEmptyModel `tfsdk:"shop_order"`
	ShopPriceInquiry                 *CDNLoadBalancerEmptyModel `tfsdk:"shop_price_inquiry"`
	ShopPromoCodeValidation          *CDNLoadBalancerEmptyModel `tfsdk:"shop_promo_code_validation"`
	ShopPurchaseGiftCard             *CDNLoadBalancerEmptyModel `tfsdk:"shop_purchase_gift_card"`
	ShopUpdateQuantity               *CDNLoadBalancerEmptyModel `tfsdk:"shop_update_quantity"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModelAttrTypes = map[string]attr.Type{
	"gift_card_make_purchase_with_gift_card": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"gift_card_validation":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_add_to_cart":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_checkout":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_choose_seat":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_enter_drawing_submission":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_make_payment":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_order":                             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_price_inquiry":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_promo_code_validation":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_purchase_gift_card":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_update_quantity":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel represents headers block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel struct {
	InvertMatcher   types.Bool                                                            `tfsdk:"invert_matcher"`
	Name            types.String                                                          `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                            `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                            `tfsdk:"check_present"`
	Item            *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel represents item block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel represents mitigation block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel struct {
	Block    *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel    `tfsdk:"block"`
	Flag     *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel     `tfsdk:"flag"`
	Redirect *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel `tfsdk:"redirect"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModelAttrTypes = map[string]attr.Type{
	"block":    types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModelAttrTypes},
	"flag":     types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModelAttrTypes},
	"redirect": types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel represents block block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel struct {
	Body   types.String `tfsdk:"body"`
	Status types.String `tfsdk:"status"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModelAttrTypes = map[string]attr.Type{
	"body":   types.StringType,
	"status": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel represents flag block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel struct {
	AppendHeaders *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel `tfsdk:"append_headers"`
	NoHeaders     *CDNLoadBalancerEmptyModel                                                            `tfsdk:"no_headers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModelAttrTypes = map[string]attr.Type{
	"append_headers": types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModelAttrTypes},
	"no_headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel represents append_headers block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel struct {
	AutoTypeHeaderName  types.String `tfsdk:"auto_type_header_name"`
	InferenceHeaderName types.String `tfsdk:"inference_header_name"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModelAttrTypes = map[string]attr.Type{
	"auto_type_header_name": types.StringType,
	"inference_header_name": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel represents redirect block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel struct {
	URI types.String `tfsdk:"uri"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModelAttrTypes = map[string]attr.Type{
	"uri": types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel represents path block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel represents query_params block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                `tfsdk:"invert_matcher"`
	Key             types.String                                                              `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                `tfsdk:"check_present"`
	Item            *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModelAttrTypes},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel represents item block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel represents web_mobile block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel struct {
	MobileIdentifier types.String `tfsdk:"mobile_identifier"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModelAttrTypes defines the attribute types for CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel
var CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModelAttrTypes = map[string]attr.Type{
	"mobile_identifier": types.StringType,
}

// CDNLoadBalancerCaptchaChallengeModel represents captcha_challenge block
type CDNLoadBalancerCaptchaChallengeModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerCaptchaChallengeModelAttrTypes defines the attribute types for CDNLoadBalancerCaptchaChallengeModel
var CDNLoadBalancerCaptchaChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// CDNLoadBalancerClientSideDefenseModel represents client_side_defense block
type CDNLoadBalancerClientSideDefenseModel struct {
	Policy *CDNLoadBalancerClientSideDefensePolicyModel `tfsdk:"policy"`
}

// CDNLoadBalancerClientSideDefenseModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefenseModel
var CDNLoadBalancerClientSideDefenseModelAttrTypes = map[string]attr.Type{
	"policy": types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyModelAttrTypes},
}

// CDNLoadBalancerClientSideDefensePolicyModel represents policy block
type CDNLoadBalancerClientSideDefensePolicyModel struct {
	DisableJsInsert        *CDNLoadBalancerEmptyModel                                         `tfsdk:"disable_js_insert"`
	JsInsertAllPages       *CDNLoadBalancerEmptyModel                                         `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules       *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel       `tfsdk:"js_insertion_rules"`
}

// CDNLoadBalancerClientSideDefensePolicyModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyModel
var CDNLoadBalancerClientSideDefensePolicyModelAttrTypes = map[string]attr.Type{
	"disable_js_insert":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages_except": types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModelAttrTypes},
	"js_insertion_rules":         types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModelAttrTypes},
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel struct {
	ExcludeList []CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes}},
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel                                                            `tfsdk:"any_domain"`
	Domain    *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel     `tfsdk:"path"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes},
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules       []CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel       `tfsdk:"rules"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModelAttrTypes}},
	"rules":        types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModelAttrTypes}},
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel                                                      `tfsdk:"any_domain"`
	Domain    *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel     `tfsdk:"path"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes},
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel represents rules block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel                                                `tfsdk:"any_domain"`
	Domain    *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel   `tfsdk:"domain"`
	Metadata  *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path      *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel     `tfsdk:"path"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModelAttrTypes},
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel represents path block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModelAttrTypes defines the attribute types for CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel
var CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerCORSPolicyModel represents cors_policy block
type CDNLoadBalancerCORSPolicyModel struct {
	AllowCredentials types.Bool   `tfsdk:"allow_credentials"`
	AllowHeaders     types.String `tfsdk:"allow_headers"`
	AllowMethods     types.String `tfsdk:"allow_methods"`
	AllowOrigin      types.List   `tfsdk:"allow_origin"`
	AllowOriginRegex types.List   `tfsdk:"allow_origin_regex"`
	Disabled         types.Bool   `tfsdk:"disabled"`
	ExposeHeaders    types.String `tfsdk:"expose_headers"`
	MaximumAge       types.Int64  `tfsdk:"maximum_age"`
}

// CDNLoadBalancerCORSPolicyModelAttrTypes defines the attribute types for CDNLoadBalancerCORSPolicyModel
var CDNLoadBalancerCORSPolicyModelAttrTypes = map[string]attr.Type{
	"allow_credentials":  types.BoolType,
	"allow_headers":      types.StringType,
	"allow_methods":      types.StringType,
	"allow_origin":       types.ListType{ElemType: types.StringType},
	"allow_origin_regex": types.ListType{ElemType: types.StringType},
	"disabled":           types.BoolType,
	"expose_headers":     types.StringType,
	"maximum_age":        types.Int64Type,
}

// CDNLoadBalancerCSRFPolicyModel represents csrf_policy block
type CDNLoadBalancerCSRFPolicyModel struct {
	AllLoadBalancerDomains *CDNLoadBalancerEmptyModel                      `tfsdk:"all_load_balancer_domains"`
	CustomDomainList       *CDNLoadBalancerCSRFPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled               *CDNLoadBalancerEmptyModel                      `tfsdk:"disabled"`
}

// CDNLoadBalancerCSRFPolicyModelAttrTypes defines the attribute types for CDNLoadBalancerCSRFPolicyModel
var CDNLoadBalancerCSRFPolicyModelAttrTypes = map[string]attr.Type{
	"all_load_balancer_domains": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"custom_domain_list":        types.ObjectType{AttrTypes: CDNLoadBalancerCSRFPolicyCustomDomainListModelAttrTypes},
	"disabled":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerCSRFPolicyCustomDomainListModel represents custom_domain_list block
type CDNLoadBalancerCSRFPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// CDNLoadBalancerCSRFPolicyCustomDomainListModelAttrTypes defines the attribute types for CDNLoadBalancerCSRFPolicyCustomDomainListModel
var CDNLoadBalancerCSRFPolicyCustomDomainListModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerCustomCacheRuleModel represents custom_cache_rule block
type CDNLoadBalancerCustomCacheRuleModel struct {
	CDNCacheRules []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel `tfsdk:"cdn_cache_rules"`
}

// CDNLoadBalancerCustomCacheRuleModelAttrTypes defines the attribute types for CDNLoadBalancerCustomCacheRuleModel
var CDNLoadBalancerCustomCacheRuleModelAttrTypes = map[string]attr.Type{
	"cdn_cache_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerCustomCacheRuleCDNCacheRulesModelAttrTypes}},
}

// CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel represents cdn_cache_rules block
type CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerCustomCacheRuleCDNCacheRulesModelAttrTypes defines the attribute types for CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel
var CDNLoadBalancerCustomCacheRuleCDNCacheRulesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerDataGuardRulesModel represents data_guard_rules block
type CDNLoadBalancerDataGuardRulesModel struct {
	ExactValue     types.String                                `tfsdk:"exact_value"`
	SuffixValue    types.String                                `tfsdk:"suffix_value"`
	AnyDomain      *CDNLoadBalancerEmptyModel                  `tfsdk:"any_domain"`
	ApplyDataGuard *CDNLoadBalancerEmptyModel                  `tfsdk:"apply_data_guard"`
	Metadata       *CDNLoadBalancerDataGuardRulesMetadataModel `tfsdk:"metadata"`
	Path           *CDNLoadBalancerDataGuardRulesPathModel     `tfsdk:"path"`
	SkipDataGuard  *CDNLoadBalancerEmptyModel                  `tfsdk:"skip_data_guard"`
}

// CDNLoadBalancerDataGuardRulesModelAttrTypes defines the attribute types for CDNLoadBalancerDataGuardRulesModel
var CDNLoadBalancerDataGuardRulesModelAttrTypes = map[string]attr.Type{
	"exact_value":      types.StringType,
	"suffix_value":     types.StringType,
	"any_domain":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"apply_data_guard": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"metadata":         types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesMetadataModelAttrTypes},
	"path":             types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesPathModelAttrTypes},
	"skip_data_guard":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerDataGuardRulesMetadataModel represents metadata block
type CDNLoadBalancerDataGuardRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerDataGuardRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerDataGuardRulesMetadataModel
var CDNLoadBalancerDataGuardRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerDataGuardRulesPathModel represents path block
type CDNLoadBalancerDataGuardRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// CDNLoadBalancerDataGuardRulesPathModelAttrTypes defines the attribute types for CDNLoadBalancerDataGuardRulesPathModel
var CDNLoadBalancerDataGuardRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// CDNLoadBalancerDDOSMitigationRulesModel represents ddos_mitigation_rules block
type CDNLoadBalancerDDOSMitigationRulesModel struct {
	ExpirationTimestamp types.String                                             `tfsdk:"expiration_timestamp"`
	Block               *CDNLoadBalancerEmptyModel                               `tfsdk:"block"`
	DDOSClientSource    *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel `tfsdk:"ddos_client_source"`
	IPPrefixList        *CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel     `tfsdk:"ip_prefix_list"`
	Metadata            *CDNLoadBalancerDDOSMitigationRulesMetadataModel         `tfsdk:"metadata"`
}

// CDNLoadBalancerDDOSMitigationRulesModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesModel
var CDNLoadBalancerDDOSMitigationRulesModelAttrTypes = map[string]attr.Type{
	"expiration_timestamp": types.StringType,
	"block":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ddos_client_source":   types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModelAttrTypes},
	"ip_prefix_list":       types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesIPPrefixListModelAttrTypes},
	"metadata":             types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesMetadataModelAttrTypes},
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel represents ddos_client_source block
type CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel struct {
	CountryList              types.List                                                                       `tfsdk:"country_list"`
	AsnList                  *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel                  `tfsdk:"asn_list"`
	Ja4TLSFingerprintMatcher *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel `tfsdk:"ja4_tls_fingerprint_matcher"`
	TLSFingerprintMatcher    *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel    `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel
var CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModelAttrTypes = map[string]attr.Type{
	"country_list":                types.ListType{ElemType: types.StringType},
	"asn_list":                    types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModelAttrTypes},
	"ja4_tls_fingerprint_matcher": types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModelAttrTypes},
	"tls_fingerprint_matcher":     types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModelAttrTypes},
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel represents asn_list block
type CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel
var CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel represents ja4_tls_fingerprint_matcher block
type CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel
var CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel
var CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerDDOSMitigationRulesIPPrefixListModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel
var CDNLoadBalancerDDOSMitigationRulesIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerDDOSMitigationRulesMetadataModel represents metadata block
type CDNLoadBalancerDDOSMitigationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerDDOSMitigationRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerDDOSMitigationRulesMetadataModel
var CDNLoadBalancerDDOSMitigationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerDefaultCacheActionModel represents default_cache_action block
type CDNLoadBalancerDefaultCacheActionModel struct {
	CacheTTLDefault  types.String               `tfsdk:"cache_ttl_default"`
	CacheTTLOverride types.String               `tfsdk:"cache_ttl_override"`
	CacheDisabled    *CDNLoadBalancerEmptyModel `tfsdk:"cache_disabled"`
}

// CDNLoadBalancerDefaultCacheActionModelAttrTypes defines the attribute types for CDNLoadBalancerDefaultCacheActionModel
var CDNLoadBalancerDefaultCacheActionModelAttrTypes = map[string]attr.Type{
	"cache_ttl_default":  types.StringType,
	"cache_ttl_override": types.StringType,
	"cache_disabled":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerEnableAPIDiscoveryModel represents enable_api_discovery block
type CDNLoadBalancerEnableAPIDiscoveryModel struct {
	APICrawler                      *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel               `tfsdk:"api_crawler"`
	APIDiscoveryFromCodeScan        *CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel `tfsdk:"api_discovery_from_code_scan"`
	CustomAPIAuthDiscovery          *CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel   `tfsdk:"custom_api_auth_discovery"`
	DefaultAPIAuthDiscovery         *CDNLoadBalancerEmptyModel                                      `tfsdk:"default_api_auth_discovery"`
	DisableLearnFromRedirectTraffic *CDNLoadBalancerEmptyModel                                      `tfsdk:"disable_learn_from_redirect_traffic"`
	DiscoveredAPISettings           *CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel    `tfsdk:"discovered_api_settings"`
	EnableLearnFromRedirectTraffic  *CDNLoadBalancerEmptyModel                                      `tfsdk:"enable_learn_from_redirect_traffic"`
}

// CDNLoadBalancerEnableAPIDiscoveryModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryModel
var CDNLoadBalancerEnableAPIDiscoveryModelAttrTypes = map[string]attr.Type{
	"api_crawler":                         types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModelAttrTypes},
	"api_discovery_from_code_scan":        types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes},
	"custom_api_auth_discovery":           types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModelAttrTypes},
	"default_api_auth_discovery":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_learn_from_redirect_traffic": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"discovered_api_settings":             types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModelAttrTypes},
	"enable_learn_from_redirect_traffic":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel represents api_crawler block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel struct {
	APICrawlerConfig  *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel `tfsdk:"api_crawler_config"`
	DisableAPICrawler *CDNLoadBalancerEmptyModel                                        `tfsdk:"disable_api_crawler"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModelAttrTypes = map[string]attr.Type{
	"api_crawler_config":  types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes},
	"disable_api_crawler": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel represents api_crawler_config block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel struct {
	Domains []CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel `tfsdk:"domains"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes}},
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel represents domains block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel struct {
	Domain      types.String                                                                        `tfsdk:"domain"`
	SimpleLogin *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel `tfsdk:"simple_login"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes = map[string]attr.Type{
	"domain":       types.StringType,
	"simple_login": types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes},
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel represents simple_login block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel struct {
	User     types.String                                                                                `tfsdk:"user"`
	Password *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel `tfsdk:"password"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes = map[string]attr.Type{
	"user":     types.StringType,
	"password": types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes},
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel represents password block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes},
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel
var CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel represents api_discovery_from_code_scan block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel struct {
	CodeBaseIntegrations []CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel `tfsdk:"code_base_integrations"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel
var CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes = map[string]attr.Type{
	"code_base_integrations": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes}},
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel represents code_base_integrations block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel struct {
	AllRepos            *CDNLoadBalancerEmptyModel                                                                             `tfsdk:"all_repos"`
	CodeBaseIntegration *CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel `tfsdk:"code_base_integration"`
	SelectedRepos       *CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel       `tfsdk:"selected_repos"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel
var CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes = map[string]attr.Type{
	"all_repos":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"code_base_integration": types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes},
	"selected_repos":        types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes},
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel represents code_base_integration block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel
var CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel represents selected_repos block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel struct {
	APICodeRepo types.List `tfsdk:"api_code_repo"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel
var CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes = map[string]attr.Type{
	"api_code_repo": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel represents custom_api_auth_discovery block
type CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel struct {
	APIDiscoveryRef *CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel `tfsdk:"api_discovery_ref"`
}

// CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel
var CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModelAttrTypes = map[string]attr.Type{
	"api_discovery_ref": types.ObjectType{AttrTypes: CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes},
}

// CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel represents api_discovery_ref block
type CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel
var CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel represents discovered_api_settings block
type CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel struct {
	PurgeDurationForInactiveDiscoveredApis types.Int64 `tfsdk:"purge_duration_for_inactive_discovered_apis"`
}

// CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModelAttrTypes defines the attribute types for CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel
var CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModelAttrTypes = map[string]attr.Type{
	"purge_duration_for_inactive_discovered_apis": types.Int64Type,
}

// CDNLoadBalancerEnableChallengeModel represents enable_challenge block
type CDNLoadBalancerEnableChallengeModel struct {
	CaptchaChallengeParameters        *CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters *CDNLoadBalancerEmptyModel                                     `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters      *CDNLoadBalancerEmptyModel                                     `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings         *CDNLoadBalancerEmptyModel                                     `tfsdk:"default_mitigation_settings"`
	JsChallengeParameters             *CDNLoadBalancerEnableChallengeJsChallengeParametersModel      `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation           *CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel    `tfsdk:"malicious_user_mitigation"`
}

// CDNLoadBalancerEnableChallengeModelAttrTypes defines the attribute types for CDNLoadBalancerEnableChallengeModel
var CDNLoadBalancerEnableChallengeModelAttrTypes = map[string]attr.Type{
	"captcha_challenge_parameters":         types.ObjectType{AttrTypes: CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModelAttrTypes},
	"default_captcha_challenge_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_js_challenge_parameters":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_mitigation_settings":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_challenge_parameters":              types.ObjectType{AttrTypes: CDNLoadBalancerEnableChallengeJsChallengeParametersModelAttrTypes},
	"malicious_user_mitigation":            types.ObjectType{AttrTypes: CDNLoadBalancerEnableChallengeMaliciousUserMitigationModelAttrTypes},
}

// CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModelAttrTypes defines the attribute types for CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel
var CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// CDNLoadBalancerEnableChallengeJsChallengeParametersModel represents js_challenge_parameters block
type CDNLoadBalancerEnableChallengeJsChallengeParametersModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerEnableChallengeJsChallengeParametersModelAttrTypes defines the attribute types for CDNLoadBalancerEnableChallengeJsChallengeParametersModel
var CDNLoadBalancerEnableChallengeJsChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerEnableChallengeMaliciousUserMitigationModelAttrTypes defines the attribute types for CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel
var CDNLoadBalancerEnableChallengeMaliciousUserMitigationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerEnableIPReputationModel represents enable_ip_reputation block
type CDNLoadBalancerEnableIPReputationModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerEnableIPReputationModelAttrTypes defines the attribute types for CDNLoadBalancerEnableIPReputationModel
var CDNLoadBalancerEnableIPReputationModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerGraphqlRulesModel represents graphql_rules block
type CDNLoadBalancerGraphqlRulesModel struct {
	ExactPath       types.String                                     `tfsdk:"exact_path"`
	ExactValue      types.String                                     `tfsdk:"exact_value"`
	SuffixValue     types.String                                     `tfsdk:"suffix_value"`
	AnyDomain       *CDNLoadBalancerEmptyModel                       `tfsdk:"any_domain"`
	GraphqlSettings *CDNLoadBalancerGraphqlRulesGraphqlSettingsModel `tfsdk:"graphql_settings"`
	Metadata        *CDNLoadBalancerGraphqlRulesMetadataModel        `tfsdk:"metadata"`
	MethodGet       *CDNLoadBalancerEmptyModel                       `tfsdk:"method_get"`
	MethodPost      *CDNLoadBalancerEmptyModel                       `tfsdk:"method_post"`
}

// CDNLoadBalancerGraphqlRulesModelAttrTypes defines the attribute types for CDNLoadBalancerGraphqlRulesModel
var CDNLoadBalancerGraphqlRulesModelAttrTypes = map[string]attr.Type{
	"exact_path":       types.StringType,
	"exact_value":      types.StringType,
	"suffix_value":     types.StringType,
	"any_domain":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"graphql_settings": types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesGraphqlSettingsModelAttrTypes},
	"metadata":         types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesMetadataModelAttrTypes},
	"method_get":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"method_post":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerGraphqlRulesGraphqlSettingsModel represents graphql_settings block
type CDNLoadBalancerGraphqlRulesGraphqlSettingsModel struct {
	MaxBatchedQueries    types.Int64                `tfsdk:"max_batched_queries"`
	MaxDepth             types.Int64                `tfsdk:"max_depth"`
	MaxTotalLength       types.Int64                `tfsdk:"max_total_length"`
	DisableIntrospection *CDNLoadBalancerEmptyModel `tfsdk:"disable_introspection"`
	EnableIntrospection  *CDNLoadBalancerEmptyModel `tfsdk:"enable_introspection"`
}

// CDNLoadBalancerGraphqlRulesGraphqlSettingsModelAttrTypes defines the attribute types for CDNLoadBalancerGraphqlRulesGraphqlSettingsModel
var CDNLoadBalancerGraphqlRulesGraphqlSettingsModelAttrTypes = map[string]attr.Type{
	"max_batched_queries":   types.Int64Type,
	"max_depth":             types.Int64Type,
	"max_total_length":      types.Int64Type,
	"disable_introspection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_introspection":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerGraphqlRulesMetadataModel represents metadata block
type CDNLoadBalancerGraphqlRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerGraphqlRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerGraphqlRulesMetadataModel
var CDNLoadBalancerGraphqlRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerHTTPModel represents http block
type CDNLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// CDNLoadBalancerHTTPModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPModel
var CDNLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// CDNLoadBalancerHTTPSModel represents https block
type CDNLoadBalancerHTTPSModel struct {
	AddHsts        types.Bool                               `tfsdk:"add_hsts"`
	HTTPRedirect   types.Bool                               `tfsdk:"http_redirect"`
	TLSCertOptions *CDNLoadBalancerHTTPSTLSCertOptionsModel `tfsdk:"tls_cert_options"`
}

// CDNLoadBalancerHTTPSModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSModel
var CDNLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":         types.BoolType,
	"http_redirect":    types.BoolType,
	"tls_cert_options": types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsModel represents tls_cert_options block
type CDNLoadBalancerHTTPSTLSCertOptionsModel struct {
	TLSCertParams   *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel   `tfsdk:"tls_cert_params"`
	TLSInlineParams *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel `tfsdk:"tls_inline_params"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsModel
var CDNLoadBalancerHTTPSTLSCertOptionsModelAttrTypes = map[string]attr.Type{
	"tls_cert_params":   types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModelAttrTypes},
	"tls_inline_params": types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel represents tls_cert_params block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel struct {
	Certificates []CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *CDNLoadBalancerEmptyModel                                         `tfsdk:"no_mtls"`
	TLSConfig    *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel represents certificates block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel represents tls_config block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *CDNLoadBalancerEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *CDNLoadBalancerEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *CDNLoadBalancerEmptyModel                                                   `tfsdk:"medium_security"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel represents use_mtls block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                              `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                            `tfsdk:"trusted_ca_url"`
	CRL                       *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *CDNLoadBalancerEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *CDNLoadBalancerEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel represents crl block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel represents tls_inline_params block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel struct {
	NoMtls          *CDNLoadBalancerEmptyModel                                              `tfsdk:"no_mtls"`
	TLSCertificates []CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel          `tfsdk:"use_mtls"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel represents tls_certificates block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel struct {
	CertificateURL       types.String                                                                               `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                               `tfsdk:"description_spec"`
	CustomHashAlgorithms *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *CDNLoadBalancerEmptyModel                                                                 `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *CDNLoadBalancerEmptyModel                                                                 `tfsdk:"use_system_defaults"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel represents private_key block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel represents tls_config block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel struct {
	CustomSecurity  *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *CDNLoadBalancerEmptyModel                                                     `tfsdk:"default_security"`
	LowSecurity     *CDNLoadBalancerEmptyModel                                                     `tfsdk:"low_security"`
	MediumSecurity  *CDNLoadBalancerEmptyModel                                                     `tfsdk:"medium_security"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel represents custom_security block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel represents use_mtls block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                              `tfsdk:"trusted_ca_url"`
	CRL                       *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *CDNLoadBalancerEmptyModel                                                `tfsdk:"no_crl"`
	TrustedCA                 *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *CDNLoadBalancerEmptyModel                                                `tfsdk:"xfcc_disabled"`
	XfccOptions               *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModelAttrTypes},
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel represents crl block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModel represents trusted_ca block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel represents xfcc_options block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel
var CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type CDNLoadBalancerHTTPSAutoCertModel struct {
	AddHsts      types.Bool                                  `tfsdk:"add_hsts"`
	HTTPRedirect types.Bool                                  `tfsdk:"http_redirect"`
	TLSConfig    *CDNLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
}

// CDNLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSAutoCertModel
var CDNLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":      types.BoolType,
	"http_redirect": types.BoolType,
	"tls_config":    types.ObjectType{AttrTypes: CDNLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
}

// CDNLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type CDNLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	TLS11Plus *CDNLoadBalancerEmptyModel `tfsdk:"tls_11_plus"`
	TLS12Plus *CDNLoadBalancerEmptyModel `tfsdk:"tls_12_plus"`
}

// CDNLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for CDNLoadBalancerHTTPSAutoCertTLSConfigModel
var CDNLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"tls_11_plus": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_12_plus": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerJsChallengeModel represents js_challenge block
type CDNLoadBalancerJsChallengeModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerJsChallengeModelAttrTypes defines the attribute types for CDNLoadBalancerJsChallengeModel
var CDNLoadBalancerJsChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// CDNLoadBalancerJWTValidationModel represents jwt_validation block
type CDNLoadBalancerJWTValidationModel struct {
	Action          *CDNLoadBalancerJWTValidationActionModel          `tfsdk:"action"`
	JwksConfig      *CDNLoadBalancerJWTValidationJwksConfigModel      `tfsdk:"jwks_config"`
	MandatoryClaims *CDNLoadBalancerJWTValidationMandatoryClaimsModel `tfsdk:"mandatory_claims"`
	ReservedClaims  *CDNLoadBalancerJWTValidationReservedClaimsModel  `tfsdk:"reserved_claims"`
	Target          *CDNLoadBalancerJWTValidationTargetModel          `tfsdk:"target"`
	TokenLocation   *CDNLoadBalancerJWTValidationTokenLocationModel   `tfsdk:"token_location"`
}

// CDNLoadBalancerJWTValidationModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationModel
var CDNLoadBalancerJWTValidationModelAttrTypes = map[string]attr.Type{
	"action":           types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationActionModelAttrTypes},
	"jwks_config":      types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationJwksConfigModelAttrTypes},
	"mandatory_claims": types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationMandatoryClaimsModelAttrTypes},
	"reserved_claims":  types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationReservedClaimsModelAttrTypes},
	"target":           types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationTargetModelAttrTypes},
	"token_location":   types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationTokenLocationModelAttrTypes},
}

// CDNLoadBalancerJWTValidationActionModel represents action block
type CDNLoadBalancerJWTValidationActionModel struct {
	Block  *CDNLoadBalancerEmptyModel `tfsdk:"block"`
	Report *CDNLoadBalancerEmptyModel `tfsdk:"report"`
}

// CDNLoadBalancerJWTValidationActionModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationActionModel
var CDNLoadBalancerJWTValidationActionModelAttrTypes = map[string]attr.Type{
	"block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerJWTValidationJwksConfigModel represents jwks_config block
type CDNLoadBalancerJWTValidationJwksConfigModel struct {
	Cleartext types.String `tfsdk:"cleartext"`
}

// CDNLoadBalancerJWTValidationJwksConfigModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationJwksConfigModel
var CDNLoadBalancerJWTValidationJwksConfigModelAttrTypes = map[string]attr.Type{
	"cleartext": types.StringType,
}

// CDNLoadBalancerJWTValidationMandatoryClaimsModel represents mandatory_claims block
type CDNLoadBalancerJWTValidationMandatoryClaimsModel struct {
	ClaimNames types.List `tfsdk:"claim_names"`
}

// CDNLoadBalancerJWTValidationMandatoryClaimsModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationMandatoryClaimsModel
var CDNLoadBalancerJWTValidationMandatoryClaimsModelAttrTypes = map[string]attr.Type{
	"claim_names": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerJWTValidationReservedClaimsModel represents reserved_claims block
type CDNLoadBalancerJWTValidationReservedClaimsModel struct {
	Issuer                types.String                                             `tfsdk:"issuer"`
	Audience              *CDNLoadBalancerJWTValidationReservedClaimsAudienceModel `tfsdk:"audience"`
	AudienceDisable       *CDNLoadBalancerEmptyModel                               `tfsdk:"audience_disable"`
	IssuerDisable         *CDNLoadBalancerEmptyModel                               `tfsdk:"issuer_disable"`
	ValidatePeriodDisable *CDNLoadBalancerEmptyModel                               `tfsdk:"validate_period_disable"`
	ValidatePeriodEnable  *CDNLoadBalancerEmptyModel                               `tfsdk:"validate_period_enable"`
}

// CDNLoadBalancerJWTValidationReservedClaimsModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationReservedClaimsModel
var CDNLoadBalancerJWTValidationReservedClaimsModelAttrTypes = map[string]attr.Type{
	"issuer":                  types.StringType,
	"audience":                types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationReservedClaimsAudienceModelAttrTypes},
	"audience_disable":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"issuer_disable":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validate_period_disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validate_period_enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerJWTValidationReservedClaimsAudienceModel represents audience block
type CDNLoadBalancerJWTValidationReservedClaimsAudienceModel struct {
	Audiences types.List `tfsdk:"audiences"`
}

// CDNLoadBalancerJWTValidationReservedClaimsAudienceModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationReservedClaimsAudienceModel
var CDNLoadBalancerJWTValidationReservedClaimsAudienceModelAttrTypes = map[string]attr.Type{
	"audiences": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerJWTValidationTargetModel represents target block
type CDNLoadBalancerJWTValidationTargetModel struct {
	AllEndpoint *CDNLoadBalancerEmptyModel                        `tfsdk:"all_endpoint"`
	APIGroups   *CDNLoadBalancerJWTValidationTargetAPIGroupsModel `tfsdk:"api_groups"`
	BasePaths   *CDNLoadBalancerJWTValidationTargetBasePathsModel `tfsdk:"base_paths"`
}

// CDNLoadBalancerJWTValidationTargetModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationTargetModel
var CDNLoadBalancerJWTValidationTargetModelAttrTypes = map[string]attr.Type{
	"all_endpoint": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_groups":   types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationTargetAPIGroupsModelAttrTypes},
	"base_paths":   types.ObjectType{AttrTypes: CDNLoadBalancerJWTValidationTargetBasePathsModelAttrTypes},
}

// CDNLoadBalancerJWTValidationTargetAPIGroupsModel represents api_groups block
type CDNLoadBalancerJWTValidationTargetAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// CDNLoadBalancerJWTValidationTargetAPIGroupsModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationTargetAPIGroupsModel
var CDNLoadBalancerJWTValidationTargetAPIGroupsModelAttrTypes = map[string]attr.Type{
	"api_groups": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerJWTValidationTargetBasePathsModel represents base_paths block
type CDNLoadBalancerJWTValidationTargetBasePathsModel struct {
	BasePaths types.List `tfsdk:"base_paths"`
}

// CDNLoadBalancerJWTValidationTargetBasePathsModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationTargetBasePathsModel
var CDNLoadBalancerJWTValidationTargetBasePathsModelAttrTypes = map[string]attr.Type{
	"base_paths": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerJWTValidationTokenLocationModel represents token_location block
type CDNLoadBalancerJWTValidationTokenLocationModel struct {
	BearerToken *CDNLoadBalancerEmptyModel `tfsdk:"bearer_token"`
}

// CDNLoadBalancerJWTValidationTokenLocationModelAttrTypes defines the attribute types for CDNLoadBalancerJWTValidationTokenLocationModel
var CDNLoadBalancerJWTValidationTokenLocationModelAttrTypes = map[string]attr.Type{
	"bearer_token": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerL7DDOSActionJsChallengeModel represents l7_ddos_action_js_challenge block
type CDNLoadBalancerL7DDOSActionJsChallengeModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerL7DDOSActionJsChallengeModelAttrTypes defines the attribute types for CDNLoadBalancerL7DDOSActionJsChallengeModel
var CDNLoadBalancerL7DDOSActionJsChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// CDNLoadBalancerOriginPoolModel represents origin_pool block
type CDNLoadBalancerOriginPoolModel struct {
	OriginRequestTimeout types.String                                     `tfsdk:"origin_request_timeout"`
	MoreOriginOptions    *CDNLoadBalancerOriginPoolMoreOriginOptionsModel `tfsdk:"more_origin_options"`
	NoTLS                *CDNLoadBalancerEmptyModel                       `tfsdk:"no_tls"`
	OriginServers        []CDNLoadBalancerOriginPoolOriginServersModel    `tfsdk:"origin_servers"`
	PublicName           *CDNLoadBalancerOriginPoolPublicNameModel        `tfsdk:"public_name"`
	UseTLS               *CDNLoadBalancerOriginPoolUseTLSModel            `tfsdk:"use_tls"`
}

// CDNLoadBalancerOriginPoolModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolModel
var CDNLoadBalancerOriginPoolModelAttrTypes = map[string]attr.Type{
	"origin_request_timeout": types.StringType,
	"more_origin_options":    types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolMoreOriginOptionsModelAttrTypes},
	"no_tls":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"origin_servers":         types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolOriginServersModelAttrTypes}},
	"public_name":            types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolPublicNameModelAttrTypes},
	"use_tls":                types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSModelAttrTypes},
}

// CDNLoadBalancerOriginPoolMoreOriginOptionsModel represents more_origin_options block
type CDNLoadBalancerOriginPoolMoreOriginOptionsModel struct {
	EnableByteRangeRequest types.Bool `tfsdk:"enable_byte_range_request"`
	WebSocketProxy         types.Bool `tfsdk:"websocket_proxy"`
}

// CDNLoadBalancerOriginPoolMoreOriginOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolMoreOriginOptionsModel
var CDNLoadBalancerOriginPoolMoreOriginOptionsModelAttrTypes = map[string]attr.Type{
	"enable_byte_range_request": types.BoolType,
	"websocket_proxy":           types.BoolType,
}

// CDNLoadBalancerOriginPoolOriginServersModel represents origin_servers block
type CDNLoadBalancerOriginPoolOriginServersModel struct {
	Port       types.Int64                                            `tfsdk:"port"`
	PublicIP   *CDNLoadBalancerOriginPoolOriginServersPublicIPModel   `tfsdk:"public_ip"`
	PublicName *CDNLoadBalancerOriginPoolOriginServersPublicNameModel `tfsdk:"public_name"`
}

// CDNLoadBalancerOriginPoolOriginServersModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolOriginServersModel
var CDNLoadBalancerOriginPoolOriginServersModelAttrTypes = map[string]attr.Type{
	"port":        types.Int64Type,
	"public_ip":   types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolOriginServersPublicIPModelAttrTypes},
	"public_name": types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolOriginServersPublicNameModelAttrTypes},
}

// CDNLoadBalancerOriginPoolOriginServersPublicIPModel represents public_ip block
type CDNLoadBalancerOriginPoolOriginServersPublicIPModel struct {
	IP types.String `tfsdk:"ip"`
}

// CDNLoadBalancerOriginPoolOriginServersPublicIPModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolOriginServersPublicIPModel
var CDNLoadBalancerOriginPoolOriginServersPublicIPModelAttrTypes = map[string]attr.Type{
	"ip": types.StringType,
}

// CDNLoadBalancerOriginPoolOriginServersPublicNameModel represents public_name block
type CDNLoadBalancerOriginPoolOriginServersPublicNameModel struct {
	DNSName         types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64  `tfsdk:"refresh_interval"`
}

// CDNLoadBalancerOriginPoolOriginServersPublicNameModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolOriginServersPublicNameModel
var CDNLoadBalancerOriginPoolOriginServersPublicNameModelAttrTypes = map[string]attr.Type{
	"dns_name":         types.StringType,
	"refresh_interval": types.Int64Type,
}

// CDNLoadBalancerOriginPoolPublicNameModel represents public_name block
type CDNLoadBalancerOriginPoolPublicNameModel struct {
	DNSName         types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64  `tfsdk:"refresh_interval"`
}

// CDNLoadBalancerOriginPoolPublicNameModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolPublicNameModel
var CDNLoadBalancerOriginPoolPublicNameModelAttrTypes = map[string]attr.Type{
	"dns_name":         types.StringType,
	"refresh_interval": types.Int64Type,
}

// CDNLoadBalancerOriginPoolUseTLSModel represents use_tls block
type CDNLoadBalancerOriginPoolUseTLSModel struct {
	MaxSessionKeys           types.Int64                                                `tfsdk:"max_session_keys"`
	Sni                      types.String                                               `tfsdk:"sni"`
	DefaultSessionKeyCaching *CDNLoadBalancerEmptyModel                                 `tfsdk:"default_session_key_caching"`
	DisableSessionKeyCaching *CDNLoadBalancerEmptyModel                                 `tfsdk:"disable_session_key_caching"`
	DisableSni               *CDNLoadBalancerEmptyModel                                 `tfsdk:"disable_sni"`
	NoMtls                   *CDNLoadBalancerEmptyModel                                 `tfsdk:"no_mtls"`
	SkipServerVerification   *CDNLoadBalancerEmptyModel                                 `tfsdk:"skip_server_verification"`
	TLSConfig                *CDNLoadBalancerOriginPoolUseTLSTLSConfigModel             `tfsdk:"tls_config"`
	UseHostHeaderAsSni       *CDNLoadBalancerEmptyModel                                 `tfsdk:"use_host_header_as_sni"`
	UseMtls                  *CDNLoadBalancerOriginPoolUseTLSUseMtlsModel               `tfsdk:"use_mtls"`
	UseMtlsObj               *CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel            `tfsdk:"use_mtls_obj"`
	UseServerVerification    *CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel `tfsdk:"use_server_verification"`
	VolterraTrustedCA        *CDNLoadBalancerEmptyModel                                 `tfsdk:"volterra_trusted_ca"`
}

// CDNLoadBalancerOriginPoolUseTLSModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSModel
var CDNLoadBalancerOriginPoolUseTLSModelAttrTypes = map[string]attr.Type{
	"max_session_keys":            types.Int64Type,
	"sni":                         types.StringType,
	"default_session_key_caching": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_session_key_caching": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_sni":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_mtls":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_server_verification":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":                  types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSTLSConfigModelAttrTypes},
	"use_host_header_as_sni":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":                    types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsModelAttrTypes},
	"use_mtls_obj":                types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModelAttrTypes},
	"use_server_verification":     types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModelAttrTypes},
	"volterra_trusted_ca":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerOriginPoolUseTLSTLSConfigModel represents tls_config block
type CDNLoadBalancerOriginPoolUseTLSTLSConfigModel struct {
	CustomSecurity  *CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *CDNLoadBalancerEmptyModel                                   `tfsdk:"default_security"`
	LowSecurity     *CDNLoadBalancerEmptyModel                                   `tfsdk:"low_security"`
	MediumSecurity  *CDNLoadBalancerEmptyModel                                   `tfsdk:"medium_security"`
}

// CDNLoadBalancerOriginPoolUseTLSTLSConfigModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSTLSConfigModel
var CDNLoadBalancerOriginPoolUseTLSTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel represents custom_security block
type CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel
var CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsModel represents use_mtls block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsModel struct {
	TLSCertificates []CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel `tfsdk:"tls_certificates"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsModelAttrTypes = map[string]attr.Type{
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes}},
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel represents tls_certificates block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel struct {
	CertificateURL       types.String                                                                    `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                    `tfsdk:"description_spec"`
	CustomHashAlgorithms *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *CDNLoadBalancerEmptyModel                                                      `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *CDNLoadBalancerEmptyModel                                                      `tfsdk:"use_system_defaults"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel represents private_key block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel represents use_mtls_obj block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel
var CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel represents use_server_verification block
type CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel struct {
	TrustedCAURL types.String                                                        `tfsdk:"trusted_ca_url"`
	TrustedCA    *CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModel `tfsdk:"trusted_ca"`
}

// CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel
var CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModelAttrTypes = map[string]attr.Type{
	"trusted_ca_url": types.StringType,
	"trusted_ca":     types.ObjectType{AttrTypes: CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes},
}

// CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModel represents trusted_ca block
type CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes defines the attribute types for CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModel
var CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerOtherSettingsModel represents other_settings block
type CDNLoadBalancerOtherSettingsModel struct {
	AddLocation    types.Bool                                       `tfsdk:"add_location"`
	HeaderOptions  *CDNLoadBalancerOtherSettingsHeaderOptionsModel  `tfsdk:"header_options"`
	LoggingOptions *CDNLoadBalancerOtherSettingsLoggingOptionsModel `tfsdk:"logging_options"`
}

// CDNLoadBalancerOtherSettingsModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsModel
var CDNLoadBalancerOtherSettingsModelAttrTypes = map[string]attr.Type{
	"add_location":    types.BoolType,
	"header_options":  types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsModelAttrTypes},
	"logging_options": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsLoggingOptionsModelAttrTypes},
}

// CDNLoadBalancerOtherSettingsHeaderOptionsModel represents header_options block
type CDNLoadBalancerOtherSettingsHeaderOptionsModel struct {
	RequestHeadersToRemove  types.List                                                           `tfsdk:"request_headers_to_remove"`
	ResponseHeadersToRemove types.List                                                           `tfsdk:"response_headers_to_remove"`
	RequestHeadersToAdd     []CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel  `tfsdk:"request_headers_to_add"`
	ResponseHeadersToAdd    []CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsModel
var CDNLoadBalancerOtherSettingsHeaderOptionsModelAttrTypes = map[string]attr.Type{
	"request_headers_to_remove":  types.ListType{ElemType: types.StringType},
	"response_headers_to_remove": types.ListType{ElemType: types.StringType},
	"request_headers_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModelAttrTypes}},
	"response_headers_to_add":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModelAttrTypes}},
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel represents request_headers_to_add block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel struct {
	Append      types.Bool                                                                    `tfsdk:"append"`
	Name        types.String                                                                  `tfsdk:"name"`
	Value       types.String                                                                  `tfsdk:"value"`
	SecretValue *CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel
var CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModelAttrTypes},
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel represents secret_value block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel
var CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel
var CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel represents response_headers_to_add block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel struct {
	Append      types.Bool                                                                     `tfsdk:"append"`
	Name        types.String                                                                   `tfsdk:"name"`
	Value       types.String                                                                   `tfsdk:"value"`
	SecretValue *CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel
var CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModelAttrTypes},
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel represents secret_value block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel
var CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel
var CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// CDNLoadBalancerOtherSettingsLoggingOptionsModel represents logging_options block
type CDNLoadBalancerOtherSettingsLoggingOptionsModel struct {
	ClientLogOptions *CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel `tfsdk:"client_log_options"`
	OriginLogOptions *CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel `tfsdk:"origin_log_options"`
}

// CDNLoadBalancerOtherSettingsLoggingOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsLoggingOptionsModel
var CDNLoadBalancerOtherSettingsLoggingOptionsModelAttrTypes = map[string]attr.Type{
	"client_log_options": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModelAttrTypes},
	"origin_log_options": types.ObjectType{AttrTypes: CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModelAttrTypes},
}

// CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel represents client_log_options block
type CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel struct {
	HeaderList types.List `tfsdk:"header_list"`
}

// CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel
var CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModelAttrTypes = map[string]attr.Type{
	"header_list": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel represents origin_log_options block
type CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel struct {
	HeaderList types.List `tfsdk:"header_list"`
}

// CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModelAttrTypes defines the attribute types for CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel
var CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModelAttrTypes = map[string]attr.Type{
	"header_list": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeModel represents policy_based_challenge block
type CDNLoadBalancerPolicyBasedChallengeModel struct {
	AlwaysEnableCaptchaChallenge       *CDNLoadBalancerEmptyModel                                          `tfsdk:"always_enable_captcha_challenge"`
	AlwaysEnableJsChallenge            *CDNLoadBalancerEmptyModel                                          `tfsdk:"always_enable_js_challenge"`
	CaptchaChallengeParameters         *CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters  *CDNLoadBalancerEmptyModel                                          `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters       *CDNLoadBalancerEmptyModel                                          `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings          *CDNLoadBalancerEmptyModel                                          `tfsdk:"default_mitigation_settings"`
	DefaultTemporaryBlockingParameters *CDNLoadBalancerEmptyModel                                          `tfsdk:"default_temporary_blocking_parameters"`
	JsChallengeParameters              *CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel      `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation            *CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel    `tfsdk:"malicious_user_mitigation"`
	NoChallenge                        *CDNLoadBalancerEmptyModel                                          `tfsdk:"no_challenge"`
	RuleList                           *CDNLoadBalancerPolicyBasedChallengeRuleListModel                   `tfsdk:"rule_list"`
	TemporaryUserBlocking              *CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel      `tfsdk:"temporary_user_blocking"`
}

// CDNLoadBalancerPolicyBasedChallengeModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeModel
var CDNLoadBalancerPolicyBasedChallengeModelAttrTypes = map[string]attr.Type{
	"always_enable_captcha_challenge":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"always_enable_js_challenge":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"captcha_challenge_parameters":          types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModelAttrTypes},
	"default_captcha_challenge_parameters":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_js_challenge_parameters":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_mitigation_settings":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_temporary_blocking_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_challenge_parameters":               types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModelAttrTypes},
	"malicious_user_mitigation":             types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModelAttrTypes},
	"no_challenge":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"rule_list":                             types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListModelAttrTypes},
	"temporary_user_blocking":               types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel
var CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel represents js_challenge_parameters block
type CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel
var CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel
var CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerPolicyBasedChallengeRuleListModel represents rule_list block
type CDNLoadBalancerPolicyBasedChallengeRuleListModel struct {
	Rules []CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel `tfsdk:"rules"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListModel
var CDNLoadBalancerPolicyBasedChallengeRuleListModelAttrTypes = map[string]attr.Type{
	"rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesModelAttrTypes}},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel represents rules block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel struct {
	Metadata *CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel `tfsdk:"metadata"`
	Spec     *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel     `tfsdk:"spec"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesModelAttrTypes = map[string]attr.Type{
	"metadata": types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModelAttrTypes},
	"spec":     types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel represents metadata block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel represents spec block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel struct {
	ExpirationTimestamp       types.String                                                                    `tfsdk:"expiration_timestamp"`
	AnyAsn                    *CDNLoadBalancerEmptyModel                                                      `tfsdk:"any_asn"`
	AnyClient                 *CDNLoadBalancerEmptyModel                                                      `tfsdk:"any_client"`
	AnyIP                     *CDNLoadBalancerEmptyModel                                                      `tfsdk:"any_ip"`
	ArgMatchers               []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel          `tfsdk:"arg_matchers"`
	AsnList                   *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher                *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel            `tfsdk:"asn_matcher"`
	BodyMatcher               *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel           `tfsdk:"body_matcher"`
	ClientSelector            *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel        `tfsdk:"client_selector"`
	CookieMatchers            []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel       `tfsdk:"cookie_matchers"`
	DisableChallenge          *CDNLoadBalancerEmptyModel                                                      `tfsdk:"disable_challenge"`
	DomainMatcher             *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel         `tfsdk:"domain_matcher"`
	EnableCaptchaChallenge    *CDNLoadBalancerEmptyModel                                                      `tfsdk:"enable_captcha_challenge"`
	EnableJavascriptChallenge *CDNLoadBalancerEmptyModel                                                      `tfsdk:"enable_javascript_challenge"`
	Headers                   []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel              `tfsdk:"headers"`
	HTTPMethod                *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel            `tfsdk:"http_method"`
	IPMatcher                 *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList              *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	Path                      *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel                  `tfsdk:"path"`
	QueryParams               []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel          `tfsdk:"query_params"`
	TLSFingerprintMatcher     *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModelAttrTypes = map[string]attr.Type{
	"expiration_timestamp":        types.StringType,
	"any_asn":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_client":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"arg_matchers":                types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModelAttrTypes}},
	"asn_list":                    types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModelAttrTypes},
	"asn_matcher":                 types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModelAttrTypes},
	"body_matcher":                types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModelAttrTypes},
	"client_selector":             types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModelAttrTypes},
	"cookie_matchers":             types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModelAttrTypes}},
	"disable_challenge":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain_matcher":              types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModelAttrTypes},
	"enable_captcha_challenge":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_javascript_challenge": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"headers":                     types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModelAttrTypes}},
	"http_method":                 types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModelAttrTypes},
	"ip_matcher":                  types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModelAttrTypes},
	"ip_prefix_list":              types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModelAttrTypes},
	"path":                        types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModelAttrTypes},
	"query_params":                types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModelAttrTypes}},
	"tls_fingerprint_matcher":     types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel represents arg_matchers block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel struct {
	InvertMatcher   types.Bool                                                                `tfsdk:"invert_matcher"`
	Name            types.String                                                              `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                `tfsdk:"check_present"`
	Item            *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel represents asn_list block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModelAttrTypes}},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel represents body_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel represents client_selector block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                   `tfsdk:"invert_matcher"`
	Name            types.String                                                                 `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                   `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                   `tfsdk:"check_present"`
	Item            *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel represents domain_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel represents headers block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel struct {
	InvertMatcher   types.Bool                                                            `tfsdk:"invert_matcher"`
	Name            types.String                                                          `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                            `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                            `tfsdk:"check_present"`
	Item            *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel represents http_method block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods       types.List `tfsdk:"methods"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"methods":        types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel represents ip_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel struct {
	InvertMatcher types.Bool                                                                     `tfsdk:"invert_matcher"`
	PrefixSets    []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModelAttrTypes}},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel represents path block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel struct {
	ExactValues   types.List `tfsdk:"exact_values"`
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixValues  types.List `tfsdk:"prefix_values"`
	RegexValues   types.List `tfsdk:"regex_values"`
	SuffixValues  types.List `tfsdk:"suffix_values"`
	Transformers  types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModelAttrTypes = map[string]attr.Type{
	"exact_values":   types.ListType{ElemType: types.StringType},
	"invert_matcher": types.BoolType,
	"prefix_values":  types.ListType{ElemType: types.StringType},
	"regex_values":   types.ListType{ElemType: types.StringType},
	"suffix_values":  types.ListType{ElemType: types.StringType},
	"transformers":   types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel represents query_params block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                `tfsdk:"invert_matcher"`
	Key             types.String                                                              `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel                                                `tfsdk:"check_not_present"`
	CheckPresent    *CDNLoadBalancerEmptyModel                                                `tfsdk:"check_present"`
	Item            *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModelAttrTypes},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel
var CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel represents temporary_user_blocking block
type CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel struct {
	CustomPage types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModelAttrTypes defines the attribute types for CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel
var CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModelAttrTypes = map[string]attr.Type{
	"custom_page": types.StringType,
}

// CDNLoadBalancerProtectedCookiesModel represents protected_cookies block
type CDNLoadBalancerProtectedCookiesModel struct {
	MaxAgeValue                types.Int64                `tfsdk:"max_age_value"`
	Name                       types.String               `tfsdk:"name"`
	AddHttponly                *CDNLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure                  *CDNLoadBalancerEmptyModel `tfsdk:"add_secure"`
	DisableTamperingProtection *CDNLoadBalancerEmptyModel `tfsdk:"disable_tampering_protection"`
	EnableTamperingProtection  *CDNLoadBalancerEmptyModel `tfsdk:"enable_tampering_protection"`
	IgnoreHttponly             *CDNLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreMaxAge               *CDNLoadBalancerEmptyModel `tfsdk:"ignore_max_age"`
	IgnoreSamesite             *CDNLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure               *CDNLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax                *CDNLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone               *CDNLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict             *CDNLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// CDNLoadBalancerProtectedCookiesModelAttrTypes defines the attribute types for CDNLoadBalancerProtectedCookiesModel
var CDNLoadBalancerProtectedCookiesModelAttrTypes = map[string]attr.Type{
	"max_age_value":                types.Int64Type,
	"name":                         types.StringType,
	"add_httponly":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_tampering_protection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_tampering_protection":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerRateLimitModel represents rate_limit block
type CDNLoadBalancerRateLimitModel struct {
	CustomIPAllowedList *CDNLoadBalancerRateLimitCustomIPAllowedListModel `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList       *CDNLoadBalancerRateLimitIPAllowedListModel       `tfsdk:"ip_allowed_list"`
	NoIPAllowedList     *CDNLoadBalancerEmptyModel                        `tfsdk:"no_ip_allowed_list"`
	NoPolicies          *CDNLoadBalancerEmptyModel                        `tfsdk:"no_policies"`
	Policies            *CDNLoadBalancerRateLimitPoliciesModel            `tfsdk:"policies"`
	RateLimiter         *CDNLoadBalancerRateLimitRateLimiterModel         `tfsdk:"rate_limiter"`
}

// CDNLoadBalancerRateLimitModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitModel
var CDNLoadBalancerRateLimitModelAttrTypes = map[string]attr.Type{
	"custom_ip_allowed_list": types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitCustomIPAllowedListModelAttrTypes},
	"ip_allowed_list":        types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitIPAllowedListModelAttrTypes},
	"no_ip_allowed_list":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_policies":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"policies":               types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitPoliciesModelAttrTypes},
	"rate_limiter":           types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitRateLimiterModelAttrTypes},
}

// CDNLoadBalancerRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type CDNLoadBalancerRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// CDNLoadBalancerRateLimitCustomIPAllowedListModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitCustomIPAllowedListModel
var CDNLoadBalancerRateLimitCustomIPAllowedListModelAttrTypes = map[string]attr.Type{
	"rate_limiter_allowed_prefixes": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes}},
}

// CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel
var CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerRateLimitIPAllowedListModel represents ip_allowed_list block
type CDNLoadBalancerRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// CDNLoadBalancerRateLimitIPAllowedListModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitIPAllowedListModel
var CDNLoadBalancerRateLimitIPAllowedListModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// CDNLoadBalancerRateLimitPoliciesModel represents policies block
type CDNLoadBalancerRateLimitPoliciesModel struct {
	Policies []CDNLoadBalancerRateLimitPoliciesPoliciesModel `tfsdk:"policies"`
}

// CDNLoadBalancerRateLimitPoliciesModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitPoliciesModel
var CDNLoadBalancerRateLimitPoliciesModelAttrTypes = map[string]attr.Type{
	"policies": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitPoliciesPoliciesModelAttrTypes}},
}

// CDNLoadBalancerRateLimitPoliciesPoliciesModel represents policies block
type CDNLoadBalancerRateLimitPoliciesPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerRateLimitPoliciesPoliciesModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitPoliciesPoliciesModel
var CDNLoadBalancerRateLimitPoliciesPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerRateLimitRateLimiterModel represents rate_limiter block
type CDNLoadBalancerRateLimitRateLimiterModel struct {
	BurstMultiplier  types.Int64                                          `tfsdk:"burst_multiplier"`
	PeriodMultiplier types.Int64                                          `tfsdk:"period_multiplier"`
	TotalNumber      types.Int64                                          `tfsdk:"total_number"`
	Unit             types.String                                         `tfsdk:"unit"`
	ActionBlock      *CDNLoadBalancerRateLimitRateLimiterActionBlockModel `tfsdk:"action_block"`
	Disabled         *CDNLoadBalancerEmptyModel                           `tfsdk:"disabled"`
	LeakyBucket      *CDNLoadBalancerEmptyModel                           `tfsdk:"leaky_bucket"`
	TokenBucket      *CDNLoadBalancerEmptyModel                           `tfsdk:"token_bucket"`
}

// CDNLoadBalancerRateLimitRateLimiterModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitRateLimiterModel
var CDNLoadBalancerRateLimitRateLimiterModelAttrTypes = map[string]attr.Type{
	"burst_multiplier":  types.Int64Type,
	"period_multiplier": types.Int64Type,
	"total_number":      types.Int64Type,
	"unit":              types.StringType,
	"action_block":      types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitRateLimiterActionBlockModelAttrTypes},
	"disabled":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"leaky_bucket":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"token_bucket":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockModel represents action_block block
type CDNLoadBalancerRateLimitRateLimiterActionBlockModel struct {
	Hours   *CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel   `tfsdk:"hours"`
	Minutes *CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel `tfsdk:"minutes"`
	Seconds *CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel `tfsdk:"seconds"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitRateLimiterActionBlockModel
var CDNLoadBalancerRateLimitRateLimiterActionBlockModelAttrTypes = map[string]attr.Type{
	"hours":   types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModelAttrTypes},
	"minutes": types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModelAttrTypes},
	"seconds": types.ObjectType{AttrTypes: CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModelAttrTypes},
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel represents hours block
type CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel
var CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModelAttrTypes = map[string]attr.Type{
	"duration": types.Int64Type,
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel represents minutes block
type CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel
var CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModelAttrTypes = map[string]attr.Type{
	"duration": types.Int64Type,
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel represents seconds block
type CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModelAttrTypes defines the attribute types for CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel
var CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModelAttrTypes = map[string]attr.Type{
	"duration": types.Int64Type,
}

// CDNLoadBalancerSensitiveDataPolicyModel represents sensitive_data_policy block
type CDNLoadBalancerSensitiveDataPolicyModel struct {
	SensitiveDataPolicyRef *CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel `tfsdk:"sensitive_data_policy_ref"`
}

// CDNLoadBalancerSensitiveDataPolicyModelAttrTypes defines the attribute types for CDNLoadBalancerSensitiveDataPolicyModel
var CDNLoadBalancerSensitiveDataPolicyModelAttrTypes = map[string]attr.Type{
	"sensitive_data_policy_ref": types.ObjectType{AttrTypes: CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModelAttrTypes},
}

// CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel represents sensitive_data_policy_ref block
type CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModelAttrTypes defines the attribute types for CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel
var CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerSlowDDOSMitigationModel represents slow_ddos_mitigation block
type CDNLoadBalancerSlowDDOSMitigationModel struct {
	RequestHeadersTimeout types.Int64                `tfsdk:"request_headers_timeout"`
	RequestTimeout        types.Int64                `tfsdk:"request_timeout"`
	DisableRequestTimeout *CDNLoadBalancerEmptyModel `tfsdk:"disable_request_timeout"`
}

// CDNLoadBalancerSlowDDOSMitigationModelAttrTypes defines the attribute types for CDNLoadBalancerSlowDDOSMitigationModel
var CDNLoadBalancerSlowDDOSMitigationModelAttrTypes = map[string]attr.Type{
	"request_headers_timeout": types.Int64Type,
	"request_timeout":         types.Int64Type,
	"disable_request_timeout": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerTrustedClientsModel represents trusted_clients block
type CDNLoadBalancerTrustedClientsModel struct {
	Actions             types.List                                    `tfsdk:"actions"`
	AsNumber            types.Int64                                   `tfsdk:"as_number"`
	ExpirationTimestamp types.String                                  `tfsdk:"expiration_timestamp"`
	IPPrefix            types.String                                  `tfsdk:"ip_prefix"`
	Ipv6Prefix          types.String                                  `tfsdk:"ipv6_prefix"`
	UserIdentifier      types.String                                  `tfsdk:"user_identifier"`
	BotSkipProcessing   *CDNLoadBalancerEmptyModel                    `tfsdk:"bot_skip_processing"`
	HTTPHeader          *CDNLoadBalancerTrustedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata            *CDNLoadBalancerTrustedClientsMetadataModel   `tfsdk:"metadata"`
	SkipProcessing      *CDNLoadBalancerEmptyModel                    `tfsdk:"skip_processing"`
	WAFSkipProcessing   *CDNLoadBalancerEmptyModel                    `tfsdk:"waf_skip_processing"`
}

// CDNLoadBalancerTrustedClientsModelAttrTypes defines the attribute types for CDNLoadBalancerTrustedClientsModel
var CDNLoadBalancerTrustedClientsModelAttrTypes = map[string]attr.Type{
	"actions":              types.ListType{ElemType: types.StringType},
	"as_number":            types.Int64Type,
	"expiration_timestamp": types.StringType,
	"ip_prefix":            types.StringType,
	"ipv6_prefix":          types.StringType,
	"user_identifier":      types.StringType,
	"bot_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_header":          types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsHTTPHeaderModelAttrTypes},
	"metadata":             types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsMetadataModelAttrTypes},
	"skip_processing":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"waf_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerTrustedClientsHTTPHeaderModel represents http_header block
type CDNLoadBalancerTrustedClientsHTTPHeaderModel struct {
	Headers []CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// CDNLoadBalancerTrustedClientsHTTPHeaderModelAttrTypes defines the attribute types for CDNLoadBalancerTrustedClientsHTTPHeaderModel
var CDNLoadBalancerTrustedClientsHTTPHeaderModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModelAttrTypes}},
}

// CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel represents headers block
type CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModelAttrTypes defines the attribute types for CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel
var CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// CDNLoadBalancerTrustedClientsMetadataModel represents metadata block
type CDNLoadBalancerTrustedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerTrustedClientsMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerTrustedClientsMetadataModel
var CDNLoadBalancerTrustedClientsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerUserIdentificationModel represents user_identification block
type CDNLoadBalancerUserIdentificationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerUserIdentificationModelAttrTypes defines the attribute types for CDNLoadBalancerUserIdentificationModel
var CDNLoadBalancerUserIdentificationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// CDNLoadBalancerWAFExclusionModel represents waf_exclusion block
type CDNLoadBalancerWAFExclusionModel struct {
	WAFExclusionInlineRules *CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel `tfsdk:"waf_exclusion_inline_rules"`
	WAFExclusionPolicy      *CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel      `tfsdk:"waf_exclusion_policy"`
}

// CDNLoadBalancerWAFExclusionModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionModel
var CDNLoadBalancerWAFExclusionModelAttrTypes = map[string]attr.Type{
	"waf_exclusion_inline_rules": types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModelAttrTypes},
	"waf_exclusion_policy":       types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionPolicyModelAttrTypes},
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel represents waf_exclusion_inline_rules block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel struct {
	Rules []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel `tfsdk:"rules"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModelAttrTypes = map[string]attr.Type{
	"rules": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModelAttrTypes}},
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel represents rules block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel struct {
	ExactValue                  types.String                                                                             `tfsdk:"exact_value"`
	ExpirationTimestamp         types.String                                                                             `tfsdk:"expiration_timestamp"`
	Methods                     types.List                                                                               `tfsdk:"methods"`
	PathPrefix                  types.String                                                                             `tfsdk:"path_prefix"`
	PathRegex                   types.String                                                                             `tfsdk:"path_regex"`
	SuffixValue                 types.String                                                                             `tfsdk:"suffix_value"`
	AnyDomain                   *CDNLoadBalancerEmptyModel                                                               `tfsdk:"any_domain"`
	AnyPath                     *CDNLoadBalancerEmptyModel                                                               `tfsdk:"any_path"`
	AppFirewallDetectionControl *CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel `tfsdk:"app_firewall_detection_control"`
	Metadata                    *CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel                    `tfsdk:"metadata"`
	WAFSkipProcessing           *CDNLoadBalancerEmptyModel                                                               `tfsdk:"waf_skip_processing"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModelAttrTypes = map[string]attr.Type{
	"exact_value":                    types.StringType,
	"expiration_timestamp":           types.StringType,
	"methods":                        types.ListType{ElemType: types.StringType},
	"path_prefix":                    types.StringType,
	"path_regex":                     types.StringType,
	"suffix_value":                   types.StringType,
	"any_domain":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_path":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"app_firewall_detection_control": types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModelAttrTypes},
	"metadata":                       types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModelAttrTypes},
	"waf_skip_processing":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel represents app_firewall_detection_control block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel struct {
	ExcludeAttackTypeContexts []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel `tfsdk:"exclude_attack_type_contexts"`
	ExcludeBotNameContexts    []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel    `tfsdk:"exclude_bot_name_contexts"`
	ExcludeSignatureContexts  []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel  `tfsdk:"exclude_signature_contexts"`
	ExcludeViolationContexts  []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel  `tfsdk:"exclude_violation_contexts"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModelAttrTypes = map[string]attr.Type{
	"exclude_attack_type_contexts": types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModelAttrTypes}},
	"exclude_bot_name_contexts":    types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModelAttrTypes}},
	"exclude_signature_contexts":   types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModelAttrTypes}},
	"exclude_violation_contexts":   types.ListType{ElemType: types.ObjectType{AttrTypes: CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModelAttrTypes}},
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel represents exclude_attack_type_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel struct {
	Context           types.String `tfsdk:"context"`
	ContextName       types.String `tfsdk:"context_name"`
	ExcludeAttackType types.String `tfsdk:"exclude_attack_type"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModelAttrTypes = map[string]attr.Type{
	"context":             types.StringType,
	"context_name":        types.StringType,
	"exclude_attack_type": types.StringType,
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel represents exclude_bot_name_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel struct {
	BotName types.String `tfsdk:"bot_name"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModelAttrTypes = map[string]attr.Type{
	"bot_name": types.StringType,
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel represents exclude_signature_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel struct {
	Context     types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	SignatureID types.Int64  `tfsdk:"signature_id"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModelAttrTypes = map[string]attr.Type{
	"context":      types.StringType,
	"context_name": types.StringType,
	"signature_id": types.Int64Type,
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel represents exclude_violation_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel struct {
	Context          types.String `tfsdk:"context"`
	ContextName      types.String `tfsdk:"context_name"`
	ExcludeViolation types.String `tfsdk:"exclude_violation"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModelAttrTypes = map[string]attr.Type{
	"context":           types.StringType,
	"context_name":      types.StringType,
	"exclude_violation": types.StringType,
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel represents metadata block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel
var CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel represents waf_exclusion_policy block
type CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionPolicyModelAttrTypes defines the attribute types for CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel
var CDNLoadBalancerWAFExclusionWAFExclusionPolicyModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

type CDNLoadBalancerResourceModel struct {
	Name                          types.String                                 `tfsdk:"name"`
	Namespace                     types.String                                 `tfsdk:"namespace"`
	Annotations                   types.Map                                    `tfsdk:"annotations"`
	Description                   types.String                                 `tfsdk:"description"`
	Disable                       types.Bool                                   `tfsdk:"disable"`
	Domains                       types.List                                   `tfsdk:"domains"`
	Labels                        types.Map                                    `tfsdk:"labels"`
	ID                            types.String                                 `tfsdk:"id"`
	Timeouts                      timeouts.Value                               `tfsdk:"timeouts"`
	ActiveServicePolicies         *CDNLoadBalancerActiveServicePoliciesModel   `tfsdk:"active_service_policies"`
	APIRateLimit                  *CDNLoadBalancerAPIRateLimitModel            `tfsdk:"api_rate_limit"`
	APISpecification              *CDNLoadBalancerAPISpecificationModel        `tfsdk:"api_specification"`
	AppFirewall                   *CDNLoadBalancerAppFirewallModel             `tfsdk:"app_firewall"`
	BlockedClients                types.List                                   `tfsdk:"blocked_clients"`
	BotDefense                    *CDNLoadBalancerBotDefenseModel              `tfsdk:"bot_defense"`
	CaptchaChallenge              *CDNLoadBalancerCaptchaChallengeModel        `tfsdk:"captcha_challenge"`
	ClientSideDefense             *CDNLoadBalancerClientSideDefenseModel       `tfsdk:"client_side_defense"`
	CORSPolicy                    *CDNLoadBalancerCORSPolicyModel              `tfsdk:"cors_policy"`
	CSRFPolicy                    *CDNLoadBalancerCSRFPolicyModel              `tfsdk:"csrf_policy"`
	CustomCacheRule               *CDNLoadBalancerCustomCacheRuleModel         `tfsdk:"custom_cache_rule"`
	DataGuardRules                types.List                                   `tfsdk:"data_guard_rules"`
	DDOSMitigationRules           types.List                                   `tfsdk:"ddos_mitigation_rules"`
	DefaultCacheAction            *CDNLoadBalancerDefaultCacheActionModel      `tfsdk:"default_cache_action"`
	DefaultSensitiveDataPolicy    *CDNLoadBalancerEmptyModel                   `tfsdk:"default_sensitive_data_policy"`
	DisableAPIDefinition          *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_api_definition"`
	DisableAPIDiscovery           *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_api_discovery"`
	DisableClientSideDefense      *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_client_side_defense"`
	DisableIPReputation           *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_ip_reputation"`
	DisableMaliciousUserDetection *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_malicious_user_detection"`
	DisableRateLimit              *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_rate_limit"`
	DisableThreatMesh             *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_threat_mesh"`
	DisableWAF                    *CDNLoadBalancerEmptyModel                   `tfsdk:"disable_waf"`
	EnableAPIDiscovery            *CDNLoadBalancerEnableAPIDiscoveryModel      `tfsdk:"enable_api_discovery"`
	EnableChallenge               *CDNLoadBalancerEnableChallengeModel         `tfsdk:"enable_challenge"`
	EnableIPReputation            *CDNLoadBalancerEnableIPReputationModel      `tfsdk:"enable_ip_reputation"`
	EnableMaliciousUserDetection  *CDNLoadBalancerEmptyModel                   `tfsdk:"enable_malicious_user_detection"`
	EnableThreatMesh              *CDNLoadBalancerEmptyModel                   `tfsdk:"enable_threat_mesh"`
	GraphqlRules                  types.List                                   `tfsdk:"graphql_rules"`
	HTTP                          *CDNLoadBalancerHTTPModel                    `tfsdk:"http"`
	HTTPS                         *CDNLoadBalancerHTTPSModel                   `tfsdk:"https"`
	HTTPSAutoCert                 *CDNLoadBalancerHTTPSAutoCertModel           `tfsdk:"https_auto_cert"`
	JsChallenge                   *CDNLoadBalancerJsChallengeModel             `tfsdk:"js_challenge"`
	JWTValidation                 *CDNLoadBalancerJWTValidationModel           `tfsdk:"jwt_validation"`
	L7DDOSActionBlock             *CDNLoadBalancerEmptyModel                   `tfsdk:"l7_ddos_action_block"`
	L7DDOSActionDefault           *CDNLoadBalancerEmptyModel                   `tfsdk:"l7_ddos_action_default"`
	L7DDOSActionJsChallenge       *CDNLoadBalancerL7DDOSActionJsChallengeModel `tfsdk:"l7_ddos_action_js_challenge"`
	NoChallenge                   *CDNLoadBalancerEmptyModel                   `tfsdk:"no_challenge"`
	NoServicePolicies             *CDNLoadBalancerEmptyModel                   `tfsdk:"no_service_policies"`
	OriginPool                    *CDNLoadBalancerOriginPoolModel              `tfsdk:"origin_pool"`
	OtherSettings                 *CDNLoadBalancerOtherSettingsModel           `tfsdk:"other_settings"`
	PolicyBasedChallenge          *CDNLoadBalancerPolicyBasedChallengeModel    `tfsdk:"policy_based_challenge"`
	ProtectedCookies              types.List                                   `tfsdk:"protected_cookies"`
	RateLimit                     *CDNLoadBalancerRateLimitModel               `tfsdk:"rate_limit"`
	SensitiveDataPolicy           *CDNLoadBalancerSensitiveDataPolicyModel     `tfsdk:"sensitive_data_policy"`
	ServicePoliciesFromNamespace  *CDNLoadBalancerEmptyModel                   `tfsdk:"service_policies_from_namespace"`
	SlowDDOSMitigation            *CDNLoadBalancerSlowDDOSMitigationModel      `tfsdk:"slow_ddos_mitigation"`
	SystemDefaultTimeouts         *CDNLoadBalancerEmptyModel                   `tfsdk:"system_default_timeouts"`
	TrustedClients                types.List                                   `tfsdk:"trusted_clients"`
	UserIDClientIP                *CDNLoadBalancerEmptyModel                   `tfsdk:"user_id_client_ip"`
	UserIdentification            *CDNLoadBalancerUserIdentificationModel      `tfsdk:"user_identification"`
	WAFExclusion                  *CDNLoadBalancerWAFExclusionModel            `tfsdk:"waf_exclusion"`
}

func (r *CDNLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cdn_loadbalancer"
}

func (r *CDNLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             cdn_loadbalancerSchemaVersion,
		MarkdownDescription: "Manages a CDN Load Balancer resource in F5 Distributed Cloud for content delivery and edge caching with load balancing.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the CDN Load Balancer. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the CDN Load Balancer will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "List of fully qualified domain names. The CDN Distribution will be setup for these FQDN name(s). [This can be a domain or a sub-domain] .",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_service_policies, no_service_policies, service_policies_from_namespace; Default: no_service_policies] Service Policy List. List of service policies.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"policies": schema.ListNestedBlock{
						MarkdownDescription: "Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the correct order (policies evaluated from top to bottom in the list) for service policies, to GET the intended result. For each request, its..",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"api_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_rate_limit, disable_rate_limit, rate_limit; Default: disable_rate_limit] APIRateLimit.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_endpoint_rules": schema.ListNestedBlock{
						MarkdownDescription: "Sets of rules for a specific endpoints. Order is matter as it uses first match policy. For creating rule that contain a whole domain or group of endpoints, please use the server URL rules above.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_endpoint_path": schema.StringAttribute{
									MarkdownDescription: "The endpoint (path) of the request.",
									Optional:            true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "The rule will apply for a specific domain.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"api_endpoint_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional:            true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional:            true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional:            true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "[Enum: SECOND|MINUTE|HOUR] Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive cookie name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"bypass_rate_limiting_rules": schema.SingleNestedBlock{
						MarkdownDescription: "Category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"bypass_rate_limiting_rules": schema.ListNestedBlock{
								MarkdownDescription: "Category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"base_path": schema.StringAttribute{
											MarkdownDescription: "The base path which this validation applies to.",
											Optional:            true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "The rule will apply for a specific domain. For",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_url": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines API endpoint.",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched .",
													Optional:            true,
												},
											},
										},
										"api_groups": schema.SingleNestedBlock{
											MarkdownDescription: "API Groups.",
											Attributes: map[string]schema.Attribute{
												"api_groups": schema.ListAttribute{
													MarkdownDescription: "API Groups. .",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"client_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional:            true,
															ElementType:         types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional:            true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"ip_threat_category_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
													Attributes: map[string]schema.Attribute{
														"ip_threat_categories": schema.ListAttribute{
															MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
										"request_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive cookie name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-insensitive HTTP header name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"jwt_claims": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert the match result.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "JWT Claim Name. JWT claim name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional:            true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive HTTP query parameter name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IP Allowed list using existing ip_prefix_set objects.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"server_url_rules": schema.ListNestedBlock{
						MarkdownDescription: "Set of rules for entire domain or base path that contain multiple endpoints. Order is matter as it uses first match policy. For matching also specific endpoints you can use the API endpoint rules set bellow.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_group": schema.StringAttribute{
									MarkdownDescription: "API groups derived from API Definition swaggers. For example oas-all-operations including all paths and methods from the swaggers, oas-base-URLs covering all requests under base-paths from the swaggers. Custom groups can be created if user tags paths or operations with 'x-F5 Distributed..",
									Optional:            true,
								},
								"base_path": schema.StringAttribute{
									MarkdownDescription: "Prefix of the request path.",
									Optional:            true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "The rule will apply for a specific domain.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional:            true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional:            true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "[Enum: SECOND|MINUTE|HOUR] Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive cookie name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"api_specification": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_specification, disable_api_definition; Default: disable_api_definition] Settings for API specification (API definition, OpenAPI validation, etc.).",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_definition": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"validation_all_spec_endpoints": schema.SingleNestedBlock{
						MarkdownDescription: "API Inventory. Settings for API Inventory validation.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. Swagger) or doesn't have a specific rule in custom rules).",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List. .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "The API group which this validation applies to.",
															Optional:            true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "The base path which this validation applies to.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines API endpoint.",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched .",
																	Optional:            true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional:            true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Custom settings for query parameters validation.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"validation_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. Swagger).",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"response_validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response.",
										Attributes: map[string]schema.Attribute{
											"response_validation_properties": schema.ListAttribute{
												MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the response to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"skip_response_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request.",
										Attributes: map[string]schema.Attribute{
											"request_validation_properties": schema.ListAttribute{
												MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the request to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
								},
							},
						},
					},
					"validation_custom_list": schema.SingleNestedBlock{
						MarkdownDescription: "Define API groups, base paths, or API endpoints and their OpenAPI validation modes. Any other API-endpoint not listed will act according to 'Fall Through Mode'.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. Swagger) or doesn't have a specific rule in custom rules).",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List. .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "The API group which this validation applies to.",
															Optional:            true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "The base path which this validation applies to.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines API endpoint.",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched .",
																	Optional:            true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional:            true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"open_api_validation_rules": schema.ListNestedBlock{
								MarkdownDescription: "Validation List. .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"api_group": schema.StringAttribute{
											MarkdownDescription: "The API group which this validation applies to.",
											Optional:            true,
										},
										"base_path": schema.StringAttribute{
											MarkdownDescription: "The base path which this validation applies to.",
											Optional:            true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "The rule will apply for a specific domain.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines API endpoint.",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched .",
													Optional:            true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"validation_mode": schema.SingleNestedBlock{
											MarkdownDescription: "Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. Swagger).",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"response_validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response.",
													Attributes: map[string]schema.Attribute{
														"response_validation_properties": schema.ListAttribute{
															MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the response to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"skip_response_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"skip_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request.",
													Attributes: map[string]schema.Attribute{
														"request_validation_properties": schema.ListAttribute{
															MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the request to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Custom settings for query parameters validation.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
						},
					},
					"validation_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"app_firewall": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: app_firewall, disable_waf; Default: disable_waf] Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"blocked_clients": schema.ListNestedBlock{
				MarkdownDescription: "Define rules to block IP Prefixes or AS numbers.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "[Enum: SKIP_PROCESSING_WAF|SKIP_PROCESSING_BOT|SKIP_PROCESSING_MUM|SKIP_PROCESSING_IP_REPUTATION|SKIP_PROCESSING_API_PROTECTION|SKIP_PROCESSING_OAS_VALIDATION|SKIP_PROCESSING_DDOS_PROTECTION|SKIP_PROCESSING_THREAT_MESH|SKIP_PROCESSING_MALWARE_PROTECTION] Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "RFC 6793 defined 4-byte AS number.",
							Optional:            true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional:            true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 prefix string.",
							Optional:            true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 prefix string.",
							Optional:            true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "List of HTTP header name and value pairs .",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"bot_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Defines various configuration OPTIONS for Bot Defense Policy.",
				Attributes: map[string]schema.Attribute{
					"regional_endpoint": schema.StringAttribute{
						MarkdownDescription: "[Enum: AUTO|US|EU|ASIA] Defines a selection for Bot Defense region - AUTO: AUTO Automatic selection based on client IP address - US: US US region - EU: EU European Union region - ASIA: ASIA Asia region. Possible values are `AUTO`, `US`, `EU`, `ASIA`. Defaults to `AUTO`.",
						Optional:            true,
					},
					"timeout": schema.Int64Attribute{
						MarkdownDescription: "The timeout for the inference check, in milliseconds.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various configuration OPTIONS for Bot Defense policy.",
						Attributes: map[string]schema.Attribute{
							"javascript_mode": schema.StringAttribute{
								MarkdownDescription: "[Enum: ASYNC_JS_NO_CACHING|ASYNC_JS_CACHING|SYNC_JS_NO_CACHING|SYNC_JS_CACHING] Web Client JavaScript Mode. Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable Bot Defense JavaScript for telemetry collection is requested.. Possible values are `ASYNC_JS_NO_CACHING`, `ASYNC_JS_CACHING`, `SYNC_JS_NO_CACHING`, `SYNC_JS_CACHING`. Defaults to `ASYNC_JS_NO_CACHING`.",
								Optional:            true,
							},
							"js_download_path": schema.StringAttribute{
								MarkdownDescription: "Customize Bot Defense Client JavaScript path. If not specified, default",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_mobile_sdk": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Bot Defense JavaScript in all pages.",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional:            true,
									},
								},
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Bot Defense JavaScript in all pages with the exceptions.",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "Defines custom JavaScript insertion rules for Bot Defense Policy.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "Required list of pages to insert Bot Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"javascript_location": schema.StringAttribute{
													MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"mobile_sdk_config": schema.SingleNestedBlock{
								MarkdownDescription: "Mobile SDK Configuration. Mobile SDK configuration.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"mobile_identifier": schema.SingleNestedBlock{
										MarkdownDescription: "Mobile Traffic Identifier. Mobile traffic identifier type.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"headers": schema.ListNestedBlock{
												MarkdownDescription: "Headers that can be used to identify mobile traffic.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Case-insensitive HTTP header name.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"check_not_present": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"check_present": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"item": schema.SingleNestedBlock{
															MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
															Attributes: map[string]schema.Attribute{
																"exact_values": schema.ListAttribute{
																	MarkdownDescription: "List of exact values to match the input against.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"regex_values": schema.ListAttribute{
																	MarkdownDescription: "List of regular expressions to match the input against.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"transformers": schema.ListAttribute{
																	MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"protected_app_endpoints": schema.ListNestedBlock{
								MarkdownDescription: "List of protected endpoints. Limit: Approx '128 endpoints per Load Balancer (LB)' upto 4 LBs, '32 endpoints per LB' after 4 LBs.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"http_methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: METHOD_ANY|METHOD_GET|METHOD_POST|METHOD_PUT|METHOD_PATCH|METHOD_DELETE|METHOD_GET_DOCUMENT] HTTP Methods. List of HTTP methods. Possible values are `METHOD_ANY`, `METHOD_GET`, `METHOD_POST`, `METHOD_PUT`, `METHOD_PATCH`, `METHOD_DELETE`, `METHOD_GET_DOCUMENT`. Defaults to `METHOD_ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"protocol": schema.StringAttribute{
											MarkdownDescription: "[Enum: BOTH|HTTP|HTTPS] SchemeType is used to indicate URL scheme. - BOTH: BOTH URL scheme for HTTPS:// or HTTP://. - HTTP: HTTP URL scheme HTTP:// only. - HTTPS: HTTPS URL scheme HTTPS:// only. Possible values are `BOTH`, `HTTP`, `HTTPS`. Defaults to `BOTH`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"allow_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
										"flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Defense Flow Label Category allows to associate traffic with selected category.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"account_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Account Management Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"password_reset": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"authentication": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Authentication Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"login": schema.SingleNestedBlock{
															MarkdownDescription: "Bot Defense Transaction Result. Bot Defense Transaction Result.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"disable_transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Enable this option",
																},
																"transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Bot Defense Transaction Result Type. Bot Defense Transaction ResultType.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"failure_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Failure Conditions. Failure Conditions.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional:            true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "List of regular expressions to match the input against.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status.. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional:            true,
																					},
																				},
																			},
																		},
																		"success_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Success Conditions. Success Conditions.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional:            true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "List of regular expressions to match the input against.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status.. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional:            true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"login_mfa": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"login_partner": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"logout": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"token_refresh": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"financial_services": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Financial Services Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"apply": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"money_transfer": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"flight": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Flight Category. Bot Defense Flow Label Flight Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"checkin": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"profile_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Profile Management Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"update": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"view": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"search": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Search Category. Bot Defense Flow Label Search Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"flight_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"product_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"reservation_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"room_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"shopping_gift_cards": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Shopping & Gift Cards Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"gift_card_make_purchase_with_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"gift_card_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_add_to_cart": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_checkout": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_choose_seat": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_enter_drawing_submission": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_make_payment": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_order": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_price_inquiry": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_promo_code_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_purchase_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_update_quantity": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"mitigate_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"mitigation": schema.SingleNestedBlock{
											MarkdownDescription: "Modify Bot Defense behavior for a matching request.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"block": schema.SingleNestedBlock{
													MarkdownDescription: "Block request and respond with custom content.",
													Attributes: map[string]schema.Attribute{
														"body": schema.StringAttribute{
															MarkdownDescription: "Custom body message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
															Optional:            true,
														},
														"status": schema.StringAttribute{
															MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status.. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
															Optional:            true,
														},
													},
												},
												"flag": schema.SingleNestedBlock{
													MarkdownDescription: "Select Flag Bot Mitigation Action. Flag mitigation action.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"append_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Append flag mitigation headers to forwarded request.",
															Attributes: map[string]schema.Attribute{
																"auto_type_header_name": schema.StringAttribute{
																	MarkdownDescription: "Case-insensitive HTTP header name.",
																	Optional:            true,
																},
																"inference_header_name": schema.StringAttribute{
																	MarkdownDescription: "Case-insensitive HTTP header name.",
																	Optional:            true,
																},
															},
														},
														"no_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"redirect": schema.SingleNestedBlock{
													MarkdownDescription: "Redirect bot mitigation. Redirect request to a custom URI.",
													Attributes: map[string]schema.Attribute{
														"uri": schema.StringAttribute{
															MarkdownDescription: "URI location for redirect may be relative or absolute.",
															Optional:            true,
														},
													},
												},
											},
										},
										"mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact path value to match.",
													Optional:            true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
													Optional:            true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
													Optional:            true,
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"undefined_flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"web": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"web_mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Web and Mobile traffic type. Web and Mobile traffic type.",
											Attributes: map[string]schema.Attribute{
												"mobile_identifier": schema.StringAttribute{
													MarkdownDescription: "[Enum: HEADERS] Mobile identifier type - HEADERS: Headers Headers. The only possible value is `HEADERS`. Defaults to `HEADERS`.",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"captcha_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: captcha_challenge, enable_challenge, js_challenge, no_challenge, policy_based_challenge; Default: no_challenge] Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional:            true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
						Optional:            true,
					},
				},
			},
			"client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: client_side_defense, disable_client_side_defense; Default: disable_client_side_defense] Defines various configuration OPTIONS for Client-Side Defense Policy.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various configuration OPTIONS for Client-Side Defense policy.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Client-Side Defense JavaScript in all pages with the exceptions.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "Defines custom JavaScript insertion rules for Client-Side Defense Policy.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "Required list of pages to insert Client-Side Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"cors_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel MAC OS X 10.5..",
				Attributes: map[string]schema.Attribute{
					"allow_credentials": schema.BoolAttribute{
						MarkdownDescription: "Specifies whether the resource allows credentials.",
						Optional:            true,
					},
					"allow_headers": schema.StringAttribute{
						MarkdownDescription: "Specifies the content for the access-control-allow-headers header.",
						Optional:            true,
					},
					"allow_methods": schema.StringAttribute{
						MarkdownDescription: "Specifies the content for the access-control-allow-methods header.",
						Optional:            true,
					},
					"allow_origin": schema.ListAttribute{
						MarkdownDescription: "Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"allow_origin_regex": schema.ListAttribute{
						MarkdownDescription: "Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"disabled": schema.BoolAttribute{
						MarkdownDescription: "Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
						Optional:            true,
					},
					"expose_headers": schema.StringAttribute{
						MarkdownDescription: "Specifies the content for the access-control-expose-headers header.",
						Optional:            true,
					},
					"maximum_age": schema.Int64Attribute{
						MarkdownDescription: "Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours).",
						Optional:            true,
					},
				},
			},
			"csrf_policy": schema.SingleNestedBlock{
				MarkdownDescription: "To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.the policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to..",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"all_load_balancer_domains": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"custom_domain_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of domain names used for Host header matching.",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "List of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"custom_cache_rule": schema.SingleNestedBlock{
				MarkdownDescription: "Custom Cache Rules. Caching policies for CDN.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"cdn_cache_rules": schema.ListNestedBlock{
						MarkdownDescription: "Reference to CDN Cache Rule configuration object.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"data_guard_rules": schema.ListNestedBlock{
				MarkdownDescription: "Data Guard prevents responses from exposing sensitive information by masking the data. The system masks credit card numbers and social security numbers leaked from the application from within the HTTP response with a string of asterisks (*).",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact domain name.",
							Optional:            true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"apply_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"path": schema.SingleNestedBlock{
							MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
							Attributes: map[string]schema.Attribute{
								"path": schema.StringAttribute{
									MarkdownDescription: "Exact path value to match.",
									Optional:            true,
								},
								"prefix": schema.StringAttribute{
									MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
									Optional:            true,
								},
								"regex": schema.StringAttribute{
									MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
									Optional:            true,
								},
							},
						},
						"skip_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"ddos_mitigation_rules": schema.ListNestedBlock{
				MarkdownDescription: "Define manual mitigation rules to block L7 DDoS attacks.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"block": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ddos_client_source": schema.SingleNestedBlock{
							MarkdownDescription: "DDoS Client Source Choice. DDoS Mitigation sources to be blocked.",
							Attributes: map[string]schema.Attribute{
								"country_list": schema.ListAttribute{
									MarkdownDescription: "[Enum: COUNTRY_NONE|COUNTRY_AD|COUNTRY_AE|COUNTRY_AF|COUNTRY_AG|COUNTRY_AI|COUNTRY_AL|COUNTRY_AM|COUNTRY_AN|COUNTRY_AO|COUNTRY_AQ|COUNTRY_AR|COUNTRY_AS|COUNTRY_AT|COUNTRY_AU|COUNTRY_AW|COUNTRY_AX|COUNTRY_AZ|COUNTRY_BA|COUNTRY_BB|COUNTRY_BD|COUNTRY_BE|COUNTRY_BF|COUNTRY_BG|COUNTRY_BH|COUNTRY_BI|COUNTRY_BJ|COUNTRY_BL|COUNTRY_BM|COUNTRY_BN|COUNTRY_BO|COUNTRY_BQ|COUNTRY_BR|COUNTRY_BS|COUNTRY_BT|COUNTRY_BV|COUNTRY_BW|COUNTRY_BY|COUNTRY_BZ|COUNTRY_CA|COUNTRY_CC|COUNTRY_CD|COUNTRY_CF|COUNTRY_CG|COUNTRY_CH|COUNTRY_CI|COUNTRY_CK|COUNTRY_CL|COUNTRY_CM|COUNTRY_CN|COUNTRY_CO|COUNTRY_CR|COUNTRY_CS|COUNTRY_CU|COUNTRY_CV|COUNTRY_CW|COUNTRY_CX|COUNTRY_CY|COUNTRY_CZ|COUNTRY_DE|COUNTRY_DJ|COUNTRY_DK|COUNTRY_DM|COUNTRY_DO|COUNTRY_DZ|COUNTRY_EC|COUNTRY_EE|COUNTRY_EG|COUNTRY_EH|COUNTRY_ER|COUNTRY_ES|COUNTRY_ET|COUNTRY_FI|COUNTRY_FJ|COUNTRY_FK|COUNTRY_FM|COUNTRY_FO|COUNTRY_FR|COUNTRY_GA|COUNTRY_GB|COUNTRY_GD|COUNTRY_GE|COUNTRY_GF|COUNTRY_GG|COUNTRY_GH|COUNTRY_GI|COUNTRY_GL|COUNTRY_GM|COUNTRY_GN|COUNTRY_GP|COUNTRY_GQ|COUNTRY_GR|COUNTRY_GS|COUNTRY_GT|COUNTRY_GU|COUNTRY_GW|COUNTRY_GY|COUNTRY_HK|COUNTRY_HM|COUNTRY_HN|COUNTRY_HR|COUNTRY_HT|COUNTRY_HU|COUNTRY_ID|COUNTRY_IE|COUNTRY_IL|COUNTRY_IM|COUNTRY_IN|COUNTRY_IO|COUNTRY_IQ|COUNTRY_IR|COUNTRY_IS|COUNTRY_IT|COUNTRY_JE|COUNTRY_JM|COUNTRY_JO|COUNTRY_JP|COUNTRY_KE|COUNTRY_KG|COUNTRY_KH|COUNTRY_KI|COUNTRY_KM|COUNTRY_KN|COUNTRY_KP|COUNTRY_KR|COUNTRY_KW|COUNTRY_KY|COUNTRY_KZ|COUNTRY_LA|COUNTRY_LB|COUNTRY_LC|COUNTRY_LI|COUNTRY_LK|COUNTRY_LR|COUNTRY_LS|COUNTRY_LT|COUNTRY_LU|COUNTRY_LV|COUNTRY_LY|COUNTRY_MA|COUNTRY_MC|COUNTRY_MD|COUNTRY_ME|COUNTRY_MF|COUNTRY_MG|COUNTRY_MH|COUNTRY_MK|COUNTRY_ML|COUNTRY_MM|COUNTRY_MN|COUNTRY_MO|COUNTRY_MP|COUNTRY_MQ|COUNTRY_MR|COUNTRY_MS|COUNTRY_MT|COUNTRY_MU|COUNTRY_MV|COUNTRY_MW|COUNTRY_MX|COUNTRY_MY|COUNTRY_MZ|COUNTRY_NA|COUNTRY_NC|COUNTRY_NE|COUNTRY_NF|COUNTRY_NG|COUNTRY_NI|COUNTRY_NL|COUNTRY_NO|COUNTRY_NP|COUNTRY_NR|COUNTRY_NU|COUNTRY_NZ|COUNTRY_OM|COUNTRY_PA|COUNTRY_PE|COUNTRY_PF|COUNTRY_PG|COUNTRY_PH|COUNTRY_PK|COUNTRY_PL|COUNTRY_PM|COUNTRY_PN|COUNTRY_PR|COUNTRY_PS|COUNTRY_PT|COUNTRY_PW|COUNTRY_PY|COUNTRY_QA|COUNTRY_RE|COUNTRY_RO|COUNTRY_RS|COUNTRY_RU|COUNTRY_RW|COUNTRY_SA|COUNTRY_SB|COUNTRY_SC|COUNTRY_SD|COUNTRY_SE|COUNTRY_SG|COUNTRY_SH|COUNTRY_SI|COUNTRY_SJ|COUNTRY_SK|COUNTRY_SL|COUNTRY_SM|COUNTRY_SN|COUNTRY_SO|COUNTRY_SR|COUNTRY_SS|COUNTRY_ST|COUNTRY_SV|COUNTRY_SX|COUNTRY_SY|COUNTRY_SZ|COUNTRY_TC|COUNTRY_TD|COUNTRY_TF|COUNTRY_TG|COUNTRY_TH|COUNTRY_TJ|COUNTRY_TK|COUNTRY_TL|COUNTRY_TM|COUNTRY_TN|COUNTRY_TO|COUNTRY_TR|COUNTRY_TT|COUNTRY_TV|COUNTRY_TW|COUNTRY_TZ|COUNTRY_UA|COUNTRY_UG|COUNTRY_UM|COUNTRY_US|COUNTRY_UY|COUNTRY_UZ|COUNTRY_VA|COUNTRY_VC|COUNTRY_VE|COUNTRY_VG|COUNTRY_VI|COUNTRY_VN|COUNTRY_VU|COUNTRY_WF|COUNTRY_WS|COUNTRY_XK|COUNTRY_XT|COUNTRY_YE|COUNTRY_YT|COUNTRY_ZA|COUNTRY_ZM|COUNTRY_ZW] Sources that are located in one of the countries in the given list. Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
									Optional:            true,
									ElementType:         types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional:            true,
											ElementType:         types.Int64Type,
										},
									},
								},
								"ja4_tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Extended version of JA3 that includes additional fields for more comprehensive fingerprinting of SSL/TLS clients and potentially has a different structure and length.",
									Attributes: map[string]schema.Attribute{
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "List of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
									Attributes: map[string]schema.Attribute{
										"classes": schema.ListAttribute{
											MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"excluded_values": schema.ListAttribute{
											MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
							},
						},
						"ip_prefix_list": schema.SingleNestedBlock{
							MarkdownDescription: "List of IP Prefix strings to match against.",
							Attributes: map[string]schema.Attribute{
								"invert_match": schema.BoolAttribute{
									MarkdownDescription: "Invert Match Result. Invert the match result.",
									Optional:            true,
								},
								"ip_prefixes": schema.ListAttribute{
									MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
									Optional:            true,
									ElementType:         types.StringType,
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
					},
				},
			},
			"default_cache_action": schema.SingleNestedBlock{
				MarkdownDescription: "Default Cache Behaviour. This defines a Default Cache Action.",
				Attributes: map[string]schema.Attribute{
					"cache_ttl_default": schema.StringAttribute{
						MarkdownDescription: "Use Cache TTL Provided by Origin, and set a contigency TTL value in case one is not provided.",
						Optional:            true,
					},
					"cache_ttl_override": schema.StringAttribute{
						MarkdownDescription: "Always override the Cahce TTL provided by Origin.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"cache_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"default_sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_sensitive_data_policy, sensitive_data_policy; Default: default_sensitive_data_policy] Enable this option",
			},
			"disable_api_definition": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_api_discovery, enable_api_discovery; Default: disable_api_discovery] Enable this option",
			},
			"disable_client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ip_reputation, enable_ip_reputation; Default: disable_ip_reputation] Enable this option",
			},
			"disable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_malicious_user_detection, enable_malicious_user_detection; Default: disable_malicious_user_detection] Enable this option",
			},
			"disable_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_threat_mesh, enable_threat_mesh; Default: disable_threat_mesh] Enable this option",
			},
			"disable_waf": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"enable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "Specifies the settings used for API discovery.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_crawler": schema.SingleNestedBlock{
						MarkdownDescription: "API Crawling. API Crawler message.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"api_crawler_config": schema.SingleNestedBlock{
								MarkdownDescription: "Crawler Configure.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"domains": schema.ListNestedBlock{
										MarkdownDescription: "Enter domains and their credentials to allow authenticated API crawling. You can only include domains you own that are associated with this Load Balancer.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"domain": schema.StringAttribute{
													MarkdownDescription: "Select the domain to execute API Crawling with given credentials.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"simple_login": schema.SingleNestedBlock{
													MarkdownDescription: "Simple Login.",
													Attributes: map[string]schema.Attribute{
														"user": schema.StringAttribute{
															MarkdownDescription: "Enter the username to assign credentials for the selected domain to crawl.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"password": schema.SingleNestedBlock{
															MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional:            true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																			Optional:            true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"disable_api_crawler": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"api_discovery_from_code_scan": schema.SingleNestedBlock{
						MarkdownDescription: "Select Code Base and Repositories.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"code_base_integrations": schema.ListNestedBlock{
								MarkdownDescription: "Select Code Base Integrations. .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"all_repos": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"code_base_integration": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"selected_repos": schema.SingleNestedBlock{
											MarkdownDescription: "Select which API repositories represent the LB applications.",
											Attributes: map[string]schema.Attribute{
												"api_code_repo": schema.ListAttribute{
													MarkdownDescription: "Code repository which contain API endpoints .",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "API Discovery Advanced Settings. API Discovery Advanced settings.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"api_discovery_ref": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
						},
					},
					"default_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"discovered_api_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Discovered API Settings. Configure Discovered API Settings.",
						Attributes: map[string]schema.Attribute{
							"purge_duration_for_inactive_discovered_apis": schema.Int64Attribute{
								MarkdownDescription: "Inactive discovered API will be deleted after configured duration.",
								Optional:            true,
							},
						},
					},
					"enable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"enable_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Configure auto mitigation i.e risk based challenges for malicious users.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
								Optional:            true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"enable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "IP Threat Category List. List of IP threat categories.",
				Attributes: map[string]schema.Attribute{
					"ip_threat_categories": schema.ListAttribute{
						MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] If the source IP matches on atleast one of the enabled IP threat categories, the request will be denied. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
			},
			"enable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"enable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"graphql_rules": schema.ListNestedBlock{
				MarkdownDescription: "GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it easier to evolve APIs over time, and enables powerful developer tools. Policy..",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_path": schema.StringAttribute{
							MarkdownDescription: "Specifies the exact path to GraphQL endpoint. Defaults to `/graphql`.",
							Optional:            true,
						},
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact domain name.",
							Optional:            true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"graphql_settings": schema.SingleNestedBlock{
							MarkdownDescription: "GraphQL Settings. GraphQL configuration.",
							Attributes: map[string]schema.Attribute{
								"max_batched_queries": schema.Int64Attribute{
									MarkdownDescription: "Specify maximum number of queries in a single batched request.",
									Optional:            true,
								},
								"max_depth": schema.Int64Attribute{
									MarkdownDescription: "Specify maximum depth for the GraphQL query.",
									Optional:            true,
								},
								"max_total_length": schema.Int64Attribute{
									MarkdownDescription: "Specify maximum length in bytes for the GraphQL query.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"disable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"enable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"method_get": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"method_post": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"http": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: http, https, https_auto_cert; Default: https_auto_cert] HTTP Choice. Choice for selecting HTTP proxy.",
				Attributes: map[string]schema.Attribute{
					"dns_volterra_managed": schema.BoolAttribute{
						MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
						Optional:            true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTP port to Listen.",
						Optional:            true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional:            true,
					},
				},
			},
			"https": schema.SingleNestedBlock{
				MarkdownDescription: "Choice for selecting CDN Distribution with bring your own certificates.",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
						Optional:            true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"tls_cert_options": schema.SingleNestedBlock{
						MarkdownDescription: "TLS OPTIONS. TLS Certificate OPTIONS.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"tls_cert_params": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"certificates": schema.ListNestedBlock{
										MarkdownDescription: "Select one or more certificates with any domain names.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
									"no_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"tls_config": schema.SingleNestedBlock{
										MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"custom_security": schema.SingleNestedBlock{
												MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
												Attributes: map[string]schema.Attribute{
													"cipher_suites": schema.ListAttribute{
														MarkdownDescription: "The TLS listener will only support the specified cipher list.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"max_version": schema.StringAttribute{
														MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional:            true,
													},
													"min_version": schema.StringAttribute{
														MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional:            true,
													},
												},
											},
											"default_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"low_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"medium_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"use_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Validation context for downstream client TLS connections.",
										Attributes: map[string]schema.Attribute{
											"client_certificate_optional": schema.BoolAttribute{
												MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
												Optional:            true,
											},
											"trusted_ca_url": schema.StringAttribute{
												MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"crl": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"no_crl": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"trusted_ca": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"xfcc_disabled": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"xfcc_options": schema.SingleNestedBlock{
												MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
												Attributes: map[string]schema.Attribute{
													"xfcc_header_elements": schema.ListAttribute{
														MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
											},
										},
									},
								},
							},
							"tls_inline_params": schema.SingleNestedBlock{
								MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"no_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional:            true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies the hash algorithms to be used.",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
									},
									"tls_config": schema.SingleNestedBlock{
										MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"custom_security": schema.SingleNestedBlock{
												MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
												Attributes: map[string]schema.Attribute{
													"cipher_suites": schema.ListAttribute{
														MarkdownDescription: "The TLS listener will only support the specified cipher list.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"max_version": schema.StringAttribute{
														MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional:            true,
													},
													"min_version": schema.StringAttribute{
														MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional:            true,
													},
												},
											},
											"default_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"low_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"medium_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"use_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Validation context for downstream client TLS connections.",
										Attributes: map[string]schema.Attribute{
											"client_certificate_optional": schema.BoolAttribute{
												MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
												Optional:            true,
											},
											"trusted_ca_url": schema.StringAttribute{
												MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"crl": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"no_crl": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"trusted_ca": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"xfcc_disabled": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"xfcc_options": schema.SingleNestedBlock{
												MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
												Attributes: map[string]schema.Attribute{
													"xfcc_header_elements": schema.ListAttribute{
														MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"https_auto_cert": schema.SingleNestedBlock{
				MarkdownDescription: "Choice for selecting HTTPS CDN distribution with bring your own certificates.",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
						Optional:            true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"tls_11_plus": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_12_plus": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional:            true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
						Optional:            true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
						Optional:            true,
					},
				},
			},
			"jwt_validation": schema.SingleNestedBlock{
				MarkdownDescription: "JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming JWTs before they are passed to your API origin. JWT Validation will also stop requests with expired tokens or tokens that are not yet valid.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"action": schema.SingleNestedBlock{
						MarkdownDescription: "Action",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"block": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"report": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"jwks_config": schema.SingleNestedBlock{
						MarkdownDescription: "The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
						Attributes: map[string]schema.Attribute{
							"cleartext": schema.StringAttribute{
								MarkdownDescription: "The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
								Optional:            true,
							},
						},
					},
					"mandatory_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Configurable Validation of mandatory Claims.",
						Attributes: map[string]schema.Attribute{
							"claim_names": schema.ListAttribute{
								MarkdownDescription: "Claim Names. Human-readable name for the resource",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"reserved_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Configurable Validation of reserved Claims.",
						Attributes: map[string]schema.Attribute{
							"issuer": schema.StringAttribute{
								MarkdownDescription: "Exact Match.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"audience": schema.SingleNestedBlock{
								MarkdownDescription: "Audiences",
								Attributes: map[string]schema.Attribute{
									"audiences": schema.ListAttribute{
										MarkdownDescription: "Values.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"audience_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"issuer_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"validate_period_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"validate_period_enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"target": schema.SingleNestedBlock{
						MarkdownDescription: "Define endpoints for which JWT token validation will be performed.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"all_endpoint": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"api_groups": schema.SingleNestedBlock{
								MarkdownDescription: "API Groups.",
								Attributes: map[string]schema.Attribute{
									"api_groups": schema.ListAttribute{
										MarkdownDescription: "API Groups. .",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"base_paths": schema.SingleNestedBlock{
								MarkdownDescription: "Base Paths.",
								Attributes: map[string]schema.Attribute{
									"base_paths": schema.ListAttribute{
										MarkdownDescription: "Prefix Values. .",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
					"token_location": schema.SingleNestedBlock{
						MarkdownDescription: "Token Location. Location of JWT in HTTP request.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"bearer_token": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"l7_ddos_action_block": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: l7_ddos_action_block, l7_ddos_action_default, l7_ddos_action_js_challenge; Default: l7_ddos_action_default] Enable this option",
			},
			"l7_ddos_action_default": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"l7_ddos_action_js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional:            true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
						Optional:            true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
						Optional:            true,
					},
				},
			},
			"no_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"origin_pool": schema.SingleNestedBlock{
				MarkdownDescription: "CDN Origin Pool. Origin Pool for the CDN distribution.",
				Attributes: map[string]schema.Attribute{
					"origin_request_timeout": schema.StringAttribute{
						MarkdownDescription: "Configures the time after which a request to the origin will time out waiting for a response.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"more_origin_options": schema.SingleNestedBlock{
						MarkdownDescription: "Origin Byte Range Request Config.",
						Attributes: map[string]schema.Attribute{
							"enable_byte_range_request": schema.BoolAttribute{
								MarkdownDescription: "Choice to enable/disable byte range requests towards origin.",
								Optional:            true,
							},
							"websocket_proxy": schema.BoolAttribute{
								MarkdownDescription: "Option to enable proxying of websocket connections to the origin server.",
								Optional:            true,
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"origin_servers": schema.ListNestedBlock{
						MarkdownDescription: "List Of Origin Servers. List of original servers .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Origin Server Port. Port the workload can be reached on.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"public_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with public IP address.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Public IPv4. Public IPv4 address.",
											Optional:            true,
										},
									},
								},
								"public_name": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with public DNS name.",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name .",
											Optional:            true,
										},
										"refresh_interval": schema.Int64Attribute{
											MarkdownDescription: "Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/HTML/rfc8767.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
					"public_name": schema.SingleNestedBlock{
						MarkdownDescription: "Specify origin server with public DNS name.",
						Attributes: map[string]schema.Attribute{
							"dns_name": schema.StringAttribute{
								MarkdownDescription: "DNS Name. DNS Name .",
								Optional:            true,
							},
							"refresh_interval": schema.Int64Attribute{
								MarkdownDescription: "Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/HTML/rfc8767.",
								Optional:            true,
							},
						},
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters for Origin Servers. Upstream TLS Parameters.",
						Attributes: map[string]schema.Attribute{
							"max_session_keys": schema.Int64Attribute{
								MarkdownDescription: "Number of session keys that are cached.",
								Optional:            true,
							},
							"sni": schema.StringAttribute{
								MarkdownDescription: "SNI value to be used.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"default_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"skip_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_host_header_as_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "MTLS Certificate. MTLS Client Certificate.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "MTLS Client Certificate. MTLS Client Certificate .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional:            true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies the hash algorithms to be used.",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
									},
								},
							},
							"use_mtls_obj": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"use_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Validation Context for Origin Servers. Upstream TLS Validation Context.",
								Attributes: map[string]schema.Attribute{
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Origin Pool for verification of server's certificate.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
								},
							},
							"volterra_trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"other_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Other Settings. Other Settings.",
				Attributes: map[string]schema.Attribute{
					"add_location": schema.BoolAttribute{
						MarkdownDescription: "Add Location. X-example: true Appends header x-F5 Distributed Cloud-location = <RE-site-name> in responses.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"header_options": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS related to request/response headers.",
						Attributes: map[string]schema.Attribute{
							"request_headers_to_remove": schema.ListAttribute{
								MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"response_headers_to_remove": schema.ListAttribute{
								MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
						Blocks: map[string]schema.Block{
							"request_headers_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"append": schema.BoolAttribute{
											MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. Name of the HTTP header.",
											Optional:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value of the HTTP header.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"response_headers_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"append": schema.BoolAttribute{
											MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. Name of the HTTP header.",
											Optional:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value of the HTTP header.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"logging_options": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS related to logging.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"client_log_options": schema.SingleNestedBlock{
								MarkdownDescription: "Headers to Log. List of headers to Log.",
								Attributes: map[string]schema.Attribute{
									"header_list": schema.ListAttribute{
										MarkdownDescription: "Headers. List of headers.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"origin_log_options": schema.SingleNestedBlock{
								MarkdownDescription: "Headers to Log. List of headers to Log.",
								Attributes: map[string]schema.Attribute{
									"header_list": schema.ListAttribute{
										MarkdownDescription: "Headers. List of headers.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
				},
			},
			"policy_based_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Specifies the settings for policy rule based challenge.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"always_enable_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"always_enable_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_temporary_blocking_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
								Optional:            true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"no_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"rule_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of challenge rules to be used in policy based challenge.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Rules that specify the match conditions and challenge type to be launched. When a challenge type is selected to be always enabled, these rules can be used to disable challenge or launch a different challenge for requests that match the specified conditions.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"spec": schema.SingleNestedBlock{
											MarkdownDescription: "Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from or derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that..",
											Attributes: map[string]schema.Attribute{
												"expiration_timestamp": schema.StringAttribute{
													MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_asn": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"arg_matchers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive JSON path in the HTTP request body.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional:            true,
															ElementType:         types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"body_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact values to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive cookie name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"disable_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact values to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"enable_captcha_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"enable_javascript_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-insensitive HTTP header name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"http_method": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Method Matcher. Invert the match result.",
															Optional:            true,
														},
														"methods": schema.ListAttribute{
															MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional:            true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact path values to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Path Matcher. Invert the match result.",
															Optional:            true,
														},
														"prefix_values": schema.ListAttribute{
															MarkdownDescription: "List of path prefix values to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"suffix_values": schema.ListAttribute{
															MarkdownDescription: "List of path suffix values to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional:            true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive HTTP query parameter name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"temporary_user_blocking": schema.SingleNestedBlock{
						MarkdownDescription: "Specifies configuration for temporary user blocking resulting from user behavior analysis. When Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for malicious activity and the configured mitigation actions will be taken on..",
						Attributes: map[string]schema.Attribute{
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type . Currently supported URL schemes is . For scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Blocked.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Blocked..",
								Optional:            true,
							},
						},
					},
				},
			},
			"protected_cookies": schema.ListNestedBlock{
				MarkdownDescription: "Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses. Cookie Tampering Protection prevents attackers from modifying the value of session cookies. For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"max_age_value": schema.Int64Attribute{
							MarkdownDescription: "Add max age attribute.",
							Optional:            true,
						},
						"name": schema.StringAttribute{
							MarkdownDescription: "Cookie Name. Name of the Cookie .",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"add_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"add_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"disable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"enable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_max_age": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_samesite": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"samesite_lax": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"samesite_none": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"samesite_strict": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "RateLimitConfigType.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IP Allowed list using existing ip_prefix_set objects.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of rate limiter policies to be applied.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered list of rate limiter policies.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"rate_limiter": schema.SingleNestedBlock{
						MarkdownDescription: "Tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
						Attributes: map[string]schema.Attribute{
							"burst_multiplier": schema.Int64Attribute{
								MarkdownDescription: "The maximum burst of requests to accommodate, expressed as a multiple of the rate.",
								Optional:            true,
							},
							"period_multiplier": schema.Int64Attribute{
								MarkdownDescription: "Setting, combined with Per Period units, provides a duration.",
								Optional:            true,
							},
							"total_number": schema.Int64Attribute{
								MarkdownDescription: "The total number of allowed requests per rate-limiting period.",
								Optional:            true,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: "[Enum: SECOND|MINUTE|HOUR] Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"action_block": schema.SingleNestedBlock{
								MarkdownDescription: "Action where a user is blocked from making further requests after exceeding rate limit threshold.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"hours": schema.SingleNestedBlock{
										MarkdownDescription: "Hours. Input Duration Hours.",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration. Configuration parameter for duration",
												Optional:            true,
											},
										},
									},
									"minutes": schema.SingleNestedBlock{
										MarkdownDescription: "Minutes. Input Duration Minutes.",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration. Configuration parameter for duration",
												Optional:            true,
											},
										},
									},
									"seconds": schema.SingleNestedBlock{
										MarkdownDescription: "Seconds. Input Duration Seconds.",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration. Configuration parameter for duration",
												Optional:            true,
											},
										},
									},
								},
							},
							"disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"leaky_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Leaky-Bucket is the default rate limiter algorithm for F5.",
							},
							"token_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Token-Bucket is a rate limiter algorithm that is stricter with enforcing limits.",
							},
						},
					},
				},
			},
			"sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Sensitive Data Discovery. Settings for data type policy.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"sensitive_data_policy_ref": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"service_policies_from_namespace": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"slow_ddos_mitigation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: slow_ddos_mitigation, system_default_timeouts; Default: system_default_timeouts] 'Slow and low' attacks tie up server resources, leaving none available for servicing requests from actual users.",
				Attributes: map[string]schema.Attribute{
					"request_headers_timeout": schema.Int64Attribute{
						MarkdownDescription: "The amount of time the client has to send only the headers on the request stream before the stream is cancelled. The  milliseconds. This setting provides protection against Slowloris attacks. Defaults to `10000`.",
						Optional:            true,
					},
					"request_timeout": schema.Int64Attribute{
						MarkdownDescription: ".",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_request_timeout": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"system_default_timeouts": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"trusted_clients": schema.ListNestedBlock{
				MarkdownDescription: "Define rules to skip processing of one or more features such as WAF, Bot Defense etc.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "[Enum: SKIP_PROCESSING_WAF|SKIP_PROCESSING_BOT|SKIP_PROCESSING_MUM|SKIP_PROCESSING_IP_REPUTATION|SKIP_PROCESSING_API_PROTECTION|SKIP_PROCESSING_OAS_VALIDATION|SKIP_PROCESSING_DDOS_PROTECTION|SKIP_PROCESSING_THREAT_MESH|SKIP_PROCESSING_MALWARE_PROTECTION] Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "RFC 6793 defined 4-byte AS number.",
							Optional:            true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional:            true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 prefix string.",
							Optional:            true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 prefix string.",
							Optional:            true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "List of HTTP header name and value pairs .",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"user_id_client_ip": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: user_id_client_ip, user_identification] Enable this option",
			},
			"user_identification": schema.SingleNestedBlock{
				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"waf_exclusion": schema.SingleNestedBlock{
				MarkdownDescription: "WAF Exclusion.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"waf_exclusion_inline_rules": schema.SingleNestedBlock{
						MarkdownDescription: "List of WAF exclusion rules that will be applied inline.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Ordered list of WAF Exclusions specific to this Load Balancer.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"exact_value": schema.StringAttribute{
											MarkdownDescription: "Exact domain name.",
											Optional:            true,
										},
										"expiration_timestamp": schema.StringAttribute{
											MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
											Optional:            true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"path_prefix": schema.StringAttribute{
											MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths).",
											Optional:            true,
										},
										"path_regex": schema.StringAttribute{
											MarkdownDescription: "Define the regex for the path. For example, the regex ^/.*$ will match on all paths.",
											Optional:            true,
										},
										"suffix_value": schema.StringAttribute{
											MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_path": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"app_firewall_detection_control": schema.SingleNestedBlock{
											MarkdownDescription: "Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"exclude_attack_type_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Attack Types to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "[Enum: CONTEXT_ANY|CONTEXT_BODY|CONTEXT_REQUEST|CONTEXT_RESPONSE|CONTEXT_PARAMETER|CONTEXT_HEADER|CONTEXT_COOKIE|CONTEXT_URL|CONTEXT_URI] The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE.. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional:            true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional:            true,
															},
															"exclude_attack_type": schema.StringAttribute{
																MarkdownDescription: "[Enum: ATTACK_TYPE_NONE|ATTACK_TYPE_NON_BROWSER_CLIENT|ATTACK_TYPE_OTHER_APPLICATION_ATTACKS|ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE|ATTACK_TYPE_DETECTION_EVASION|ATTACK_TYPE_VULNERABILITY_SCAN|ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY|ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS|ATTACK_TYPE_BUFFER_OVERFLOW|ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION|ATTACK_TYPE_INFORMATION_LEAKAGE|ATTACK_TYPE_DIRECTORY_INDEXING|ATTACK_TYPE_PATH_TRAVERSAL|ATTACK_TYPE_XPATH_INJECTION|ATTACK_TYPE_LDAP_INJECTION|ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION|ATTACK_TYPE_COMMAND_EXECUTION|ATTACK_TYPE_SQL_INJECTION|ATTACK_TYPE_CROSS_SITE_SCRIPTING|ATTACK_TYPE_DENIAL_OF_SERVICE|ATTACK_TYPE_HTTP_PARSER_ATTACK|ATTACK_TYPE_SESSION_HIJACKING|ATTACK_TYPE_HTTP_RESPONSE_SPLITTING|ATTACK_TYPE_FORCEFUL_BROWSING|ATTACK_TYPE_REMOTE_FILE_INCLUDE|ATTACK_TYPE_MALICIOUS_FILE_UPLOAD|ATTACK_TYPE_GRAPHQL_PARSER_ATTACK] List of all Attack Types ATTACK_TYPE_NONE ATTACK_TYPE_NON_BROWSER_CLIENT ATTACK_TYPE_OTHER_APPLICATION_ATTACKS ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE ATTACK_TYPE_DETECTION_EVASION ATTACK_TYPE_VULNERABILITY_SCAN ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS.. Possible values are `ATTACK_TYPE_NONE`, `ATTACK_TYPE_NON_BROWSER_CLIENT`, `ATTACK_TYPE_OTHER_APPLICATION_ATTACKS`, `ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE`, `ATTACK_TYPE_DETECTION_EVASION`, `ATTACK_TYPE_VULNERABILITY_SCAN`, `ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY`, `ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS`, `ATTACK_TYPE_BUFFER_OVERFLOW`, `ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION`, `ATTACK_TYPE_INFORMATION_LEAKAGE`, `ATTACK_TYPE_DIRECTORY_INDEXING`, `ATTACK_TYPE_PATH_TRAVERSAL`, `ATTACK_TYPE_XPATH_INJECTION`, `ATTACK_TYPE_LDAP_INJECTION`, `ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION`, `ATTACK_TYPE_COMMAND_EXECUTION`, `ATTACK_TYPE_SQL_INJECTION`, `ATTACK_TYPE_CROSS_SITE_SCRIPTING`, `ATTACK_TYPE_DENIAL_OF_SERVICE`, `ATTACK_TYPE_HTTP_PARSER_ATTACK`, `ATTACK_TYPE_SESSION_HIJACKING`, `ATTACK_TYPE_HTTP_RESPONSE_SPLITTING`, `ATTACK_TYPE_FORCEFUL_BROWSING`, `ATTACK_TYPE_REMOTE_FILE_INCLUDE`, `ATTACK_TYPE_MALICIOUS_FILE_UPLOAD`, `ATTACK_TYPE_GRAPHQL_PARSER_ATTACK`. Defaults to `ATTACK_TYPE_NONE`.",
																Optional:            true,
															},
														},
													},
												},
												"exclude_bot_name_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Bot Names to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"bot_name": schema.StringAttribute{
																MarkdownDescription: "Bot Name.",
																Optional:            true,
															},
														},
													},
												},
												"exclude_signature_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Signature IDs to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "[Enum: CONTEXT_ANY|CONTEXT_BODY|CONTEXT_REQUEST|CONTEXT_RESPONSE|CONTEXT_PARAMETER|CONTEXT_HEADER|CONTEXT_COOKIE|CONTEXT_URL|CONTEXT_URI] The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE.. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional:            true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional:            true,
															},
															"signature_id": schema.Int64Attribute{
																MarkdownDescription: "The allowed values for signature ID are 0 and in the range of 200000001-299999999. 0 implies that all signatures will be excluded for the specified context.",
																Optional:            true,
															},
														},
													},
												},
												"exclude_violation_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Violations to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "[Enum: CONTEXT_ANY|CONTEXT_BODY|CONTEXT_REQUEST|CONTEXT_RESPONSE|CONTEXT_PARAMETER|CONTEXT_HEADER|CONTEXT_COOKIE|CONTEXT_URL|CONTEXT_URI] The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE.. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional:            true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional:            true,
															},
															"exclude_violation": schema.StringAttribute{
																MarkdownDescription: "[Enum: VIOL_NONE|VIOL_FILETYPE|VIOL_METHOD|VIOL_MANDATORY_HEADER|VIOL_HTTP_RESPONSE_STATUS|VIOL_REQUEST_MAX_LENGTH|VIOL_FILE_UPLOAD|VIOL_FILE_UPLOAD_IN_BODY|VIOL_XML_MALFORMED|VIOL_JSON_MALFORMED|VIOL_ASM_COOKIE_MODIFIED|VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS|VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE|VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT|VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST|VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION|VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS|VIOL_EVASION_DIRECTORY_TRAVERSALS|VIOL_MALFORMED_REQUEST|VIOL_EVASION_MULTIPLE_DECODING|VIOL_DATA_GUARD|VIOL_EVASION_APACHE_WHITESPACE|VIOL_COOKIE_MODIFIED|VIOL_EVASION_IIS_UNICODE_CODEPOINTS|VIOL_EVASION_IIS_BACKSLASHES|VIOL_EVASION_PERCENT_U_DECODING|VIOL_EVASION_BARE_BYTE_DECODING|VIOL_EVASION_BAD_UNESCAPE|VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST|VIOL_ENCODING|VIOL_COOKIE_MALFORMED|VIOL_GRAPHQL_FORMAT|VIOL_GRAPHQL_MALFORMED|VIOL_GRAPHQL_INTROSPECTION_QUERY] List of all supported Violation Types VIOL_NONE VIOL_FILETYPE VIOL_METHOD VIOL_MANDATORY_HEADER VIOL_HTTP_RESPONSE_STATUS VIOL_REQUEST_MAX_LENGTH VIOL_FILE_UPLOAD VIOL_FILE_UPLOAD_IN_BODY VIOL_XML_MALFORMED VIOL_JSON_MALFORMED VIOL_ASM_COOKIE_MODIFIED VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS.. Possible values are `VIOL_NONE`, `VIOL_FILETYPE`, `VIOL_METHOD`, `VIOL_MANDATORY_HEADER`, `VIOL_HTTP_RESPONSE_STATUS`, `VIOL_REQUEST_MAX_LENGTH`, `VIOL_FILE_UPLOAD`, `VIOL_FILE_UPLOAD_IN_BODY`, `VIOL_XML_MALFORMED`, `VIOL_JSON_MALFORMED`, `VIOL_ASM_COOKIE_MODIFIED`, `VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS`, `VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE`, `VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT`, `VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST`, `VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION`, `VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS`, `VIOL_EVASION_DIRECTORY_TRAVERSALS`, `VIOL_MALFORMED_REQUEST`, `VIOL_EVASION_MULTIPLE_DECODING`, `VIOL_DATA_GUARD`, `VIOL_EVASION_APACHE_WHITESPACE`, `VIOL_COOKIE_MODIFIED`, `VIOL_EVASION_IIS_UNICODE_CODEPOINTS`, `VIOL_EVASION_IIS_BACKSLASHES`, `VIOL_EVASION_PERCENT_U_DECODING`, `VIOL_EVASION_BARE_BYTE_DECODING`, `VIOL_EVASION_BAD_UNESCAPE`, `VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST`, `VIOL_ENCODING`, `VIOL_COOKIE_MALFORMED`, `VIOL_GRAPHQL_FORMAT`, `VIOL_GRAPHQL_MALFORMED`, `VIOL_GRAPHQL_INTROSPECTION_QUERY`. Defaults to `VIOL_NONE`.",
																Optional:            true,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"waf_skip_processing": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"waf_exclusion_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *CDNLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *CDNLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *CDNLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the cdn_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan CDNLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *CDNLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := CDNLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *CDNLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating cdn_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.CDNLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		createReq.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		createReq.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		createReq.Spec["api_specification"] = api_specificationMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		createReq.Spec["app_firewall"] = app_firewallMap
	}
	if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
		var blocked_clientsItems []CDNLoadBalancerBlockedClientsModel
		diags := data.BlockedClients.ElementsAs(ctx, &blocked_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(blocked_clientsItems) > 0 {
			var blocked_clientsList []map[string]interface{}
			for _, item := range blocked_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				blocked_clientsList = append(blocked_clientsList, itemMap)
			}
			createReq.Spec["blocked_clients"] = blocked_clientsList
		}
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCORSSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCORSSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		createReq.Spec["bot_defense"] = bot_defenseMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		createReq.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		createReq.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CORSPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CORSPolicy.AllowCredentials.IsNull() && !data.CORSPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CORSPolicy.AllowCredentials.ValueBool()
		}
		if !data.CORSPolicy.AllowHeaders.IsNull() && !data.CORSPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CORSPolicy.AllowHeaders.ValueString()
		}
		if !data.CORSPolicy.AllowMethods.IsNull() && !data.CORSPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CORSPolicy.AllowMethods.ValueString()
		}
		if !data.CORSPolicy.AllowOrigin.IsNull() && !data.CORSPolicy.AllowOrigin.IsUnknown() {
			var allow_originItems []string
			diags := data.CORSPolicy.AllowOrigin.ElementsAs(ctx, &allow_originItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin"] = allow_originItems
			}
		}
		if !data.CORSPolicy.AllowOriginRegex.IsNull() && !data.CORSPolicy.AllowOriginRegex.IsUnknown() {
			var allow_origin_regexItems []string
			diags := data.CORSPolicy.AllowOriginRegex.ElementsAs(ctx, &allow_origin_regexItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin_regex"] = allow_origin_regexItems
			}
		}
		if !data.CORSPolicy.Disabled.IsNull() && !data.CORSPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CORSPolicy.Disabled.ValueBool()
		}
		if !data.CORSPolicy.ExposeHeaders.IsNull() && !data.CORSPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CORSPolicy.ExposeHeaders.ValueString()
		}
		if !data.CORSPolicy.MaximumAge.IsNull() && !data.CORSPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CORSPolicy.MaximumAge.ValueInt64()
		}
		createReq.Spec["cors_policy"] = cors_policyMap
	}
	if data.CSRFPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CSRFPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CSRFPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CSRFPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		createReq.Spec["csrf_policy"] = csrf_policyMap
	}
	if data.CustomCacheRule != nil {
		custom_cache_ruleMap := make(map[string]interface{})
		if len(data.CustomCacheRule.CDNCacheRules) > 0 {
			var cdn_cache_rulesList []map[string]interface{}
			for _, listItem := range data.CustomCacheRule.CDNCacheRules {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				cdn_cache_rulesList = append(cdn_cache_rulesList, listItemMap)
			}
			custom_cache_ruleMap["cdn_cache_rules"] = cdn_cache_rulesList
		}
		createReq.Spec["custom_cache_rule"] = custom_cache_ruleMap
	}
	if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
		var data_guard_rulesItems []CDNLoadBalancerDataGuardRulesModel
		diags := data.DataGuardRules.ElementsAs(ctx, &data_guard_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(data_guard_rulesItems) > 0 {
			var data_guard_rulesList []map[string]interface{}
			for _, item := range data_guard_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if item.ApplyDataGuard != nil {
					itemMap["apply_data_guard"] = map[string]interface{}{}
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.Path != nil {
					pathNestedMap := make(map[string]interface{})
					if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
						pathNestedMap["path"] = item.Path.Path.ValueString()
					}
					if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
						pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
					}
					if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
						pathNestedMap["regex"] = item.Path.Regex.ValueString()
					}
					itemMap["path"] = pathNestedMap
				}
				if item.SkipDataGuard != nil {
					itemMap["skip_data_guard"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				data_guard_rulesList = append(data_guard_rulesList, itemMap)
			}
			createReq.Spec["data_guard_rules"] = data_guard_rulesList
		}
	}
	if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
		var ddos_mitigation_rulesItems []CDNLoadBalancerDDOSMitigationRulesModel
		diags := data.DDOSMitigationRules.ElementsAs(ctx, &ddos_mitigation_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(ddos_mitigation_rulesItems) > 0 {
			var ddos_mitigation_rulesList []map[string]interface{}
			for _, item := range ddos_mitigation_rulesItems {
				itemMap := make(map[string]interface{})
				if item.Block != nil {
					itemMap["block"] = map[string]interface{}{}
				}
				if item.DDOSClientSource != nil {
					ddos_client_sourceNestedMap := make(map[string]interface{})
					if item.DDOSClientSource.AsnList != nil {
						asn_listDeepMap := make(map[string]interface{})
						ddos_client_sourceNestedMap["asn_list"] = asn_listDeepMap
					}
					if !item.DDOSClientSource.CountryList.IsNull() && !item.DDOSClientSource.CountryList.IsUnknown() {
						var CountryListItems []string
						diags := item.DDOSClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
						if !diags.HasError() {
							ddos_client_sourceNestedMap["country_list"] = CountryListItems
						}
					}
					if item.DDOSClientSource.Ja4TLSFingerprintMatcher != nil {
						ja4_tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								ja4_tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						ddos_client_sourceNestedMap["ja4_tls_fingerprint_matcher"] = ja4_tls_fingerprint_matcherDeepMap
					}
					if item.DDOSClientSource.TLSFingerprintMatcher != nil {
						tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsUnknown() {
							var ClassesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.Classes.ElementsAs(ctx, &ClassesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["classes"] = ClassesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsUnknown() {
							var ExcludedValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.ElementsAs(ctx, &ExcludedValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["excluded_values"] = ExcludedValuesItems
							}
						}
						ddos_client_sourceNestedMap["tls_fingerprint_matcher"] = tls_fingerprint_matcherDeepMap
					}
					itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.IPPrefixList != nil {
					ip_prefix_listNestedMap := make(map[string]interface{})
					if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
					}
					if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
						var IPPrefixesItems []string
						diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
						if !diags.HasError() {
							ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
						}
					}
					itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
			}
			createReq.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
		}
	}
	if data.DefaultCacheAction != nil {
		default_cache_actionMap := make(map[string]interface{})
		if data.DefaultCacheAction.CacheDisabled != nil {
			default_cache_actionMap["cache_disabled"] = map[string]interface{}{}
		}
		if !data.DefaultCacheAction.CacheTTLDefault.IsNull() && !data.DefaultCacheAction.CacheTTLDefault.IsUnknown() {
			default_cache_actionMap["cache_ttl_default"] = data.DefaultCacheAction.CacheTTLDefault.ValueString()
		}
		if !data.DefaultCacheAction.CacheTTLOverride.IsNull() && !data.DefaultCacheAction.CacheTTLOverride.IsUnknown() {
			default_cache_actionMap["cache_ttl_override"] = data.DefaultCacheAction.CacheTTLOverride.ValueString()
		}
		createReq.Spec["default_cache_action"] = default_cache_actionMap
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		createReq.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		createReq.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		createReq.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		createReq.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		createReq.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		createReq.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		createReq.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		createReq.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		createReq.Spec["disable_waf"] = disable_wafMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			createReq.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		createReq.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		createReq.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		if !data.EnableIPReputation.IPThreatCategories.IsNull() && !data.EnableIPReputation.IPThreatCategories.IsUnknown() {
			var ip_threat_categoriesItems []string
			diags := data.EnableIPReputation.IPThreatCategories.ElementsAs(ctx, &ip_threat_categoriesItems, false)
			if !diags.HasError() {
				enable_ip_reputationMap["ip_threat_categories"] = ip_threat_categoriesItems
			}
		}
		createReq.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		createReq.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		createReq.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
		var graphql_rulesItems []CDNLoadBalancerGraphqlRulesModel
		diags := data.GraphqlRules.ElementsAs(ctx, &graphql_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(graphql_rulesItems) > 0 {
			var graphql_rulesList []map[string]interface{}
			for _, item := range graphql_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
					itemMap["exact_path"] = item.ExactPath.ValueString()
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.GraphqlSettings != nil {
					graphql_settingsNestedMap := make(map[string]interface{})
					if item.GraphqlSettings.DisableIntrospection != nil {
						graphql_settingsNestedMap["disable_introspection"] = map[string]interface{}{}
					}
					if item.GraphqlSettings.EnableIntrospection != nil {
						graphql_settingsNestedMap["enable_introspection"] = map[string]interface{}{}
					}
					if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
						graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
					}
					if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
						graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
					}
					if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
						graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
					}
					itemMap["graphql_settings"] = graphql_settingsNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.MethodGet != nil {
					itemMap["method_get"] = map[string]interface{}{}
				}
				if item.MethodPost != nil {
					itemMap["method_post"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				graphql_rulesList = append(graphql_rulesList, itemMap)
			}
			createReq.Spec["graphql_rules"] = graphql_rulesList
		}
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		createReq.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.TLSCertOptions != nil {
			tls_cert_optionsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_options"] = tls_cert_optionsNestedMap
		}
		createReq.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		createReq.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		createReq.Spec["js_challenge"] = js_challengeMap
	}
	if data.JWTValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JWTValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JWTValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JWTValidation.JwksConfig.Cleartext.IsNull() && !data.JWTValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JWTValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JWTValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JWTValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JWTValidation.ReservedClaims.Issuer.IsNull() && !data.JWTValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JWTValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JWTValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JWTValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		createReq.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DDOSActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		createReq.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DDOSActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		createReq.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DDOSActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DDOSActionJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DDOSActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DDOSActionJsChallenge.CustomPage.IsNull() && !data.L7DDOSActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DDOSActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DDOSActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DDOSActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		createReq.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		createReq.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		createReq.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginPool != nil {
		origin_poolMap := make(map[string]interface{})
		if data.OriginPool.MoreOriginOptions != nil {
			more_origin_optionsNestedMap := make(map[string]interface{})
			if !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsNull() && !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsUnknown() {
				more_origin_optionsNestedMap["enable_byte_range_request"] = data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.ValueBool()
			}
			if !data.OriginPool.MoreOriginOptions.WebSocketProxy.IsNull() && !data.OriginPool.MoreOriginOptions.WebSocketProxy.IsUnknown() {
				more_origin_optionsNestedMap["websocket_proxy"] = data.OriginPool.MoreOriginOptions.WebSocketProxy.ValueBool()
			}
			origin_poolMap["more_origin_options"] = more_origin_optionsNestedMap
		}
		if data.OriginPool.NoTLS != nil {
			origin_poolMap["no_tls"] = map[string]interface{}{}
		}
		if !data.OriginPool.OriginRequestTimeout.IsNull() && !data.OriginPool.OriginRequestTimeout.IsUnknown() {
			origin_poolMap["origin_request_timeout"] = data.OriginPool.OriginRequestTimeout.ValueString()
		}
		if len(data.OriginPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.OriginPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			origin_poolMap["origin_servers"] = origin_serversList
		}
		if data.OriginPool.PublicName != nil {
			public_nameNestedMap := make(map[string]interface{})
			if !data.OriginPool.PublicName.DNSName.IsNull() && !data.OriginPool.PublicName.DNSName.IsUnknown() {
				public_nameNestedMap["dns_name"] = data.OriginPool.PublicName.DNSName.ValueString()
			}
			if !data.OriginPool.PublicName.RefreshInterval.IsNull() && !data.OriginPool.PublicName.RefreshInterval.IsUnknown() {
				public_nameNestedMap["refresh_interval"] = data.OriginPool.PublicName.RefreshInterval.ValueInt64()
			}
			origin_poolMap["public_name"] = public_nameNestedMap
		}
		if data.OriginPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.OriginPool.UseTLS.MaxSessionKeys.IsNull() && !data.OriginPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.OriginPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.OriginPool.UseTLS.Sni.IsNull() && !data.OriginPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.OriginPool.UseTLS.Sni.ValueString()
			}
			origin_poolMap["use_tls"] = use_tlsNestedMap
		}
		createReq.Spec["origin_pool"] = origin_poolMap
	}
	if data.OtherSettings != nil {
		other_settingsMap := make(map[string]interface{})
		if !data.OtherSettings.AddLocation.IsNull() && !data.OtherSettings.AddLocation.IsUnknown() {
			other_settingsMap["add_location"] = data.OtherSettings.AddLocation.ValueBool()
		}
		if data.OtherSettings.HeaderOptions != nil {
			header_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["header_options"] = header_optionsNestedMap
		}
		if data.OtherSettings.LoggingOptions != nil {
			logging_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["logging_options"] = logging_optionsNestedMap
		}
		createReq.Spec["other_settings"] = other_settingsMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		createReq.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
		var protected_cookiesItems []CDNLoadBalancerProtectedCookiesModel
		diags := data.ProtectedCookies.ElementsAs(ctx, &protected_cookiesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(protected_cookiesItems) > 0 {
			var protected_cookiesList []map[string]interface{}
			for _, item := range protected_cookiesItems {
				itemMap := make(map[string]interface{})
				if item.AddHttponly != nil {
					itemMap["add_httponly"] = map[string]interface{}{}
				}
				if item.AddSecure != nil {
					itemMap["add_secure"] = map[string]interface{}{}
				}
				if item.DisableTamperingProtection != nil {
					itemMap["disable_tampering_protection"] = map[string]interface{}{}
				}
				if item.EnableTamperingProtection != nil {
					itemMap["enable_tampering_protection"] = map[string]interface{}{}
				}
				if item.IgnoreHttponly != nil {
					itemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if item.IgnoreMaxAge != nil {
					itemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if item.IgnoreSamesite != nil {
					itemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if item.IgnoreSecure != nil {
					itemMap["ignore_secure"] = map[string]interface{}{}
				}
				if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
					itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
				}
				if !item.Name.IsNull() && !item.Name.IsUnknown() {
					itemMap["name"] = item.Name.ValueString()
				}
				if item.SamesiteLax != nil {
					itemMap["samesite_lax"] = map[string]interface{}{}
				}
				if item.SamesiteNone != nil {
					itemMap["samesite_none"] = map[string]interface{}{}
				}
				if item.SamesiteStrict != nil {
					itemMap["samesite_strict"] = map[string]interface{}{}
				}
				protected_cookiesList = append(protected_cookiesList, itemMap)
			}
			createReq.Spec["protected_cookies"] = protected_cookiesList
		}
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		createReq.Spec["rate_limit"] = rate_limitMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		createReq.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		createReq.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SlowDDOSMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDDOSMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDDOSMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDDOSMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDDOSMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDDOSMitigation.RequestTimeout.IsNull() && !data.SlowDDOSMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDDOSMitigation.RequestTimeout.ValueInt64()
		}
		createReq.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		createReq.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
		var trusted_clientsItems []CDNLoadBalancerTrustedClientsModel
		diags := data.TrustedClients.ElementsAs(ctx, &trusted_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(trusted_clientsItems) > 0 {
			var trusted_clientsList []map[string]interface{}
			for _, item := range trusted_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				trusted_clientsList = append(trusted_clientsList, itemMap)
			}
			createReq.Spec["trusted_clients"] = trusted_clientsList
		}
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		createReq.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		createReq.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		createReq.Spec["waf_exclusion"] = waf_exclusionMap
	}

	apiResource, err := r.client.CreateCDNLoadBalancer(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create CDNLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &CDNLoadBalancerActiveServicePoliciesModel{
			Policies: func() []CDNLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &CDNLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel{}
				}
				return nil
			}(),
			IPAllowedList: func() *CDNLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []CDNLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &CDNLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &CDNLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []CDNLoadBalancerBlockedClientsModel
		var existingBlockedClientsItems []CDNLoadBalancerBlockedClientsModel
		if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
			data.BlockedClients.ElementsAs(ctx, &existingBlockedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, CDNLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].BotSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].SkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsModelAttrTypes}, blocked_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.BlockedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.BlockedClients = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &CDNLoadBalancerBotDefenseModel{
			DisableCORSSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCORSSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *CDNLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &CDNLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if !isImport && data.BotDefense != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.BotDefense.Timeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &CDNLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CaptchaChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CaptchaChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &CDNLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CORSPolicy != nil) {
		data.CORSPolicy = &CDNLoadBalancerCORSPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.AllowCredentials
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.Disabled
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CORSPolicy.MaximumAge
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CSRFPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CSRFPolicy = &CDNLoadBalancerCSRFPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["custom_cache_rule"].(map[string]interface{}); ok && (isImport || data.CustomCacheRule != nil) {
		data.CustomCacheRule = &CDNLoadBalancerCustomCacheRuleModel{
			CDNCacheRules: func() []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel {
				if listData, ok := blockData["cdn_cache_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []CDNLoadBalancerDataGuardRulesModel
		var existingDataGuardRulesItems []CDNLoadBalancerDataGuardRulesModel
		if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
			data.DataGuardRules.ElementsAs(ctx, &existingDataGuardRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, CDNLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].AnyDomain != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].ApplyDataGuard != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *CDNLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].SkipDataGuard != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesModelAttrTypes}, data_guard_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DataGuardRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DataGuardRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesModelAttrTypes})
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []CDNLoadBalancerDDOSMitigationRulesModel
		var existingDDOSMitigationRulesItems []CDNLoadBalancerDDOSMitigationRulesModel
		if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
			data.DDOSMitigationRules.ElementsAs(ctx, &existingDDOSMitigationRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, CDNLoadBalancerDDOSMitigationRulesModel{
					Block: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDDOSMitigationRulesItems) > listIdx && existingDDOSMitigationRulesItems[listIdx].Block != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DDOSClientSource: func() *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerDDOSMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesModelAttrTypes}, ddos_mitigation_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DDOSMitigationRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DDOSMitigationRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["default_cache_action"].(map[string]interface{}); ok && (isImport || data.DefaultCacheAction != nil) {
		data.DefaultCacheAction = &CDNLoadBalancerDefaultCacheActionModel{
			CacheDisabled: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.DefaultCacheAction != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultCacheAction.CacheDisabled
				}
				// Import case: read from API
				if _, ok := blockData["cache_disabled"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			CacheTTLDefault: func() types.String {
				if v, ok := blockData["cache_ttl_default"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CacheTTLOverride: func() types.String {
				if v, ok := blockData["cache_ttl_override"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &CDNLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &CDNLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &CDNLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []CDNLoadBalancerGraphqlRulesModel
		var existingGraphqlRulesItems []CDNLoadBalancerGraphqlRulesModel
		if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
			data.GraphqlRules.ElementsAs(ctx, &existingGraphqlRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, CDNLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].AnyDomain != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *CDNLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesGraphqlSettingsModel{
								DisableIntrospection: func() *CDNLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.DisableIntrospection != nil {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								EnableIntrospection: func() *CDNLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.EnableIntrospection != nil {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodGet != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodPost != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesModelAttrTypes}, graphql_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.GraphqlRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.GraphqlRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &CDNLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTP.DNSVolterraManaged
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTP.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &CDNLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSCertOptions: func() *CDNLoadBalancerHTTPSTLSCertOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertOptions
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSTLSCertOptionsModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &CDNLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSConfig: func() *CDNLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSAutoCertTLSConfigModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &CDNLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JWTValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JWTValidation = &CDNLoadBalancerJWTValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DDOSActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionBlock = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DDOSActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionDefault = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DDOSActionJsChallenge != nil) {
		data.L7DDOSActionJsChallenge = &CDNLoadBalancerL7DDOSActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_pool"].(map[string]interface{}); ok && (isImport || data.OriginPool != nil) {
		data.OriginPool = &CDNLoadBalancerOriginPoolModel{
			MoreOriginOptions: func() *CDNLoadBalancerOriginPoolMoreOriginOptionsModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.MoreOriginOptions != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.MoreOriginOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["more_origin_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolMoreOriginOptionsModel{
						EnableByteRangeRequest: func() types.Bool {
							if v, ok := nestedBlockData["enable_byte_range_request"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						WebSocketProxy: func() types.Bool {
							if v, ok := nestedBlockData["websocket_proxy"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			NoTLS: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.OriginPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OriginPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginRequestTimeout: func() types.String {
				if v, ok := blockData["origin_request_timeout"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OriginServers: func() []CDNLoadBalancerOriginPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerOriginPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerOriginPoolOriginServersModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PublicIP: func() *CDNLoadBalancerOriginPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *CDNLoadBalancerOriginPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PublicName: func() *CDNLoadBalancerOriginPoolPublicNameModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.PublicName != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.PublicName
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["public_name"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolPublicNameModel{
						DNSName: func() types.String {
							if v, ok := nestedBlockData["dns_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						RefreshInterval: func() types.Int64 {
							if v, ok := nestedBlockData["refresh_interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			UseTLS: func() *CDNLoadBalancerOriginPoolUseTLSModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["other_settings"].(map[string]interface{}); ok && (isImport || data.OtherSettings != nil) {
		data.OtherSettings = &CDNLoadBalancerOtherSettingsModel{
			AddLocation: func() types.Bool {
				if !isImport && data.OtherSettings != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.OtherSettings.AddLocation
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_location"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HeaderOptions: func() *CDNLoadBalancerOtherSettingsHeaderOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.HeaderOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.HeaderOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["header_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsHeaderOptionsModel{
						RequestHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ResponseHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			LoggingOptions: func() *CDNLoadBalancerOtherSettingsLoggingOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.LoggingOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.LoggingOptions
				}
				// Import case: read from API
				if _, ok := blockData["logging_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsLoggingOptionsModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &CDNLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []CDNLoadBalancerProtectedCookiesModel
		var existingProtectedCookiesItems []CDNLoadBalancerProtectedCookiesModel
		if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
			data.ProtectedCookies.ElementsAs(ctx, &existingProtectedCookiesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, CDNLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddHttponly != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddSecure != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].DisableTamperingProtection != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].EnableTamperingProtection != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreHttponly != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreMaxAge != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSamesite != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSecure != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteLax != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteNone != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteStrict != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerProtectedCookiesModelAttrTypes}, protected_cookiesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.ProtectedCookies = listVal
		}
	} else {
		// No data from API - set to null list
		data.ProtectedCookies = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerProtectedCookiesModelAttrTypes})
	}
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &CDNLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &CDNLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDDOSMitigation != nil) {
		data.SlowDDOSMitigation = &CDNLoadBalancerSlowDDOSMitigationModel{
			DisableRequestTimeout: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDDOSMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestHeadersTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []CDNLoadBalancerTrustedClientsModel
		var existingTrustedClientsItems []CDNLoadBalancerTrustedClientsModel
		if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
			data.TrustedClients.ElementsAs(ctx, &existingTrustedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, CDNLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].BotSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].SkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsModelAttrTypes}, trusted_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.TrustedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.TrustedClients = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &CDNLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &CDNLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created CDNLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetCDNLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CDNLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CDNLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The cdn_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &CDNLoadBalancerActiveServicePoliciesModel{
			Policies: func() []CDNLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &CDNLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel{}
				}
				return nil
			}(),
			IPAllowedList: func() *CDNLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []CDNLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &CDNLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &CDNLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []CDNLoadBalancerBlockedClientsModel
		var existingBlockedClientsItems []CDNLoadBalancerBlockedClientsModel
		if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
			data.BlockedClients.ElementsAs(ctx, &existingBlockedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, CDNLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].BotSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].SkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsModelAttrTypes}, blocked_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.BlockedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.BlockedClients = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &CDNLoadBalancerBotDefenseModel{
			DisableCORSSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCORSSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *CDNLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &CDNLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if !isImport && data.BotDefense != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.BotDefense.Timeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &CDNLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CaptchaChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CaptchaChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &CDNLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CORSPolicy != nil) {
		data.CORSPolicy = &CDNLoadBalancerCORSPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.AllowCredentials
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.Disabled
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CORSPolicy.MaximumAge
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CSRFPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CSRFPolicy = &CDNLoadBalancerCSRFPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["custom_cache_rule"].(map[string]interface{}); ok && (isImport || data.CustomCacheRule != nil) {
		data.CustomCacheRule = &CDNLoadBalancerCustomCacheRuleModel{
			CDNCacheRules: func() []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel {
				if listData, ok := blockData["cdn_cache_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []CDNLoadBalancerDataGuardRulesModel
		var existingDataGuardRulesItems []CDNLoadBalancerDataGuardRulesModel
		if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
			data.DataGuardRules.ElementsAs(ctx, &existingDataGuardRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, CDNLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].AnyDomain != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].ApplyDataGuard != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *CDNLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].SkipDataGuard != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesModelAttrTypes}, data_guard_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DataGuardRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DataGuardRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesModelAttrTypes})
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []CDNLoadBalancerDDOSMitigationRulesModel
		var existingDDOSMitigationRulesItems []CDNLoadBalancerDDOSMitigationRulesModel
		if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
			data.DDOSMitigationRules.ElementsAs(ctx, &existingDDOSMitigationRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, CDNLoadBalancerDDOSMitigationRulesModel{
					Block: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDDOSMitigationRulesItems) > listIdx && existingDDOSMitigationRulesItems[listIdx].Block != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DDOSClientSource: func() *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerDDOSMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesModelAttrTypes}, ddos_mitigation_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DDOSMitigationRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DDOSMitigationRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["default_cache_action"].(map[string]interface{}); ok && (isImport || data.DefaultCacheAction != nil) {
		data.DefaultCacheAction = &CDNLoadBalancerDefaultCacheActionModel{
			CacheDisabled: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.DefaultCacheAction != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultCacheAction.CacheDisabled
				}
				// Import case: read from API
				if _, ok := blockData["cache_disabled"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			CacheTTLDefault: func() types.String {
				if v, ok := blockData["cache_ttl_default"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CacheTTLOverride: func() types.String {
				if v, ok := blockData["cache_ttl_override"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &CDNLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &CDNLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &CDNLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []CDNLoadBalancerGraphqlRulesModel
		var existingGraphqlRulesItems []CDNLoadBalancerGraphqlRulesModel
		if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
			data.GraphqlRules.ElementsAs(ctx, &existingGraphqlRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, CDNLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].AnyDomain != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *CDNLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesGraphqlSettingsModel{
								DisableIntrospection: func() *CDNLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.DisableIntrospection != nil {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								EnableIntrospection: func() *CDNLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.EnableIntrospection != nil {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodGet != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodPost != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesModelAttrTypes}, graphql_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.GraphqlRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.GraphqlRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &CDNLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTP.DNSVolterraManaged
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTP.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &CDNLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSCertOptions: func() *CDNLoadBalancerHTTPSTLSCertOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertOptions
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSTLSCertOptionsModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &CDNLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSConfig: func() *CDNLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSAutoCertTLSConfigModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &CDNLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JWTValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JWTValidation = &CDNLoadBalancerJWTValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DDOSActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionBlock = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DDOSActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionDefault = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DDOSActionJsChallenge != nil) {
		data.L7DDOSActionJsChallenge = &CDNLoadBalancerL7DDOSActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_pool"].(map[string]interface{}); ok && (isImport || data.OriginPool != nil) {
		data.OriginPool = &CDNLoadBalancerOriginPoolModel{
			MoreOriginOptions: func() *CDNLoadBalancerOriginPoolMoreOriginOptionsModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.MoreOriginOptions != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.MoreOriginOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["more_origin_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolMoreOriginOptionsModel{
						EnableByteRangeRequest: func() types.Bool {
							if v, ok := nestedBlockData["enable_byte_range_request"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						WebSocketProxy: func() types.Bool {
							if v, ok := nestedBlockData["websocket_proxy"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			NoTLS: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.OriginPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OriginPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginRequestTimeout: func() types.String {
				if v, ok := blockData["origin_request_timeout"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OriginServers: func() []CDNLoadBalancerOriginPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerOriginPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerOriginPoolOriginServersModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PublicIP: func() *CDNLoadBalancerOriginPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *CDNLoadBalancerOriginPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PublicName: func() *CDNLoadBalancerOriginPoolPublicNameModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.PublicName != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.PublicName
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["public_name"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolPublicNameModel{
						DNSName: func() types.String {
							if v, ok := nestedBlockData["dns_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						RefreshInterval: func() types.Int64 {
							if v, ok := nestedBlockData["refresh_interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			UseTLS: func() *CDNLoadBalancerOriginPoolUseTLSModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["other_settings"].(map[string]interface{}); ok && (isImport || data.OtherSettings != nil) {
		data.OtherSettings = &CDNLoadBalancerOtherSettingsModel{
			AddLocation: func() types.Bool {
				if !isImport && data.OtherSettings != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.OtherSettings.AddLocation
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_location"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HeaderOptions: func() *CDNLoadBalancerOtherSettingsHeaderOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.HeaderOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.HeaderOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["header_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsHeaderOptionsModel{
						RequestHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ResponseHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			LoggingOptions: func() *CDNLoadBalancerOtherSettingsLoggingOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.LoggingOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.LoggingOptions
				}
				// Import case: read from API
				if _, ok := blockData["logging_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsLoggingOptionsModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &CDNLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []CDNLoadBalancerProtectedCookiesModel
		var existingProtectedCookiesItems []CDNLoadBalancerProtectedCookiesModel
		if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
			data.ProtectedCookies.ElementsAs(ctx, &existingProtectedCookiesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, CDNLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddHttponly != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddSecure != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].DisableTamperingProtection != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].EnableTamperingProtection != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreHttponly != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreMaxAge != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSamesite != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSecure != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteLax != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteNone != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteStrict != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerProtectedCookiesModelAttrTypes}, protected_cookiesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.ProtectedCookies = listVal
		}
	} else {
		// No data from API - set to null list
		data.ProtectedCookies = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerProtectedCookiesModelAttrTypes})
	}
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &CDNLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &CDNLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDDOSMitigation != nil) {
		data.SlowDDOSMitigation = &CDNLoadBalancerSlowDDOSMitigationModel{
			DisableRequestTimeout: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDDOSMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestHeadersTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []CDNLoadBalancerTrustedClientsModel
		var existingTrustedClientsItems []CDNLoadBalancerTrustedClientsModel
		if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
			data.TrustedClients.ElementsAs(ctx, &existingTrustedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, CDNLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].BotSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].SkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsModelAttrTypes}, trusted_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.TrustedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.TrustedClients = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &CDNLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &CDNLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.CDNLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		apiResource.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["api_specification"] = api_specificationMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		apiResource.Spec["app_firewall"] = app_firewallMap
	}
	if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
		var blocked_clientsItems []CDNLoadBalancerBlockedClientsModel
		diags := data.BlockedClients.ElementsAs(ctx, &blocked_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(blocked_clientsItems) > 0 {
			var blocked_clientsList []map[string]interface{}
			for _, item := range blocked_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				blocked_clientsList = append(blocked_clientsList, itemMap)
			}
			apiResource.Spec["blocked_clients"] = blocked_clientsList
		}
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCORSSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCORSSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		apiResource.Spec["bot_defense"] = bot_defenseMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		apiResource.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		apiResource.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CORSPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CORSPolicy.AllowCredentials.IsNull() && !data.CORSPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CORSPolicy.AllowCredentials.ValueBool()
		}
		if !data.CORSPolicy.AllowHeaders.IsNull() && !data.CORSPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CORSPolicy.AllowHeaders.ValueString()
		}
		if !data.CORSPolicy.AllowMethods.IsNull() && !data.CORSPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CORSPolicy.AllowMethods.ValueString()
		}
		if !data.CORSPolicy.AllowOrigin.IsNull() && !data.CORSPolicy.AllowOrigin.IsUnknown() {
			var allow_originItems []string
			diags := data.CORSPolicy.AllowOrigin.ElementsAs(ctx, &allow_originItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin"] = allow_originItems
			}
		}
		if !data.CORSPolicy.AllowOriginRegex.IsNull() && !data.CORSPolicy.AllowOriginRegex.IsUnknown() {
			var allow_origin_regexItems []string
			diags := data.CORSPolicy.AllowOriginRegex.ElementsAs(ctx, &allow_origin_regexItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin_regex"] = allow_origin_regexItems
			}
		}
		if !data.CORSPolicy.Disabled.IsNull() && !data.CORSPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CORSPolicy.Disabled.ValueBool()
		}
		if !data.CORSPolicy.ExposeHeaders.IsNull() && !data.CORSPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CORSPolicy.ExposeHeaders.ValueString()
		}
		if !data.CORSPolicy.MaximumAge.IsNull() && !data.CORSPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CORSPolicy.MaximumAge.ValueInt64()
		}
		apiResource.Spec["cors_policy"] = cors_policyMap
	}
	if data.CSRFPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CSRFPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CSRFPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CSRFPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["csrf_policy"] = csrf_policyMap
	}
	if data.CustomCacheRule != nil {
		custom_cache_ruleMap := make(map[string]interface{})
		if len(data.CustomCacheRule.CDNCacheRules) > 0 {
			var cdn_cache_rulesList []map[string]interface{}
			for _, listItem := range data.CustomCacheRule.CDNCacheRules {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				cdn_cache_rulesList = append(cdn_cache_rulesList, listItemMap)
			}
			custom_cache_ruleMap["cdn_cache_rules"] = cdn_cache_rulesList
		}
		apiResource.Spec["custom_cache_rule"] = custom_cache_ruleMap
	}
	if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
		var data_guard_rulesItems []CDNLoadBalancerDataGuardRulesModel
		diags := data.DataGuardRules.ElementsAs(ctx, &data_guard_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(data_guard_rulesItems) > 0 {
			var data_guard_rulesList []map[string]interface{}
			for _, item := range data_guard_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if item.ApplyDataGuard != nil {
					itemMap["apply_data_guard"] = map[string]interface{}{}
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.Path != nil {
					pathNestedMap := make(map[string]interface{})
					if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
						pathNestedMap["path"] = item.Path.Path.ValueString()
					}
					if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
						pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
					}
					if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
						pathNestedMap["regex"] = item.Path.Regex.ValueString()
					}
					itemMap["path"] = pathNestedMap
				}
				if item.SkipDataGuard != nil {
					itemMap["skip_data_guard"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				data_guard_rulesList = append(data_guard_rulesList, itemMap)
			}
			apiResource.Spec["data_guard_rules"] = data_guard_rulesList
		}
	}
	if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
		var ddos_mitigation_rulesItems []CDNLoadBalancerDDOSMitigationRulesModel
		diags := data.DDOSMitigationRules.ElementsAs(ctx, &ddos_mitigation_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(ddos_mitigation_rulesItems) > 0 {
			var ddos_mitigation_rulesList []map[string]interface{}
			for _, item := range ddos_mitigation_rulesItems {
				itemMap := make(map[string]interface{})
				if item.Block != nil {
					itemMap["block"] = map[string]interface{}{}
				}
				if item.DDOSClientSource != nil {
					ddos_client_sourceNestedMap := make(map[string]interface{})
					if item.DDOSClientSource.AsnList != nil {
						asn_listDeepMap := make(map[string]interface{})
						ddos_client_sourceNestedMap["asn_list"] = asn_listDeepMap
					}
					if !item.DDOSClientSource.CountryList.IsNull() && !item.DDOSClientSource.CountryList.IsUnknown() {
						var CountryListItems []string
						diags := item.DDOSClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
						if !diags.HasError() {
							ddos_client_sourceNestedMap["country_list"] = CountryListItems
						}
					}
					if item.DDOSClientSource.Ja4TLSFingerprintMatcher != nil {
						ja4_tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								ja4_tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						ddos_client_sourceNestedMap["ja4_tls_fingerprint_matcher"] = ja4_tls_fingerprint_matcherDeepMap
					}
					if item.DDOSClientSource.TLSFingerprintMatcher != nil {
						tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsUnknown() {
							var ClassesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.Classes.ElementsAs(ctx, &ClassesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["classes"] = ClassesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsUnknown() {
							var ExcludedValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.ElementsAs(ctx, &ExcludedValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["excluded_values"] = ExcludedValuesItems
							}
						}
						ddos_client_sourceNestedMap["tls_fingerprint_matcher"] = tls_fingerprint_matcherDeepMap
					}
					itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.IPPrefixList != nil {
					ip_prefix_listNestedMap := make(map[string]interface{})
					if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
					}
					if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
						var IPPrefixesItems []string
						diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
						if !diags.HasError() {
							ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
						}
					}
					itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
			}
			apiResource.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
		}
	}
	if data.DefaultCacheAction != nil {
		default_cache_actionMap := make(map[string]interface{})
		if data.DefaultCacheAction.CacheDisabled != nil {
			default_cache_actionMap["cache_disabled"] = map[string]interface{}{}
		}
		if !data.DefaultCacheAction.CacheTTLDefault.IsNull() && !data.DefaultCacheAction.CacheTTLDefault.IsUnknown() {
			default_cache_actionMap["cache_ttl_default"] = data.DefaultCacheAction.CacheTTLDefault.ValueString()
		}
		if !data.DefaultCacheAction.CacheTTLOverride.IsNull() && !data.DefaultCacheAction.CacheTTLOverride.IsUnknown() {
			default_cache_actionMap["cache_ttl_override"] = data.DefaultCacheAction.CacheTTLOverride.ValueString()
		}
		apiResource.Spec["default_cache_action"] = default_cache_actionMap
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		apiResource.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		apiResource.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		apiResource.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		apiResource.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		apiResource.Spec["disable_waf"] = disable_wafMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		apiResource.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		apiResource.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		if !data.EnableIPReputation.IPThreatCategories.IsNull() && !data.EnableIPReputation.IPThreatCategories.IsUnknown() {
			var ip_threat_categoriesItems []string
			diags := data.EnableIPReputation.IPThreatCategories.ElementsAs(ctx, &ip_threat_categoriesItems, false)
			if !diags.HasError() {
				enable_ip_reputationMap["ip_threat_categories"] = ip_threat_categoriesItems
			}
		}
		apiResource.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
		var graphql_rulesItems []CDNLoadBalancerGraphqlRulesModel
		diags := data.GraphqlRules.ElementsAs(ctx, &graphql_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(graphql_rulesItems) > 0 {
			var graphql_rulesList []map[string]interface{}
			for _, item := range graphql_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
					itemMap["exact_path"] = item.ExactPath.ValueString()
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.GraphqlSettings != nil {
					graphql_settingsNestedMap := make(map[string]interface{})
					if item.GraphqlSettings.DisableIntrospection != nil {
						graphql_settingsNestedMap["disable_introspection"] = map[string]interface{}{}
					}
					if item.GraphqlSettings.EnableIntrospection != nil {
						graphql_settingsNestedMap["enable_introspection"] = map[string]interface{}{}
					}
					if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
						graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
					}
					if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
						graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
					}
					if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
						graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
					}
					itemMap["graphql_settings"] = graphql_settingsNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.MethodGet != nil {
					itemMap["method_get"] = map[string]interface{}{}
				}
				if item.MethodPost != nil {
					itemMap["method_post"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				graphql_rulesList = append(graphql_rulesList, itemMap)
			}
			apiResource.Spec["graphql_rules"] = graphql_rulesList
		}
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		apiResource.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.TLSCertOptions != nil {
			tls_cert_optionsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_options"] = tls_cert_optionsNestedMap
		}
		apiResource.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		apiResource.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["js_challenge"] = js_challengeMap
	}
	if data.JWTValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JWTValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JWTValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JWTValidation.JwksConfig.Cleartext.IsNull() && !data.JWTValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JWTValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JWTValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JWTValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JWTValidation.ReservedClaims.Issuer.IsNull() && !data.JWTValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JWTValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JWTValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JWTValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		apiResource.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DDOSActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DDOSActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DDOSActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DDOSActionJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DDOSActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DDOSActionJsChallenge.CustomPage.IsNull() && !data.L7DDOSActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DDOSActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DDOSActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DDOSActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		apiResource.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginPool != nil {
		origin_poolMap := make(map[string]interface{})
		if data.OriginPool.MoreOriginOptions != nil {
			more_origin_optionsNestedMap := make(map[string]interface{})
			if !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsNull() && !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsUnknown() {
				more_origin_optionsNestedMap["enable_byte_range_request"] = data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.ValueBool()
			}
			if !data.OriginPool.MoreOriginOptions.WebSocketProxy.IsNull() && !data.OriginPool.MoreOriginOptions.WebSocketProxy.IsUnknown() {
				more_origin_optionsNestedMap["websocket_proxy"] = data.OriginPool.MoreOriginOptions.WebSocketProxy.ValueBool()
			}
			origin_poolMap["more_origin_options"] = more_origin_optionsNestedMap
		}
		if data.OriginPool.NoTLS != nil {
			origin_poolMap["no_tls"] = map[string]interface{}{}
		}
		if !data.OriginPool.OriginRequestTimeout.IsNull() && !data.OriginPool.OriginRequestTimeout.IsUnknown() {
			origin_poolMap["origin_request_timeout"] = data.OriginPool.OriginRequestTimeout.ValueString()
		}
		if len(data.OriginPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.OriginPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			origin_poolMap["origin_servers"] = origin_serversList
		}
		if data.OriginPool.PublicName != nil {
			public_nameNestedMap := make(map[string]interface{})
			if !data.OriginPool.PublicName.DNSName.IsNull() && !data.OriginPool.PublicName.DNSName.IsUnknown() {
				public_nameNestedMap["dns_name"] = data.OriginPool.PublicName.DNSName.ValueString()
			}
			if !data.OriginPool.PublicName.RefreshInterval.IsNull() && !data.OriginPool.PublicName.RefreshInterval.IsUnknown() {
				public_nameNestedMap["refresh_interval"] = data.OriginPool.PublicName.RefreshInterval.ValueInt64()
			}
			origin_poolMap["public_name"] = public_nameNestedMap
		}
		if data.OriginPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.OriginPool.UseTLS.MaxSessionKeys.IsNull() && !data.OriginPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.OriginPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.OriginPool.UseTLS.Sni.IsNull() && !data.OriginPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.OriginPool.UseTLS.Sni.ValueString()
			}
			origin_poolMap["use_tls"] = use_tlsNestedMap
		}
		apiResource.Spec["origin_pool"] = origin_poolMap
	}
	if data.OtherSettings != nil {
		other_settingsMap := make(map[string]interface{})
		if !data.OtherSettings.AddLocation.IsNull() && !data.OtherSettings.AddLocation.IsUnknown() {
			other_settingsMap["add_location"] = data.OtherSettings.AddLocation.ValueBool()
		}
		if data.OtherSettings.HeaderOptions != nil {
			header_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["header_options"] = header_optionsNestedMap
		}
		if data.OtherSettings.LoggingOptions != nil {
			logging_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["logging_options"] = logging_optionsNestedMap
		}
		apiResource.Spec["other_settings"] = other_settingsMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		apiResource.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
		var protected_cookiesItems []CDNLoadBalancerProtectedCookiesModel
		diags := data.ProtectedCookies.ElementsAs(ctx, &protected_cookiesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(protected_cookiesItems) > 0 {
			var protected_cookiesList []map[string]interface{}
			for _, item := range protected_cookiesItems {
				itemMap := make(map[string]interface{})
				if item.AddHttponly != nil {
					itemMap["add_httponly"] = map[string]interface{}{}
				}
				if item.AddSecure != nil {
					itemMap["add_secure"] = map[string]interface{}{}
				}
				if item.DisableTamperingProtection != nil {
					itemMap["disable_tampering_protection"] = map[string]interface{}{}
				}
				if item.EnableTamperingProtection != nil {
					itemMap["enable_tampering_protection"] = map[string]interface{}{}
				}
				if item.IgnoreHttponly != nil {
					itemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if item.IgnoreMaxAge != nil {
					itemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if item.IgnoreSamesite != nil {
					itemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if item.IgnoreSecure != nil {
					itemMap["ignore_secure"] = map[string]interface{}{}
				}
				if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
					itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
				}
				if !item.Name.IsNull() && !item.Name.IsUnknown() {
					itemMap["name"] = item.Name.ValueString()
				}
				if item.SamesiteLax != nil {
					itemMap["samesite_lax"] = map[string]interface{}{}
				}
				if item.SamesiteNone != nil {
					itemMap["samesite_none"] = map[string]interface{}{}
				}
				if item.SamesiteStrict != nil {
					itemMap["samesite_strict"] = map[string]interface{}{}
				}
				protected_cookiesList = append(protected_cookiesList, itemMap)
			}
			apiResource.Spec["protected_cookies"] = protected_cookiesList
		}
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		apiResource.Spec["rate_limit"] = rate_limitMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		apiResource.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SlowDDOSMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDDOSMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDDOSMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDDOSMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDDOSMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDDOSMitigation.RequestTimeout.IsNull() && !data.SlowDDOSMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDDOSMitigation.RequestTimeout.ValueInt64()
		}
		apiResource.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		apiResource.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
		var trusted_clientsItems []CDNLoadBalancerTrustedClientsModel
		diags := data.TrustedClients.ElementsAs(ctx, &trusted_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(trusted_clientsItems) > 0 {
			var trusted_clientsList []map[string]interface{}
			for _, item := range trusted_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				trusted_clientsList = append(trusted_clientsList, itemMap)
			}
			apiResource.Spec["trusted_clients"] = trusted_clientsList
		}
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		apiResource.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		apiResource.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		apiResource.Spec["waf_exclusion"] = waf_exclusionMap
	}

	_, err := r.client.UpdateCDNLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update CDNLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetCDNLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CDNLoadBalancer after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &CDNLoadBalancerActiveServicePoliciesModel{
			Policies: func() []CDNLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &CDNLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel{}
				}
				return nil
			}(),
			IPAllowedList: func() *CDNLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []CDNLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &CDNLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &CDNLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []CDNLoadBalancerBlockedClientsModel
		var existingBlockedClientsItems []CDNLoadBalancerBlockedClientsModel
		if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
			data.BlockedClients.ElementsAs(ctx, &existingBlockedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, CDNLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].BotSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].SkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsModelAttrTypes}, blocked_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.BlockedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.BlockedClients = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerBlockedClientsModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &CDNLoadBalancerBotDefenseModel{
			DisableCORSSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCORSSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *CDNLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &CDNLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if !isImport && data.BotDefense != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.BotDefense.Timeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &CDNLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CaptchaChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CaptchaChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &CDNLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CORSPolicy != nil) {
		data.CORSPolicy = &CDNLoadBalancerCORSPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.AllowCredentials
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.Disabled
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CORSPolicy.MaximumAge
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CSRFPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CSRFPolicy = &CDNLoadBalancerCSRFPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["custom_cache_rule"].(map[string]interface{}); ok && (isImport || data.CustomCacheRule != nil) {
		data.CustomCacheRule = &CDNLoadBalancerCustomCacheRuleModel{
			CDNCacheRules: func() []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel {
				if listData, ok := blockData["cdn_cache_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []CDNLoadBalancerDataGuardRulesModel
		var existingDataGuardRulesItems []CDNLoadBalancerDataGuardRulesModel
		if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
			data.DataGuardRules.ElementsAs(ctx, &existingDataGuardRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, CDNLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].AnyDomain != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].ApplyDataGuard != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *CDNLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].SkipDataGuard != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesModelAttrTypes}, data_guard_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DataGuardRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DataGuardRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerDataGuardRulesModelAttrTypes})
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []CDNLoadBalancerDDOSMitigationRulesModel
		var existingDDOSMitigationRulesItems []CDNLoadBalancerDDOSMitigationRulesModel
		if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
			data.DDOSMitigationRules.ElementsAs(ctx, &existingDDOSMitigationRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, CDNLoadBalancerDDOSMitigationRulesModel{
					Block: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingDDOSMitigationRulesItems) > listIdx && existingDDOSMitigationRulesItems[listIdx].Block != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DDOSClientSource: func() *CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesDDOSClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerDDOSMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDDOSMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesModelAttrTypes}, ddos_mitigation_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DDOSMitigationRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DDOSMitigationRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerDDOSMitigationRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["default_cache_action"].(map[string]interface{}); ok && (isImport || data.DefaultCacheAction != nil) {
		data.DefaultCacheAction = &CDNLoadBalancerDefaultCacheActionModel{
			CacheDisabled: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.DefaultCacheAction != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultCacheAction.CacheDisabled
				}
				// Import case: read from API
				if _, ok := blockData["cache_disabled"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			CacheTTLDefault: func() types.String {
				if v, ok := blockData["cache_ttl_default"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CacheTTLOverride: func() types.String {
				if v, ok := blockData["cache_ttl_override"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &CDNLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &CDNLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &CDNLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []CDNLoadBalancerGraphqlRulesModel
		var existingGraphqlRulesItems []CDNLoadBalancerGraphqlRulesModel
		if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
			data.GraphqlRules.ElementsAs(ctx, &existingGraphqlRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, CDNLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].AnyDomain != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *CDNLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesGraphqlSettingsModel{
								DisableIntrospection: func() *CDNLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.DisableIntrospection != nil {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								EnableIntrospection: func() *CDNLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.EnableIntrospection != nil {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodGet != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodPost != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesModelAttrTypes}, graphql_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.GraphqlRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.GraphqlRules = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerGraphqlRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &CDNLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTP.DNSVolterraManaged
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTP.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &CDNLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSCertOptions: func() *CDNLoadBalancerHTTPSTLSCertOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertOptions
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSTLSCertOptionsModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &CDNLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSConfig: func() *CDNLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSAutoCertTLSConfigModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &CDNLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JWTValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JWTValidation = &CDNLoadBalancerJWTValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DDOSActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionBlock = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DDOSActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionDefault = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DDOSActionJsChallenge != nil) {
		data.L7DDOSActionJsChallenge = &CDNLoadBalancerL7DDOSActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_pool"].(map[string]interface{}); ok && (isImport || data.OriginPool != nil) {
		data.OriginPool = &CDNLoadBalancerOriginPoolModel{
			MoreOriginOptions: func() *CDNLoadBalancerOriginPoolMoreOriginOptionsModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.MoreOriginOptions != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.MoreOriginOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["more_origin_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolMoreOriginOptionsModel{
						EnableByteRangeRequest: func() types.Bool {
							if v, ok := nestedBlockData["enable_byte_range_request"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						WebSocketProxy: func() types.Bool {
							if v, ok := nestedBlockData["websocket_proxy"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			NoTLS: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.OriginPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OriginPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginRequestTimeout: func() types.String {
				if v, ok := blockData["origin_request_timeout"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OriginServers: func() []CDNLoadBalancerOriginPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerOriginPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerOriginPoolOriginServersModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PublicIP: func() *CDNLoadBalancerOriginPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *CDNLoadBalancerOriginPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PublicName: func() *CDNLoadBalancerOriginPoolPublicNameModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.PublicName != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.PublicName
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["public_name"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolPublicNameModel{
						DNSName: func() types.String {
							if v, ok := nestedBlockData["dns_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						RefreshInterval: func() types.Int64 {
							if v, ok := nestedBlockData["refresh_interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			UseTLS: func() *CDNLoadBalancerOriginPoolUseTLSModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["other_settings"].(map[string]interface{}); ok && (isImport || data.OtherSettings != nil) {
		data.OtherSettings = &CDNLoadBalancerOtherSettingsModel{
			AddLocation: func() types.Bool {
				if !isImport && data.OtherSettings != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.OtherSettings.AddLocation
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_location"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HeaderOptions: func() *CDNLoadBalancerOtherSettingsHeaderOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.HeaderOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.HeaderOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["header_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsHeaderOptionsModel{
						RequestHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ResponseHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			LoggingOptions: func() *CDNLoadBalancerOtherSettingsLoggingOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.LoggingOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.LoggingOptions
				}
				// Import case: read from API
				if _, ok := blockData["logging_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsLoggingOptionsModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &CDNLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []CDNLoadBalancerProtectedCookiesModel
		var existingProtectedCookiesItems []CDNLoadBalancerProtectedCookiesModel
		if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
			data.ProtectedCookies.ElementsAs(ctx, &existingProtectedCookiesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, CDNLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddHttponly != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddSecure != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].DisableTamperingProtection != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].EnableTamperingProtection != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreHttponly != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreMaxAge != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSamesite != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSecure != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteLax != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteNone != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteStrict != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerProtectedCookiesModelAttrTypes}, protected_cookiesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.ProtectedCookies = listVal
		}
	} else {
		// No data from API - set to null list
		data.ProtectedCookies = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerProtectedCookiesModelAttrTypes})
	}
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &CDNLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &CDNLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDDOSMitigation != nil) {
		data.SlowDDOSMitigation = &CDNLoadBalancerSlowDDOSMitigationModel{
			DisableRequestTimeout: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDDOSMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestHeadersTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []CDNLoadBalancerTrustedClientsModel
		var existingTrustedClientsItems []CDNLoadBalancerTrustedClientsModel
		if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
			data.TrustedClients.ElementsAs(ctx, &existingTrustedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, CDNLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].BotSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].SkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsModelAttrTypes}, trusted_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.TrustedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.TrustedClients = types.ListNull(types.ObjectType{AttrTypes: CDNLoadBalancerTrustedClientsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &CDNLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &CDNLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteCDNLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CDNLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "CDNLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete CDNLoadBalancer: %s", err))
		return
	}
}

func (r *CDNLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
