// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &CDNLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &CDNLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &CDNLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &CDNLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &CDNLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &CDNLoadBalancerResource{}
)

// cdn_loadbalancerSchemaVersion is the schema version for state upgrades
const cdn_loadbalancerSchemaVersion int64 = 1

func NewCDNLoadBalancerResource() resource.Resource {
	return &CDNLoadBalancerResource{}
}

type CDNLoadBalancerResource struct {
	client *client.Client
}

// CDNLoadBalancerEmptyModel represents empty nested blocks
type CDNLoadBalancerEmptyModel struct {
}

// CDNLoadBalancerActiveServicePoliciesModel represents active_service_policies block
type CDNLoadBalancerActiveServicePoliciesModel struct {
	Policies []CDNLoadBalancerActiveServicePoliciesPoliciesModel `tfsdk:"policies"`
}

// CDNLoadBalancerActiveServicePoliciesPoliciesModel represents policies block
type CDNLoadBalancerActiveServicePoliciesPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitModel represents api_rate_limit block
type CDNLoadBalancerAPIRateLimitModel struct {
	APIEndpointRules []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel `tfsdk:"api_endpoint_rules"`
	BypassRateLimitingRules *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
	CustomIPAllowedList *CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList *CDNLoadBalancerAPIRateLimitIPAllowedListModel `tfsdk:"ip_allowed_list"`
	NoIPAllowedList *CDNLoadBalancerEmptyModel `tfsdk:"no_ip_allowed_list"`
	ServerURLRules []CDNLoadBalancerAPIRateLimitServerURLRulesModel `tfsdk:"server_url_rules"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel represents api_endpoint_rules block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel struct {
	APIEndpointPath types.String `tfsdk:"api_endpoint_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	APIEndpointMethod *CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel `tfsdk:"api_endpoint_method"`
	ClientMatcher *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel `tfsdk:"client_matcher"`
	InlineRateLimiter *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel `tfsdk:"ref_rate_limiter"`
	RequestMatcher *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel represents api_endpoint_method block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods types.List `tfsdk:"methods"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel represents client_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel struct {
	AnyClient *CDNLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *CDNLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel represents asn_list block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel represents client_selector block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel represents ip_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel represents inline_rate_limiter block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel struct {
	Threshold types.Int64 `tfsdk:"threshold"`
	Unit types.String `tfsdk:"unit"`
	RefUserID *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLbUserID *CDNLoadBalancerEmptyModel `tfsdk:"use_http_lb_user_id"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel represents ref_rate_limiter block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel represents request_matcher block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel struct {
	CookieMatchers []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel represents headers block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel represents query_params block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel represents item block
type CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel struct {
	BypassRateLimitingRules []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel struct {
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	AnyURL *CDNLoadBalancerEmptyModel `tfsdk:"any_url"`
	APIEndpoint *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	APIGroups *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel `tfsdk:"api_groups"`
	ClientMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel `tfsdk:"client_matcher"`
	RequestMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel represents api_groups block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel represents client_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel struct {
	AnyClient *CDNLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *CDNLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel represents asn_list block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel represents client_selector block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel represents ip_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel represents request_matcher block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel struct {
	CookieMatchers []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel represents headers block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel represents query_params block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel represents item block
type CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type CDNLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitIPAllowedListModel represents ip_allowed_list block
type CDNLoadBalancerAPIRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesModel represents server_url_rules block
type CDNLoadBalancerAPIRateLimitServerURLRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	ClientMatcher *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel `tfsdk:"client_matcher"`
	InlineRateLimiter *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter *CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel `tfsdk:"ref_rate_limiter"`
	RequestMatcher *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel represents client_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel struct {
	AnyClient *CDNLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *CDNLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel represents asn_list block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel represents client_selector block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel represents ip_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel represents inline_rate_limiter block
type CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel struct {
	Threshold types.Int64 `tfsdk:"threshold"`
	Unit types.String `tfsdk:"unit"`
	RefUserID *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLbUserID *CDNLoadBalancerEmptyModel `tfsdk:"use_http_lb_user_id"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel represents ref_rate_limiter block
type CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel represents request_matcher block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel struct {
	CookieMatchers []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel represents headers block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel represents query_params block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel represents item block
type CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerAPISpecificationModel represents api_specification block
type CDNLoadBalancerAPISpecificationModel struct {
	APIDefinition *CDNLoadBalancerAPISpecificationAPIDefinitionModel `tfsdk:"api_definition"`
	ValidationAllSpecEndpoints *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel `tfsdk:"validation_all_spec_endpoints"`
	ValidationCustomList *CDNLoadBalancerAPISpecificationValidationCustomListModel `tfsdk:"validation_custom_list"`
	ValidationDisabled *CDNLoadBalancerEmptyModel `tfsdk:"validation_disabled"`
}

// CDNLoadBalancerAPISpecificationAPIDefinitionModel represents api_definition block
type CDNLoadBalancerAPISpecificationAPIDefinitionModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel represents validation_all_spec_endpoints block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsModel struct {
	FallThroughMode *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel `tfsdk:"fall_through_mode"`
	Settings *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel `tfsdk:"settings"`
	ValidationMode *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel `tfsdk:"validation_mode"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel represents fall_through_mode block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel struct {
	FallThroughModeAllow *CDNLoadBalancerEmptyModel `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	ActionBlock *CDNLoadBalancerEmptyModel `tfsdk:"action_block"`
	ActionReport *CDNLoadBalancerEmptyModel `tfsdk:"action_report"`
	ActionSkip *CDNLoadBalancerEmptyModel `tfsdk:"action_skip"`
	APIEndpoint *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel `tfsdk:"metadata"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel represents settings block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel struct {
	OversizedBodyFailValidation *CDNLoadBalancerEmptyModel `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation *CDNLoadBalancerEmptyModel `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *CDNLoadBalancerEmptyModel `tfsdk:"property_validation_settings_default"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters *CDNLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *CDNLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel represents validation_mode block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel struct {
	ResponseValidationModeActive *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation *CDNLoadBalancerEmptyModel `tfsdk:"skip_response_validation"`
	SkipValidation *CDNLoadBalancerEmptyModel `tfsdk:"skip_validation"`
	ValidationModeActive *CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel `tfsdk:"validation_mode_active"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List `tfsdk:"response_validation_properties"`
	EnforcementBlock *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel represents validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List `tfsdk:"request_validation_properties"`
	EnforcementBlock *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListModel represents validation_custom_list block
type CDNLoadBalancerAPISpecificationValidationCustomListModel struct {
	FallThroughMode *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel `tfsdk:"fall_through_mode"`
	OpenAPIValidationRules []CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
	Settings *CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel `tfsdk:"settings"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel represents fall_through_mode block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel struct {
	FallThroughModeAllow *CDNLoadBalancerEmptyModel `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	ActionBlock *CDNLoadBalancerEmptyModel `tfsdk:"action_block"`
	ActionReport *CDNLoadBalancerEmptyModel `tfsdk:"action_report"`
	ActionSkip *CDNLoadBalancerEmptyModel `tfsdk:"action_skip"`
	APIEndpoint *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata *CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel `tfsdk:"metadata"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type CDNLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel represents open_api_validation_rules block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	APIEndpoint *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel `tfsdk:"metadata"`
	ValidationMode *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel `tfsdk:"validation_mode"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel represents metadata block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel represents validation_mode block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel struct {
	ResponseValidationModeActive *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation *CDNLoadBalancerEmptyModel `tfsdk:"skip_response_validation"`
	SkipValidation *CDNLoadBalancerEmptyModel `tfsdk:"skip_validation"`
	ValidationModeActive *CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel `tfsdk:"validation_mode_active"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List `tfsdk:"response_validation_properties"`
	EnforcementBlock *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel represents validation_mode_active block
type CDNLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List `tfsdk:"request_validation_properties"`
	EnforcementBlock *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *CDNLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel represents settings block
type CDNLoadBalancerAPISpecificationValidationCustomListSettingsModel struct {
	OversizedBodyFailValidation *CDNLoadBalancerEmptyModel `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation *CDNLoadBalancerEmptyModel `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom *CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *CDNLoadBalancerEmptyModel `tfsdk:"property_validation_settings_default"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type CDNLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters *CDNLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *CDNLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// CDNLoadBalancerAppFirewallModel represents app_firewall block
type CDNLoadBalancerAppFirewallModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerBlockedClientsModel represents blocked_clients block
type CDNLoadBalancerBlockedClientsModel struct {
	Actions types.List `tfsdk:"actions"`
	AsNumber types.Int64 `tfsdk:"as_number"`
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	IPPrefix types.String `tfsdk:"ip_prefix"`
	IPV6Prefix types.String `tfsdk:"ipv6_prefix"`
	UserIdentifier types.String `tfsdk:"user_identifier"`
	BotSkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"bot_skip_processing"`
	HTTPHeader *CDNLoadBalancerBlockedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata *CDNLoadBalancerBlockedClientsMetadataModel `tfsdk:"metadata"`
	SkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"skip_processing"`
	WAFSkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"waf_skip_processing"`
}

// CDNLoadBalancerBlockedClientsHTTPHeaderModel represents http_header block
type CDNLoadBalancerBlockedClientsHTTPHeaderModel struct {
	Headers []CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel represents headers block
type CDNLoadBalancerBlockedClientsHTTPHeaderHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBlockedClientsMetadataModel represents metadata block
type CDNLoadBalancerBlockedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefenseModel represents bot_defense block
type CDNLoadBalancerBotDefenseModel struct {
	RegionalEndpoint types.String `tfsdk:"regional_endpoint"`
	Timeout types.Int64 `tfsdk:"timeout"`
	DisableCorsSupport *CDNLoadBalancerEmptyModel `tfsdk:"disable_cors_support"`
	EnableCorsSupport *CDNLoadBalancerEmptyModel `tfsdk:"enable_cors_support"`
	Policy *CDNLoadBalancerBotDefensePolicyModel `tfsdk:"policy"`
}

// CDNLoadBalancerBotDefensePolicyModel represents policy block
type CDNLoadBalancerBotDefensePolicyModel struct {
	JavascriptMode types.String `tfsdk:"javascript_mode"`
	JsDownloadPath types.String `tfsdk:"js_download_path"`
	DisableJsInsert *CDNLoadBalancerEmptyModel `tfsdk:"disable_js_insert"`
	DisableMobileSdk *CDNLoadBalancerEmptyModel `tfsdk:"disable_mobile_sdk"`
	JsInsertAllPages *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules *CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel `tfsdk:"js_insertion_rules"`
	MobileSdkConfig *CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel `tfsdk:"mobile_sdk_config"`
	ProtectedAppEndpoints []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel `tfsdk:"protected_app_endpoints"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel represents js_insert_all_pages block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	ExcludeList []CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel `tfsdk:"domain"`
	Metadata *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel `tfsdk:"path"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type CDNLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules []CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel `tfsdk:"rules"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel `tfsdk:"domain"`
	Metadata *CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel `tfsdk:"path"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel represents rules block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel `tfsdk:"domain"`
	Metadata *CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel `tfsdk:"path"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel represents path block
type CDNLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel represents mobile_sdk_config block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigModel struct {
	MobileIdentifier *CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel `tfsdk:"mobile_identifier"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel represents mobile_identifier block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel struct {
	Headers []CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel `tfsdk:"headers"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel represents headers block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel struct {
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel represents item block
type CDNLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel represents protected_app_endpoints block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsModel struct {
	HTTPMethods types.List `tfsdk:"http_methods"`
	Protocol types.String `tfsdk:"protocol"`
	AllowGoodBots *CDNLoadBalancerEmptyModel `tfsdk:"allow_good_bots"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel `tfsdk:"domain"`
	FlowLabel *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel `tfsdk:"flow_label"`
	Headers []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel `tfsdk:"headers"`
	Metadata *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel `tfsdk:"metadata"`
	MitigateGoodBots *CDNLoadBalancerEmptyModel `tfsdk:"mitigate_good_bots"`
	Mitigation *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel `tfsdk:"mitigation"`
	Mobile *CDNLoadBalancerEmptyModel `tfsdk:"mobile"`
	Path *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel `tfsdk:"path"`
	QueryParams []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel `tfsdk:"query_params"`
	UndefinedFlowLabel *CDNLoadBalancerEmptyModel `tfsdk:"undefined_flow_label"`
	Web *CDNLoadBalancerEmptyModel `tfsdk:"web"`
	WebMobile *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel `tfsdk:"web_mobile"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel represents domain block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel represents flow_label block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel struct {
	AccountManagement *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel `tfsdk:"account_management"`
	Authentication *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel `tfsdk:"authentication"`
	FinancialServices *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel `tfsdk:"financial_services"`
	Flight *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel `tfsdk:"flight"`
	ProfileManagement *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel `tfsdk:"profile_management"`
	Search *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel `tfsdk:"search"`
	ShoppingGiftCards *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel `tfsdk:"shopping_gift_cards"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel represents account_management block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel struct {
	Create *CDNLoadBalancerEmptyModel `tfsdk:"create"`
	PasswordReset *CDNLoadBalancerEmptyModel `tfsdk:"password_reset"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel represents authentication block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel struct {
	Login *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel `tfsdk:"login"`
	LoginMfa *CDNLoadBalancerEmptyModel `tfsdk:"login_mfa"`
	LoginPartner *CDNLoadBalancerEmptyModel `tfsdk:"login_partner"`
	Logout *CDNLoadBalancerEmptyModel `tfsdk:"logout"`
	TokenRefresh *CDNLoadBalancerEmptyModel `tfsdk:"token_refresh"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel represents login block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel struct {
	DisableTransactionResult *CDNLoadBalancerEmptyModel `tfsdk:"disable_transaction_result"`
	TransactionResult *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel `tfsdk:"transaction_result"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel represents transaction_result block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel struct {
	FailureConditions []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel `tfsdk:"failure_conditions"`
	SuccessConditions []CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel `tfsdk:"success_conditions"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel represents failure_conditions block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel struct {
	Name types.String `tfsdk:"name"`
	RegexValues types.List `tfsdk:"regex_values"`
	Status types.String `tfsdk:"status"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel represents success_conditions block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel struct {
	Name types.String `tfsdk:"name"`
	RegexValues types.List `tfsdk:"regex_values"`
	Status types.String `tfsdk:"status"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel represents financial_services block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel struct {
	Apply *CDNLoadBalancerEmptyModel `tfsdk:"apply"`
	MoneyTransfer *CDNLoadBalancerEmptyModel `tfsdk:"money_transfer"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel represents flight block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel struct {
	Checkin *CDNLoadBalancerEmptyModel `tfsdk:"checkin"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel represents profile_management block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel struct {
	Create *CDNLoadBalancerEmptyModel `tfsdk:"create"`
	Update *CDNLoadBalancerEmptyModel `tfsdk:"update"`
	View *CDNLoadBalancerEmptyModel `tfsdk:"view"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel represents search block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel struct {
	FlightSearch *CDNLoadBalancerEmptyModel `tfsdk:"flight_search"`
	ProductSearch *CDNLoadBalancerEmptyModel `tfsdk:"product_search"`
	ReservationSearch *CDNLoadBalancerEmptyModel `tfsdk:"reservation_search"`
	RoomSearch *CDNLoadBalancerEmptyModel `tfsdk:"room_search"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel represents shopping_gift_cards block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel struct {
	GiftCardMakePurchaseWithGiftCard *CDNLoadBalancerEmptyModel `tfsdk:"gift_card_make_purchase_with_gift_card"`
	GiftCardValidation *CDNLoadBalancerEmptyModel `tfsdk:"gift_card_validation"`
	ShopAddToCart *CDNLoadBalancerEmptyModel `tfsdk:"shop_add_to_cart"`
	ShopCheckout *CDNLoadBalancerEmptyModel `tfsdk:"shop_checkout"`
	ShopChooseSeat *CDNLoadBalancerEmptyModel `tfsdk:"shop_choose_seat"`
	ShopEnterDrawingSubmission *CDNLoadBalancerEmptyModel `tfsdk:"shop_enter_drawing_submission"`
	ShopMakePayment *CDNLoadBalancerEmptyModel `tfsdk:"shop_make_payment"`
	ShopOrder *CDNLoadBalancerEmptyModel `tfsdk:"shop_order"`
	ShopPriceInquiry *CDNLoadBalancerEmptyModel `tfsdk:"shop_price_inquiry"`
	ShopPromoCodeValidation *CDNLoadBalancerEmptyModel `tfsdk:"shop_promo_code_validation"`
	ShopPurchaseGiftCard *CDNLoadBalancerEmptyModel `tfsdk:"shop_purchase_gift_card"`
	ShopUpdateQuantity *CDNLoadBalancerEmptyModel `tfsdk:"shop_update_quantity"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel represents headers block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel represents item block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel represents metadata block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel represents mitigation block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel struct {
	Block *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel `tfsdk:"block"`
	Flag *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel `tfsdk:"flag"`
	Redirect *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel `tfsdk:"redirect"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel represents block block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel struct {
	Body types.String `tfsdk:"body"`
	Status types.String `tfsdk:"status"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel represents flag block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel struct {
	AppendHeaders *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel `tfsdk:"append_headers"`
	NoHeaders *CDNLoadBalancerEmptyModel `tfsdk:"no_headers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel represents append_headers block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel struct {
	AutoTypeHeaderName types.String `tfsdk:"auto_type_header_name"`
	InferenceHeaderName types.String `tfsdk:"inference_header_name"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel represents redirect block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel struct {
	URI types.String `tfsdk:"uri"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel represents path block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel represents query_params block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel represents item block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel represents web_mobile block
type CDNLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel struct {
	MobileIdentifier types.String `tfsdk:"mobile_identifier"`
}

// CDNLoadBalancerCaptchaChallengeModel represents captcha_challenge block
type CDNLoadBalancerCaptchaChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerClientSideDefenseModel represents client_side_defense block
type CDNLoadBalancerClientSideDefenseModel struct {
	Policy *CDNLoadBalancerClientSideDefensePolicyModel `tfsdk:"policy"`
}

// CDNLoadBalancerClientSideDefensePolicyModel represents policy block
type CDNLoadBalancerClientSideDefensePolicyModel struct {
	DisableJsInsert *CDNLoadBalancerEmptyModel `tfsdk:"disable_js_insert"`
	JsInsertAllPages *CDNLoadBalancerEmptyModel `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel `tfsdk:"js_insertion_rules"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel struct {
	ExcludeList []CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel `tfsdk:"domain"`
	Metadata *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel `tfsdk:"path"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type CDNLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules []CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel `tfsdk:"rules"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel `tfsdk:"domain"`
	Metadata *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel `tfsdk:"path"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel represents rules block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel struct {
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel `tfsdk:"domain"`
	Metadata *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel `tfsdk:"path"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel represents path block
type CDNLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerCorsPolicyModel represents cors_policy block
type CDNLoadBalancerCorsPolicyModel struct {
	AllowCredentials types.Bool `tfsdk:"allow_credentials"`
	AllowHeaders types.String `tfsdk:"allow_headers"`
	AllowMethods types.String `tfsdk:"allow_methods"`
	AllowOrigin types.List `tfsdk:"allow_origin"`
	AllowOriginRegex types.List `tfsdk:"allow_origin_regex"`
	Disabled types.Bool `tfsdk:"disabled"`
	ExposeHeaders types.String `tfsdk:"expose_headers"`
	MaximumAge types.Int64 `tfsdk:"maximum_age"`
}

// CDNLoadBalancerCsrfPolicyModel represents csrf_policy block
type CDNLoadBalancerCsrfPolicyModel struct {
	AllLoadBalancerDomains *CDNLoadBalancerEmptyModel `tfsdk:"all_load_balancer_domains"`
	CustomDomainList *CDNLoadBalancerCsrfPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled *CDNLoadBalancerEmptyModel `tfsdk:"disabled"`
}

// CDNLoadBalancerCsrfPolicyCustomDomainListModel represents custom_domain_list block
type CDNLoadBalancerCsrfPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// CDNLoadBalancerCustomCacheRuleModel represents custom_cache_rule block
type CDNLoadBalancerCustomCacheRuleModel struct {
	CDNCacheRules []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel `tfsdk:"cdn_cache_rules"`
}

// CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel represents cdn_cache_rules block
type CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerDataGuardRulesModel represents data_guard_rules block
type CDNLoadBalancerDataGuardRulesModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	ApplyDataGuard *CDNLoadBalancerEmptyModel `tfsdk:"apply_data_guard"`
	Metadata *CDNLoadBalancerDataGuardRulesMetadataModel `tfsdk:"metadata"`
	Path *CDNLoadBalancerDataGuardRulesPathModel `tfsdk:"path"`
	SkipDataGuard *CDNLoadBalancerEmptyModel `tfsdk:"skip_data_guard"`
}

// CDNLoadBalancerDataGuardRulesMetadataModel represents metadata block
type CDNLoadBalancerDataGuardRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerDataGuardRulesPathModel represents path block
type CDNLoadBalancerDataGuardRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerDdosMitigationRulesModel represents ddos_mitigation_rules block
type CDNLoadBalancerDdosMitigationRulesModel struct {
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	Block *CDNLoadBalancerEmptyModel `tfsdk:"block"`
	DdosClientSource *CDNLoadBalancerDdosMitigationRulesDdosClientSourceModel `tfsdk:"ddos_client_source"`
	IPPrefixList *CDNLoadBalancerDdosMitigationRulesIPPrefixListModel `tfsdk:"ip_prefix_list"`
	Metadata *CDNLoadBalancerDdosMitigationRulesMetadataModel `tfsdk:"metadata"`
}

// CDNLoadBalancerDdosMitigationRulesDdosClientSourceModel represents ddos_client_source block
type CDNLoadBalancerDdosMitigationRulesDdosClientSourceModel struct {
	CountryList types.List `tfsdk:"country_list"`
	AsnList *CDNLoadBalancerDdosMitigationRulesDdosClientSourceAsnListModel `tfsdk:"asn_list"`
	Ja4TLSFingerprintMatcher *CDNLoadBalancerDdosMitigationRulesDdosClientSourceJa4TLSFingerprintMatcherModel `tfsdk:"ja4_tls_fingerprint_matcher"`
	TLSFingerprintMatcher *CDNLoadBalancerDdosMitigationRulesDdosClientSourceTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerDdosMitigationRulesDdosClientSourceAsnListModel represents asn_list block
type CDNLoadBalancerDdosMitigationRulesDdosClientSourceAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerDdosMitigationRulesDdosClientSourceJa4TLSFingerprintMatcherModel represents ja4_tls_fingerprint_matcher block
type CDNLoadBalancerDdosMitigationRulesDdosClientSourceJa4TLSFingerprintMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
}

// CDNLoadBalancerDdosMitigationRulesDdosClientSourceTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerDdosMitigationRulesDdosClientSourceTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerDdosMitigationRulesIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerDdosMitigationRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerDdosMitigationRulesMetadataModel represents metadata block
type CDNLoadBalancerDdosMitigationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerDefaultCacheActionModel represents default_cache_action block
type CDNLoadBalancerDefaultCacheActionModel struct {
	CacheTtlDefault types.String `tfsdk:"cache_ttl_default"`
	CacheTtlOverride types.String `tfsdk:"cache_ttl_override"`
	CacheDisabled *CDNLoadBalancerEmptyModel `tfsdk:"cache_disabled"`
}

// CDNLoadBalancerEnableAPIDiscoveryModel represents enable_api_discovery block
type CDNLoadBalancerEnableAPIDiscoveryModel struct {
	APICrawler *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel `tfsdk:"api_crawler"`
	APIDiscoveryFromCodeScan *CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel `tfsdk:"api_discovery_from_code_scan"`
	CustomAPIAuthDiscovery *CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel `tfsdk:"custom_api_auth_discovery"`
	DefaultAPIAuthDiscovery *CDNLoadBalancerEmptyModel `tfsdk:"default_api_auth_discovery"`
	DisableLearnFromRedirectTraffic *CDNLoadBalancerEmptyModel `tfsdk:"disable_learn_from_redirect_traffic"`
	DiscoveredAPISettings *CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel `tfsdk:"discovered_api_settings"`
	EnableLearnFromRedirectTraffic *CDNLoadBalancerEmptyModel `tfsdk:"enable_learn_from_redirect_traffic"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel represents api_crawler block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerModel struct {
	APICrawlerConfig *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel `tfsdk:"api_crawler_config"`
	DisableAPICrawler *CDNLoadBalancerEmptyModel `tfsdk:"disable_api_crawler"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel represents api_crawler_config block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel struct {
	Domains []CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel `tfsdk:"domains"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel represents domains block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel struct {
	Domain types.String `tfsdk:"domain"`
	SimpleLogin *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel `tfsdk:"simple_login"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel represents simple_login block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel struct {
	User types.String `tfsdk:"user"`
	Password *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel `tfsdk:"password"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel represents password block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel represents api_discovery_from_code_scan block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel struct {
	CodeBaseIntegrations []CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel `tfsdk:"code_base_integrations"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel represents code_base_integrations block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel struct {
	AllRepos *CDNLoadBalancerEmptyModel `tfsdk:"all_repos"`
	CodeBaseIntegration *CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel `tfsdk:"code_base_integration"`
	SelectedRepos *CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel `tfsdk:"selected_repos"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel represents code_base_integration block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel represents selected_repos block
type CDNLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel struct {
	APICodeRepo types.List `tfsdk:"api_code_repo"`
}

// CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel represents custom_api_auth_discovery block
type CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel struct {
	APIDiscoveryRef *CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel `tfsdk:"api_discovery_ref"`
}

// CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel represents api_discovery_ref block
type CDNLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel represents discovered_api_settings block
type CDNLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel struct {
	PurgeDurationForInactiveDiscoveredApis types.Int64 `tfsdk:"purge_duration_for_inactive_discovered_apis"`
}

// CDNLoadBalancerEnableChallengeModel represents enable_challenge block
type CDNLoadBalancerEnableChallengeModel struct {
	CaptchaChallengeParameters *CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters *CDNLoadBalancerEmptyModel `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters *CDNLoadBalancerEmptyModel `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings *CDNLoadBalancerEmptyModel `tfsdk:"default_mitigation_settings"`
	JsChallengeParameters *CDNLoadBalancerEnableChallengeJsChallengeParametersModel `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation *CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel `tfsdk:"malicious_user_mitigation"`
}

// CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type CDNLoadBalancerEnableChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerEnableChallengeJsChallengeParametersModel represents js_challenge_parameters block
type CDNLoadBalancerEnableChallengeJsChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type CDNLoadBalancerEnableChallengeMaliciousUserMitigationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerEnableIPReputationModel represents enable_ip_reputation block
type CDNLoadBalancerEnableIPReputationModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// CDNLoadBalancerGraphqlRulesModel represents graphql_rules block
type CDNLoadBalancerGraphqlRulesModel struct {
	ExactPath types.String `tfsdk:"exact_path"`
	ExactValue types.String `tfsdk:"exact_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	GraphqlSettings *CDNLoadBalancerGraphqlRulesGraphqlSettingsModel `tfsdk:"graphql_settings"`
	Metadata *CDNLoadBalancerGraphqlRulesMetadataModel `tfsdk:"metadata"`
	MethodGet *CDNLoadBalancerEmptyModel `tfsdk:"method_get"`
	MethodPost *CDNLoadBalancerEmptyModel `tfsdk:"method_post"`
}

// CDNLoadBalancerGraphqlRulesGraphqlSettingsModel represents graphql_settings block
type CDNLoadBalancerGraphqlRulesGraphqlSettingsModel struct {
	MaxBatchedQueries types.Int64 `tfsdk:"max_batched_queries"`
	MaxDepth types.Int64 `tfsdk:"max_depth"`
	MaxTotalLength types.Int64 `tfsdk:"max_total_length"`
	DisableIntrospection *CDNLoadBalancerEmptyModel `tfsdk:"disable_introspection"`
	EnableIntrospection *CDNLoadBalancerEmptyModel `tfsdk:"enable_introspection"`
}

// CDNLoadBalancerGraphqlRulesMetadataModel represents metadata block
type CDNLoadBalancerGraphqlRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerHTTPModel represents http block
type CDNLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// CDNLoadBalancerHTTPSModel represents https block
type CDNLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	TLSCertOptions *CDNLoadBalancerHTTPSTLSCertOptionsModel `tfsdk:"tls_cert_options"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsModel represents tls_cert_options block
type CDNLoadBalancerHTTPSTLSCertOptionsModel struct {
	TLSCertParams *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSInlineParams *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel `tfsdk:"tls_inline_params"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel represents tls_cert_params block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsModel struct {
	Certificates []CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *CDNLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel represents certificates block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel represents tls_config block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigModel struct {
	CustomSecurity *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *CDNLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *CDNLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *CDNLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel represents use_mtls block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *CDNLoadBalancerEmptyModel `tfsdk:"no_crl"`
	TrustedCa *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *CDNLoadBalancerEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel represents crl block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel represents tls_inline_params block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsModel struct {
	NoMtls *CDNLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel represents tls_certificates block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *CDNLoadBalancerEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *CDNLoadBalancerEmptyModel `tfsdk:"use_system_defaults"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel represents private_key block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel represents tls_config block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigModel struct {
	CustomSecurity *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *CDNLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *CDNLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *CDNLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel represents custom_security block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel represents use_mtls block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *CDNLoadBalancerEmptyModel `tfsdk:"no_crl"`
	TrustedCa *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *CDNLoadBalancerEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel represents crl block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCaModel represents trusted_ca block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel represents xfcc_options block
type CDNLoadBalancerHTTPSTLSCertOptionsTLSInlineParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// CDNLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type CDNLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	TLSConfig *CDNLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
}

// CDNLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type CDNLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	TLS11Plus *CDNLoadBalancerEmptyModel `tfsdk:"tls_11_plus"`
	TLS12Plus *CDNLoadBalancerEmptyModel `tfsdk:"tls_12_plus"`
}

// CDNLoadBalancerJsChallengeModel represents js_challenge block
type CDNLoadBalancerJsChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerJwtValidationModel represents jwt_validation block
type CDNLoadBalancerJwtValidationModel struct {
	Action *CDNLoadBalancerJwtValidationActionModel `tfsdk:"action"`
	JwksConfig *CDNLoadBalancerJwtValidationJwksConfigModel `tfsdk:"jwks_config"`
	MandatoryClaims *CDNLoadBalancerJwtValidationMandatoryClaimsModel `tfsdk:"mandatory_claims"`
	ReservedClaims *CDNLoadBalancerJwtValidationReservedClaimsModel `tfsdk:"reserved_claims"`
	Target *CDNLoadBalancerJwtValidationTargetModel `tfsdk:"target"`
	TokenLocation *CDNLoadBalancerJwtValidationTokenLocationModel `tfsdk:"token_location"`
}

// CDNLoadBalancerJwtValidationActionModel represents action block
type CDNLoadBalancerJwtValidationActionModel struct {
	Block *CDNLoadBalancerEmptyModel `tfsdk:"block"`
	Report *CDNLoadBalancerEmptyModel `tfsdk:"report"`
}

// CDNLoadBalancerJwtValidationJwksConfigModel represents jwks_config block
type CDNLoadBalancerJwtValidationJwksConfigModel struct {
	Cleartext types.String `tfsdk:"cleartext"`
}

// CDNLoadBalancerJwtValidationMandatoryClaimsModel represents mandatory_claims block
type CDNLoadBalancerJwtValidationMandatoryClaimsModel struct {
	ClaimNames types.List `tfsdk:"claim_names"`
}

// CDNLoadBalancerJwtValidationReservedClaimsModel represents reserved_claims block
type CDNLoadBalancerJwtValidationReservedClaimsModel struct {
	Issuer types.String `tfsdk:"issuer"`
	Audience *CDNLoadBalancerJwtValidationReservedClaimsAudienceModel `tfsdk:"audience"`
	AudienceDisable *CDNLoadBalancerEmptyModel `tfsdk:"audience_disable"`
	IssuerDisable *CDNLoadBalancerEmptyModel `tfsdk:"issuer_disable"`
	ValidatePeriodDisable *CDNLoadBalancerEmptyModel `tfsdk:"validate_period_disable"`
	ValidatePeriodEnable *CDNLoadBalancerEmptyModel `tfsdk:"validate_period_enable"`
}

// CDNLoadBalancerJwtValidationReservedClaimsAudienceModel represents audience block
type CDNLoadBalancerJwtValidationReservedClaimsAudienceModel struct {
	Audiences types.List `tfsdk:"audiences"`
}

// CDNLoadBalancerJwtValidationTargetModel represents target block
type CDNLoadBalancerJwtValidationTargetModel struct {
	AllEndpoint *CDNLoadBalancerEmptyModel `tfsdk:"all_endpoint"`
	APIGroups *CDNLoadBalancerJwtValidationTargetAPIGroupsModel `tfsdk:"api_groups"`
	BasePaths *CDNLoadBalancerJwtValidationTargetBasePathsModel `tfsdk:"base_paths"`
}

// CDNLoadBalancerJwtValidationTargetAPIGroupsModel represents api_groups block
type CDNLoadBalancerJwtValidationTargetAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// CDNLoadBalancerJwtValidationTargetBasePathsModel represents base_paths block
type CDNLoadBalancerJwtValidationTargetBasePathsModel struct {
	BasePaths types.List `tfsdk:"base_paths"`
}

// CDNLoadBalancerJwtValidationTokenLocationModel represents token_location block
type CDNLoadBalancerJwtValidationTokenLocationModel struct {
	BearerToken *CDNLoadBalancerEmptyModel `tfsdk:"bearer_token"`
}

// CDNLoadBalancerL7DdosActionJsChallengeModel represents l7_ddos_action_js_challenge block
type CDNLoadBalancerL7DdosActionJsChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerOriginPoolModel represents origin_pool block
type CDNLoadBalancerOriginPoolModel struct {
	OriginRequestTimeout types.String `tfsdk:"origin_request_timeout"`
	MoreOriginOptions *CDNLoadBalancerOriginPoolMoreOriginOptionsModel `tfsdk:"more_origin_options"`
	NoTLS *CDNLoadBalancerEmptyModel `tfsdk:"no_tls"`
	OriginServers []CDNLoadBalancerOriginPoolOriginServersModel `tfsdk:"origin_servers"`
	PublicName *CDNLoadBalancerOriginPoolPublicNameModel `tfsdk:"public_name"`
	UseTLS *CDNLoadBalancerOriginPoolUseTLSModel `tfsdk:"use_tls"`
}

// CDNLoadBalancerOriginPoolMoreOriginOptionsModel represents more_origin_options block
type CDNLoadBalancerOriginPoolMoreOriginOptionsModel struct {
	EnableByteRangeRequest types.Bool `tfsdk:"enable_byte_range_request"`
	WebsocketProxy types.Bool `tfsdk:"websocket_proxy"`
}

// CDNLoadBalancerOriginPoolOriginServersModel represents origin_servers block
type CDNLoadBalancerOriginPoolOriginServersModel struct {
	Port types.Int64 `tfsdk:"port"`
	PublicIP *CDNLoadBalancerOriginPoolOriginServersPublicIPModel `tfsdk:"public_ip"`
	PublicName *CDNLoadBalancerOriginPoolOriginServersPublicNameModel `tfsdk:"public_name"`
}

// CDNLoadBalancerOriginPoolOriginServersPublicIPModel represents public_ip block
type CDNLoadBalancerOriginPoolOriginServersPublicIPModel struct {
	IP types.String `tfsdk:"ip"`
}

// CDNLoadBalancerOriginPoolOriginServersPublicNameModel represents public_name block
type CDNLoadBalancerOriginPoolOriginServersPublicNameModel struct {
	DNSName types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64 `tfsdk:"refresh_interval"`
}

// CDNLoadBalancerOriginPoolPublicNameModel represents public_name block
type CDNLoadBalancerOriginPoolPublicNameModel struct {
	DNSName types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64 `tfsdk:"refresh_interval"`
}

// CDNLoadBalancerOriginPoolUseTLSModel represents use_tls block
type CDNLoadBalancerOriginPoolUseTLSModel struct {
	MaxSessionKeys types.Int64 `tfsdk:"max_session_keys"`
	Sni types.String `tfsdk:"sni"`
	DefaultSessionKeyCaching *CDNLoadBalancerEmptyModel `tfsdk:"default_session_key_caching"`
	DisableSessionKeyCaching *CDNLoadBalancerEmptyModel `tfsdk:"disable_session_key_caching"`
	DisableSni *CDNLoadBalancerEmptyModel `tfsdk:"disable_sni"`
	NoMtls *CDNLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	SkipServerVerification *CDNLoadBalancerEmptyModel `tfsdk:"skip_server_verification"`
	TLSConfig *CDNLoadBalancerOriginPoolUseTLSTLSConfigModel `tfsdk:"tls_config"`
	UseHostHeaderAsSni *CDNLoadBalancerEmptyModel `tfsdk:"use_host_header_as_sni"`
	UseMtls *CDNLoadBalancerOriginPoolUseTLSUseMtlsModel `tfsdk:"use_mtls"`
	UseMtlsObj *CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel `tfsdk:"use_mtls_obj"`
	UseServerVerification *CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel `tfsdk:"use_server_verification"`
	VolterraTrustedCa *CDNLoadBalancerEmptyModel `tfsdk:"volterra_trusted_ca"`
}

// CDNLoadBalancerOriginPoolUseTLSTLSConfigModel represents tls_config block
type CDNLoadBalancerOriginPoolUseTLSTLSConfigModel struct {
	CustomSecurity *CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *CDNLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *CDNLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *CDNLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel represents custom_security block
type CDNLoadBalancerOriginPoolUseTLSTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsModel represents use_mtls block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsModel struct {
	TLSCertificates []CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel `tfsdk:"tls_certificates"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel represents tls_certificates block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *CDNLoadBalancerEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *CDNLoadBalancerEmptyModel `tfsdk:"use_system_defaults"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel represents private_key block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel represents use_mtls_obj block
type CDNLoadBalancerOriginPoolUseTLSUseMtlsObjModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel represents use_server_verification block
type CDNLoadBalancerOriginPoolUseTLSUseServerVerificationModel struct {
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	TrustedCa *CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCaModel `tfsdk:"trusted_ca"`
}

// CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCaModel represents trusted_ca block
type CDNLoadBalancerOriginPoolUseTLSUseServerVerificationTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerOtherSettingsModel represents other_settings block
type CDNLoadBalancerOtherSettingsModel struct {
	AddLocation types.Bool `tfsdk:"add_location"`
	HeaderOptions *CDNLoadBalancerOtherSettingsHeaderOptionsModel `tfsdk:"header_options"`
	LoggingOptions *CDNLoadBalancerOtherSettingsLoggingOptionsModel `tfsdk:"logging_options"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsModel represents header_options block
type CDNLoadBalancerOtherSettingsHeaderOptionsModel struct {
	RequestHeadersToRemove types.List `tfsdk:"request_headers_to_remove"`
	ResponseHeadersToRemove types.List `tfsdk:"response_headers_to_remove"`
	RequestHeadersToAdd []CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel `tfsdk:"request_headers_to_add"`
	ResponseHeadersToAdd []CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel represents request_headers_to_add block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddModel struct {
	Append types.Bool `tfsdk:"append"`
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
	SecretValue *CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel represents secret_value block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel represents response_headers_to_add block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddModel struct {
	Append types.Bool `tfsdk:"append"`
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
	SecretValue *CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel represents secret_value block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type CDNLoadBalancerOtherSettingsHeaderOptionsResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// CDNLoadBalancerOtherSettingsLoggingOptionsModel represents logging_options block
type CDNLoadBalancerOtherSettingsLoggingOptionsModel struct {
	ClientLogOptions *CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel `tfsdk:"client_log_options"`
	OriginLogOptions *CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel `tfsdk:"origin_log_options"`
}

// CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel represents client_log_options block
type CDNLoadBalancerOtherSettingsLoggingOptionsClientLogOptionsModel struct {
	HeaderList types.List `tfsdk:"header_list"`
}

// CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel represents origin_log_options block
type CDNLoadBalancerOtherSettingsLoggingOptionsOriginLogOptionsModel struct {
	HeaderList types.List `tfsdk:"header_list"`
}

// CDNLoadBalancerPolicyBasedChallengeModel represents policy_based_challenge block
type CDNLoadBalancerPolicyBasedChallengeModel struct {
	AlwaysEnableCaptchaChallenge *CDNLoadBalancerEmptyModel `tfsdk:"always_enable_captcha_challenge"`
	AlwaysEnableJsChallenge *CDNLoadBalancerEmptyModel `tfsdk:"always_enable_js_challenge"`
	CaptchaChallengeParameters *CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters *CDNLoadBalancerEmptyModel `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters *CDNLoadBalancerEmptyModel `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings *CDNLoadBalancerEmptyModel `tfsdk:"default_mitigation_settings"`
	DefaultTemporaryBlockingParameters *CDNLoadBalancerEmptyModel `tfsdk:"default_temporary_blocking_parameters"`
	JsChallengeParameters *CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation *CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel `tfsdk:"malicious_user_mitigation"`
	NoChallenge *CDNLoadBalancerEmptyModel `tfsdk:"no_challenge"`
	RuleList *CDNLoadBalancerPolicyBasedChallengeRuleListModel `tfsdk:"rule_list"`
	TemporaryUserBlocking *CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel `tfsdk:"temporary_user_blocking"`
}

// CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type CDNLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel represents js_challenge_parameters block
type CDNLoadBalancerPolicyBasedChallengeJsChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type CDNLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListModel represents rule_list block
type CDNLoadBalancerPolicyBasedChallengeRuleListModel struct {
	Rules []CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel `tfsdk:"rules"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel represents rules block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesModel struct {
	Metadata *CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel `tfsdk:"metadata"`
	Spec *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel `tfsdk:"spec"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel represents metadata block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel represents spec block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel struct {
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	AnyAsn *CDNLoadBalancerEmptyModel `tfsdk:"any_asn"`
	AnyClient *CDNLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *CDNLoadBalancerEmptyModel `tfsdk:"any_ip"`
	ArgMatchers []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel `tfsdk:"arg_matchers"`
	AsnList *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel `tfsdk:"asn_matcher"`
	BodyMatcher *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel `tfsdk:"body_matcher"`
	ClientSelector *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel `tfsdk:"client_selector"`
	CookieMatchers []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel `tfsdk:"cookie_matchers"`
	DisableChallenge *CDNLoadBalancerEmptyModel `tfsdk:"disable_challenge"`
	DomainMatcher *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel `tfsdk:"domain_matcher"`
	EnableCaptchaChallenge *CDNLoadBalancerEmptyModel `tfsdk:"enable_captcha_challenge"`
	EnableJavascriptChallenge *CDNLoadBalancerEmptyModel `tfsdk:"enable_javascript_challenge"`
	Headers []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel `tfsdk:"headers"`
	HTTPMethod *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel `tfsdk:"http_method"`
	IPMatcher *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel `tfsdk:"ip_prefix_list"`
	Path *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel `tfsdk:"path"`
	QueryParams []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel `tfsdk:"query_params"`
	TLSFingerprintMatcher *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel represents arg_matchers block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel represents asn_list block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel represents asn_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel struct {
	AsnSets []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel represents asn_sets block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel represents body_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel represents client_selector block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel represents cookie_matchers block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel represents domain_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel represents headers block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel represents http_method block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods types.List `tfsdk:"methods"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel represents ip_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel represents prefix_sets block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel represents ip_prefix_list block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel represents path block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixValues types.List `tfsdk:"prefix_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	SuffixValues types.List `tfsdk:"suffix_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel represents query_params block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *CDNLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel `tfsdk:"item"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel represents item block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type CDNLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel represents temporary_user_blocking block
type CDNLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel struct {
	CustomPage types.String `tfsdk:"custom_page"`
}

// CDNLoadBalancerProtectedCookiesModel represents protected_cookies block
type CDNLoadBalancerProtectedCookiesModel struct {
	MaxAgeValue types.Int64 `tfsdk:"max_age_value"`
	Name types.String `tfsdk:"name"`
	AddHttponly *CDNLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure *CDNLoadBalancerEmptyModel `tfsdk:"add_secure"`
	DisableTamperingProtection *CDNLoadBalancerEmptyModel `tfsdk:"disable_tampering_protection"`
	EnableTamperingProtection *CDNLoadBalancerEmptyModel `tfsdk:"enable_tampering_protection"`
	IgnoreHttponly *CDNLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreMaxAge *CDNLoadBalancerEmptyModel `tfsdk:"ignore_max_age"`
	IgnoreSamesite *CDNLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *CDNLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax *CDNLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *CDNLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *CDNLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// CDNLoadBalancerRateLimitModel represents rate_limit block
type CDNLoadBalancerRateLimitModel struct {
	CustomIPAllowedList *CDNLoadBalancerRateLimitCustomIPAllowedListModel `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList *CDNLoadBalancerRateLimitIPAllowedListModel `tfsdk:"ip_allowed_list"`
	NoIPAllowedList *CDNLoadBalancerEmptyModel `tfsdk:"no_ip_allowed_list"`
	NoPolicies *CDNLoadBalancerEmptyModel `tfsdk:"no_policies"`
	Policies *CDNLoadBalancerRateLimitPoliciesModel `tfsdk:"policies"`
	RateLimiter *CDNLoadBalancerRateLimitRateLimiterModel `tfsdk:"rate_limiter"`
}

// CDNLoadBalancerRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type CDNLoadBalancerRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type CDNLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerRateLimitIPAllowedListModel represents ip_allowed_list block
type CDNLoadBalancerRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// CDNLoadBalancerRateLimitPoliciesModel represents policies block
type CDNLoadBalancerRateLimitPoliciesModel struct {
	Policies []CDNLoadBalancerRateLimitPoliciesPoliciesModel `tfsdk:"policies"`
}

// CDNLoadBalancerRateLimitPoliciesPoliciesModel represents policies block
type CDNLoadBalancerRateLimitPoliciesPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerRateLimitRateLimiterModel represents rate_limiter block
type CDNLoadBalancerRateLimitRateLimiterModel struct {
	BurstMultiplier types.Int64 `tfsdk:"burst_multiplier"`
	PeriodMultiplier types.Int64 `tfsdk:"period_multiplier"`
	TotalNumber types.Int64 `tfsdk:"total_number"`
	Unit types.String `tfsdk:"unit"`
	ActionBlock *CDNLoadBalancerRateLimitRateLimiterActionBlockModel `tfsdk:"action_block"`
	Disabled *CDNLoadBalancerEmptyModel `tfsdk:"disabled"`
	LeakyBucket *CDNLoadBalancerEmptyModel `tfsdk:"leaky_bucket"`
	TokenBucket *CDNLoadBalancerEmptyModel `tfsdk:"token_bucket"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockModel represents action_block block
type CDNLoadBalancerRateLimitRateLimiterActionBlockModel struct {
	Hours *CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel `tfsdk:"hours"`
	Minutes *CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel `tfsdk:"minutes"`
	Seconds *CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel `tfsdk:"seconds"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel represents hours block
type CDNLoadBalancerRateLimitRateLimiterActionBlockHoursModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel represents minutes block
type CDNLoadBalancerRateLimitRateLimiterActionBlockMinutesModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel represents seconds block
type CDNLoadBalancerRateLimitRateLimiterActionBlockSecondsModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// CDNLoadBalancerSensitiveDataPolicyModel represents sensitive_data_policy block
type CDNLoadBalancerSensitiveDataPolicyModel struct {
	SensitiveDataPolicyRef *CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel `tfsdk:"sensitive_data_policy_ref"`
}

// CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel represents sensitive_data_policy_ref block
type CDNLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerSlowDdosMitigationModel represents slow_ddos_mitigation block
type CDNLoadBalancerSlowDdosMitigationModel struct {
	RequestHeadersTimeout types.Int64 `tfsdk:"request_headers_timeout"`
	RequestTimeout types.Int64 `tfsdk:"request_timeout"`
	DisableRequestTimeout *CDNLoadBalancerEmptyModel `tfsdk:"disable_request_timeout"`
}

// CDNLoadBalancerTrustedClientsModel represents trusted_clients block
type CDNLoadBalancerTrustedClientsModel struct {
	Actions types.List `tfsdk:"actions"`
	AsNumber types.Int64 `tfsdk:"as_number"`
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	IPPrefix types.String `tfsdk:"ip_prefix"`
	IPV6Prefix types.String `tfsdk:"ipv6_prefix"`
	UserIdentifier types.String `tfsdk:"user_identifier"`
	BotSkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"bot_skip_processing"`
	HTTPHeader *CDNLoadBalancerTrustedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata *CDNLoadBalancerTrustedClientsMetadataModel `tfsdk:"metadata"`
	SkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"skip_processing"`
	WAFSkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"waf_skip_processing"`
}

// CDNLoadBalancerTrustedClientsHTTPHeaderModel represents http_header block
type CDNLoadBalancerTrustedClientsHTTPHeaderModel struct {
	Headers []CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel represents headers block
type CDNLoadBalancerTrustedClientsHTTPHeaderHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// CDNLoadBalancerTrustedClientsMetadataModel represents metadata block
type CDNLoadBalancerTrustedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerUserIdentificationModel represents user_identification block
type CDNLoadBalancerUserIdentificationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// CDNLoadBalancerWAFExclusionModel represents waf_exclusion block
type CDNLoadBalancerWAFExclusionModel struct {
	WAFExclusionInlineRules *CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel `tfsdk:"waf_exclusion_inline_rules"`
	WAFExclusionPolicy *CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel `tfsdk:"waf_exclusion_policy"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel represents waf_exclusion_inline_rules block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesModel struct {
	Rules []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel `tfsdk:"rules"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel represents rules block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	Methods types.List `tfsdk:"methods"`
	PathPrefix types.String `tfsdk:"path_prefix"`
	PathRegex types.String `tfsdk:"path_regex"`
	SuffixValue types.String `tfsdk:"suffix_value"`
	AnyDomain *CDNLoadBalancerEmptyModel `tfsdk:"any_domain"`
	AnyPath *CDNLoadBalancerEmptyModel `tfsdk:"any_path"`
	AppFirewallDetectionControl *CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel `tfsdk:"app_firewall_detection_control"`
	Metadata *CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel `tfsdk:"metadata"`
	WAFSkipProcessing *CDNLoadBalancerEmptyModel `tfsdk:"waf_skip_processing"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel represents app_firewall_detection_control block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel struct {
	ExcludeAttackTypeContexts []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel `tfsdk:"exclude_attack_type_contexts"`
	ExcludeBotNameContexts []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel `tfsdk:"exclude_bot_name_contexts"`
	ExcludeSignatureContexts []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel `tfsdk:"exclude_signature_contexts"`
	ExcludeViolationContexts []CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel `tfsdk:"exclude_violation_contexts"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel represents exclude_attack_type_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel struct {
	Context types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	ExcludeAttackType types.String `tfsdk:"exclude_attack_type"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel represents exclude_bot_name_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel struct {
	BotName types.String `tfsdk:"bot_name"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel represents exclude_signature_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel struct {
	Context types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	SignatureID types.Int64 `tfsdk:"signature_id"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel represents exclude_violation_contexts block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel struct {
	Context types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	ExcludeViolation types.String `tfsdk:"exclude_violation"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel represents metadata block
type CDNLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel represents waf_exclusion_policy block
type CDNLoadBalancerWAFExclusionWAFExclusionPolicyModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

type CDNLoadBalancerResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Domains types.List `tfsdk:"domains"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	ActiveServicePolicies *CDNLoadBalancerActiveServicePoliciesModel `tfsdk:"active_service_policies"`
	APIRateLimit *CDNLoadBalancerAPIRateLimitModel `tfsdk:"api_rate_limit"`
	APISpecification *CDNLoadBalancerAPISpecificationModel `tfsdk:"api_specification"`
	AppFirewall *CDNLoadBalancerAppFirewallModel `tfsdk:"app_firewall"`
	BlockedClients []CDNLoadBalancerBlockedClientsModel `tfsdk:"blocked_clients"`
	BotDefense *CDNLoadBalancerBotDefenseModel `tfsdk:"bot_defense"`
	CaptchaChallenge *CDNLoadBalancerCaptchaChallengeModel `tfsdk:"captcha_challenge"`
	ClientSideDefense *CDNLoadBalancerClientSideDefenseModel `tfsdk:"client_side_defense"`
	CorsPolicy *CDNLoadBalancerCorsPolicyModel `tfsdk:"cors_policy"`
	CsrfPolicy *CDNLoadBalancerCsrfPolicyModel `tfsdk:"csrf_policy"`
	CustomCacheRule *CDNLoadBalancerCustomCacheRuleModel `tfsdk:"custom_cache_rule"`
	DataGuardRules []CDNLoadBalancerDataGuardRulesModel `tfsdk:"data_guard_rules"`
	DdosMitigationRules []CDNLoadBalancerDdosMitigationRulesModel `tfsdk:"ddos_mitigation_rules"`
	DefaultCacheAction *CDNLoadBalancerDefaultCacheActionModel `tfsdk:"default_cache_action"`
	DefaultSensitiveDataPolicy *CDNLoadBalancerEmptyModel `tfsdk:"default_sensitive_data_policy"`
	DisableAPIDefinition *CDNLoadBalancerEmptyModel `tfsdk:"disable_api_definition"`
	DisableAPIDiscovery *CDNLoadBalancerEmptyModel `tfsdk:"disable_api_discovery"`
	DisableClientSideDefense *CDNLoadBalancerEmptyModel `tfsdk:"disable_client_side_defense"`
	DisableIPReputation *CDNLoadBalancerEmptyModel `tfsdk:"disable_ip_reputation"`
	DisableMaliciousUserDetection *CDNLoadBalancerEmptyModel `tfsdk:"disable_malicious_user_detection"`
	DisableRateLimit *CDNLoadBalancerEmptyModel `tfsdk:"disable_rate_limit"`
	DisableThreatMesh *CDNLoadBalancerEmptyModel `tfsdk:"disable_threat_mesh"`
	DisableWAF *CDNLoadBalancerEmptyModel `tfsdk:"disable_waf"`
	EnableAPIDiscovery *CDNLoadBalancerEnableAPIDiscoveryModel `tfsdk:"enable_api_discovery"`
	EnableChallenge *CDNLoadBalancerEnableChallengeModel `tfsdk:"enable_challenge"`
	EnableIPReputation *CDNLoadBalancerEnableIPReputationModel `tfsdk:"enable_ip_reputation"`
	EnableMaliciousUserDetection *CDNLoadBalancerEmptyModel `tfsdk:"enable_malicious_user_detection"`
	EnableThreatMesh *CDNLoadBalancerEmptyModel `tfsdk:"enable_threat_mesh"`
	GraphqlRules []CDNLoadBalancerGraphqlRulesModel `tfsdk:"graphql_rules"`
	HTTP *CDNLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *CDNLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *CDNLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	JsChallenge *CDNLoadBalancerJsChallengeModel `tfsdk:"js_challenge"`
	JwtValidation *CDNLoadBalancerJwtValidationModel `tfsdk:"jwt_validation"`
	L7DdosActionBlock *CDNLoadBalancerEmptyModel `tfsdk:"l7_ddos_action_block"`
	L7DdosActionDefault *CDNLoadBalancerEmptyModel `tfsdk:"l7_ddos_action_default"`
	L7DdosActionJsChallenge *CDNLoadBalancerL7DdosActionJsChallengeModel `tfsdk:"l7_ddos_action_js_challenge"`
	NoChallenge *CDNLoadBalancerEmptyModel `tfsdk:"no_challenge"`
	NoServicePolicies *CDNLoadBalancerEmptyModel `tfsdk:"no_service_policies"`
	OriginPool *CDNLoadBalancerOriginPoolModel `tfsdk:"origin_pool"`
	OtherSettings *CDNLoadBalancerOtherSettingsModel `tfsdk:"other_settings"`
	PolicyBasedChallenge *CDNLoadBalancerPolicyBasedChallengeModel `tfsdk:"policy_based_challenge"`
	ProtectedCookies []CDNLoadBalancerProtectedCookiesModel `tfsdk:"protected_cookies"`
	RateLimit *CDNLoadBalancerRateLimitModel `tfsdk:"rate_limit"`
	SensitiveDataPolicy *CDNLoadBalancerSensitiveDataPolicyModel `tfsdk:"sensitive_data_policy"`
	ServicePoliciesFromNamespace *CDNLoadBalancerEmptyModel `tfsdk:"service_policies_from_namespace"`
	SlowDdosMitigation *CDNLoadBalancerSlowDdosMitigationModel `tfsdk:"slow_ddos_mitigation"`
	SystemDefaultTimeouts *CDNLoadBalancerEmptyModel `tfsdk:"system_default_timeouts"`
	TrustedClients []CDNLoadBalancerTrustedClientsModel `tfsdk:"trusted_clients"`
	UserIDClientIP *CDNLoadBalancerEmptyModel `tfsdk:"user_id_client_ip"`
	UserIdentification *CDNLoadBalancerUserIdentificationModel `tfsdk:"user_identification"`
	WAFExclusion *CDNLoadBalancerWAFExclusionModel `tfsdk:"waf_exclusion"`
}

func (r *CDNLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cdn_loadbalancer"
}

func (r *CDNLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             cdn_loadbalancerSchemaVersion,
		MarkdownDescription: "Manages a CDNLoadBalancer resource in F5 Distributed Cloud for content delivery and edge caching with load balancing.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the CDNLoadBalancer. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the CDNLoadBalancer will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "Domains. A list of fully qualified domain names. The CDN Distribution will be setup for these FQDN name(s). [This can be a domain or a sub-domain]",
				Optional: true,
				ElementType: types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_service_policies, no_service_policies, service_policies_from_namespace] Service Policy List. List of service policies.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"policies": schema.ListNestedBlock{
						MarkdownDescription: "Policies. Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the correct order (policies evaluated from top to bottom in the list) for service policies, to get the intended result. For each request, its characteristics are evaluated based on the match criteria in each service policy starting at the top. If there is a match in the current policy, then the policy takes effect, and no more policies are evaluated. Otherwise, the next policy is evaluated. If all policies are evaluated and none match, then the request will be denied by default.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},
				},

			},
			"api_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_rate_limit, disable_rate_limit, rate_limit] APIRateLimit.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_endpoint_rules": schema.ListNestedBlock{
						MarkdownDescription: "API Endpoints. Sets of rules for a specific endpoints. Order is matter as it uses first match policy. For creating rule that contain a whole domain or group of endpoints, please use the server URL rules above.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_endpoint_path": schema.StringAttribute{
									MarkdownDescription: "API Endpoint. The endpoint (path) of the request.",
									Optional: true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "Specific Domain. The rule will apply for a specific domain.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"api_endpoint_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP Method Matcher. A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional: true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "Method List. List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional: true,
													ElementType: types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional: true,
													ElementType: types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "Threshold. The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional: true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "Rate Limit Period Unit. Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"bypass_rate_limiting_rules": schema.SingleNestedBlock{
						MarkdownDescription: "Bypass Rate Limiting. This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"bypass_rate_limiting_rules": schema.ListNestedBlock{
								MarkdownDescription: "Bypass Rate Limiting. This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"base_path": schema.StringAttribute{
											MarkdownDescription: "Base Path. The base path which this validation applies to",
											Optional: true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "Specific Domain. The rule will apply for a specific domain. For example: api.example.com",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_url": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines api endpoint",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched",
													Optional: true,
												},
											},
										},
										"api_groups": schema.SingleNestedBlock{
											MarkdownDescription: "API Groups.",
											Attributes: map[string]schema.Attribute{
												"api_groups": schema.ListAttribute{
													MarkdownDescription: "API Groups.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"client_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional: true,
															ElementType: types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional: true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"ip_threat_category_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
													Attributes: map[string]schema.Attribute{
														"ip_threat_categories": schema.ListAttribute{
															MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
										"request_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"jwt_claims": schema.ListNestedBlock{
													MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert the match result.",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "JWT Claim Name. JWT claim name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional: true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom IP Allowed List. IP Allowed list using existing ip_prefix_set objects",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "List of IP Prefix Sets. References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"server_url_rules": schema.ListNestedBlock{
						MarkdownDescription: "Server URLs. Set of rules for entire domain or base path that contain multiple endpoints. Order is matter as it uses first match policy. For matching also specific endpoints you can use the API endpoint rules set bellow.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_group": schema.StringAttribute{
									MarkdownDescription: "API Group. API groups derived from API Definition swaggers. For example oas-all-operations including all paths and methods from the swaggers, oas-base-urls covering all requests under base-paths from the swaggers. Custom groups can be created if user tags paths or operations with 'x-volterra-api-group' extensions inside swaggers.",
									Optional: true,
								},
								"base_path": schema.StringAttribute{
									MarkdownDescription: "Base Path. Prefix of the request path.",
									Optional: true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "Specific Domain. The rule will apply for a specific domain.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional: true,
													ElementType: types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional: true,
													ElementType: types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "Threshold. The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional: true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "Rate Limit Period Unit. Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"api_specification": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_specification, disable_api_definition] API Specification and Validation. Settings for api specification (api definition, OpenAPI validation, etc.)",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_definition": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"validation_all_spec_endpoints": schema.SingleNestedBlock{
						MarkdownDescription: "API Inventory. Settings for API Inventory validation",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Fall Through Mode. x-required Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "API Group. The API group which this validation applies to",
															Optional: true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "Base Path. The base path which this validation applies to",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines api endpoint",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched",
																	Optional: true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional: true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "Common Settings. OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Validation Settings For Query Parameters. Custom settings for query parameters validation",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"validation_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Validation Mode. x-required Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"response_validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response",
										Attributes: map[string]schema.Attribute{
											"response_validation_properties": schema.ListAttribute{
												MarkdownDescription: "Response Validation Properties. List of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"skip_response_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request",
										Attributes: map[string]schema.Attribute{
											"request_validation_properties": schema.ListAttribute{
												MarkdownDescription: "Request Validation Properties. List of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
						},
					},
					"validation_custom_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom List. Define API groups, base paths, or API endpoints and their OpenAPI validation modes. Any other api-endpoint not listed will act according to 'Fall Through Mode'.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Fall Through Mode. x-required Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "API Group. The API group which this validation applies to",
															Optional: true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "Base Path. The base path which this validation applies to",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines api endpoint",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched",
																	Optional: true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional: true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"open_api_validation_rules": schema.ListNestedBlock{
								MarkdownDescription: "Validation List.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"api_group": schema.StringAttribute{
											MarkdownDescription: "API Group. The API group which this validation applies to",
											Optional: true,
										},
										"base_path": schema.StringAttribute{
											MarkdownDescription: "Base Path. The base path which this validation applies to",
											Optional: true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "Specific Domain. The rule will apply for a specific domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines api endpoint",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched",
													Optional: true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"validation_mode": schema.SingleNestedBlock{
											MarkdownDescription: "Validation Mode. x-required Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"response_validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response",
													Attributes: map[string]schema.Attribute{
														"response_validation_properties": schema.ListAttribute{
															MarkdownDescription: "Response Validation Properties. List of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"skip_response_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"skip_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request",
													Attributes: map[string]schema.Attribute{
														"request_validation_properties": schema.ListAttribute{
															MarkdownDescription: "Request Validation Properties. List of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "Common Settings. OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Validation Settings For Query Parameters. Custom settings for query parameters validation",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
						},
					},
					"validation_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"app_firewall": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: app_firewall, disable_waf] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"blocked_clients": schema.ListNestedBlock{
				MarkdownDescription: "Client Blocking Rules. Define rules to block IP Prefixes or AS numbers.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "Actions. Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional: true,
							ElementType: types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "AS Number. RFC 6793 defined 4-byte AS number",
							Optional: true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional: true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 Prefix. IPv4 prefix string.",
							Optional: true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 Prefix. IPv6 prefix string.",
							Optional: true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "User Identifier. Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs",
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "HTTP Headers. List of HTTP header name and value pairs",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"bot_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Bot Defense. This defines various configuration options for Bot Defense Policy.",
				Attributes: map[string]schema.Attribute{
					"regional_endpoint": schema.StringAttribute{
						MarkdownDescription: "Bot Defense Region. Defines a selection for Bot Defense region - AUTO: AUTO Automatic selection based on client IP address - US: US US region - EU: EU European Union region - ASIA: ASIA Asia region. Possible values are `AUTO`, `US`, `EU`, `ASIA`. Defaults to `AUTO`.",
						Optional: true,
					},
					"timeout": schema.Int64Attribute{
						MarkdownDescription: "Timeout. The timeout for the inference check, in milliseconds.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Bot Defense Policy. This defines various configuration options for Bot Defense policy.",
						Attributes: map[string]schema.Attribute{
							"javascript_mode": schema.StringAttribute{
								MarkdownDescription: "Web Client JavaScript Mode. Web Client JavaScript Mode. Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable Bot Defense JavaScript for telemetry collection is requested synchronously, and it is non-cacheable Bot Defense JavaScript for telemetry collection is requested synchronously, and it is cacheable. Possible values are `ASYNC_JS_NO_CACHING`, `ASYNC_JS_CACHING`, `SYNC_JS_NO_CACHING`, `SYNC_JS_CACHING`. Defaults to `ASYNC_JS_NO_CACHING`.",
								Optional: true,
							},
							"js_download_path": schema.StringAttribute{
								MarkdownDescription: "JavaScript Download Path. Customize Bot Defense Client JavaScript path. If not specified, default `/common.js`",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_mobile_sdk": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Bot Defense JavaScript in All Pages. Insert Bot Defense JavaScript in all pages",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional: true,
									},
								},
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert JavaScript in All Pages with the Exceptions. Insert Bot Defense JavaScript in all pages with the exceptions",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Pages. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "JavaScript Custom Insertion Rules. This defines custom JavaScript insertion rules for Bot Defense Policy.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Paths. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "JavaScript Insertions. Required list of pages to insert Bot Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"javascript_location": schema.StringAttribute{
													MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"mobile_sdk_config": schema.SingleNestedBlock{
								MarkdownDescription: "Mobile SDK Configuration. Mobile SDK configuration.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"mobile_identifier": schema.SingleNestedBlock{
										MarkdownDescription: "Mobile Traffic Identifier. Mobile traffic identifier type.",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"headers": schema.ListNestedBlock{
												MarkdownDescription: "Headers. Headers that can be used to identify mobile traffic.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"check_not_present": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"check_present": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"item": schema.SingleNestedBlock{
															MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
															Attributes: map[string]schema.Attribute{
																"exact_values": schema.ListAttribute{
																	MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"regex_values": schema.ListAttribute{
																	MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"transformers": schema.ListAttribute{
																	MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																	Optional: true,
																	ElementType: types.StringType,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"protected_app_endpoints": schema.ListNestedBlock{
								MarkdownDescription: "App Endpoint Type. List of protected endpoints. Limit: Approx '128 endpoints per Load Balancer (LB)' upto 4 LBs, '32 endpoints per LB' after 4 LBs.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"http_methods": schema.ListAttribute{
											MarkdownDescription: "HTTP Methods. List of HTTP methods. Possible values are `METHOD_ANY`, `METHOD_GET`, `METHOD_POST`, `METHOD_PUT`, `METHOD_PATCH`, `METHOD_DELETE`, `METHOD_GET_DOCUMENT`. Defaults to `METHOD_ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"protocol": schema.StringAttribute{
											MarkdownDescription: "URL Scheme. SchemeType is used to indicate URL scheme. - BOTH: BOTH URL scheme for https:// or http://. - HTTP: HTTP URL scheme http:// only. - HTTPS: HTTPS URL scheme https:// only. Possible values are `BOTH`, `HTTP`, `HTTPS`. Defaults to `BOTH`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"allow_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact Value. Exact domain name.",
													Optional: true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
													Optional: true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
													Optional: true,
												},
											},
										},
										"flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Defense Flow Label Category. Bot Defense Flow Label Category allows to associate traffic with selected category",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"account_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Account Management Category. Bot Defense Flow Label Account Management Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"password_reset": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"authentication": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Authentication Category. Bot Defense Flow Label Authentication Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"login": schema.SingleNestedBlock{
															MarkdownDescription: "Bot Defense Transaction Result. Bot Defense Transaction Result",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"disable_transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Bot Defense Transaction Result Type. Bot Defense Transaction ResultType",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"failure_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Failure Conditions. Failure Conditions",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional: true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional: true,
																					},
																				},
																			},
																		},
																		"success_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Success Conditions. Success Conditions",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional: true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"login_mfa": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"login_partner": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"logout": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"token_refresh": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"financial_services": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Financial Services Category. Bot Defense Flow Label Financial Services Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"apply": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"money_transfer": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"flight": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Flight Category. Bot Defense Flow Label Flight Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"checkin": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"profile_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Profile Management Category. Bot Defense Flow Label Profile Management Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"update": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"view": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"search": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Search Category. Bot Defense Flow Label Search Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"flight_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"product_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"reservation_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"room_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"shopping_gift_cards": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Shopping & Gift Cards Category. Bot Defense Flow Label Shopping & Gift Cards Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"gift_card_make_purchase_with_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"gift_card_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_add_to_cart": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_checkout": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_choose_seat": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_enter_drawing_submission": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_make_payment": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_order": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_price_inquiry": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_promo_code_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_purchase_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_update_quantity": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"mitigate_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"mitigation": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Mitigation Action. Modify Bot Defense behavior for a matching request.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"block": schema.SingleNestedBlock{
													MarkdownDescription: "Block bot mitigation. Block request and respond with custom content.",
													Attributes: map[string]schema.Attribute{
														"body": schema.StringAttribute{
															MarkdownDescription: "Body. Custom body message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Your request was blocked' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Your request was blocked </p>'. Base64 encoded string for this html is 'LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg=='",
															Optional: true,
														},
														"status": schema.StringAttribute{
															MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
															Optional: true,
														},
													},
												},
												"flag": schema.SingleNestedBlock{
													MarkdownDescription: "Select Flag Bot Mitigation Action. Flag mitigation action.",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"append_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Append Flag Mitigation Headers. Append flag mitigation headers to forwarded request.",
															Attributes: map[string]schema.Attribute{
																"auto_type_header_name": schema.StringAttribute{
																	MarkdownDescription: "Automation Type Header Name. A case-insensitive HTTP header name.",
																	Optional: true,
																},
																"inference_header_name": schema.StringAttribute{
																	MarkdownDescription: "Inference Header Name. A case-insensitive HTTP header name.",
																	Optional: true,
																},
															},
														},
														"no_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"redirect": schema.SingleNestedBlock{
													MarkdownDescription: "Redirect bot mitigation. Redirect request to a custom URI.",
													Attributes: map[string]schema.Attribute{
														"uri": schema.StringAttribute{
															MarkdownDescription: "URI. URI location for redirect may be relative or absolute.",
															Optional: true,
														},
													},
												},
											},
										},
										"mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact. Exact path value to match",
													Optional: true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
													Optional: true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
													Optional: true,
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"undefined_flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"web": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"web_mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Web and Mobile traffic type. Web and Mobile traffic type",
											Attributes: map[string]schema.Attribute{
												"mobile_identifier": schema.StringAttribute{
													MarkdownDescription: "Mobile Identifier. Mobile identifier type - HEADERS: Headers Headers. The only possible value is `HEADERS`. Defaults to `HEADERS`.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"captcha_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: captcha_challenge, enable_challenge, js_challenge, no_challenge, policy_based_challenge] Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional: true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
						Optional: true,
					},
				},

			},
			"client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: client_side_defense, disable_client_side_defense] Client-Side Defense. This defines various configuration options for Client-Side Defense Policy.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Client-Side Defense Policy. This defines various configuration options for Client-Side Defense policy.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert JavaScript in All Pages with the Exceptions. Insert Client-Side Defense JavaScript in all pages with the exceptions",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Pages. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "JavaScript Custom Insertion Rules. This defines custom JavaScript insertion rules for Client-Side Defense Policy.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Paths. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "JavaScript Insertions. Required list of pages to insert Client-Side Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"cors_policy": schema.SingleNestedBlock{
				MarkdownDescription: "CORS Policy. Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html Origin: http://foo.example HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2.0.61 Access-Control-Allow-Origin: * Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml An example for cross origin HTTP OPTIONS request with Access-Control-Request-* header OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type HTTP/1.1 204 No Content Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Keep-Alive: timeout=2, max=100 Connection: Keep-Alive",
				Attributes: map[string]schema.Attribute{
					"allow_credentials": schema.BoolAttribute{
						MarkdownDescription: "Allow Credentials. Specifies whether the resource allows credentials",
						Optional: true,
					},
					"allow_headers": schema.StringAttribute{
						MarkdownDescription: "Allow Headers. Specifies the content for the access-control-allow-headers header",
						Optional: true,
					},
					"allow_methods": schema.StringAttribute{
						MarkdownDescription: "Allow Methods. Specifies the content for the access-control-allow-methods header",
						Optional: true,
					},
					"allow_origin": schema.ListAttribute{
						MarkdownDescription: "Allow Origin. Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match",
						Optional: true,
						ElementType: types.StringType,
					},
					"allow_origin_regex": schema.ListAttribute{
						MarkdownDescription: "Allow Origin Regex. Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match",
						Optional: true,
						ElementType: types.StringType,
					},
					"disabled": schema.BoolAttribute{
						MarkdownDescription: "Disabled. Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host",
						Optional: true,
					},
					"expose_headers": schema.StringAttribute{
						MarkdownDescription: "Expose Headers. Specifies the content for the access-control-expose-headers header",
						Optional: true,
					},
					"maximum_age": schema.Int64Attribute{
						MarkdownDescription: "Maximum Age. Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours)",
						Optional: true,
					},
				},

			},
			"csrf_policy": schema.SingleNestedBlock{
				MarkdownDescription: "CSRF Policy. To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.The policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to issue the request (source origin). 2. The origin that the request is going to (target origin). When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being if the source-origin has been added to they policy as valid. Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"all_load_balancer_domains": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"custom_domain_list": schema.SingleNestedBlock{
						MarkdownDescription: "Domain name list. List of domain names used for Host header matching",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "Domain names. A list of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"custom_cache_rule": schema.SingleNestedBlock{
				MarkdownDescription: "Custom Cache Rules. Caching policies for CDN",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"cdn_cache_rules": schema.ListNestedBlock{
						MarkdownDescription: "CDN Cache Rule. Reference to CDN Cache Rule configuration object",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},
				},

			},
			"data_guard_rules": schema.ListNestedBlock{
				MarkdownDescription: "Data Guard Rules. Data Guard prevents responses from exposing sensitive information by masking the data. The system masks credit card numbers and social security numbers leaked from the application from within the http response with a string of asterisks (*). Note: App Firewall should be enabled, to use Data Guard feature.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact Value. Exact domain name",
							Optional: true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"apply_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"path": schema.SingleNestedBlock{
							MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
							Attributes: map[string]schema.Attribute{
								"path": schema.StringAttribute{
									MarkdownDescription: "Exact. Exact path value to match",
									Optional: true,
								},
								"prefix": schema.StringAttribute{
									MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
									Optional: true,
								},
								"regex": schema.StringAttribute{
									MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
									Optional: true,
								},
							},
						},
						"skip_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"ddos_mitigation_rules": schema.ListNestedBlock{
				MarkdownDescription: "DDoS Mitigation Rules. Define manual mitigation rules to block L7 DDoS attacks.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"block": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ddos_client_source": schema.SingleNestedBlock{
							MarkdownDescription: "DDoS Client Source Choice. DDoS Mitigation sources to be blocked",
							Attributes: map[string]schema.Attribute{
								"country_list": schema.ListAttribute{
									MarkdownDescription: "Country List. Sources that are located in one of the countries in the given list. Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
									Optional: true,
									ElementType: types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional: true,
											ElementType: types.Int64Type,
										},
									},
								},
								"ja4_tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "JA4 TLS Fingerprint Matcher. An extended version of JA3 that includes additional fields for more comprehensive fingerprinting of SSL/TLS clients and potentially has a different structure and length.",
									Attributes: map[string]schema.Attribute{
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "Exact Values. A list of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
									Attributes: map[string]schema.Attribute{
										"classes": schema.ListAttribute{
											MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
											Optional: true,
											ElementType: types.StringType,
										},
										"excluded_values": schema.ListAttribute{
											MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
							},
						},
						"ip_prefix_list": schema.SingleNestedBlock{
							MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
							Attributes: map[string]schema.Attribute{
								"invert_match": schema.BoolAttribute{
									MarkdownDescription: "Invert Match Result. Invert the match result.",
									Optional: true,
								},
								"ip_prefixes": schema.ListAttribute{
									MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
									Optional: true,
									ElementType: types.StringType,
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
					},

				},
			},
			"default_cache_action": schema.SingleNestedBlock{
				MarkdownDescription: "Default Cache Behaviour. This defines a Default Cache Action",
				Attributes: map[string]schema.Attribute{
					"cache_ttl_default": schema.StringAttribute{
						MarkdownDescription: "Fallback Cache TTL (d/ h/ m). Use Cache TTL Provided by Origin, and set a contigency TTL value in case one is not provided",
						Optional: true,
					},
					"cache_ttl_override": schema.StringAttribute{
						MarkdownDescription: "Override Cache TTL (d/ h/ m/ s). Always override the Cahce TTL provided by Origin",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"cache_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"default_sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_sensitive_data_policy, sensitive_data_policy] Empty. This can be used for messages where no values are needed",
			},
			"disable_api_definition": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_api_discovery, enable_api_discovery] Empty. This can be used for messages where no values are needed",
			},
			"disable_client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ip_reputation, enable_ip_reputation] Empty. This can be used for messages where no values are needed",
			},
			"disable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_malicious_user_detection, enable_malicious_user_detection] Empty. This can be used for messages where no values are needed",
			},
			"disable_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_threat_mesh, enable_threat_mesh] Empty. This can be used for messages where no values are needed",
			},
			"disable_waf": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"enable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "API Discovery Setting. Specifies the settings used for API discovery",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_crawler": schema.SingleNestedBlock{
						MarkdownDescription: "API Crawling. Api Crawler message",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"api_crawler_config": schema.SingleNestedBlock{
								MarkdownDescription: "Crawler Configure.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"domains": schema.ListNestedBlock{
										MarkdownDescription: "Domains to Crawl. Enter domains and their credentials to allow authenticated API crawling. You can only include domains you own that are associated with this Load Balancer.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"domain": schema.StringAttribute{
													MarkdownDescription: "Domain. Select the domain to execute API Crawling with given credentials.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"simple_login": schema.SingleNestedBlock{
													MarkdownDescription: "Simple Login.",
													Attributes: map[string]schema.Attribute{
														"user": schema.StringAttribute{
															MarkdownDescription: "User. Enter the username to assign credentials for the selected domain to crawl",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"password": schema.SingleNestedBlock{
															MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional: true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																			Optional: true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional: true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional: true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"disable_api_crawler": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"api_discovery_from_code_scan": schema.SingleNestedBlock{
						MarkdownDescription: "Select Code Base and Repositories. x-required",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"code_base_integrations": schema.ListNestedBlock{
								MarkdownDescription: "Select Code Base Integrations.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"all_repos": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"code_base_integration": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"selected_repos": schema.SingleNestedBlock{
											MarkdownDescription: "API Code Repositories. Select which API repositories represent the LB applications",
											Attributes: map[string]schema.Attribute{
												"api_code_repo": schema.ListAttribute{
													MarkdownDescription: "API Code Repository. Code repository which contain API endpoints",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "API Discovery Advanced Settings. API Discovery Advanced settings",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"api_discovery_ref": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
						},
					},
					"default_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"discovered_api_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Discovered API Settings. x-example: '2' Configure Discovered API Settings.",
						Attributes: map[string]schema.Attribute{
							"purge_duration_for_inactive_discovered_apis": schema.Int64Attribute{
								MarkdownDescription: "Purge Duration for Inactive Discovered APIs from Traffic. Inactive discovered API will be deleted after configured duration.",
								Optional: true,
							},
						},
					},
					"enable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"enable_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enable Malicious User Challenge. Configure auto mitigation i.e risk based challenges for malicious users",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
								Optional: true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"enable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "IP Threat Category List. List of ip threat categories",
				Attributes: map[string]schema.Attribute{
					"ip_threat_categories": schema.ListAttribute{
						MarkdownDescription: "List of IP Threat Categories to choose. If the source IP matches on atleast one of the enabled IP threat categories, the request will be denied. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
						Optional: true,
						ElementType: types.StringType,
					},
				},

			},
			"enable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"enable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"graphql_rules": schema.ListNestedBlock{
				MarkdownDescription: "GraphQL Inspection. GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it easier to evolve APIs over time, and enables powerful developer tools. Policy configuration to analyze GraphQL queries and prevent GraphQL tailored attacks.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_path": schema.StringAttribute{
							MarkdownDescription: "Path. Specifies the exact path to GraphQL endpoint. Defaults to `/graphql`.",
							Optional: true,
						},
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact Value. Exact domain name",
							Optional: true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"graphql_settings": schema.SingleNestedBlock{
							MarkdownDescription: "GraphQL Settings. GraphQL configuration.",
							Attributes: map[string]schema.Attribute{
								"max_batched_queries": schema.Int64Attribute{
									MarkdownDescription: "Maximum Batched Queries. Specify maximum number of queries in a single batched request.",
									Optional: true,
								},
								"max_depth": schema.Int64Attribute{
									MarkdownDescription: "Maximum Structure Depth. Specify maximum depth for the GraphQL query.",
									Optional: true,
								},
								"max_total_length": schema.Int64Attribute{
									MarkdownDescription: "Maximum Total Length. Specify maximum length in bytes for the GraphQL query.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"disable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"enable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"method_get": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"method_post": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"http": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: http, https, https_auto_cert] HTTP Choice. Choice for selecting HTTP proxy",
				Attributes: map[string]schema.Attribute{
					"dns_volterra_managed": schema.BoolAttribute{
						MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
						Optional: true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
						Optional: true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional: true,
					},
				},

			},
			"https": schema.SingleNestedBlock{
				MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting CDN Distribution with bring your own certificates",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
						Optional: true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"tls_cert_options": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Options. TLS Certificate Options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"tls_cert_params": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"certificates": schema.ListNestedBlock{
										MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
									"no_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"tls_config": schema.SingleNestedBlock{
										MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"custom_security": schema.SingleNestedBlock{
												MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
												Attributes: map[string]schema.Attribute{
													"cipher_suites": schema.ListAttribute{
														MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
														Optional: true,
														ElementType: types.StringType,
													},
													"max_version": schema.StringAttribute{
														MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional: true,
													},
													"min_version": schema.StringAttribute{
														MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional: true,
													},
												},
											},
											"default_security": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"low_security": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"medium_security": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"use_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
										Attributes: map[string]schema.Attribute{
											"client_certificate_optional": schema.BoolAttribute{
												MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
												Optional: true,
											},
											"trusted_ca_url": schema.StringAttribute{
												MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"crl": schema.SingleNestedBlock{
												MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
												},
											},
											"no_crl": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"trusted_ca": schema.SingleNestedBlock{
												MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
												},
											},
											"xfcc_disabled": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"xfcc_options": schema.SingleNestedBlock{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
												Attributes: map[string]schema.Attribute{
													"xfcc_header_elements": schema.ListAttribute{
														MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
														Optional: true,
														ElementType: types.StringType,
													},
												},
											},
										},
									},
								},
							},
							"tls_inline_params": schema.SingleNestedBlock{
								MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"no_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional: true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional: true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																	Optional: true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																	Optional: true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																	Optional: true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																	Optional: true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
									"tls_config": schema.SingleNestedBlock{
										MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"custom_security": schema.SingleNestedBlock{
												MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
												Attributes: map[string]schema.Attribute{
													"cipher_suites": schema.ListAttribute{
														MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
														Optional: true,
														ElementType: types.StringType,
													},
													"max_version": schema.StringAttribute{
														MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional: true,
													},
													"min_version": schema.StringAttribute{
														MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional: true,
													},
												},
											},
											"default_security": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"low_security": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"medium_security": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"use_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
										Attributes: map[string]schema.Attribute{
											"client_certificate_optional": schema.BoolAttribute{
												MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
												Optional: true,
											},
											"trusted_ca_url": schema.StringAttribute{
												MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"crl": schema.SingleNestedBlock{
												MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
												},
											},
											"no_crl": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"trusted_ca": schema.SingleNestedBlock{
												MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
												},
											},
											"xfcc_disabled": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"xfcc_options": schema.SingleNestedBlock{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
												Attributes: map[string]schema.Attribute{
													"xfcc_header_elements": schema.ListAttribute{
														MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
														Optional: true,
														ElementType: types.StringType,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"https_auto_cert": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS with Automatic Certificate. Choice for selecting HTTPS CDN distribution with bring your own certificates",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
						Optional: true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"tls_11_plus": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_12_plus": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional: true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
						Optional: true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
						Optional: true,
					},
				},

			},
			"jwt_validation": schema.SingleNestedBlock{
				MarkdownDescription: "JWT Validation. JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming JWTs before they are passed to your API origin. JWT Validation will also stop requests with expired tokens or tokens that are not yet valid.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"action": schema.SingleNestedBlock{
						MarkdownDescription: "Action.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"block": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"report": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"jwks_config": schema.SingleNestedBlock{
						MarkdownDescription: "JSON Web Key Set (JWKS). The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
						Attributes: map[string]schema.Attribute{
							"cleartext": schema.StringAttribute{
								MarkdownDescription: "JSON Web Key Set (JWKS). The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
								Optional: true,
							},
						},
					},
					"mandatory_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Mandatory Claims. Configurable Validation of mandatory Claims.",
						Attributes: map[string]schema.Attribute{
							"claim_names": schema.ListAttribute{
								MarkdownDescription: "Claim Names.",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"reserved_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Reserved claims configuration. Configurable Validation of reserved Claims",
						Attributes: map[string]schema.Attribute{
							"issuer": schema.StringAttribute{
								MarkdownDescription: "Exact Match.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"audience": schema.SingleNestedBlock{
								MarkdownDescription: "Audiences.",
								Attributes: map[string]schema.Attribute{
									"audiences": schema.ListAttribute{
										MarkdownDescription: "Values.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
							"audience_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"issuer_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"validate_period_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"validate_period_enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"target": schema.SingleNestedBlock{
						MarkdownDescription: "Target. Define endpoints for which JWT token validation will be performed",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_endpoint": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"api_groups": schema.SingleNestedBlock{
								MarkdownDescription: "API Groups.",
								Attributes: map[string]schema.Attribute{
									"api_groups": schema.ListAttribute{
										MarkdownDescription: "API Groups.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
							"base_paths": schema.SingleNestedBlock{
								MarkdownDescription: "Base Paths.",
								Attributes: map[string]schema.Attribute{
									"base_paths": schema.ListAttribute{
										MarkdownDescription: "Prefix Values.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
						},
					},
					"token_location": schema.SingleNestedBlock{
						MarkdownDescription: "Token Location. Location of JWT in Http request",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"bearer_token": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"l7_ddos_action_block": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: l7_ddos_action_block, l7_ddos_action_default, l7_ddos_action_js_challenge] Empty. This can be used for messages where no values are needed",
			},
			"l7_ddos_action_default": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"l7_ddos_action_js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional: true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
						Optional: true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
						Optional: true,
					},
				},

			},
			"no_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"origin_pool": schema.SingleNestedBlock{
				MarkdownDescription: "CDN Origin Pool. Origin Pool for the CDN distribution",
				Attributes: map[string]schema.Attribute{
					"origin_request_timeout": schema.StringAttribute{
						MarkdownDescription: "Origin Request Timeout Duration. Configures the time after which a request to the origin will time out waiting for a response",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"more_origin_options": schema.SingleNestedBlock{
						MarkdownDescription: "Origin Byte Range Request Config.",
						Attributes: map[string]schema.Attribute{
							"enable_byte_range_request": schema.BoolAttribute{
								MarkdownDescription: "Enable Origin Byte Range Requests. Choice to enable/disable byte range requests towards origin",
								Optional: true,
							},
							"websocket_proxy": schema.BoolAttribute{
								MarkdownDescription: "Enable websocket proxy to the origin. Option to enable proxying of websocket connections to the origin server",
								Optional: true,
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"origin_servers": schema.ListNestedBlock{
						MarkdownDescription: "List Of Origin Servers. List of original servers",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Origin Server Port. Port the workload can be reached on",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"public_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Public IP. Specify origin server with public IP address",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Public IPV4. Public IPV4 address",
											Optional: true,
										},
									},
								},
								"public_name": schema.SingleNestedBlock{
									MarkdownDescription: "Public DNS Name. Specify origin server with public DNS name",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name",
											Optional: true,
										},
										"refresh_interval": schema.Int64Attribute{
											MarkdownDescription: "DNS Refresh Interval. Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"public_name": schema.SingleNestedBlock{
						MarkdownDescription: "Public DNS Name. Specify origin server with public DNS name",
						Attributes: map[string]schema.Attribute{
							"dns_name": schema.StringAttribute{
								MarkdownDescription: "DNS Name. DNS Name",
								Optional: true,
							},
							"refresh_interval": schema.Int64Attribute{
								MarkdownDescription: "DNS Refresh Interval. Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767",
								Optional: true,
							},
						},
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters for Origin Servers. Upstream TLS Parameters",
						Attributes: map[string]schema.Attribute{
							"max_session_keys": schema.Int64Attribute{
								MarkdownDescription: "Max Session Keys Cached. x-example:'25' Number of session keys that are cached.",
								Optional: true,
							},
							"sni": schema.StringAttribute{
								MarkdownDescription: "SNI Value. SNI value to be used.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"default_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"skip_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_host_header_as_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Certificate. mTLS Client Certificate",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "mTLS Client Certificate. mTLS Client Certificate",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional: true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional: true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																	Optional: true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																	Optional: true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																	Optional: true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																	Optional: true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
							"use_mtls_obj": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"use_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Validation Context for Origin Servers. Upstream TLS Validation Context",
								Attributes: map[string]schema.Attribute{
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Origin Pool for verification of server's certificate",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
								},
							},
							"volterra_trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"other_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Other Settings. Other Settings",
				Attributes: map[string]schema.Attribute{
					"add_location": schema.BoolAttribute{
						MarkdownDescription: "Add Location. x-example: true Appends header x-volterra-location = <re-site-name> in responses.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"header_options": schema.SingleNestedBlock{
						MarkdownDescription: "Header Control. This defines various options related to request/response headers",
						Attributes: map[string]schema.Attribute{
							"request_headers_to_remove": schema.ListAttribute{
								MarkdownDescription: "Remove Origin Request Headers. List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
								Optional: true,
								ElementType: types.StringType,
							},
							"response_headers_to_remove": schema.ListAttribute{
								MarkdownDescription: "Remove Response Headers. List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
								Optional: true,
								ElementType: types.StringType,
							},
						},
						Blocks: map[string]schema.Block{
							"request_headers_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Add Origin Request Headers. Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"append": schema.BoolAttribute{
											MarkdownDescription: "Append. Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. Name of the HTTP header.",
											Optional: true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value. Value of the HTTP header.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"response_headers_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Add Response Headers. Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"append": schema.BoolAttribute{
											MarkdownDescription: "Append. Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. Name of the HTTP header.",
											Optional: true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value. Value of the HTTP header.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"logging_options": schema.SingleNestedBlock{
						MarkdownDescription: "Logging Options. This defines various options related to logging",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"client_log_options": schema.SingleNestedBlock{
								MarkdownDescription: "Headers to Log. List of headers to Log",
								Attributes: map[string]schema.Attribute{
									"header_list": schema.ListAttribute{
										MarkdownDescription: "Headers. List of headers",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
							"origin_log_options": schema.SingleNestedBlock{
								MarkdownDescription: "Headers to Log. List of headers to Log",
								Attributes: map[string]schema.Attribute{
									"header_list": schema.ListAttribute{
										MarkdownDescription: "Headers. List of headers",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
						},
					},
				},

			},
			"policy_based_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Policy Based Challenge. Specifies the settings for policy rule based challenge",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"always_enable_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"always_enable_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_temporary_blocking_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
								Optional: true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"no_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"rule_list": schema.SingleNestedBlock{
						MarkdownDescription: "Challenge Rule List. List of challenge rules to be used in policy based challenge",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Rules. Rules that specify the match conditions and challenge type to be launched. When a challenge type is selected to be always enabled, these rules can be used to disable challenge or launch a different challenge for requests that match the specified conditions",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"spec": schema.SingleNestedBlock{
											MarkdownDescription: "Challenge Rule Specification. A Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from or derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that request. Any predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a challenge rule, the configured challenge is enforced.",
											Attributes: map[string]schema.Attribute{
												"expiration_timestamp": schema.StringAttribute{
													MarkdownDescription: "The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_asn": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"arg_matchers": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name. Note that all specified arg matcher predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Argument Name. x-example: 'phones[_]' x-example: 'cars.make.toyota.models[1]' x-example: 'cars.make.honda.models[_]' x-example: 'cars.make[_].models[_]' A case-sensitive JSON path in the HTTP request body.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional: true,
															ElementType: types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"body_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"disable_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"enable_captcha_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"enable_javascript_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"http_method": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP Method Matcher. A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Method Matcher. Invert the match result.",
															Optional: true,
														},
														"methods": schema.ListAttribute{
															MarkdownDescription: "Method List. List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional: true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path Matcher. A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact path values to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Path Matcher. Invert the match result.",
															Optional: true,
														},
														"prefix_values": schema.ListAttribute{
															MarkdownDescription: "Prefix Values. A list of path prefix values to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"suffix_values": schema.ListAttribute{
															MarkdownDescription: "Suffix Values. A list of path suffix values to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional: true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"temporary_user_blocking": schema.SingleNestedBlock{
						MarkdownDescription: "Temporary User Blocking. Specifies configuration for temporary user blocking resulting from user behavior analysis. When Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for malicious activity and the configured mitigation actions will be taken on identified malicious users. These mitigation actions include setting up temporary blocking on that user. This configuration specifies settings on how that blocking should be done by the loadbalancer.",
						Attributes: map[string]schema.Attribute{
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Temporary Blocking. Custom message is of type `uri_ref`. Currently supported URL schemes is `string:///`. For `string:///` scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Blocked.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Blocked </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
				},

			},
			"protected_cookies": schema.ListNestedBlock{
				MarkdownDescription: "Cookie Protection. Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses. Cookie Tampering Protection prevents attackers from modifying the value of session cookies. For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite. The configured mode of WAF (monitoring or blocking) will be enforced on the request when cookie tampering is identified. Note: We recommend enabling Secure and HttpOnly attributes along with cookie tampering protection.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"max_age_value": schema.Int64Attribute{
							MarkdownDescription: "Add Max Age. Add max age attribute",
							Optional: true,
						},
						"name": schema.StringAttribute{
							MarkdownDescription: "Cookie Name. Name of the Cookie",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"add_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"add_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"disable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"enable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_max_age": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_samesite": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"samesite_lax": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"samesite_none": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"samesite_strict": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "RateLimitConfigType.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom IP Allowed List. IP Allowed list using existing ip_prefix_set objects",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "List of IP Prefix Sets. References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"policies": schema.SingleNestedBlock{
						MarkdownDescription: "Rate Limiter Policy List. List of rate limiter policies to be applied.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"policies": schema.ListNestedBlock{
								MarkdownDescription: "Rate Limiter Policies. Ordered list of rate limiter policies.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"rate_limiter": schema.SingleNestedBlock{
						MarkdownDescription: "Rate Limit Value. A tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
						Attributes: map[string]schema.Attribute{
							"burst_multiplier": schema.Int64Attribute{
								MarkdownDescription: "Burst Multiplier. The maximum burst of requests to accommodate, expressed as a multiple of the rate.",
								Optional: true,
							},
							"period_multiplier": schema.Int64Attribute{
								MarkdownDescription: "Periods. This setting, combined with Per Period units, provides a duration",
								Optional: true,
							},
							"total_number": schema.Int64Attribute{
								MarkdownDescription: "Number Of Requests. The total number of allowed requests per rate-limiting period.",
								Optional: true,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: "Rate Limit Period Unit. Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"action_block": schema.SingleNestedBlock{
								MarkdownDescription: "Rate Limit Block Action. Action where a user is blocked from making further requests after exceeding rate limit threshold.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"hours": schema.SingleNestedBlock{
										MarkdownDescription: "Hours. Input Duration Hours",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration.",
												Optional: true,
											},
										},
									},
									"minutes": schema.SingleNestedBlock{
										MarkdownDescription: "Minutes. Input Duration Minutes",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration.",
												Optional: true,
											},
										},
									},
									"seconds": schema.SingleNestedBlock{
										MarkdownDescription: "Seconds. Input Duration Seconds",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration.",
												Optional: true,
											},
										},
									},
								},
							},
							"disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"leaky_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Leaky Bucket Rate Limiter. Leaky-Bucket is the default rate limiter algorithm for F5",
							},
							"token_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Token Bucket Rate Limiter. Token-Bucket is a rate limiter algorithm that is stricter with enforcing limits",
							},
						},
					},
				},

			},
			"sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Sensitive Data Discovery. Settings for data type policy",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"sensitive_data_policy_ref": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"service_policies_from_namespace": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"slow_ddos_mitigation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: slow_ddos_mitigation, system_default_timeouts] Slow DDoS Mitigation. 'Slow and low' attacks tie up server resources, leaving none available for servicing requests from actual users.",
				Attributes: map[string]schema.Attribute{
					"request_headers_timeout": schema.Int64Attribute{
						MarkdownDescription: "Request Headers Timeout. The amount of time the client has to send only the headers on the request stream before the stream is cancelled. The  milliseconds. This setting provides protection against Slowloris attacks. Defaults to `10000`.",
						Optional: true,
					},
					"request_timeout": schema.Int64Attribute{
						MarkdownDescription: "Custom Timeout.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_request_timeout": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"system_default_timeouts": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"trusted_clients": schema.ListNestedBlock{
				MarkdownDescription: "Trusted Client Rules. Define rules to skip processing of one or more features such as WAF, Bot Defense etc. for clients.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "Actions. Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional: true,
							ElementType: types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "AS Number. RFC 6793 defined 4-byte AS number",
							Optional: true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional: true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 Prefix. IPv4 prefix string.",
							Optional: true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 Prefix. IPv6 prefix string.",
							Optional: true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "User Identifier. Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs",
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "HTTP Headers. List of HTTP header name and value pairs",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"user_id_client_ip": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: user_id_client_ip, user_identification] Empty. This can be used for messages where no values are needed",
			},
			"user_identification": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"waf_exclusion": schema.SingleNestedBlock{
				MarkdownDescription: "WAF Exclusion.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"waf_exclusion_inline_rules": schema.SingleNestedBlock{
						MarkdownDescription: "WAF Exclusion Inline Rules. A list of WAF exclusion rules that will be applied inline",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "WAF Exclusion Rules. An ordered list of WAF Exclusions specific to this Load Balancer.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"exact_value": schema.StringAttribute{
											MarkdownDescription: "Exact Value. Exact domain name",
											Optional: true,
										},
										"expiration_timestamp": schema.StringAttribute{
											MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
											Optional: true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "Methods. methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"path_prefix": schema.StringAttribute{
											MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
											Optional: true,
										},
										"path_regex": schema.StringAttribute{
											MarkdownDescription: "Path Regex. Define the regex for the path. For example, the regex ^/.*$ will match on all paths",
											Optional: true,
										},
										"suffix_value": schema.StringAttribute{
											MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_path": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"app_firewall_detection_control": schema.SingleNestedBlock{
											MarkdownDescription: "App Firewall Detection Control. Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"exclude_attack_type_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Attack Types. Attack Types to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "WAF Exclusion Context Options. The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE: CONTEXT_RESPONSE - CONTEXT_PARAMETER: CONTEXT_PARAMETER Detection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters. - CONTEXT_HEADER: CONTEXT_HEADER Detection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers. - CONTEXT_COOKIE: CONTEXT_COOKIE Detection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies. - CONTEXT_URL: CONTEXT_URL Detection will be excluded for the request URL. - CONTEXT_URI: CONTEXT_URI. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional: true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Context Name. Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional: true,
															},
															"exclude_attack_type": schema.StringAttribute{
																MarkdownDescription: "Attack Types. List of all Attack Types ATTACK_TYPE_NONE ATTACK_TYPE_NON_BROWSER_CLIENT ATTACK_TYPE_OTHER_APPLICATION_ATTACKS ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE ATTACK_TYPE_DETECTION_EVASION ATTACK_TYPE_VULNERABILITY_SCAN ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS ATTACK_TYPE_BUFFER_OVERFLOW ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION ATTACK_TYPE_INFORMATION_LEAKAGE ATTACK_TYPE_DIRECTORY_INDEXING ATTACK_TYPE_PATH_TRAVERSAL ATTACK_TYPE_XPATH_INJECTION ATTACK_TYPE_LDAP_INJECTION ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION ATTACK_TYPE_COMMAND_EXECUTION ATTACK_TYPE_SQL_INJECTION ATTACK_TYPE_CROSS_SITE_SCRIPTING ATTACK_TYPE_DENIAL_OF_SERVICE ATTACK_TYPE_HTTP_PARSER_ATTACK ATTACK_TYPE_SESSION_HIJACKING ATTACK_TYPE_HTTP_RESPONSE_SPLITTING ATTACK_TYPE_FORCEFUL_BROWSING ATTACK_TYPE_REMOTE_FILE_INCLUDE ATTACK_TYPE_MALICIOUS_FILE_UPLOAD ATTACK_TYPE_GRAPHQL_PARSER_ATTACK. Possible values are `ATTACK_TYPE_NONE`, `ATTACK_TYPE_NON_BROWSER_CLIENT`, `ATTACK_TYPE_OTHER_APPLICATION_ATTACKS`, `ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE`, `ATTACK_TYPE_DETECTION_EVASION`, `ATTACK_TYPE_VULNERABILITY_SCAN`, `ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY`, `ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS`, `ATTACK_TYPE_BUFFER_OVERFLOW`, `ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION`, `ATTACK_TYPE_INFORMATION_LEAKAGE`, `ATTACK_TYPE_DIRECTORY_INDEXING`, `ATTACK_TYPE_PATH_TRAVERSAL`, `ATTACK_TYPE_XPATH_INJECTION`, `ATTACK_TYPE_LDAP_INJECTION`, `ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION`, `ATTACK_TYPE_COMMAND_EXECUTION`, `ATTACK_TYPE_SQL_INJECTION`, `ATTACK_TYPE_CROSS_SITE_SCRIPTING`, `ATTACK_TYPE_DENIAL_OF_SERVICE`, `ATTACK_TYPE_HTTP_PARSER_ATTACK`, `ATTACK_TYPE_SESSION_HIJACKING`, `ATTACK_TYPE_HTTP_RESPONSE_SPLITTING`, `ATTACK_TYPE_FORCEFUL_BROWSING`, `ATTACK_TYPE_REMOTE_FILE_INCLUDE`, `ATTACK_TYPE_MALICIOUS_FILE_UPLOAD`, `ATTACK_TYPE_GRAPHQL_PARSER_ATTACK`. Defaults to `ATTACK_TYPE_NONE`.",
																Optional: true,
															},
														},
													},
												},
												"exclude_bot_name_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Bot Names. Bot Names to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"bot_name": schema.StringAttribute{
																MarkdownDescription: "Bot Name.",
																Optional: true,
															},
														},
													},
												},
												"exclude_signature_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Signature IDs. Signature IDs to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "WAF Exclusion Context Options. The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE: CONTEXT_RESPONSE - CONTEXT_PARAMETER: CONTEXT_PARAMETER Detection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters. - CONTEXT_HEADER: CONTEXT_HEADER Detection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers. - CONTEXT_COOKIE: CONTEXT_COOKIE Detection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies. - CONTEXT_URL: CONTEXT_URL Detection will be excluded for the request URL. - CONTEXT_URI: CONTEXT_URI. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional: true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Context Name. Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional: true,
															},
															"signature_id": schema.Int64Attribute{
																MarkdownDescription: "SignatureID. The allowed values for signature id are 0 and in the range of 200000001-299999999. 0 implies that all signatures will be excluded for the specified context.",
																Optional: true,
															},
														},
													},
												},
												"exclude_violation_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Violations. Violations to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "WAF Exclusion Context Options. The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE: CONTEXT_RESPONSE - CONTEXT_PARAMETER: CONTEXT_PARAMETER Detection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters. - CONTEXT_HEADER: CONTEXT_HEADER Detection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers. - CONTEXT_COOKIE: CONTEXT_COOKIE Detection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies. - CONTEXT_URL: CONTEXT_URL Detection will be excluded for the request URL. - CONTEXT_URI: CONTEXT_URI. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional: true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Context Name. Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional: true,
															},
															"exclude_violation": schema.StringAttribute{
																MarkdownDescription: "App Firewall Violation Type. List of all supported Violation Types VIOL_NONE VIOL_FILETYPE VIOL_METHOD VIOL_MANDATORY_HEADER VIOL_HTTP_RESPONSE_STATUS VIOL_REQUEST_MAX_LENGTH VIOL_FILE_UPLOAD VIOL_FILE_UPLOAD_IN_BODY VIOL_XML_MALFORMED VIOL_JSON_MALFORMED VIOL_ASM_COOKIE_MODIFIED VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER VIOL_EVASION_DIRECTORY_TRAVERSALS VIOL_MALFORMED_REQUEST VIOL_EVASION_MULTIPLE_DECODING VIOL_DATA_GUARD VIOL_EVASION_APACHE_WHITESPACE VIOL_COOKIE_MODIFIED VIOL_EVASION_IIS_UNICODE_CODEPOINTS VIOL_EVASION_IIS_BACKSLASHES VIOL_EVASION_PERCENT_U_DECODING VIOL_EVASION_BARE_BYTE_DECODING VIOL_EVASION_BAD_UNESCAPE VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS VIOL_ENCODING VIOL_COOKIE_MALFORMED VIOL_GRAPHQL_FORMAT VIOL_GRAPHQL_MALFORMED VIOL_GRAPHQL_INTROSPECTION_QUERY. Possible values are `VIOL_NONE`, `VIOL_FILETYPE`, `VIOL_METHOD`, `VIOL_MANDATORY_HEADER`, `VIOL_HTTP_RESPONSE_STATUS`, `VIOL_REQUEST_MAX_LENGTH`, `VIOL_FILE_UPLOAD`, `VIOL_FILE_UPLOAD_IN_BODY`, `VIOL_XML_MALFORMED`, `VIOL_JSON_MALFORMED`, `VIOL_ASM_COOKIE_MODIFIED`, `VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS`, `VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE`, `VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT`, `VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST`, `VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION`, `VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS`, `VIOL_EVASION_DIRECTORY_TRAVERSALS`, `VIOL_MALFORMED_REQUEST`, `VIOL_EVASION_MULTIPLE_DECODING`, `VIOL_DATA_GUARD`, `VIOL_EVASION_APACHE_WHITESPACE`, `VIOL_COOKIE_MODIFIED`, `VIOL_EVASION_IIS_UNICODE_CODEPOINTS`, `VIOL_EVASION_IIS_BACKSLASHES`, `VIOL_EVASION_PERCENT_U_DECODING`, `VIOL_EVASION_BARE_BYTE_DECODING`, `VIOL_EVASION_BAD_UNESCAPE`, `VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST`, `VIOL_ENCODING`, `VIOL_COOKIE_MALFORMED`, `VIOL_GRAPHQL_FORMAT`, `VIOL_GRAPHQL_MALFORMED`, `VIOL_GRAPHQL_INTROSPECTION_QUERY`. Defaults to `VIOL_NONE`.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"waf_skip_processing": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
					},
					"waf_exclusion_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
		},
	}
}

func (r *CDNLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *CDNLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *CDNLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the cdn_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan CDNLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *CDNLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := CDNLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *CDNLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating cdn_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.CDNLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		apiResource.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["api_specification"] = api_specificationMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		apiResource.Spec["app_firewall"] = app_firewallMap
	}
	if len(data.BlockedClients) > 0 {
		var blocked_clientsList []map[string]interface{}
		for _, item := range data.BlockedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			blocked_clientsList = append(blocked_clientsList, itemMap)
		}
		apiResource.Spec["blocked_clients"] = blocked_clientsList
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCorsSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCorsSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		apiResource.Spec["bot_defense"] = bot_defenseMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		apiResource.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		apiResource.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CorsPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CorsPolicy.AllowCredentials.IsNull() && !data.CorsPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CorsPolicy.AllowCredentials.ValueBool()
		}
		if !data.CorsPolicy.AllowHeaders.IsNull() && !data.CorsPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CorsPolicy.AllowHeaders.ValueString()
		}
		if !data.CorsPolicy.AllowMethods.IsNull() && !data.CorsPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CorsPolicy.AllowMethods.ValueString()
		}
		if !data.CorsPolicy.Disabled.IsNull() && !data.CorsPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CorsPolicy.Disabled.ValueBool()
		}
		if !data.CorsPolicy.ExposeHeaders.IsNull() && !data.CorsPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CorsPolicy.ExposeHeaders.ValueString()
		}
		if !data.CorsPolicy.MaximumAge.IsNull() && !data.CorsPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CorsPolicy.MaximumAge.ValueInt64()
		}
		apiResource.Spec["cors_policy"] = cors_policyMap
	}
	if data.CsrfPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CsrfPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CsrfPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CsrfPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["csrf_policy"] = csrf_policyMap
	}
	if data.CustomCacheRule != nil {
		custom_cache_ruleMap := make(map[string]interface{})
		if len(data.CustomCacheRule.CDNCacheRules) > 0 {
			var cdn_cache_rulesList []map[string]interface{}
			for _, listItem := range data.CustomCacheRule.CDNCacheRules {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				cdn_cache_rulesList = append(cdn_cache_rulesList, listItemMap)
			}
			custom_cache_ruleMap["cdn_cache_rules"] = cdn_cache_rulesList
		}
		apiResource.Spec["custom_cache_rule"] = custom_cache_ruleMap
	}
	if len(data.DataGuardRules) > 0 {
		var data_guard_rulesList []map[string]interface{}
		for _, item := range data.DataGuardRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if item.ApplyDataGuard != nil {
				itemMap["apply_data_guard"] = map[string]interface{}{}
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.Path != nil {
				pathNestedMap := make(map[string]interface{})
				if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
					pathNestedMap["path"] = item.Path.Path.ValueString()
				}
				if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
					pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
				}
				if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
					pathNestedMap["regex"] = item.Path.Regex.ValueString()
				}
				itemMap["path"] = pathNestedMap
			}
			if item.SkipDataGuard != nil {
				itemMap["skip_data_guard"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			data_guard_rulesList = append(data_guard_rulesList, itemMap)
		}
		apiResource.Spec["data_guard_rules"] = data_guard_rulesList
	}
	if len(data.DdosMitigationRules) > 0 {
		var ddos_mitigation_rulesList []map[string]interface{}
		for _, item := range data.DdosMitigationRules {
			itemMap := make(map[string]interface{})
			if item.Block != nil {
				itemMap["block"] = map[string]interface{}{}
			}
			if item.DdosClientSource != nil {
				ddos_client_sourceNestedMap := make(map[string]interface{})
				if !item.DdosClientSource.CountryList.IsNull() && !item.DdosClientSource.CountryList.IsUnknown() {
					var CountryListItems []string
					diags := item.DdosClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
					if !diags.HasError() {
						ddos_client_sourceNestedMap["country_list"] = CountryListItems
					}
				}
				itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.IPPrefixList != nil {
				ip_prefix_listNestedMap := make(map[string]interface{})
				if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
					ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
				}
				if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
					var IPPrefixesItems []string
					diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
					if !diags.HasError() {
						ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
					}
				}
				itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
		}
		apiResource.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
	}
	if data.DefaultCacheAction != nil {
		default_cache_actionMap := make(map[string]interface{})
		if data.DefaultCacheAction.CacheDisabled != nil {
			default_cache_actionMap["cache_disabled"] = map[string]interface{}{}
		}
		if !data.DefaultCacheAction.CacheTtlDefault.IsNull() && !data.DefaultCacheAction.CacheTtlDefault.IsUnknown() {
			default_cache_actionMap["cache_ttl_default"] = data.DefaultCacheAction.CacheTtlDefault.ValueString()
		}
		if !data.DefaultCacheAction.CacheTtlOverride.IsNull() && !data.DefaultCacheAction.CacheTtlOverride.IsUnknown() {
			default_cache_actionMap["cache_ttl_override"] = data.DefaultCacheAction.CacheTtlOverride.ValueString()
		}
		apiResource.Spec["default_cache_action"] = default_cache_actionMap
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		apiResource.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		apiResource.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		apiResource.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		apiResource.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		apiResource.Spec["disable_waf"] = disable_wafMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		apiResource.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		apiResource.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if len(data.GraphqlRules) > 0 {
		var graphql_rulesList []map[string]interface{}
		for _, item := range data.GraphqlRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
				itemMap["exact_path"] = item.ExactPath.ValueString()
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.GraphqlSettings != nil {
				graphql_settingsNestedMap := make(map[string]interface{})
				if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
					graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
				}
				if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
					graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
				}
				if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
					graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
				}
				itemMap["graphql_settings"] = graphql_settingsNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.MethodGet != nil {
				itemMap["method_get"] = map[string]interface{}{}
			}
			if item.MethodPost != nil {
				itemMap["method_post"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			graphql_rulesList = append(graphql_rulesList, itemMap)
		}
		apiResource.Spec["graphql_rules"] = graphql_rulesList
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		apiResource.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.TLSCertOptions != nil {
			tls_cert_optionsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_options"] = tls_cert_optionsNestedMap
		}
		apiResource.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		apiResource.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["js_challenge"] = js_challengeMap
	}
	if data.JwtValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JwtValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JwtValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JwtValidation.JwksConfig.Cleartext.IsNull() && !data.JwtValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JwtValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JwtValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JwtValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JwtValidation.ReservedClaims.Issuer.IsNull() && !data.JwtValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JwtValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JwtValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JwtValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		apiResource.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DdosActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DdosActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DdosActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DdosActionJsChallenge.CookieExpiry.IsNull() && !data.L7DdosActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DdosActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DdosActionJsChallenge.CustomPage.IsNull() && !data.L7DdosActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DdosActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DdosActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DdosActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		apiResource.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginPool != nil {
		origin_poolMap := make(map[string]interface{})
		if data.OriginPool.MoreOriginOptions != nil {
			more_origin_optionsNestedMap := make(map[string]interface{})
			if !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsNull() && !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsUnknown() {
				more_origin_optionsNestedMap["enable_byte_range_request"] = data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.ValueBool()
			}
			if !data.OriginPool.MoreOriginOptions.WebsocketProxy.IsNull() && !data.OriginPool.MoreOriginOptions.WebsocketProxy.IsUnknown() {
				more_origin_optionsNestedMap["websocket_proxy"] = data.OriginPool.MoreOriginOptions.WebsocketProxy.ValueBool()
			}
			origin_poolMap["more_origin_options"] = more_origin_optionsNestedMap
		}
		if data.OriginPool.NoTLS != nil {
			origin_poolMap["no_tls"] = map[string]interface{}{}
		}
		if !data.OriginPool.OriginRequestTimeout.IsNull() && !data.OriginPool.OriginRequestTimeout.IsUnknown() {
			origin_poolMap["origin_request_timeout"] = data.OriginPool.OriginRequestTimeout.ValueString()
		}
		if len(data.OriginPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.OriginPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			origin_poolMap["origin_servers"] = origin_serversList
		}
		if data.OriginPool.PublicName != nil {
			public_nameNestedMap := make(map[string]interface{})
			if !data.OriginPool.PublicName.DNSName.IsNull() && !data.OriginPool.PublicName.DNSName.IsUnknown() {
				public_nameNestedMap["dns_name"] = data.OriginPool.PublicName.DNSName.ValueString()
			}
			if !data.OriginPool.PublicName.RefreshInterval.IsNull() && !data.OriginPool.PublicName.RefreshInterval.IsUnknown() {
				public_nameNestedMap["refresh_interval"] = data.OriginPool.PublicName.RefreshInterval.ValueInt64()
			}
			origin_poolMap["public_name"] = public_nameNestedMap
		}
		if data.OriginPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.OriginPool.UseTLS.MaxSessionKeys.IsNull() && !data.OriginPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.OriginPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.OriginPool.UseTLS.Sni.IsNull() && !data.OriginPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.OriginPool.UseTLS.Sni.ValueString()
			}
			origin_poolMap["use_tls"] = use_tlsNestedMap
		}
		apiResource.Spec["origin_pool"] = origin_poolMap
	}
	if data.OtherSettings != nil {
		other_settingsMap := make(map[string]interface{})
		if !data.OtherSettings.AddLocation.IsNull() && !data.OtherSettings.AddLocation.IsUnknown() {
			other_settingsMap["add_location"] = data.OtherSettings.AddLocation.ValueBool()
		}
		if data.OtherSettings.HeaderOptions != nil {
			header_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["header_options"] = header_optionsNestedMap
		}
		if data.OtherSettings.LoggingOptions != nil {
			logging_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["logging_options"] = logging_optionsNestedMap
		}
		apiResource.Spec["other_settings"] = other_settingsMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		apiResource.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if len(data.ProtectedCookies) > 0 {
		var protected_cookiesList []map[string]interface{}
		for _, item := range data.ProtectedCookies {
			itemMap := make(map[string]interface{})
			if item.AddHttponly != nil {
				itemMap["add_httponly"] = map[string]interface{}{}
			}
			if item.AddSecure != nil {
				itemMap["add_secure"] = map[string]interface{}{}
			}
			if item.DisableTamperingProtection != nil {
				itemMap["disable_tampering_protection"] = map[string]interface{}{}
			}
			if item.EnableTamperingProtection != nil {
				itemMap["enable_tampering_protection"] = map[string]interface{}{}
			}
			if item.IgnoreHttponly != nil {
				itemMap["ignore_httponly"] = map[string]interface{}{}
			}
			if item.IgnoreMaxAge != nil {
				itemMap["ignore_max_age"] = map[string]interface{}{}
			}
			if item.IgnoreSamesite != nil {
				itemMap["ignore_samesite"] = map[string]interface{}{}
			}
			if item.IgnoreSecure != nil {
				itemMap["ignore_secure"] = map[string]interface{}{}
			}
			if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
				itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
			}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				itemMap["name"] = item.Name.ValueString()
			}
			if item.SamesiteLax != nil {
				itemMap["samesite_lax"] = map[string]interface{}{}
			}
			if item.SamesiteNone != nil {
				itemMap["samesite_none"] = map[string]interface{}{}
			}
			if item.SamesiteStrict != nil {
				itemMap["samesite_strict"] = map[string]interface{}{}
			}
			protected_cookiesList = append(protected_cookiesList, itemMap)
		}
		apiResource.Spec["protected_cookies"] = protected_cookiesList
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		apiResource.Spec["rate_limit"] = rate_limitMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		apiResource.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SlowDdosMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDdosMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDdosMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDdosMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDdosMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDdosMitigation.RequestTimeout.IsNull() && !data.SlowDdosMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDdosMitigation.RequestTimeout.ValueInt64()
		}
		apiResource.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		apiResource.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if len(data.TrustedClients) > 0 {
		var trusted_clientsList []map[string]interface{}
		for _, item := range data.TrustedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			trusted_clientsList = append(trusted_clientsList, itemMap)
		}
		apiResource.Spec["trusted_clients"] = trusted_clientsList
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		apiResource.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		apiResource.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		apiResource.Spec["waf_exclusion"] = waf_exclusionMap
	}


	created, err := r.client.CreateCDNLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create CDNLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created CDNLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetCDNLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CDNLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CDNLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The cdn_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &CDNLoadBalancerActiveServicePoliciesModel{
			Policies: func() []CDNLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &CDNLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLbUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{
										}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{
					}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitCustomIPAllowedListModel{
					}
				}
				return nil
			}(),
			IPAllowedList: func() *CDNLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []CDNLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *CDNLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &CDNLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLbUserID: func() *CDNLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &CDNLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &CDNLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{
										}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &CDNLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &CDNLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []CDNLoadBalancerBlockedClientsModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, CDNLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["bot_skip_processing"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsHTTPHeaderModel{
							}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPV6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["skip_processing"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["waf_skip_processing"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		data.BlockedClients = blocked_clientsList
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &CDNLoadBalancerBotDefenseModel{
			DisableCorsSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCorsSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCorsSupport: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCorsSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *CDNLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &CDNLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &CDNLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &CDNLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CorsPolicy != nil) {
		data.CorsPolicy = &CDNLoadBalancerCorsPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CorsPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.CorsPolicy.AllowCredentials
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CorsPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.CorsPolicy.Disabled
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CsrfPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CsrfPolicy = &CDNLoadBalancerCsrfPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["custom_cache_rule"].(map[string]interface{}); ok && (isImport || data.CustomCacheRule != nil) {
		data.CustomCacheRule = &CDNLoadBalancerCustomCacheRuleModel{
			CDNCacheRules: func() []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel {
				if listData, ok := blockData["cdn_cache_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerCustomCacheRuleCDNCacheRulesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []CDNLoadBalancerDataGuardRulesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, CDNLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["apply_data_guard"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *CDNLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["skip_data_guard"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.DataGuardRules = data_guard_rulesList
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []CDNLoadBalancerDdosMitigationRulesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, CDNLoadBalancerDdosMitigationRulesModel{
					Block: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["block"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DdosClientSource: func() *CDNLoadBalancerDdosMitigationRulesDdosClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDdosMitigationRulesDdosClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *CDNLoadBalancerDdosMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDdosMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerDdosMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerDdosMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		data.DdosMitigationRules = ddos_mitigation_rulesList
	}
	if blockData, ok := apiResource.Spec["default_cache_action"].(map[string]interface{}); ok && (isImport || data.DefaultCacheAction != nil) {
		data.DefaultCacheAction = &CDNLoadBalancerDefaultCacheActionModel{
			CacheDisabled: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.DefaultCacheAction != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultCacheAction.CacheDisabled
				}
				// Import case: read from API
				if _, ok := blockData["cache_disabled"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			CacheTtlDefault: func() types.String {
				if v, ok := blockData["cache_ttl_default"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CacheTtlOverride: func() types.String {
				if v, ok := blockData["cache_ttl_override"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &CDNLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &CDNLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &CDNLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []CDNLoadBalancerGraphqlRulesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, CDNLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *CDNLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesGraphqlSettingsModel{
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *CDNLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["method_get"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["method_post"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.GraphqlRules = graphql_rulesList
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &CDNLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTP.DNSVolterraManaged
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &CDNLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPS.AddHsts
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPS.HTTPRedirect
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSCertOptions: func() *CDNLoadBalancerHTTPSTLSCertOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertOptions
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSTLSCertOptionsModel{
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &CDNLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPSAutoCert.AddHsts
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPSAutoCert.HTTPRedirect
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			TLSConfig: func() *CDNLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &CDNLoadBalancerHTTPSAutoCertTLSConfigModel{
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &CDNLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JwtValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JwtValidation = &CDNLoadBalancerJwtValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DdosActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DdosActionBlock = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DdosActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DdosActionDefault = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DdosActionJsChallenge != nil) {
		data.L7DdosActionJsChallenge = &CDNLoadBalancerL7DdosActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_pool"].(map[string]interface{}); ok && (isImport || data.OriginPool != nil) {
		data.OriginPool = &CDNLoadBalancerOriginPoolModel{
			MoreOriginOptions: func() *CDNLoadBalancerOriginPoolMoreOriginOptionsModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.MoreOriginOptions != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.MoreOriginOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["more_origin_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolMoreOriginOptionsModel{
						EnableByteRangeRequest: func() types.Bool {
							if v, ok := nestedBlockData["enable_byte_range_request"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						WebsocketProxy: func() types.Bool {
							if v, ok := nestedBlockData["websocket_proxy"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			NoTLS: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.OriginPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OriginPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginRequestTimeout: func() types.String {
				if v, ok := blockData["origin_request_timeout"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OriginServers: func() []CDNLoadBalancerOriginPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []CDNLoadBalancerOriginPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, CDNLoadBalancerOriginPoolOriginServersModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PublicIP: func() *CDNLoadBalancerOriginPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *CDNLoadBalancerOriginPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &CDNLoadBalancerOriginPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			PublicName: func() *CDNLoadBalancerOriginPoolPublicNameModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.PublicName != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.PublicName
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["public_name"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolPublicNameModel{
						DNSName: func() types.String {
							if v, ok := nestedBlockData["dns_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						RefreshInterval: func() types.Int64 {
							if v, ok := nestedBlockData["refresh_interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			UseTLS: func() *CDNLoadBalancerOriginPoolUseTLSModel {
				if !isImport && data.OriginPool != nil && data.OriginPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.OriginPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOriginPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["other_settings"].(map[string]interface{}); ok && (isImport || data.OtherSettings != nil) {
		data.OtherSettings = &CDNLoadBalancerOtherSettingsModel{
			AddLocation: func() types.Bool {
				if !isImport && data.OtherSettings != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OtherSettings.AddLocation
				}
				// Import case: read from API
				if v, ok := blockData["add_location"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HeaderOptions: func() *CDNLoadBalancerOtherSettingsHeaderOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.HeaderOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.HeaderOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["header_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsHeaderOptionsModel{
						RequestHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ResponseHeadersToRemove: func() types.List {
							if v, ok := nestedBlockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			LoggingOptions: func() *CDNLoadBalancerOtherSettingsLoggingOptionsModel {
				if !isImport && data.OtherSettings != nil && data.OtherSettings.LoggingOptions != nil {
					// Normal Read: preserve existing state value
					return data.OtherSettings.LoggingOptions
				}
				// Import case: read from API
				if _, ok := blockData["logging_options"].(map[string]interface{}); ok {
					return &CDNLoadBalancerOtherSettingsLoggingOptionsModel{
					}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &CDNLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []CDNLoadBalancerProtectedCookiesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, CDNLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["add_httponly"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["add_secure"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["disable_tampering_protection"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["enable_tampering_protection"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_httponly"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_max_age"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_samesite"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_secure"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["samesite_lax"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["samesite_none"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["samesite_strict"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		data.ProtectedCookies = protected_cookiesList
	}
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &CDNLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &CDNLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDdosMitigation != nil) {
		data.SlowDdosMitigation = &CDNLoadBalancerSlowDdosMitigationModel{
			DisableRequestTimeout: func() *CDNLoadBalancerEmptyModel {
				if !isImport && data.SlowDdosMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDdosMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &CDNLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []CDNLoadBalancerTrustedClientsModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, CDNLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["bot_skip_processing"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *CDNLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsHTTPHeaderModel{
							}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPV6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *CDNLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &CDNLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["skip_processing"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *CDNLoadBalancerEmptyModel {
						if _, ok := itemMap["waf_skip_processing"].(map[string]interface{}); ok {
							return &CDNLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		data.TrustedClients = trusted_clientsList
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &CDNLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &CDNLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &CDNLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.CDNLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		apiResource.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["api_specification"] = api_specificationMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		apiResource.Spec["app_firewall"] = app_firewallMap
	}
	if len(data.BlockedClients) > 0 {
		var blocked_clientsList []map[string]interface{}
		for _, item := range data.BlockedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			blocked_clientsList = append(blocked_clientsList, itemMap)
		}
		apiResource.Spec["blocked_clients"] = blocked_clientsList
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCorsSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCorsSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		apiResource.Spec["bot_defense"] = bot_defenseMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		apiResource.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		apiResource.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CorsPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CorsPolicy.AllowCredentials.IsNull() && !data.CorsPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CorsPolicy.AllowCredentials.ValueBool()
		}
		if !data.CorsPolicy.AllowHeaders.IsNull() && !data.CorsPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CorsPolicy.AllowHeaders.ValueString()
		}
		if !data.CorsPolicy.AllowMethods.IsNull() && !data.CorsPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CorsPolicy.AllowMethods.ValueString()
		}
		if !data.CorsPolicy.Disabled.IsNull() && !data.CorsPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CorsPolicy.Disabled.ValueBool()
		}
		if !data.CorsPolicy.ExposeHeaders.IsNull() && !data.CorsPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CorsPolicy.ExposeHeaders.ValueString()
		}
		if !data.CorsPolicy.MaximumAge.IsNull() && !data.CorsPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CorsPolicy.MaximumAge.ValueInt64()
		}
		apiResource.Spec["cors_policy"] = cors_policyMap
	}
	if data.CsrfPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CsrfPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CsrfPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CsrfPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["csrf_policy"] = csrf_policyMap
	}
	if data.CustomCacheRule != nil {
		custom_cache_ruleMap := make(map[string]interface{})
		if len(data.CustomCacheRule.CDNCacheRules) > 0 {
			var cdn_cache_rulesList []map[string]interface{}
			for _, listItem := range data.CustomCacheRule.CDNCacheRules {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				cdn_cache_rulesList = append(cdn_cache_rulesList, listItemMap)
			}
			custom_cache_ruleMap["cdn_cache_rules"] = cdn_cache_rulesList
		}
		apiResource.Spec["custom_cache_rule"] = custom_cache_ruleMap
	}
	if len(data.DataGuardRules) > 0 {
		var data_guard_rulesList []map[string]interface{}
		for _, item := range data.DataGuardRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if item.ApplyDataGuard != nil {
				itemMap["apply_data_guard"] = map[string]interface{}{}
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.Path != nil {
				pathNestedMap := make(map[string]interface{})
				if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
					pathNestedMap["path"] = item.Path.Path.ValueString()
				}
				if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
					pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
				}
				if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
					pathNestedMap["regex"] = item.Path.Regex.ValueString()
				}
				itemMap["path"] = pathNestedMap
			}
			if item.SkipDataGuard != nil {
				itemMap["skip_data_guard"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			data_guard_rulesList = append(data_guard_rulesList, itemMap)
		}
		apiResource.Spec["data_guard_rules"] = data_guard_rulesList
	}
	if len(data.DdosMitigationRules) > 0 {
		var ddos_mitigation_rulesList []map[string]interface{}
		for _, item := range data.DdosMitigationRules {
			itemMap := make(map[string]interface{})
			if item.Block != nil {
				itemMap["block"] = map[string]interface{}{}
			}
			if item.DdosClientSource != nil {
				ddos_client_sourceNestedMap := make(map[string]interface{})
				if !item.DdosClientSource.CountryList.IsNull() && !item.DdosClientSource.CountryList.IsUnknown() {
					var CountryListItems []string
					diags := item.DdosClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
					if !diags.HasError() {
						ddos_client_sourceNestedMap["country_list"] = CountryListItems
					}
				}
				itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.IPPrefixList != nil {
				ip_prefix_listNestedMap := make(map[string]interface{})
				if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
					ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
				}
				if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
					var IPPrefixesItems []string
					diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
					if !diags.HasError() {
						ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
					}
				}
				itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
		}
		apiResource.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
	}
	if data.DefaultCacheAction != nil {
		default_cache_actionMap := make(map[string]interface{})
		if data.DefaultCacheAction.CacheDisabled != nil {
			default_cache_actionMap["cache_disabled"] = map[string]interface{}{}
		}
		if !data.DefaultCacheAction.CacheTtlDefault.IsNull() && !data.DefaultCacheAction.CacheTtlDefault.IsUnknown() {
			default_cache_actionMap["cache_ttl_default"] = data.DefaultCacheAction.CacheTtlDefault.ValueString()
		}
		if !data.DefaultCacheAction.CacheTtlOverride.IsNull() && !data.DefaultCacheAction.CacheTtlOverride.IsUnknown() {
			default_cache_actionMap["cache_ttl_override"] = data.DefaultCacheAction.CacheTtlOverride.ValueString()
		}
		apiResource.Spec["default_cache_action"] = default_cache_actionMap
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		apiResource.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		apiResource.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		apiResource.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		apiResource.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		apiResource.Spec["disable_waf"] = disable_wafMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		apiResource.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		apiResource.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if len(data.GraphqlRules) > 0 {
		var graphql_rulesList []map[string]interface{}
		for _, item := range data.GraphqlRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
				itemMap["exact_path"] = item.ExactPath.ValueString()
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.GraphqlSettings != nil {
				graphql_settingsNestedMap := make(map[string]interface{})
				if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
					graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
				}
				if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
					graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
				}
				if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
					graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
				}
				itemMap["graphql_settings"] = graphql_settingsNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.MethodGet != nil {
				itemMap["method_get"] = map[string]interface{}{}
			}
			if item.MethodPost != nil {
				itemMap["method_post"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			graphql_rulesList = append(graphql_rulesList, itemMap)
		}
		apiResource.Spec["graphql_rules"] = graphql_rulesList
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		apiResource.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.TLSCertOptions != nil {
			tls_cert_optionsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_options"] = tls_cert_optionsNestedMap
		}
		apiResource.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		apiResource.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["js_challenge"] = js_challengeMap
	}
	if data.JwtValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JwtValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JwtValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JwtValidation.JwksConfig.Cleartext.IsNull() && !data.JwtValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JwtValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JwtValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JwtValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JwtValidation.ReservedClaims.Issuer.IsNull() && !data.JwtValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JwtValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JwtValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JwtValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		apiResource.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DdosActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DdosActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DdosActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DdosActionJsChallenge.CookieExpiry.IsNull() && !data.L7DdosActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DdosActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DdosActionJsChallenge.CustomPage.IsNull() && !data.L7DdosActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DdosActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DdosActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DdosActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		apiResource.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginPool != nil {
		origin_poolMap := make(map[string]interface{})
		if data.OriginPool.MoreOriginOptions != nil {
			more_origin_optionsNestedMap := make(map[string]interface{})
			if !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsNull() && !data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.IsUnknown() {
				more_origin_optionsNestedMap["enable_byte_range_request"] = data.OriginPool.MoreOriginOptions.EnableByteRangeRequest.ValueBool()
			}
			if !data.OriginPool.MoreOriginOptions.WebsocketProxy.IsNull() && !data.OriginPool.MoreOriginOptions.WebsocketProxy.IsUnknown() {
				more_origin_optionsNestedMap["websocket_proxy"] = data.OriginPool.MoreOriginOptions.WebsocketProxy.ValueBool()
			}
			origin_poolMap["more_origin_options"] = more_origin_optionsNestedMap
		}
		if data.OriginPool.NoTLS != nil {
			origin_poolMap["no_tls"] = map[string]interface{}{}
		}
		if !data.OriginPool.OriginRequestTimeout.IsNull() && !data.OriginPool.OriginRequestTimeout.IsUnknown() {
			origin_poolMap["origin_request_timeout"] = data.OriginPool.OriginRequestTimeout.ValueString()
		}
		if len(data.OriginPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.OriginPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			origin_poolMap["origin_servers"] = origin_serversList
		}
		if data.OriginPool.PublicName != nil {
			public_nameNestedMap := make(map[string]interface{})
			if !data.OriginPool.PublicName.DNSName.IsNull() && !data.OriginPool.PublicName.DNSName.IsUnknown() {
				public_nameNestedMap["dns_name"] = data.OriginPool.PublicName.DNSName.ValueString()
			}
			if !data.OriginPool.PublicName.RefreshInterval.IsNull() && !data.OriginPool.PublicName.RefreshInterval.IsUnknown() {
				public_nameNestedMap["refresh_interval"] = data.OriginPool.PublicName.RefreshInterval.ValueInt64()
			}
			origin_poolMap["public_name"] = public_nameNestedMap
		}
		if data.OriginPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.OriginPool.UseTLS.MaxSessionKeys.IsNull() && !data.OriginPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.OriginPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.OriginPool.UseTLS.Sni.IsNull() && !data.OriginPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.OriginPool.UseTLS.Sni.ValueString()
			}
			origin_poolMap["use_tls"] = use_tlsNestedMap
		}
		apiResource.Spec["origin_pool"] = origin_poolMap
	}
	if data.OtherSettings != nil {
		other_settingsMap := make(map[string]interface{})
		if !data.OtherSettings.AddLocation.IsNull() && !data.OtherSettings.AddLocation.IsUnknown() {
			other_settingsMap["add_location"] = data.OtherSettings.AddLocation.ValueBool()
		}
		if data.OtherSettings.HeaderOptions != nil {
			header_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["header_options"] = header_optionsNestedMap
		}
		if data.OtherSettings.LoggingOptions != nil {
			logging_optionsNestedMap := make(map[string]interface{})
			other_settingsMap["logging_options"] = logging_optionsNestedMap
		}
		apiResource.Spec["other_settings"] = other_settingsMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		apiResource.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if len(data.ProtectedCookies) > 0 {
		var protected_cookiesList []map[string]interface{}
		for _, item := range data.ProtectedCookies {
			itemMap := make(map[string]interface{})
			if item.AddHttponly != nil {
				itemMap["add_httponly"] = map[string]interface{}{}
			}
			if item.AddSecure != nil {
				itemMap["add_secure"] = map[string]interface{}{}
			}
			if item.DisableTamperingProtection != nil {
				itemMap["disable_tampering_protection"] = map[string]interface{}{}
			}
			if item.EnableTamperingProtection != nil {
				itemMap["enable_tampering_protection"] = map[string]interface{}{}
			}
			if item.IgnoreHttponly != nil {
				itemMap["ignore_httponly"] = map[string]interface{}{}
			}
			if item.IgnoreMaxAge != nil {
				itemMap["ignore_max_age"] = map[string]interface{}{}
			}
			if item.IgnoreSamesite != nil {
				itemMap["ignore_samesite"] = map[string]interface{}{}
			}
			if item.IgnoreSecure != nil {
				itemMap["ignore_secure"] = map[string]interface{}{}
			}
			if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
				itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
			}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				itemMap["name"] = item.Name.ValueString()
			}
			if item.SamesiteLax != nil {
				itemMap["samesite_lax"] = map[string]interface{}{}
			}
			if item.SamesiteNone != nil {
				itemMap["samesite_none"] = map[string]interface{}{}
			}
			if item.SamesiteStrict != nil {
				itemMap["samesite_strict"] = map[string]interface{}{}
			}
			protected_cookiesList = append(protected_cookiesList, itemMap)
		}
		apiResource.Spec["protected_cookies"] = protected_cookiesList
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		apiResource.Spec["rate_limit"] = rate_limitMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		apiResource.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SlowDdosMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDdosMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDdosMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDdosMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDdosMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDdosMitigation.RequestTimeout.IsNull() && !data.SlowDdosMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDdosMitigation.RequestTimeout.ValueInt64()
		}
		apiResource.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		apiResource.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if len(data.TrustedClients) > 0 {
		var trusted_clientsList []map[string]interface{}
		for _, item := range data.TrustedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			trusted_clientsList = append(trusted_clientsList, itemMap)
		}
		apiResource.Spec["trusted_clients"] = trusted_clientsList
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		apiResource.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		apiResource.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		apiResource.Spec["waf_exclusion"] = waf_exclusionMap
	}


	updated, err := r.client.UpdateCDNLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update CDNLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetCDNLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CDNLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CDNLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteCDNLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CDNLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "CDNLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete CDNLoadBalancer: %s", err))
		return
	}
}

func (r *CDNLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
