// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &ChildTenantResource{}
	_ resource.ResourceWithConfigure      = &ChildTenantResource{}
	_ resource.ResourceWithImportState    = &ChildTenantResource{}
	_ resource.ResourceWithModifyPlan     = &ChildTenantResource{}
	_ resource.ResourceWithUpgradeState   = &ChildTenantResource{}
	_ resource.ResourceWithValidateConfig = &ChildTenantResource{}
)

// child_tenantSchemaVersion is the schema version for state upgrades
const child_tenantSchemaVersion int64 = 1

func NewChildTenantResource() resource.Resource {
	return &ChildTenantResource{}
}

type ChildTenantResource struct {
	client *client.Client
}

// ChildTenantEmptyModel represents empty nested blocks
type ChildTenantEmptyModel struct {
}

// ChildTenantChildTenantManagerModel represents child_tenant_manager block
type ChildTenantChildTenantManagerModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ChildTenantContactDetailModel represents contact_detail block
type ChildTenantContactDetailModel struct {
	Address1    types.String `tfsdk:"address1"`
	Address2    types.String `tfsdk:"address2"`
	City        types.String `tfsdk:"city"`
	ContactType types.String `tfsdk:"contact_type"`
	Country     types.String `tfsdk:"country"`
	County      types.String `tfsdk:"county"`
	PhoneNumber types.String `tfsdk:"phone_number"`
	State       types.String `tfsdk:"state"`
	StateCode   types.String `tfsdk:"state_code"`
	ZipCode     types.String `tfsdk:"zip_code"`
}

// ChildTenantCustomerInfoModel represents customer_info block
type ChildTenantCustomerInfoModel struct {
	AdditionalInfo types.String `tfsdk:"additional_info"`
	Email          types.String `tfsdk:"email"`
	FirstName      types.String `tfsdk:"first_name"`
	LastName       types.String `tfsdk:"last_name"`
}

// ChildTenantTenantProfileModel represents tenant_profile block
type ChildTenantTenantProfileModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

type ChildTenantResourceModel struct {
	Name               types.String                        `tfsdk:"name"`
	Namespace          types.String                        `tfsdk:"namespace"`
	Annotations        types.Map                           `tfsdk:"annotations"`
	Description        types.String                        `tfsdk:"description"`
	Disable            types.Bool                          `tfsdk:"disable"`
	Labels             types.Map                           `tfsdk:"labels"`
	ID                 types.String                        `tfsdk:"id"`
	CompanyName        types.String                        `tfsdk:"company_name"`
	Domain             types.String                        `tfsdk:"domain"`
	Timeouts           timeouts.Value                      `tfsdk:"timeouts"`
	ChildTenantManager *ChildTenantChildTenantManagerModel `tfsdk:"child_tenant_manager"`
	ContactDetail      *ChildTenantContactDetailModel      `tfsdk:"contact_detail"`
	CustomerInfo       *ChildTenantCustomerInfoModel       `tfsdk:"customer_info"`
	TenantProfile      *ChildTenantTenantProfileModel      `tfsdk:"tenant_profile"`
}

func (r *ChildTenantResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_child_tenant"
}

func (r *ChildTenantResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             child_tenantSchemaVersion,
		MarkdownDescription: "[Namespace: required] Manages child_tenant config instance. Name of the object is the name of the child tenant to be created. in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Child Tenant. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace for the Child Tenant. For this resource type, namespace should be empty or omitted.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"company_name": schema.StringAttribute{
				MarkdownDescription: "Company Name. Company name (enterprise only)",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"domain": schema.StringAttribute{
				MarkdownDescription: "Domain. Text string that will be used for the subdomain of the new Child Tenant. This will be where users will directly log into the new Child Tenant. example domain.console.ves.volterra.io.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"child_tenant_manager": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional:            true,
						Computed:            true,
					},
				},
			},
			"contact_detail": schema.SingleNestedBlock{
				MarkdownDescription: "Contact. Instance of one single contact that can be used to communicate with customers. Depending on contact type we use these details to send general communication (regular, physical mail) or invoices.",
				Attributes: map[string]schema.Attribute{
					"address1": schema.StringAttribute{
						MarkdownDescription: "Address Line 1.",
						Optional:            true,
					},
					"address2": schema.StringAttribute{
						MarkdownDescription: "Address Line 2.",
						Optional:            true,
					},
					"city": schema.StringAttribute{
						MarkdownDescription: "City.",
						Optional:            true,
					},
					"contact_type": schema.StringAttribute{
						MarkdownDescription: "[Enum: MAILING|BILLING|PAYMENT] Contact Type. Determines the contact type Indicates snail mail address (used for correspondence) Indicates billing address (this address will appear on invoices) Indicates contact used for a payment method (this address is used when charging a payment method). Possible values are `MAILING`, `BILLING`, `PAYMENT`. Defaults to `MAILING`.",
						Optional:            true,
					},
					"country": schema.StringAttribute{
						MarkdownDescription: "Country.",
						Optional:            true,
					},
					"county": schema.StringAttribute{
						MarkdownDescription: "County.",
						Optional:            true,
					},
					"phone_number": schema.StringAttribute{
						MarkdownDescription: "Phone Number.",
						Optional:            true,
					},
					"state": schema.StringAttribute{
						MarkdownDescription: "State.",
						Optional:            true,
					},
					"state_code": schema.StringAttribute{
						MarkdownDescription: "State Code.",
						Optional:            true,
					},
					"zip_code": schema.StringAttribute{
						MarkdownDescription: "ZIP code.",
						Optional:            true,
					},
				},
			},
			"customer_info": schema.SingleNestedBlock{
				MarkdownDescription: "Customer Info. Optional details for the new child tenant",
				Attributes: map[string]schema.Attribute{
					"additional_info": schema.StringAttribute{
						MarkdownDescription: "Additional Info. Use this field for any additional information about the new child tenant",
						Optional:            true,
					},
					"email": schema.StringAttribute{
						MarkdownDescription: "Email.",
						Optional:            true,
					},
					"first_name": schema.StringAttribute{
						MarkdownDescription: "First Name.",
						Optional:            true,
					},
					"last_name": schema.StringAttribute{
						MarkdownDescription: "Last Name.",
						Optional:            true,
					},
				},
			},
			"tenant_profile": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional:            true,
						Computed:            true,
					},
				},
			},
		},
	}
}

func (r *ChildTenantResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *ChildTenantResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data ChildTenantResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *ChildTenantResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the child_tenant from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan ChildTenantResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *ChildTenantResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := ChildTenantResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *ChildTenantResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data ChildTenantResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating child_tenant", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.ChildTenant{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ChildTenantManager != nil {
		child_tenant_managerMap := make(map[string]interface{})
		if !data.ChildTenantManager.Name.IsNull() && !data.ChildTenantManager.Name.IsUnknown() {
			child_tenant_managerMap["name"] = data.ChildTenantManager.Name.ValueString()
		}
		if !data.ChildTenantManager.Namespace.IsNull() && !data.ChildTenantManager.Namespace.IsUnknown() {
			child_tenant_managerMap["namespace"] = data.ChildTenantManager.Namespace.ValueString()
		}
		if !data.ChildTenantManager.Tenant.IsNull() && !data.ChildTenantManager.Tenant.IsUnknown() {
			child_tenant_managerMap["tenant"] = data.ChildTenantManager.Tenant.ValueString()
		}
		createReq.Spec["child_tenant_manager"] = child_tenant_managerMap
	}
	if data.ContactDetail != nil {
		contact_detailMap := make(map[string]interface{})
		if !data.ContactDetail.Address1.IsNull() && !data.ContactDetail.Address1.IsUnknown() {
			contact_detailMap["address1"] = data.ContactDetail.Address1.ValueString()
		}
		if !data.ContactDetail.Address2.IsNull() && !data.ContactDetail.Address2.IsUnknown() {
			contact_detailMap["address2"] = data.ContactDetail.Address2.ValueString()
		}
		if !data.ContactDetail.City.IsNull() && !data.ContactDetail.City.IsUnknown() {
			contact_detailMap["city"] = data.ContactDetail.City.ValueString()
		}
		if !data.ContactDetail.ContactType.IsNull() && !data.ContactDetail.ContactType.IsUnknown() {
			contact_detailMap["contact_type"] = data.ContactDetail.ContactType.ValueString()
		}
		if !data.ContactDetail.Country.IsNull() && !data.ContactDetail.Country.IsUnknown() {
			contact_detailMap["country"] = data.ContactDetail.Country.ValueString()
		}
		if !data.ContactDetail.County.IsNull() && !data.ContactDetail.County.IsUnknown() {
			contact_detailMap["county"] = data.ContactDetail.County.ValueString()
		}
		if !data.ContactDetail.PhoneNumber.IsNull() && !data.ContactDetail.PhoneNumber.IsUnknown() {
			contact_detailMap["phone_number"] = data.ContactDetail.PhoneNumber.ValueString()
		}
		if !data.ContactDetail.State.IsNull() && !data.ContactDetail.State.IsUnknown() {
			contact_detailMap["state"] = data.ContactDetail.State.ValueString()
		}
		if !data.ContactDetail.StateCode.IsNull() && !data.ContactDetail.StateCode.IsUnknown() {
			contact_detailMap["state_code"] = data.ContactDetail.StateCode.ValueString()
		}
		if !data.ContactDetail.ZipCode.IsNull() && !data.ContactDetail.ZipCode.IsUnknown() {
			contact_detailMap["zip_code"] = data.ContactDetail.ZipCode.ValueString()
		}
		createReq.Spec["contact_detail"] = contact_detailMap
	}
	if data.CustomerInfo != nil {
		customer_infoMap := make(map[string]interface{})
		if !data.CustomerInfo.AdditionalInfo.IsNull() && !data.CustomerInfo.AdditionalInfo.IsUnknown() {
			customer_infoMap["additional_info"] = data.CustomerInfo.AdditionalInfo.ValueString()
		}
		if !data.CustomerInfo.Email.IsNull() && !data.CustomerInfo.Email.IsUnknown() {
			customer_infoMap["email"] = data.CustomerInfo.Email.ValueString()
		}
		if !data.CustomerInfo.FirstName.IsNull() && !data.CustomerInfo.FirstName.IsUnknown() {
			customer_infoMap["first_name"] = data.CustomerInfo.FirstName.ValueString()
		}
		if !data.CustomerInfo.LastName.IsNull() && !data.CustomerInfo.LastName.IsUnknown() {
			customer_infoMap["last_name"] = data.CustomerInfo.LastName.ValueString()
		}
		createReq.Spec["customer_info"] = customer_infoMap
	}
	if data.TenantProfile != nil {
		tenant_profileMap := make(map[string]interface{})
		if !data.TenantProfile.Name.IsNull() && !data.TenantProfile.Name.IsUnknown() {
			tenant_profileMap["name"] = data.TenantProfile.Name.ValueString()
		}
		if !data.TenantProfile.Namespace.IsNull() && !data.TenantProfile.Namespace.IsUnknown() {
			tenant_profileMap["namespace"] = data.TenantProfile.Namespace.ValueString()
		}
		if !data.TenantProfile.Tenant.IsNull() && !data.TenantProfile.Tenant.IsUnknown() {
			tenant_profileMap["tenant"] = data.TenantProfile.Tenant.ValueString()
		}
		createReq.Spec["tenant_profile"] = tenant_profileMap
	}
	if !data.CompanyName.IsNull() && !data.CompanyName.IsUnknown() {
		createReq.Spec["company_name"] = data.CompanyName.ValueString()
	}
	if !data.Domain.IsNull() && !data.Domain.IsUnknown() {
		createReq.Spec["domain"] = data.Domain.ValueString()
	}

	apiResource, err := r.client.CreateChildTenant(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create ChildTenant: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["child_tenant_manager"].(map[string]interface{}); ok && (isImport || data.ChildTenantManager != nil) {
		data.ChildTenantManager = &ChildTenantChildTenantManagerModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["contact_detail"].(map[string]interface{}); ok && (isImport || data.ContactDetail != nil) {
		data.ContactDetail = &ChildTenantContactDetailModel{
			Address1: func() types.String {
				if v, ok := blockData["address1"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Address2: func() types.String {
				if v, ok := blockData["address2"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			City: func() types.String {
				if v, ok := blockData["city"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ContactType: func() types.String {
				if v, ok := blockData["contact_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Country: func() types.String {
				if v, ok := blockData["country"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			County: func() types.String {
				if v, ok := blockData["county"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PhoneNumber: func() types.String {
				if v, ok := blockData["phone_number"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			State: func() types.String {
				if v, ok := blockData["state"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			StateCode: func() types.String {
				if v, ok := blockData["state_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ZipCode: func() types.String {
				if v, ok := blockData["zip_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["customer_info"].(map[string]interface{}); ok && (isImport || data.CustomerInfo != nil) {
		data.CustomerInfo = &ChildTenantCustomerInfoModel{
			AdditionalInfo: func() types.String {
				if v, ok := blockData["additional_info"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Email: func() types.String {
				if v, ok := blockData["email"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			FirstName: func() types.String {
				if v, ok := blockData["first_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LastName: func() types.String {
				if v, ok := blockData["last_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tenant_profile"].(map[string]interface{}); ok && (isImport || data.TenantProfile != nil) {
		data.TenantProfile = &ChildTenantTenantProfileModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["company_name"].(string); ok && v != "" {
		data.CompanyName = types.StringValue(v)
	} else {
		data.CompanyName = types.StringNull()
	}
	if v, ok := apiResource.Spec["domain"].(string); ok && v != "" {
		data.Domain = types.StringValue(v)
	} else {
		data.Domain = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created ChildTenant resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ChildTenantResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data ChildTenantResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetChildTenant(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "ChildTenant not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read ChildTenant: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The child_tenant may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["child_tenant_manager"].(map[string]interface{}); ok && (isImport || data.ChildTenantManager != nil) {
		data.ChildTenantManager = &ChildTenantChildTenantManagerModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["contact_detail"].(map[string]interface{}); ok && (isImport || data.ContactDetail != nil) {
		data.ContactDetail = &ChildTenantContactDetailModel{
			Address1: func() types.String {
				if v, ok := blockData["address1"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Address2: func() types.String {
				if v, ok := blockData["address2"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			City: func() types.String {
				if v, ok := blockData["city"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ContactType: func() types.String {
				if v, ok := blockData["contact_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Country: func() types.String {
				if v, ok := blockData["country"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			County: func() types.String {
				if v, ok := blockData["county"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PhoneNumber: func() types.String {
				if v, ok := blockData["phone_number"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			State: func() types.String {
				if v, ok := blockData["state"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			StateCode: func() types.String {
				if v, ok := blockData["state_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ZipCode: func() types.String {
				if v, ok := blockData["zip_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["customer_info"].(map[string]interface{}); ok && (isImport || data.CustomerInfo != nil) {
		data.CustomerInfo = &ChildTenantCustomerInfoModel{
			AdditionalInfo: func() types.String {
				if v, ok := blockData["additional_info"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Email: func() types.String {
				if v, ok := blockData["email"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			FirstName: func() types.String {
				if v, ok := blockData["first_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LastName: func() types.String {
				if v, ok := blockData["last_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tenant_profile"].(map[string]interface{}); ok && (isImport || data.TenantProfile != nil) {
		data.TenantProfile = &ChildTenantTenantProfileModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["company_name"].(string); ok && v != "" {
		data.CompanyName = types.StringValue(v)
	} else {
		data.CompanyName = types.StringNull()
	}
	if v, ok := apiResource.Spec["domain"].(string); ok && v != "" {
		data.Domain = types.StringValue(v)
	} else {
		data.Domain = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ChildTenantResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data ChildTenantResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.ChildTenant{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ChildTenantManager != nil {
		child_tenant_managerMap := make(map[string]interface{})
		if !data.ChildTenantManager.Name.IsNull() && !data.ChildTenantManager.Name.IsUnknown() {
			child_tenant_managerMap["name"] = data.ChildTenantManager.Name.ValueString()
		}
		if !data.ChildTenantManager.Namespace.IsNull() && !data.ChildTenantManager.Namespace.IsUnknown() {
			child_tenant_managerMap["namespace"] = data.ChildTenantManager.Namespace.ValueString()
		}
		if !data.ChildTenantManager.Tenant.IsNull() && !data.ChildTenantManager.Tenant.IsUnknown() {
			child_tenant_managerMap["tenant"] = data.ChildTenantManager.Tenant.ValueString()
		}
		apiResource.Spec["child_tenant_manager"] = child_tenant_managerMap
	}
	if data.ContactDetail != nil {
		contact_detailMap := make(map[string]interface{})
		if !data.ContactDetail.Address1.IsNull() && !data.ContactDetail.Address1.IsUnknown() {
			contact_detailMap["address1"] = data.ContactDetail.Address1.ValueString()
		}
		if !data.ContactDetail.Address2.IsNull() && !data.ContactDetail.Address2.IsUnknown() {
			contact_detailMap["address2"] = data.ContactDetail.Address2.ValueString()
		}
		if !data.ContactDetail.City.IsNull() && !data.ContactDetail.City.IsUnknown() {
			contact_detailMap["city"] = data.ContactDetail.City.ValueString()
		}
		if !data.ContactDetail.ContactType.IsNull() && !data.ContactDetail.ContactType.IsUnknown() {
			contact_detailMap["contact_type"] = data.ContactDetail.ContactType.ValueString()
		}
		if !data.ContactDetail.Country.IsNull() && !data.ContactDetail.Country.IsUnknown() {
			contact_detailMap["country"] = data.ContactDetail.Country.ValueString()
		}
		if !data.ContactDetail.County.IsNull() && !data.ContactDetail.County.IsUnknown() {
			contact_detailMap["county"] = data.ContactDetail.County.ValueString()
		}
		if !data.ContactDetail.PhoneNumber.IsNull() && !data.ContactDetail.PhoneNumber.IsUnknown() {
			contact_detailMap["phone_number"] = data.ContactDetail.PhoneNumber.ValueString()
		}
		if !data.ContactDetail.State.IsNull() && !data.ContactDetail.State.IsUnknown() {
			contact_detailMap["state"] = data.ContactDetail.State.ValueString()
		}
		if !data.ContactDetail.StateCode.IsNull() && !data.ContactDetail.StateCode.IsUnknown() {
			contact_detailMap["state_code"] = data.ContactDetail.StateCode.ValueString()
		}
		if !data.ContactDetail.ZipCode.IsNull() && !data.ContactDetail.ZipCode.IsUnknown() {
			contact_detailMap["zip_code"] = data.ContactDetail.ZipCode.ValueString()
		}
		apiResource.Spec["contact_detail"] = contact_detailMap
	}
	if data.CustomerInfo != nil {
		customer_infoMap := make(map[string]interface{})
		if !data.CustomerInfo.AdditionalInfo.IsNull() && !data.CustomerInfo.AdditionalInfo.IsUnknown() {
			customer_infoMap["additional_info"] = data.CustomerInfo.AdditionalInfo.ValueString()
		}
		if !data.CustomerInfo.Email.IsNull() && !data.CustomerInfo.Email.IsUnknown() {
			customer_infoMap["email"] = data.CustomerInfo.Email.ValueString()
		}
		if !data.CustomerInfo.FirstName.IsNull() && !data.CustomerInfo.FirstName.IsUnknown() {
			customer_infoMap["first_name"] = data.CustomerInfo.FirstName.ValueString()
		}
		if !data.CustomerInfo.LastName.IsNull() && !data.CustomerInfo.LastName.IsUnknown() {
			customer_infoMap["last_name"] = data.CustomerInfo.LastName.ValueString()
		}
		apiResource.Spec["customer_info"] = customer_infoMap
	}
	if data.TenantProfile != nil {
		tenant_profileMap := make(map[string]interface{})
		if !data.TenantProfile.Name.IsNull() && !data.TenantProfile.Name.IsUnknown() {
			tenant_profileMap["name"] = data.TenantProfile.Name.ValueString()
		}
		if !data.TenantProfile.Namespace.IsNull() && !data.TenantProfile.Namespace.IsUnknown() {
			tenant_profileMap["namespace"] = data.TenantProfile.Namespace.ValueString()
		}
		if !data.TenantProfile.Tenant.IsNull() && !data.TenantProfile.Tenant.IsUnknown() {
			tenant_profileMap["tenant"] = data.TenantProfile.Tenant.ValueString()
		}
		apiResource.Spec["tenant_profile"] = tenant_profileMap
	}
	if !data.CompanyName.IsNull() && !data.CompanyName.IsUnknown() {
		apiResource.Spec["company_name"] = data.CompanyName.ValueString()
	}
	if !data.Domain.IsNull() && !data.Domain.IsUnknown() {
		apiResource.Spec["domain"] = data.Domain.ValueString()
	}

	_, err := r.client.UpdateChildTenant(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update ChildTenant: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetChildTenant(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read ChildTenant after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["company_name"].(string); ok && v != "" {
		data.CompanyName = types.StringValue(v)
	} else if data.CompanyName.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.CompanyName = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["domain"].(string); ok && v != "" {
		data.Domain = types.StringValue(v)
	} else if data.Domain.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Domain = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["child_tenant_manager"].(map[string]interface{}); ok && (isImport || data.ChildTenantManager != nil) {
		data.ChildTenantManager = &ChildTenantChildTenantManagerModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["contact_detail"].(map[string]interface{}); ok && (isImport || data.ContactDetail != nil) {
		data.ContactDetail = &ChildTenantContactDetailModel{
			Address1: func() types.String {
				if v, ok := blockData["address1"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Address2: func() types.String {
				if v, ok := blockData["address2"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			City: func() types.String {
				if v, ok := blockData["city"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ContactType: func() types.String {
				if v, ok := blockData["contact_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Country: func() types.String {
				if v, ok := blockData["country"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			County: func() types.String {
				if v, ok := blockData["county"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PhoneNumber: func() types.String {
				if v, ok := blockData["phone_number"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			State: func() types.String {
				if v, ok := blockData["state"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			StateCode: func() types.String {
				if v, ok := blockData["state_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ZipCode: func() types.String {
				if v, ok := blockData["zip_code"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["customer_info"].(map[string]interface{}); ok && (isImport || data.CustomerInfo != nil) {
		data.CustomerInfo = &ChildTenantCustomerInfoModel{
			AdditionalInfo: func() types.String {
				if v, ok := blockData["additional_info"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Email: func() types.String {
				if v, ok := blockData["email"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			FirstName: func() types.String {
				if v, ok := blockData["first_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LastName: func() types.String {
				if v, ok := blockData["last_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tenant_profile"].(map[string]interface{}); ok && (isImport || data.TenantProfile != nil) {
		data.TenantProfile = &ChildTenantTenantProfileModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["company_name"].(string); ok && v != "" {
		data.CompanyName = types.StringValue(v)
	} else {
		data.CompanyName = types.StringNull()
	}
	if v, ok := apiResource.Spec["domain"].(string); ok && v != "" {
		data.Domain = types.StringValue(v)
	} else {
		data.Domain = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ChildTenantResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data ChildTenantResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteChildTenant(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "ChildTenant already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "ChildTenant delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete ChildTenant: %s", err))
		return
	}
}

func (r *ChildTenantResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
