// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
)

var (
	_ resource.Resource                = &CloudCredentialsResource{}
	_ resource.ResourceWithConfigure   = &CloudCredentialsResource{}
	_ resource.ResourceWithImportState = &CloudCredentialsResource{}
)

func NewCloudCredentialsResource() resource.Resource {
	return &CloudCredentialsResource{}
}

type CloudCredentialsResource struct {
	client *client.Client
}

type CloudCredentialsResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Labels types.Map `tfsdk:"labels"`
	Annotations types.Map `tfsdk:"annotations"`
	ID types.String `tfsdk:"id"`
}

func (r *CloudCredentialsResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cloud_credentials"
}

func (r *CloudCredentialsResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a CloudCredentials resource in F5 Distributed Cloud for cloud provider credential management for site deployment.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the CloudCredentials. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the CloudCredentials will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"aws_assume_role": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: aws_assume_role, aws_secret_key, azure_client_secret, azure_pfx_certificate, gcp_cred_file] AWS Assume Role to Handle Delegated Access. AWS Assume Role to Handle Delegated Access",
				Attributes: map[string]schema.Attribute{
					"custom_external_id": schema.StringAttribute{
						MarkdownDescription: "External ID is Custom ID. External ID is Custom ID",
						Optional: true,
					},
					"duration_seconds": schema.Int64Attribute{
						MarkdownDescription: "Role Session Duration Seconds. The duration, in seconds of the role session.",
						Optional: true,
					},
					"role_arn": schema.StringAttribute{
						MarkdownDescription: "IAM Role ARN. IAM Role ARN to assume the role",
						Optional: true,
					},
					"session_name": schema.StringAttribute{
						MarkdownDescription: "Role Session Name. Use the role session name to uniquely identify a session, which will be used for deploy, monitor from F5XC console",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"external_id_is_optional": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"external_id_is_tenant_id": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"session_tags": schema.SingleNestedBlock{
						MarkdownDescription: "Role Session Tags. Session tags are key-value pair attributes that you pass when you assume an IAM role",
					},
				},

			},
			"aws_secret_key": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Programmatic Access Credentials. AWS Programmatic Access Credentials type",
				Attributes: map[string]schema.Attribute{
					"access_key": schema.StringAttribute{
						MarkdownDescription: "Access Key ID. Access key ID for your AWS account",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"secret_key": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
			"azure_client_secret": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Client Secret. Azure Credentials Client Secret type",
				Attributes: map[string]schema.Attribute{
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID for your Azure service principal",
						Optional: true,
					},
					"subscription_id": schema.StringAttribute{
						MarkdownDescription: "Subscription ID. Subscription ID for your Azure service principal",
						Optional: true,
					},
					"tenant_id": schema.StringAttribute{
						MarkdownDescription: "Tenant ID. Tenant ID for your Azure service principal",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"client_secret": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
			"azure_pfx_certificate": schema.SingleNestedBlock{
				MarkdownDescription: "Client Certificate. Azure Credentials Client Certificate type",
				Attributes: map[string]schema.Attribute{
					"certificate_url": schema.StringAttribute{
						MarkdownDescription: "URL for Client Certificate. URL for Client Certificate in '.pfx' or '.p12' whose certificate is linked to service principal object Certificate URL can contain client certificate in string:///<Base64 of certificate> format. Here <Base64 of certificate> is base64 of '.pfx' or '.p12' binary file",
						Optional: true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID for your Azure service principal",
						Optional: true,
					},
					"subscription_id": schema.StringAttribute{
						MarkdownDescription: "Subscription ID. Subscription ID for your Azure service principal",
						Optional: true,
					},
					"tenant_id": schema.StringAttribute{
						MarkdownDescription: "Tenant ID. Tenant ID for your Azure service principal",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"password": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
			"gcp_cred_file": schema.SingleNestedBlock{
				MarkdownDescription: "GCP Credentials. GCP Credentials type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"credential_file": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *CloudCredentialsResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *CloudCredentialsResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CloudCredentialsResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.CloudCredentials{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.CloudCredentialsSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateCloudCredentials(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create CloudCredentials: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)
	tflog.Trace(ctx, "created CloudCredentials resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CloudCredentialsResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CloudCredentialsResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource, err := r.client.GetCloudCredentials(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CloudCredentials: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CloudCredentialsResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data CloudCredentialsResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.CloudCredentials{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.CloudCredentialsSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateCloudCredentials(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update CloudCredentials: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CloudCredentialsResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CloudCredentialsResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteCloudCredentials(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete CloudCredentials: %s", err))
		return
	}
}

func (r *CloudCredentialsResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
