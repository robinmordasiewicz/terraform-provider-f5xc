// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &CustomerSupportResource{}
	_ resource.ResourceWithConfigure      = &CustomerSupportResource{}
	_ resource.ResourceWithImportState    = &CustomerSupportResource{}
	_ resource.ResourceWithModifyPlan     = &CustomerSupportResource{}
	_ resource.ResourceWithUpgradeState   = &CustomerSupportResource{}
	_ resource.ResourceWithValidateConfig = &CustomerSupportResource{}
)

// customer_supportSchemaVersion is the schema version for state upgrades
const customer_supportSchemaVersion int64 = 1

func NewCustomerSupportResource() resource.Resource {
	return &CustomerSupportResource{}
}

type CustomerSupportResource struct {
	client *client.Client
}

// CustomerSupportEmptyModel represents empty nested blocks
type CustomerSupportEmptyModel struct {
}

// CustomerSupportCommentsModel represents comments block
type CustomerSupportCommentsModel struct {
	AttachmentIds types.List `tfsdk:"attachment_ids"`
	AuthorEmail types.String `tfsdk:"author_email"`
	AuthorName types.String `tfsdk:"author_name"`
	CreatedAt types.String `tfsdk:"created_at"`
	Html types.String `tfsdk:"html"`
	PlainText types.String `tfsdk:"plain_text"`
	AttachmentsInfo []CustomerSupportCommentsAttachmentsInfoModel `tfsdk:"attachments_info"`
}

// CustomerSupportCommentsAttachmentsInfoModel represents attachments_info block
type CustomerSupportCommentsAttachmentsInfoModel struct {
	Attachment types.String `tfsdk:"attachment"`
	ContentType types.String `tfsdk:"content_type"`
	Filename types.String `tfsdk:"filename"`
	TpID types.String `tfsdk:"tp_id"`
}

// CustomerSupportRelatesToModel represents relates_to block
type CustomerSupportRelatesToModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

type CustomerSupportResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Category types.String `tfsdk:"category"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Ongoing types.Bool `tfsdk:"ongoing"`
	Priority types.String `tfsdk:"priority"`
	ProductData types.String `tfsdk:"product_data"`
	Service types.String `tfsdk:"service"`
	Status types.String `tfsdk:"status"`
	Subject types.String `tfsdk:"subject"`
	Timeline types.String `tfsdk:"timeline"`
	Topic types.String `tfsdk:"topic"`
	TpID types.String `tfsdk:"tp_id"`
	Type types.String `tfsdk:"type"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	Comments []CustomerSupportCommentsModel `tfsdk:"comments"`
	RelatesTo []CustomerSupportRelatesToModel `tfsdk:"relates_to"`
}

func (r *CustomerSupportResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_customer_support"
}

func (r *CustomerSupportResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             customer_supportSchemaVersion,
		MarkdownDescription: "Manages new customer support ticket in our customer support provider system. in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the CustomerSupport. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the CustomerSupport will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"category": schema.StringAttribute{
				MarkdownDescription: "Category. ticket area further narrows down the ticket - infrastructure, application, dashboards can be examples.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"description_spec": schema.StringAttribute{
				MarkdownDescription: "Description. customer's description of the issue (free text)",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ongoing": schema.BoolAttribute{
				MarkdownDescription: "Ongoing. Ongoing is a flag that indicates whether the issue is ongoing or not.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"priority": schema.StringAttribute{
				MarkdownDescription: "Priority. Support ticket priority helps understand importance of the ticket and focus more on more critical issues. Unknown/empty priority Normal priority issue High priority issue Urgent priority issue. Possible values are `PRIORITY_UNKNOWN`, `PRIORITY_NORMAL`, `PRIORITY_HIGH`, `PRIORITY_URGENT`. Defaults to `PRIORITY_UNKNOWN`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"product_data": schema.StringAttribute{
				MarkdownDescription: "Product Data. Product data is a free text field that can be used to describe the issue in more detail.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"service": schema.StringAttribute{
				MarkdownDescription: "Support Service. Indicates the list of support service Unknown Support Service Account Protection Support Service Administration Support Service Application Traffic Insight Support Service Audit Logs & Alerts Support Service Authentication Intelligence Support Service Billing Support Service Client Side Defense Support Service Cloud & Edge Sites Support Service deprecated: use SS_MULTI_CLOUD_NETWORK_CONNECT instead DDOS & Transit Support Service Deprecated: use SS_ROUTED_DDOS instead Distributed Apps Support Service DNS Management Support Service LoadBalancers Support Service deprecated: use SS_MULTI_CLOUD_APP_CONNECT instead Shared Configuration Support Service Web App & API Protection Support Service Other Support Service Bot Defense Support Service Content delivery network Support Service Observability Support Service Delegated Access Support Service Networking & security across clouds, edge and on-premises Connect apps across clouds, edge and on-premises using Load Balancers BIG-IP Access Policy Manager (APM) Data Intelligence Support Service NGINX One Support Service Web App Scanning Support Service Routed DDoS Support Service Mobile App Shield protects mobile apps from reverse engineering, tampering and malware. Possible values are `SS_UNKNOWN`, `SS_ACCOUNT_PROTECTION`, `SS_ADMINISTRATION`, `SS_APPLICATION_TRAFFIC_INSIGHT`, `SS_AUDIT_LOGS_AND_ALERTS`, `SS_AUTHENTICATION_INTELLIGENCE`, `SS_BILLING`, `SS_CLIENT_SIDE_DEFENSE`, `SS_CLOUD_AND_EDGE_SITES`, `SS_DDOS_AND_TRANSIT_SERVICES`, `SS_DISTRIBUTED_APPS`, `SS_DNS_MANAGEMENT`, `SS_LOAD_BALANCERS`, `SS_SHARED_CONFIGURATION`, `SS_WEB_APP_AND_API_PROTECTION`, `SS_OTHER`, `SS_BOT_DEFENSE`, `SS_CDN`, `SS_OBSERVABILITY`, `SS_DELEGATED_ACCESS`, `SS_MULTI_CLOUD_NETWORK_CONNECT`, `SS_MULTI_CLOUD_APP_CONNECT`, `SS_BIG_IP_APM`, `SS_DATA_INTELLIGENCE`, `SS_NGINX_ONE`, `SS_WEB_APP_SCANNING`, `SS_ROUTED_DDOS`, `SS_MOBILE_APP_SHIELD`. Defaults to `SS_UNKNOWN`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"status": schema.StringAttribute{
				MarkdownDescription: "Support Ticket Status. State of the ticket so the customers know if the problem is being looked into Unknown or empty support ticket status Indicates a new ticket, waiting to be assigned to an agent Indicates an open issues, actively being looked into Indicates a pending issue, an open issue not actively being looked into Indicates on issue that on-hold, waiting for more information Indicates a solved issue, waiting for customer's confirmation Indicates a closed issue, resolved and customer approved Indicates a failed ticket, a failed ticket didn't make it into Zendesk and a customer should create new one instead. Possible values are `STATUS_UNKNOWN`, `STATUS_NEW`, `STATUS_OPEN`, `STATUS_PENDING`, `STATUS_ONHOLD`, `STATUS_SOLVED`, `STATUS_CLOSED`, `STATUS_FAILED`. Defaults to `STATUS_UNKNOWN`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"subject": schema.StringAttribute{
				MarkdownDescription: "Subject. subject of the ticket",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"timeline": schema.StringAttribute{
				MarkdownDescription: "Timeline. Timeline is a free text field that can be used to describe the issue in more detail.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"topic": schema.StringAttribute{
				MarkdownDescription: "Support Topic. Support Topic indicates the list of topics for service tickets Unknown/empty priority ACCOUNT_SUPPORT_TOPIC_ACCESS_REQUEST ACCOUNT_SUPPORT_TOPIC_ACCOUNT ACCOUNT_SUPPORT_TOPIC_BILLING ACCOUNT_SUPPORT_TOPIC_BILLING_PLAN_CHANGE ACCOUNT_SUPPORT_TOPIC_PUBLIC_IP ACCOUNT_SUPPORT_TOPIC_QUOTA_INCREASE ACCOUNT_SUPPORT_TOPIC_RMA ACCOUNT_SUPPORT_TOPIC_TAX_EXEMPT_VERIFICATION ACCOUNT_SUPPORT_TOPIC_OTHERS TECHNICAL_SUPPORT_TOPIC_CONFIGURATION_CHANGES TECHNICAL_SUPPORT_TOPIC_ERROR_MESSAGE TECHNICAL_SUPPORT_TOPIC_NEW_CONFIGURATION TECHNICAL_SUPPORT_TOPIC_PRODUCT_QUESTION TECHNICAL_SUPPORT_TOPIC_TROUBLESHOOTING TECHNICAL_SUPPORT_TOPIC_OTHERS INCIDENT_SUPPORT_TOPIC_LATENCY INCIDENT_SUPPORT_TOPIC_PERFORMANCE_DEGRADATION INCIDENT_SUPPORT_TOPIC_PARTIAL_OUTAGE INCIDENT_SUPPORT_TOPIC_COMPLETE_OUTAGE INCIDENT_SUPPORT_TOPIC_OTHERS TASK_TOPIC_PLAN_TRANSITION PROBLEM_TOPIC_SUPPORT_ALERT QUESTION_TOPIC_INFRASTRUCTURE TECHNICAL_SUPPORT_TOPIC_DELEGATED_DOMAIN_MIGRATION. Possible values are `TOPIC_UNKNOWN`, `ACCOUNT_SUPPORT_TOPIC_ACCESS_REQUEST`, `ACCOUNT_SUPPORT_TOPIC_ACCOUNT`, `ACCOUNT_SUPPORT_TOPIC_BILLING`, `ACCOUNT_SUPPORT_TOPIC_BILLING_PLAN_CHANGE`, `ACCOUNT_SUPPORT_TOPIC_PUBLIC_IP`, `ACCOUNT_SUPPORT_TOPIC_QUOTA_INCREASE`, `ACCOUNT_SUPPORT_TOPIC_RMA`, `ACCOUNT_SUPPORT_TOPIC_TAX_EXEMPT_VERIFICATION`, `ACCOUNT_SUPPORT_TOPIC_OTHERS`, `TECHNICAL_SUPPORT_TOPIC_CONFIGURATION_CHANGES`, `TECHNICAL_SUPPORT_TOPIC_ERROR_MESSAGE`, `TECHNICAL_SUPPORT_TOPIC_NEW_CONFIGURATION`, `TECHNICAL_SUPPORT_TOPIC_PRODUCT_QUESTION`, `TECHNICAL_SUPPORT_TOPIC_TROUBLESHOOTING`, `TECHNICAL_SUPPORT_TOPIC_OTHERS`, `INCIDENT_SUPPORT_TOPIC_LATENCY`, `INCIDENT_SUPPORT_TOPIC_PERFORMANCE_DEGRADATION`, `INCIDENT_SUPPORT_TOPIC_PARTIAL_OUTAGE`, `INCIDENT_SUPPORT_TOPIC_COMPLETE_OUTAGE`, `INCIDENT_SUPPORT_TOPIC_OTHERS`, `TASK_TOPIC_PLAN_TRANSITION`, `PROBLEM_TOPIC_SUPPORT_ALERT`, `QUESTION_TOPIC_INFRASTRUCTURE`, `TECHNICAL_SUPPORT_TOPIC_DELEGATED_DOMAIN_MIGRATION`. Defaults to `TOPIC_UNKNOWN`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"tp_id": schema.StringAttribute{
				MarkdownDescription: "Third Party ID. ID assigned to this ticket by our support provider.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"type": schema.StringAttribute{
				MarkdownDescription: "Support Ticket. Several types of issues are supported, such as problems, questions. Unknown or empty ticket type Indicates a problem (e.g. misconfiguration) Indicates a task (a request to do something) Indicates a question (billing, services related) Indicates an incident (something is not working) Indicates a technical support ticket Indicates an account support ticket Indicates an Incident support ticket. Possible values are `TYPE_UNKNOWN`, `TYPE_PROBLEM`, `TYPE_TASK`, `TYPE_QUESTION`, `TYPE_INCIDENT`, `TYPE_TECHNICAL_SUPPORT`, `TYPE_ACCOUNT_SUPPORT`, `TYPE_INCIDENT_SUPPORT`. Defaults to `TYPE_UNKNOWN`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"comments": schema.ListNestedBlock{
				MarkdownDescription: "Comments. Comments are all public comments on an issue. They're usually conversation between the support personnel and the customer.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"attachment_ids": schema.ListAttribute{
							MarkdownDescription: "Attachment IDs. Third party id of any attachment related to this ticket comment",
							Optional: true,
							ElementType: types.StringType,
						},
						"author_email": schema.StringAttribute{
							MarkdownDescription: "Email. Email of the author of the comment",
							Optional: true,
						},
						"author_name": schema.StringAttribute{
							MarkdownDescription: "Author. Author of the comment (as a name)",
							Optional: true,
						},
						"created_at": schema.StringAttribute{
							MarkdownDescription: "At. Comment creation time",
							Optional: true,
						},
						"html": schema.StringAttribute{
							MarkdownDescription: "Comment. Comment body as HTML",
							Optional: true,
						},
						"plain_text": schema.StringAttribute{
							MarkdownDescription: "Comment. Comment body as plain text",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"attachments_info": schema.ListNestedBlock{
							MarkdownDescription: "Attachments details. Information about any attachments (such as screenshots, plain text files) the comment can have.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"attachment": schema.StringAttribute{
										MarkdownDescription: "Attachment data. Any binary attachment (such as screenshots, plain text files, PDFs) encoded as base64 if used over HTTP.",
										Optional: true,
									},
									"content_type": schema.StringAttribute{
										MarkdownDescription: "Content type. Mime content type of the attachment. Helps the UI to properly display the data.",
										Optional: true,
									},
									"filename": schema.StringAttribute{
										MarkdownDescription: "Filename. Filename of the attachment as provided by the caller.",
										Optional: true,
									},
									"tp_id": schema.StringAttribute{
										MarkdownDescription: "3rd party ID. Optional ID as assigned by the 3rd party actually storing the data.",
										Optional: true,
									},
								},
							},
						},
					},

				},
			},
			"relates_to": schema.ListNestedBlock{
				MarkdownDescription: "Ticket which this one relates to. Optional reference to any original ticket in case the ticket being created is a followup.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"kind": schema.StringAttribute{
							MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
							Optional: true,
							Computed: true,
						},
						"name": schema.StringAttribute{
							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
							Optional: true,
						},
						"tenant": schema.StringAttribute{
							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
							Optional: true,
							Computed: true,
						},
						"uid": schema.StringAttribute{
							MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
							Optional: true,
							Computed: true,
						},
					},

				},
			},
		},
	}
}

func (r *CustomerSupportResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *CustomerSupportResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data CustomerSupportResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *CustomerSupportResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the customer_support from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan CustomerSupportResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *CustomerSupportResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := CustomerSupportResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *CustomerSupportResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data CustomerSupportResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating customer_support", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.CustomerSupport{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if len(data.Comments) > 0 {
		var commentsList []map[string]interface{}
		for _, item := range data.Comments {
			itemMap := make(map[string]interface{})
			if len(item.AttachmentsInfo) > 0 {
				var attachments_infoNestedList []map[string]interface{}
				for _, nestedItem := range item.AttachmentsInfo {
					nestedItemMap := make(map[string]interface{})
					if !nestedItem.Attachment.IsNull() && !nestedItem.Attachment.IsUnknown() {
						nestedItemMap["attachment"] = nestedItem.Attachment.ValueString()
					}
					if !nestedItem.ContentType.IsNull() && !nestedItem.ContentType.IsUnknown() {
						nestedItemMap["content_type"] = nestedItem.ContentType.ValueString()
					}
					if !nestedItem.Filename.IsNull() && !nestedItem.Filename.IsUnknown() {
						nestedItemMap["filename"] = nestedItem.Filename.ValueString()
					}
					if !nestedItem.TpID.IsNull() && !nestedItem.TpID.IsUnknown() {
						nestedItemMap["tp_id"] = nestedItem.TpID.ValueString()
					}
					attachments_infoNestedList = append(attachments_infoNestedList, nestedItemMap)
				}
				itemMap["attachments_info"] = attachments_infoNestedList
			}
			if !item.AuthorEmail.IsNull() && !item.AuthorEmail.IsUnknown() {
				itemMap["author_email"] = item.AuthorEmail.ValueString()
			}
			if !item.AuthorName.IsNull() && !item.AuthorName.IsUnknown() {
				itemMap["author_name"] = item.AuthorName.ValueString()
			}
			if !item.CreatedAt.IsNull() && !item.CreatedAt.IsUnknown() {
				itemMap["created_at"] = item.CreatedAt.ValueString()
			}
			if !item.Html.IsNull() && !item.Html.IsUnknown() {
				itemMap["html"] = item.Html.ValueString()
			}
			if !item.PlainText.IsNull() && !item.PlainText.IsUnknown() {
				itemMap["plain_text"] = item.PlainText.ValueString()
			}
			commentsList = append(commentsList, itemMap)
		}
		createReq.Spec["comments"] = commentsList
	}
	if len(data.RelatesTo) > 0 {
		var relates_toList []map[string]interface{}
		for _, item := range data.RelatesTo {
			itemMap := make(map[string]interface{})
			if !item.Kind.IsNull() && !item.Kind.IsUnknown() {
				itemMap["kind"] = item.Kind.ValueString()
			}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				itemMap["name"] = item.Name.ValueString()
			}
			if !item.Namespace.IsNull() && !item.Namespace.IsUnknown() {
				itemMap["namespace"] = item.Namespace.ValueString()
			}
			if !item.Tenant.IsNull() && !item.Tenant.IsUnknown() {
				itemMap["tenant"] = item.Tenant.ValueString()
			}
			if !item.Uid.IsNull() && !item.Uid.IsUnknown() {
				itemMap["uid"] = item.Uid.ValueString()
			}
			relates_toList = append(relates_toList, itemMap)
		}
		createReq.Spec["relates_to"] = relates_toList
	}
	if !data.Category.IsNull() && !data.Category.IsUnknown() {
		createReq.Spec["category"] = data.Category.ValueString()
	}
	if !data.DescriptionSpec.IsNull() && !data.DescriptionSpec.IsUnknown() {
		createReq.Spec["description"] = data.DescriptionSpec.ValueString()
	}
	if !data.Ongoing.IsNull() && !data.Ongoing.IsUnknown() {
		createReq.Spec["ongoing"] = data.Ongoing.ValueBool()
	}
	if !data.Priority.IsNull() && !data.Priority.IsUnknown() {
		createReq.Spec["priority"] = data.Priority.ValueString()
	}
	if !data.ProductData.IsNull() && !data.ProductData.IsUnknown() {
		createReq.Spec["product_data"] = data.ProductData.ValueString()
	}
	if !data.Service.IsNull() && !data.Service.IsUnknown() {
		createReq.Spec["service"] = data.Service.ValueString()
	}
	if !data.Status.IsNull() && !data.Status.IsUnknown() {
		createReq.Spec["status"] = data.Status.ValueString()
	}
	if !data.Subject.IsNull() && !data.Subject.IsUnknown() {
		createReq.Spec["subject"] = data.Subject.ValueString()
	}
	if !data.Timeline.IsNull() && !data.Timeline.IsUnknown() {
		createReq.Spec["timeline"] = data.Timeline.ValueString()
	}
	if !data.Topic.IsNull() && !data.Topic.IsUnknown() {
		createReq.Spec["topic"] = data.Topic.ValueString()
	}
	if !data.TpID.IsNull() && !data.TpID.IsUnknown() {
		createReq.Spec["tp_id"] = data.TpID.ValueString()
	}
	if !data.Type.IsNull() && !data.Type.IsUnknown() {
		createReq.Spec["type"] = data.Type.ValueString()
	}


	apiResource, err := r.client.CreateCustomerSupport(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create CustomerSupport: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport // May be unused if resource has no blocks needing import detection
	if listData, ok := apiResource.Spec["comments"].([]interface{}); ok && len(listData) > 0 {
		var commentsList []CustomerSupportCommentsModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				commentsList = append(commentsList, CustomerSupportCommentsModel{
					AttachmentIds: func() types.List {
						if v, ok := itemMap["attachment_ids"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AttachmentsInfo: func() []CustomerSupportCommentsAttachmentsInfoModel {
						if nestedListData, ok := itemMap["attachments_info"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []CustomerSupportCommentsAttachmentsInfoModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, CustomerSupportCommentsAttachmentsInfoModel{
										Attachment: func() types.String {
											if v, ok := nestedItemMap["attachment"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										ContentType: func() types.String {
											if v, ok := nestedItemMap["content_type"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Filename: func() types.String {
											if v, ok := nestedItemMap["filename"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										TpID: func() types.String {
											if v, ok := nestedItemMap["tp_id"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					AuthorEmail: func() types.String {
						if v, ok := itemMap["author_email"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					AuthorName: func() types.String {
						if v, ok := itemMap["author_name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					CreatedAt: func() types.String {
						if v, ok := itemMap["created_at"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Html: func() types.String {
						if v, ok := itemMap["html"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					PlainText: func() types.String {
						if v, ok := itemMap["plain_text"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.Comments = commentsList
	}
	if listData, ok := apiResource.Spec["relates_to"].([]interface{}); ok && len(listData) > 0 {
		var relates_toList []CustomerSupportRelatesToModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				relates_toList = append(relates_toList, CustomerSupportRelatesToModel{
					Kind: func() types.String {
						if v, ok := itemMap["kind"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Namespace: func() types.String {
						if v, ok := itemMap["namespace"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Tenant: func() types.String {
						if v, ok := itemMap["tenant"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Uid: func() types.String {
						if v, ok := itemMap["uid"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.RelatesTo = relates_toList
	}
	if v, ok := apiResource.Spec["category"].(string); ok && v != "" {
		data.Category = types.StringValue(v)
	} else {
		data.Category = types.StringNull()
	}
	if v, ok := apiResource.Spec["description"].(string); ok && v != "" {
		data.DescriptionSpec = types.StringValue(v)
	} else {
		data.DescriptionSpec = types.StringNull()
	}
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.Ongoing.IsNull() && !data.Ongoing.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["ongoing"].(bool); ok {
			data.Ongoing = types.BoolValue(v)
		} else {
			data.Ongoing = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["priority"].(string); ok && v != "" {
		data.Priority = types.StringValue(v)
	} else {
		data.Priority = types.StringNull()
	}
	if v, ok := apiResource.Spec["product_data"].(string); ok && v != "" {
		data.ProductData = types.StringValue(v)
	} else {
		data.ProductData = types.StringNull()
	}
	if v, ok := apiResource.Spec["service"].(string); ok && v != "" {
		data.Service = types.StringValue(v)
	} else {
		data.Service = types.StringNull()
	}
	if v, ok := apiResource.Spec["status"].(string); ok && v != "" {
		data.Status = types.StringValue(v)
	} else {
		data.Status = types.StringNull()
	}
	if v, ok := apiResource.Spec["subject"].(string); ok && v != "" {
		data.Subject = types.StringValue(v)
	} else {
		data.Subject = types.StringNull()
	}
	if v, ok := apiResource.Spec["timeline"].(string); ok && v != "" {
		data.Timeline = types.StringValue(v)
	} else {
		data.Timeline = types.StringNull()
	}
	if v, ok := apiResource.Spec["topic"].(string); ok && v != "" {
		data.Topic = types.StringValue(v)
	} else {
		data.Topic = types.StringNull()
	}
	if v, ok := apiResource.Spec["tp_id"].(string); ok && v != "" {
		data.TpID = types.StringValue(v)
	} else {
		data.TpID = types.StringNull()
	}
	if v, ok := apiResource.Spec["type"].(string); ok && v != "" {
		data.Type = types.StringValue(v)
	} else {
		data.Type = types.StringNull()
	}


	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created CustomerSupport resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CustomerSupportResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data CustomerSupportResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetCustomerSupport(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CustomerSupport not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read CustomerSupport: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The customer_support may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if listData, ok := apiResource.Spec["comments"].([]interface{}); ok && len(listData) > 0 {
		var commentsList []CustomerSupportCommentsModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				commentsList = append(commentsList, CustomerSupportCommentsModel{
					AttachmentIds: func() types.List {
						if v, ok := itemMap["attachment_ids"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AttachmentsInfo: func() []CustomerSupportCommentsAttachmentsInfoModel {
						if nestedListData, ok := itemMap["attachments_info"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []CustomerSupportCommentsAttachmentsInfoModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, CustomerSupportCommentsAttachmentsInfoModel{
										Attachment: func() types.String {
											if v, ok := nestedItemMap["attachment"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										ContentType: func() types.String {
											if v, ok := nestedItemMap["content_type"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Filename: func() types.String {
											if v, ok := nestedItemMap["filename"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										TpID: func() types.String {
											if v, ok := nestedItemMap["tp_id"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					AuthorEmail: func() types.String {
						if v, ok := itemMap["author_email"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					AuthorName: func() types.String {
						if v, ok := itemMap["author_name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					CreatedAt: func() types.String {
						if v, ok := itemMap["created_at"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Html: func() types.String {
						if v, ok := itemMap["html"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					PlainText: func() types.String {
						if v, ok := itemMap["plain_text"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.Comments = commentsList
	}
	if listData, ok := apiResource.Spec["relates_to"].([]interface{}); ok && len(listData) > 0 {
		var relates_toList []CustomerSupportRelatesToModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				relates_toList = append(relates_toList, CustomerSupportRelatesToModel{
					Kind: func() types.String {
						if v, ok := itemMap["kind"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Namespace: func() types.String {
						if v, ok := itemMap["namespace"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Tenant: func() types.String {
						if v, ok := itemMap["tenant"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Uid: func() types.String {
						if v, ok := itemMap["uid"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.RelatesTo = relates_toList
	}
	if v, ok := apiResource.Spec["category"].(string); ok && v != "" {
		data.Category = types.StringValue(v)
	} else {
		data.Category = types.StringNull()
	}
	if v, ok := apiResource.Spec["description"].(string); ok && v != "" {
		data.DescriptionSpec = types.StringValue(v)
	} else {
		data.DescriptionSpec = types.StringNull()
	}
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.Ongoing.IsNull() && !data.Ongoing.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["ongoing"].(bool); ok {
			data.Ongoing = types.BoolValue(v)
		} else {
			data.Ongoing = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["priority"].(string); ok && v != "" {
		data.Priority = types.StringValue(v)
	} else {
		data.Priority = types.StringNull()
	}
	if v, ok := apiResource.Spec["product_data"].(string); ok && v != "" {
		data.ProductData = types.StringValue(v)
	} else {
		data.ProductData = types.StringNull()
	}
	if v, ok := apiResource.Spec["service"].(string); ok && v != "" {
		data.Service = types.StringValue(v)
	} else {
		data.Service = types.StringNull()
	}
	if v, ok := apiResource.Spec["status"].(string); ok && v != "" {
		data.Status = types.StringValue(v)
	} else {
		data.Status = types.StringNull()
	}
	if v, ok := apiResource.Spec["subject"].(string); ok && v != "" {
		data.Subject = types.StringValue(v)
	} else {
		data.Subject = types.StringNull()
	}
	if v, ok := apiResource.Spec["timeline"].(string); ok && v != "" {
		data.Timeline = types.StringValue(v)
	} else {
		data.Timeline = types.StringNull()
	}
	if v, ok := apiResource.Spec["topic"].(string); ok && v != "" {
		data.Topic = types.StringValue(v)
	} else {
		data.Topic = types.StringNull()
	}
	if v, ok := apiResource.Spec["tp_id"].(string); ok && v != "" {
		data.TpID = types.StringValue(v)
	} else {
		data.TpID = types.StringNull()
	}
	if v, ok := apiResource.Spec["type"].(string); ok && v != "" {
		data.Type = types.StringValue(v)
	} else {
		data.Type = types.StringNull()
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CustomerSupportResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data CustomerSupportResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.CustomerSupport{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if len(data.Comments) > 0 {
		var commentsList []map[string]interface{}
		for _, item := range data.Comments {
			itemMap := make(map[string]interface{})
			if len(item.AttachmentsInfo) > 0 {
				var attachments_infoNestedList []map[string]interface{}
				for _, nestedItem := range item.AttachmentsInfo {
					nestedItemMap := make(map[string]interface{})
					if !nestedItem.Attachment.IsNull() && !nestedItem.Attachment.IsUnknown() {
						nestedItemMap["attachment"] = nestedItem.Attachment.ValueString()
					}
					if !nestedItem.ContentType.IsNull() && !nestedItem.ContentType.IsUnknown() {
						nestedItemMap["content_type"] = nestedItem.ContentType.ValueString()
					}
					if !nestedItem.Filename.IsNull() && !nestedItem.Filename.IsUnknown() {
						nestedItemMap["filename"] = nestedItem.Filename.ValueString()
					}
					if !nestedItem.TpID.IsNull() && !nestedItem.TpID.IsUnknown() {
						nestedItemMap["tp_id"] = nestedItem.TpID.ValueString()
					}
					attachments_infoNestedList = append(attachments_infoNestedList, nestedItemMap)
				}
				itemMap["attachments_info"] = attachments_infoNestedList
			}
			if !item.AuthorEmail.IsNull() && !item.AuthorEmail.IsUnknown() {
				itemMap["author_email"] = item.AuthorEmail.ValueString()
			}
			if !item.AuthorName.IsNull() && !item.AuthorName.IsUnknown() {
				itemMap["author_name"] = item.AuthorName.ValueString()
			}
			if !item.CreatedAt.IsNull() && !item.CreatedAt.IsUnknown() {
				itemMap["created_at"] = item.CreatedAt.ValueString()
			}
			if !item.Html.IsNull() && !item.Html.IsUnknown() {
				itemMap["html"] = item.Html.ValueString()
			}
			if !item.PlainText.IsNull() && !item.PlainText.IsUnknown() {
				itemMap["plain_text"] = item.PlainText.ValueString()
			}
			commentsList = append(commentsList, itemMap)
		}
		apiResource.Spec["comments"] = commentsList
	}
	if len(data.RelatesTo) > 0 {
		var relates_toList []map[string]interface{}
		for _, item := range data.RelatesTo {
			itemMap := make(map[string]interface{})
			if !item.Kind.IsNull() && !item.Kind.IsUnknown() {
				itemMap["kind"] = item.Kind.ValueString()
			}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				itemMap["name"] = item.Name.ValueString()
			}
			if !item.Namespace.IsNull() && !item.Namespace.IsUnknown() {
				itemMap["namespace"] = item.Namespace.ValueString()
			}
			if !item.Tenant.IsNull() && !item.Tenant.IsUnknown() {
				itemMap["tenant"] = item.Tenant.ValueString()
			}
			if !item.Uid.IsNull() && !item.Uid.IsUnknown() {
				itemMap["uid"] = item.Uid.ValueString()
			}
			relates_toList = append(relates_toList, itemMap)
		}
		apiResource.Spec["relates_to"] = relates_toList
	}
	if !data.Category.IsNull() && !data.Category.IsUnknown() {
		apiResource.Spec["category"] = data.Category.ValueString()
	}
	if !data.DescriptionSpec.IsNull() && !data.DescriptionSpec.IsUnknown() {
		apiResource.Spec["description"] = data.DescriptionSpec.ValueString()
	}
	if !data.Ongoing.IsNull() && !data.Ongoing.IsUnknown() {
		apiResource.Spec["ongoing"] = data.Ongoing.ValueBool()
	}
	if !data.Priority.IsNull() && !data.Priority.IsUnknown() {
		apiResource.Spec["priority"] = data.Priority.ValueString()
	}
	if !data.ProductData.IsNull() && !data.ProductData.IsUnknown() {
		apiResource.Spec["product_data"] = data.ProductData.ValueString()
	}
	if !data.Service.IsNull() && !data.Service.IsUnknown() {
		apiResource.Spec["service"] = data.Service.ValueString()
	}
	if !data.Status.IsNull() && !data.Status.IsUnknown() {
		apiResource.Spec["status"] = data.Status.ValueString()
	}
	if !data.Subject.IsNull() && !data.Subject.IsUnknown() {
		apiResource.Spec["subject"] = data.Subject.ValueString()
	}
	if !data.Timeline.IsNull() && !data.Timeline.IsUnknown() {
		apiResource.Spec["timeline"] = data.Timeline.ValueString()
	}
	if !data.Topic.IsNull() && !data.Topic.IsUnknown() {
		apiResource.Spec["topic"] = data.Topic.ValueString()
	}
	if !data.TpID.IsNull() && !data.TpID.IsUnknown() {
		apiResource.Spec["tp_id"] = data.TpID.ValueString()
	}
	if !data.Type.IsNull() && !data.Type.IsUnknown() {
		apiResource.Spec["type"] = data.Type.ValueString()
	}


	updated, err := r.client.UpdateCustomerSupport(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update CustomerSupport: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response
	if v, ok := updated.Spec["category"].(string); ok && v != "" {
		data.Category = types.StringValue(v)
	} else if data.Category.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Category = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["description"].(string); ok && v != "" {
		data.DescriptionSpec = types.StringValue(v)
	} else if data.DescriptionSpec.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DescriptionSpec = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["ongoing"].(bool); ok {
		data.Ongoing = types.BoolValue(v)
	} else if data.Ongoing.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Ongoing = types.BoolNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["priority"].(string); ok && v != "" {
		data.Priority = types.StringValue(v)
	} else if data.Priority.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Priority = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["product_data"].(string); ok && v != "" {
		data.ProductData = types.StringValue(v)
	} else if data.ProductData.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ProductData = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["service"].(string); ok && v != "" {
		data.Service = types.StringValue(v)
	} else if data.Service.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Service = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["status"].(string); ok && v != "" {
		data.Status = types.StringValue(v)
	} else if data.Status.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Status = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["subject"].(string); ok && v != "" {
		data.Subject = types.StringValue(v)
	} else if data.Subject.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Subject = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["timeline"].(string); ok && v != "" {
		data.Timeline = types.StringValue(v)
	} else if data.Timeline.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Timeline = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["topic"].(string); ok && v != "" {
		data.Topic = types.StringValue(v)
	} else if data.Topic.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Topic = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["tp_id"].(string); ok && v != "" {
		data.TpID = types.StringValue(v)
	} else if data.TpID.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TpID = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["type"].(string); ok && v != "" {
		data.Type = types.StringValue(v)
	} else if data.Type.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Type = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetCustomerSupport(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CustomerSupportResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data CustomerSupportResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteCustomerSupport(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "CustomerSupport already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "CustomerSupport delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete CustomerSupport: %s", err))
		return
	}
}

func (r *CustomerSupportResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
