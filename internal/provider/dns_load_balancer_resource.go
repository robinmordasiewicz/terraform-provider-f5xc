// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &DNSLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &DNSLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &DNSLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &DNSLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &DNSLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &DNSLoadBalancerResource{}
)

// dns_load_balancerSchemaVersion is the schema version for state upgrades
const dns_load_balancerSchemaVersion int64 = 1

func NewDNSLoadBalancerResource() resource.Resource {
	return &DNSLoadBalancerResource{}
}

type DNSLoadBalancerResource struct {
	client *client.Client
}

// DNSLoadBalancerEmptyModel represents empty nested blocks
type DNSLoadBalancerEmptyModel struct {
}

// DNSLoadBalancerFallbackPoolModel represents fallback_pool block
type DNSLoadBalancerFallbackPoolModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// DNSLoadBalancerResponseCacheModel represents response_cache block
type DNSLoadBalancerResponseCacheModel struct {
	DefaultResponseCacheParameters *DNSLoadBalancerEmptyModel `tfsdk:"default_response_cache_parameters"`
	Disable *DNSLoadBalancerEmptyModel `tfsdk:"disable"`
	ResponseCacheParameters *DNSLoadBalancerResponseCacheResponseCacheParametersModel `tfsdk:"response_cache_parameters"`
}

// DNSLoadBalancerResponseCacheResponseCacheParametersModel represents response_cache_parameters block
type DNSLoadBalancerResponseCacheResponseCacheParametersModel struct {
	CacheCidrIPV4 types.Int64 `tfsdk:"cache_cidr_ipv4"`
	CacheCidrIPV6 types.Int64 `tfsdk:"cache_cidr_ipv6"`
	CacheTtl types.Int64 `tfsdk:"cache_ttl"`
}

// DNSLoadBalancerRuleListModel represents rule_list block
type DNSLoadBalancerRuleListModel struct {
	Rules []DNSLoadBalancerRuleListRulesModel `tfsdk:"rules"`
}

// DNSLoadBalancerRuleListRulesModel represents rules block
type DNSLoadBalancerRuleListRulesModel struct {
	Score types.Int64 `tfsdk:"score"`
	AsnList *DNSLoadBalancerRuleListRulesAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *DNSLoadBalancerRuleListRulesAsnMatcherModel `tfsdk:"asn_matcher"`
	GeoLocationLabelSelector *DNSLoadBalancerRuleListRulesGeoLocationLabelSelectorModel `tfsdk:"geo_location_label_selector"`
	GeoLocationSet *DNSLoadBalancerRuleListRulesGeoLocationSetModel `tfsdk:"geo_location_set"`
	IPPrefixList *DNSLoadBalancerRuleListRulesIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPPrefixSet *DNSLoadBalancerRuleListRulesIPPrefixSetModel `tfsdk:"ip_prefix_set"`
	Pool *DNSLoadBalancerRuleListRulesPoolModel `tfsdk:"pool"`
}

// DNSLoadBalancerRuleListRulesAsnListModel represents asn_list block
type DNSLoadBalancerRuleListRulesAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// DNSLoadBalancerRuleListRulesAsnMatcherModel represents asn_matcher block
type DNSLoadBalancerRuleListRulesAsnMatcherModel struct {
	AsnSets []DNSLoadBalancerRuleListRulesAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// DNSLoadBalancerRuleListRulesAsnMatcherAsnSetsModel represents asn_sets block
type DNSLoadBalancerRuleListRulesAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// DNSLoadBalancerRuleListRulesGeoLocationLabelSelectorModel represents geo_location_label_selector block
type DNSLoadBalancerRuleListRulesGeoLocationLabelSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// DNSLoadBalancerRuleListRulesGeoLocationSetModel represents geo_location_set block
type DNSLoadBalancerRuleListRulesGeoLocationSetModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// DNSLoadBalancerRuleListRulesIPPrefixListModel represents ip_prefix_list block
type DNSLoadBalancerRuleListRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// DNSLoadBalancerRuleListRulesIPPrefixSetModel represents ip_prefix_set block
type DNSLoadBalancerRuleListRulesIPPrefixSetModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []DNSLoadBalancerRuleListRulesIPPrefixSetPrefixSetsModel `tfsdk:"prefix_sets"`
}

// DNSLoadBalancerRuleListRulesIPPrefixSetPrefixSetsModel represents prefix_sets block
type DNSLoadBalancerRuleListRulesIPPrefixSetPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// DNSLoadBalancerRuleListRulesPoolModel represents pool block
type DNSLoadBalancerRuleListRulesPoolModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

type DNSLoadBalancerResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	RecordType types.String `tfsdk:"record_type"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	FallbackPool *DNSLoadBalancerFallbackPoolModel `tfsdk:"fallback_pool"`
	ResponseCache *DNSLoadBalancerResponseCacheModel `tfsdk:"response_cache"`
	RuleList *DNSLoadBalancerRuleListModel `tfsdk:"rule_list"`
}

func (r *DNSLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dns_load_balancer"
}

func (r *DNSLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             dns_load_balancerSchemaVersion,
		MarkdownDescription: "Manages DNS Load Balancer in a given namespace. If one already exist it will give a error. in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the DNSLoadBalancer. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the DNSLoadBalancer will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"record_type": schema.StringAttribute{
				MarkdownDescription: "Resource Record Type. Resource Record Type - A: A - AAAA: AAAA - MX: MX - CNAME: CNAME - SRV: SRV. Possible values are `A`, `AAAA`, `MX`, `CNAME`, `SRV`. Defaults to `A`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"fallback_pool": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"response_cache": schema.SingleNestedBlock{
				MarkdownDescription: "Response Cache. Response Cache x-required",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"default_response_cache_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"response_cache_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Response Cache Parameters.",
						Attributes: map[string]schema.Attribute{
							"cache_cidr_ipv4": schema.Int64Attribute{
								MarkdownDescription: "Length of IPv4 CIDR masks. Length of CIDR masks used to group IPv4 clients",
								Optional: true,
							},
							"cache_cidr_ipv6": schema.Int64Attribute{
								MarkdownDescription: "Length of IPv6 CIDR masks. Length of CIDR masks used to group IPv6 clients",
								Optional: true,
							},
							"cache_ttl": schema.Int64Attribute{
								MarkdownDescription: "TTL. TTL for response cache",
								Optional: true,
							},
						},
					},
				},

			},
			"rule_list": schema.SingleNestedBlock{
				MarkdownDescription: "Load Balancing Rule List. List of the Load Balancing Rules",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"rules": schema.ListNestedBlock{
						MarkdownDescription: "Load Balancing Rules. Rules to perform load balancing",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"score": schema.Int64Attribute{
									MarkdownDescription: "Score. When multiple load balancing rules match a query, the one with the highest score is chosen",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional: true,
											ElementType: types.Int64Type,
										},
									},
								},
								"asn_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"asn_sets": schema.ListNestedBlock{
											MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
														Optional: true,
													},
												},
											},
										},
									},
								},
								"geo_location_label_selector": schema.SingleNestedBlock{
									MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
									Attributes: map[string]schema.Attribute{
										"expressions": schema.ListAttribute{
											MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"geo_location_set": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"ip_prefix_list": schema.SingleNestedBlock{
									MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
									Attributes: map[string]schema.Attribute{
										"invert_match": schema.BoolAttribute{
											MarkdownDescription: "Invert Match Result. Invert the match result.",
											Optional: true,
										},
										"ip_prefixes": schema.ListAttribute{
											MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"ip_prefix_set": schema.SingleNestedBlock{
									MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert IP Matcher. Invert the match result.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"prefix_sets": schema.ListNestedBlock{
											MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
														Optional: true,
													},
												},
											},
										},
									},
								},
								"pool": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *DNSLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *DNSLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data DNSLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *DNSLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the dns_load_balancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan DNSLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *DNSLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := DNSLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *DNSLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data DNSLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating dns_load_balancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.DNSLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.FallbackPool != nil {
		fallback_poolMap := make(map[string]interface{})
		if !data.FallbackPool.Name.IsNull() && !data.FallbackPool.Name.IsUnknown() {
			fallback_poolMap["name"] = data.FallbackPool.Name.ValueString()
		}
		if !data.FallbackPool.Namespace.IsNull() && !data.FallbackPool.Namespace.IsUnknown() {
			fallback_poolMap["namespace"] = data.FallbackPool.Namespace.ValueString()
		}
		if !data.FallbackPool.Tenant.IsNull() && !data.FallbackPool.Tenant.IsUnknown() {
			fallback_poolMap["tenant"] = data.FallbackPool.Tenant.ValueString()
		}
		apiResource.Spec["fallback_pool"] = fallback_poolMap
	}
	if data.ResponseCache != nil {
		response_cacheMap := make(map[string]interface{})
		if data.ResponseCache.DefaultResponseCacheParameters != nil {
			response_cacheMap["default_response_cache_parameters"] = map[string]interface{}{}
		}
		if data.ResponseCache.Disable != nil {
			response_cacheMap["disable"] = map[string]interface{}{}
		}
		if data.ResponseCache.ResponseCacheParameters != nil {
			response_cache_parametersNestedMap := make(map[string]interface{})
			if !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV4.IsNull() && !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV4.IsUnknown() {
				response_cache_parametersNestedMap["cache_cidr_ipv4"] = data.ResponseCache.ResponseCacheParameters.CacheCidrIPV4.ValueInt64()
			}
			if !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV6.IsNull() && !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV6.IsUnknown() {
				response_cache_parametersNestedMap["cache_cidr_ipv6"] = data.ResponseCache.ResponseCacheParameters.CacheCidrIPV6.ValueInt64()
			}
			if !data.ResponseCache.ResponseCacheParameters.CacheTtl.IsNull() && !data.ResponseCache.ResponseCacheParameters.CacheTtl.IsUnknown() {
				response_cache_parametersNestedMap["cache_ttl"] = data.ResponseCache.ResponseCacheParameters.CacheTtl.ValueInt64()
			}
			response_cacheMap["response_cache_parameters"] = response_cache_parametersNestedMap
		}
		apiResource.Spec["response_cache"] = response_cacheMap
	}
	if data.RuleList != nil {
		rule_listMap := make(map[string]interface{})
		if len(data.RuleList.Rules) > 0 {
			var rulesList []map[string]interface{}
			for _, listItem := range data.RuleList.Rules {
				listItemMap := make(map[string]interface{})
				if listItem.AsnList != nil {
					asn_listDeepMap := make(map[string]interface{})
					listItemMap["asn_list"] = asn_listDeepMap
				}
				if listItem.AsnMatcher != nil {
					asn_matcherDeepMap := make(map[string]interface{})
					listItemMap["asn_matcher"] = asn_matcherDeepMap
				}
				if listItem.GeoLocationLabelSelector != nil {
					geo_location_label_selectorDeepMap := make(map[string]interface{})
					listItemMap["geo_location_label_selector"] = geo_location_label_selectorDeepMap
				}
				if listItem.GeoLocationSet != nil {
					geo_location_setDeepMap := make(map[string]interface{})
					if !listItem.GeoLocationSet.Name.IsNull() && !listItem.GeoLocationSet.Name.IsUnknown() {
						geo_location_setDeepMap["name"] = listItem.GeoLocationSet.Name.ValueString()
					}
					if !listItem.GeoLocationSet.Namespace.IsNull() && !listItem.GeoLocationSet.Namespace.IsUnknown() {
						geo_location_setDeepMap["namespace"] = listItem.GeoLocationSet.Namespace.ValueString()
					}
					if !listItem.GeoLocationSet.Tenant.IsNull() && !listItem.GeoLocationSet.Tenant.IsUnknown() {
						geo_location_setDeepMap["tenant"] = listItem.GeoLocationSet.Tenant.ValueString()
					}
					listItemMap["geo_location_set"] = geo_location_setDeepMap
				}
				if listItem.IPPrefixList != nil {
					ip_prefix_listDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixList.InvertMatch.IsNull() && !listItem.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listDeepMap["invert_match"] = listItem.IPPrefixList.InvertMatch.ValueBool()
					}
					listItemMap["ip_prefix_list"] = ip_prefix_listDeepMap
				}
				if listItem.IPPrefixSet != nil {
					ip_prefix_setDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixSet.InvertMatcher.IsNull() && !listItem.IPPrefixSet.InvertMatcher.IsUnknown() {
						ip_prefix_setDeepMap["invert_matcher"] = listItem.IPPrefixSet.InvertMatcher.ValueBool()
					}
					listItemMap["ip_prefix_set"] = ip_prefix_setDeepMap
				}
				if listItem.Pool != nil {
					poolDeepMap := make(map[string]interface{})
					if !listItem.Pool.Name.IsNull() && !listItem.Pool.Name.IsUnknown() {
						poolDeepMap["name"] = listItem.Pool.Name.ValueString()
					}
					if !listItem.Pool.Namespace.IsNull() && !listItem.Pool.Namespace.IsUnknown() {
						poolDeepMap["namespace"] = listItem.Pool.Namespace.ValueString()
					}
					if !listItem.Pool.Tenant.IsNull() && !listItem.Pool.Tenant.IsUnknown() {
						poolDeepMap["tenant"] = listItem.Pool.Tenant.ValueString()
					}
					listItemMap["pool"] = poolDeepMap
				}
				if !listItem.Score.IsNull() && !listItem.Score.IsUnknown() {
					listItemMap["score"] = listItem.Score.ValueInt64()
				}
				rulesList = append(rulesList, listItemMap)
			}
			rule_listMap["rules"] = rulesList
		}
		apiResource.Spec["rule_list"] = rule_listMap
	}
	if !data.RecordType.IsNull() && !data.RecordType.IsUnknown() {
		apiResource.Spec["record_type"] = data.RecordType.ValueString()
	}


	created, err := r.client.CreateDNSLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create DNSLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response
	if v, ok := created.Spec["record_type"].(string); ok && v != "" {
		data.RecordType = types.StringValue(v)
	} else if data.RecordType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.RecordType = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created DNSLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DNSLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data DNSLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetDNSLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "DNSLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read DNSLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The dns_load_balancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["fallback_pool"].(map[string]interface{}); ok && (isImport || data.FallbackPool != nil) {
		data.FallbackPool = &DNSLoadBalancerFallbackPoolModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["response_cache"].(map[string]interface{}); ok && isImport && data.ResponseCache == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ResponseCache = &DNSLoadBalancerResponseCacheModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["rule_list"].(map[string]interface{}); ok && (isImport || data.RuleList != nil) {
		data.RuleList = &DNSLoadBalancerRuleListModel{
			Rules: func() []DNSLoadBalancerRuleListRulesModel {
				if listData, ok := blockData["rules"].([]interface{}); ok && len(listData) > 0 {
					var result []DNSLoadBalancerRuleListRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, DNSLoadBalancerRuleListRulesModel{
								AsnList: func() *DNSLoadBalancerRuleListRulesAsnListModel {
									if _, ok := itemMap["asn_list"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesAsnListModel{
										}
									}
									return nil
								}(),
								AsnMatcher: func() *DNSLoadBalancerRuleListRulesAsnMatcherModel {
									if _, ok := itemMap["asn_matcher"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesAsnMatcherModel{
										}
									}
									return nil
								}(),
								GeoLocationLabelSelector: func() *DNSLoadBalancerRuleListRulesGeoLocationLabelSelectorModel {
									if _, ok := itemMap["geo_location_label_selector"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesGeoLocationLabelSelectorModel{
										}
									}
									return nil
								}(),
								GeoLocationSet: func() *DNSLoadBalancerRuleListRulesGeoLocationSetModel {
									if deepMap, ok := itemMap["geo_location_set"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesGeoLocationSetModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								IPPrefixList: func() *DNSLoadBalancerRuleListRulesIPPrefixListModel {
									if deepMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesIPPrefixListModel{
											InvertMatch: func() types.Bool {
												if v, ok := deepMap["invert_match"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								IPPrefixSet: func() *DNSLoadBalancerRuleListRulesIPPrefixSetModel {
									if deepMap, ok := itemMap["ip_prefix_set"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesIPPrefixSetModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								Pool: func() *DNSLoadBalancerRuleListRulesPoolModel {
									if deepMap, ok := itemMap["pool"].(map[string]interface{}); ok {
										return &DNSLoadBalancerRuleListRulesPoolModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Score: func() types.Int64 {
									if v, ok := itemMap["score"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["record_type"].(string); ok && v != "" {
		data.RecordType = types.StringValue(v)
	} else {
		data.RecordType = types.StringNull()
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DNSLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data DNSLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.DNSLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.FallbackPool != nil {
		fallback_poolMap := make(map[string]interface{})
		if !data.FallbackPool.Name.IsNull() && !data.FallbackPool.Name.IsUnknown() {
			fallback_poolMap["name"] = data.FallbackPool.Name.ValueString()
		}
		if !data.FallbackPool.Namespace.IsNull() && !data.FallbackPool.Namespace.IsUnknown() {
			fallback_poolMap["namespace"] = data.FallbackPool.Namespace.ValueString()
		}
		if !data.FallbackPool.Tenant.IsNull() && !data.FallbackPool.Tenant.IsUnknown() {
			fallback_poolMap["tenant"] = data.FallbackPool.Tenant.ValueString()
		}
		apiResource.Spec["fallback_pool"] = fallback_poolMap
	}
	if data.ResponseCache != nil {
		response_cacheMap := make(map[string]interface{})
		if data.ResponseCache.DefaultResponseCacheParameters != nil {
			response_cacheMap["default_response_cache_parameters"] = map[string]interface{}{}
		}
		if data.ResponseCache.Disable != nil {
			response_cacheMap["disable"] = map[string]interface{}{}
		}
		if data.ResponseCache.ResponseCacheParameters != nil {
			response_cache_parametersNestedMap := make(map[string]interface{})
			if !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV4.IsNull() && !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV4.IsUnknown() {
				response_cache_parametersNestedMap["cache_cidr_ipv4"] = data.ResponseCache.ResponseCacheParameters.CacheCidrIPV4.ValueInt64()
			}
			if !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV6.IsNull() && !data.ResponseCache.ResponseCacheParameters.CacheCidrIPV6.IsUnknown() {
				response_cache_parametersNestedMap["cache_cidr_ipv6"] = data.ResponseCache.ResponseCacheParameters.CacheCidrIPV6.ValueInt64()
			}
			if !data.ResponseCache.ResponseCacheParameters.CacheTtl.IsNull() && !data.ResponseCache.ResponseCacheParameters.CacheTtl.IsUnknown() {
				response_cache_parametersNestedMap["cache_ttl"] = data.ResponseCache.ResponseCacheParameters.CacheTtl.ValueInt64()
			}
			response_cacheMap["response_cache_parameters"] = response_cache_parametersNestedMap
		}
		apiResource.Spec["response_cache"] = response_cacheMap
	}
	if data.RuleList != nil {
		rule_listMap := make(map[string]interface{})
		if len(data.RuleList.Rules) > 0 {
			var rulesList []map[string]interface{}
			for _, listItem := range data.RuleList.Rules {
				listItemMap := make(map[string]interface{})
				if listItem.AsnList != nil {
					asn_listDeepMap := make(map[string]interface{})
					listItemMap["asn_list"] = asn_listDeepMap
				}
				if listItem.AsnMatcher != nil {
					asn_matcherDeepMap := make(map[string]interface{})
					listItemMap["asn_matcher"] = asn_matcherDeepMap
				}
				if listItem.GeoLocationLabelSelector != nil {
					geo_location_label_selectorDeepMap := make(map[string]interface{})
					listItemMap["geo_location_label_selector"] = geo_location_label_selectorDeepMap
				}
				if listItem.GeoLocationSet != nil {
					geo_location_setDeepMap := make(map[string]interface{})
					if !listItem.GeoLocationSet.Name.IsNull() && !listItem.GeoLocationSet.Name.IsUnknown() {
						geo_location_setDeepMap["name"] = listItem.GeoLocationSet.Name.ValueString()
					}
					if !listItem.GeoLocationSet.Namespace.IsNull() && !listItem.GeoLocationSet.Namespace.IsUnknown() {
						geo_location_setDeepMap["namespace"] = listItem.GeoLocationSet.Namespace.ValueString()
					}
					if !listItem.GeoLocationSet.Tenant.IsNull() && !listItem.GeoLocationSet.Tenant.IsUnknown() {
						geo_location_setDeepMap["tenant"] = listItem.GeoLocationSet.Tenant.ValueString()
					}
					listItemMap["geo_location_set"] = geo_location_setDeepMap
				}
				if listItem.IPPrefixList != nil {
					ip_prefix_listDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixList.InvertMatch.IsNull() && !listItem.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listDeepMap["invert_match"] = listItem.IPPrefixList.InvertMatch.ValueBool()
					}
					listItemMap["ip_prefix_list"] = ip_prefix_listDeepMap
				}
				if listItem.IPPrefixSet != nil {
					ip_prefix_setDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixSet.InvertMatcher.IsNull() && !listItem.IPPrefixSet.InvertMatcher.IsUnknown() {
						ip_prefix_setDeepMap["invert_matcher"] = listItem.IPPrefixSet.InvertMatcher.ValueBool()
					}
					listItemMap["ip_prefix_set"] = ip_prefix_setDeepMap
				}
				if listItem.Pool != nil {
					poolDeepMap := make(map[string]interface{})
					if !listItem.Pool.Name.IsNull() && !listItem.Pool.Name.IsUnknown() {
						poolDeepMap["name"] = listItem.Pool.Name.ValueString()
					}
					if !listItem.Pool.Namespace.IsNull() && !listItem.Pool.Namespace.IsUnknown() {
						poolDeepMap["namespace"] = listItem.Pool.Namespace.ValueString()
					}
					if !listItem.Pool.Tenant.IsNull() && !listItem.Pool.Tenant.IsUnknown() {
						poolDeepMap["tenant"] = listItem.Pool.Tenant.ValueString()
					}
					listItemMap["pool"] = poolDeepMap
				}
				if !listItem.Score.IsNull() && !listItem.Score.IsUnknown() {
					listItemMap["score"] = listItem.Score.ValueInt64()
				}
				rulesList = append(rulesList, listItemMap)
			}
			rule_listMap["rules"] = rulesList
		}
		apiResource.Spec["rule_list"] = rule_listMap
	}
	if !data.RecordType.IsNull() && !data.RecordType.IsUnknown() {
		apiResource.Spec["record_type"] = data.RecordType.ValueString()
	}


	updated, err := r.client.UpdateDNSLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update DNSLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response
	if v, ok := updated.Spec["record_type"].(string); ok && v != "" {
		data.RecordType = types.StringValue(v)
	} else if data.RecordType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.RecordType = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetDNSLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DNSLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data DNSLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteDNSLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "DNSLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "DNSLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete DNSLoadBalancer: %s", err))
		return
	}
}

func (r *DNSLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
