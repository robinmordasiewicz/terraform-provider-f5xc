// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
)

var (
	_ resource.Resource                = &DNSZoneResource{}
	_ resource.ResourceWithConfigure   = &DNSZoneResource{}
	_ resource.ResourceWithImportState = &DNSZoneResource{}
)

func NewDNSZoneResource() resource.Resource {
	return &DNSZoneResource{}
}

type DNSZoneResource struct {
	client *client.Client
}

type DNSZoneResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Labels types.Map `tfsdk:"labels"`
	Annotations types.Map `tfsdk:"annotations"`
	ID types.String `tfsdk:"id"`
}

func (r *DNSZoneResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dns_zone"
}

func (r *DNSZoneResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages DNS Zone in a given namespace. If one already exist it will give a error. in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the DNSZone. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the DNSZone will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"primary": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: primary, secondary] PrimaryDNSCreateSpecType.",
				Attributes: map[string]schema.Attribute{
					"allow_http_lb_managed_records": schema.BoolAttribute{
						MarkdownDescription: "Option to allow user-created HTTP, TCP, and CDN load balancer related resource records to be automatically managed in a protected RRset.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_rr_set_group": schema.ListNestedBlock{
						MarkdownDescription: "Add and manage DNS resource record sets part of Default set group.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									MarkdownDescription: "Comment.",
									Optional: true,
								},
								"ttl": schema.Int64Attribute{
									MarkdownDescription: "Time to live.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"a_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSAResourceRecord. A Records",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). A Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"values": schema.ListAttribute{
											MarkdownDescription: "IPv4 Addresses. A valid IPv4 address, for example: 1.1.1.1",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"aaaa_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSAAAAResourceRecord. RecordSet for AAAA Records",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). AAAA Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"values": schema.ListAttribute{
											MarkdownDescription: "IPv6 Addresses. A valid IPv6 address, for example: 2001:0db8:85a3:0000:0000:8a2e:0370:7334",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"afsdb_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS AFSDB Record. DNS AFSDB Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). AFSDB Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "AFSDB Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"alias_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSAliasResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"value": schema.StringAttribute{
											MarkdownDescription: "Domain. A valid domain name, for example: example.com",
											Optional: true,
										},
									},
								},
								"caa_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSCAAResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). CAA Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "CAA Record Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"cds_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS CDS Record. DNS CDS Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). CDS Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "DS Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"cert_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS CERT Record. DNS CERT Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). CERT Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "CERT Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"cname_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSCNAMEResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). CName Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Domain.",
											Optional: true,
										},
									},
								},
								"ds_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS DS Record. DNS DS Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). DS Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "DS Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"eui48_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS EUI48 Record. DNS EUI48 Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). EUI48 Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "EUI48 Identifier. A valid eui48 identifier, for example: 01-23-45-67-89-ab",
											Optional: true,
										},
									},
								},
								"eui64_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS EUI64 Record. DNS EUI64 Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). EUI64 Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "EUI64 Identifier. A valid EUI64 identifier, for example: 01-23-45-67-89-ab-cd-ef",
											Optional: true,
										},
									},
								},
								"lb_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS Load Balancer Record. DNS Load Balancer Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). Load Balancer record name (except for SRV DNS Load balancer record) should be a simple record name and not a subdomain of a subdomain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"value": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										},
									},
								},
								"loc_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS LOC Record. DNS LOC Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). LOC Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "LOC Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"mx_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSMXResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). MX Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "MX Record Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"naptr_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS NAPTR Record. DNS NAPTR Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). NAPTR Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "NAPTR Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"ns_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSNSResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). NS Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"values": schema.ListAttribute{
											MarkdownDescription: "Name Servers.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"ptr_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSPTRResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). PTR Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"values": schema.ListAttribute{
											MarkdownDescription: "Domain Name.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"srv_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSSRVResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). SRV Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "SRV Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"sshfp_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS SSHFP Record. DNS SSHFP Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). SSHFP Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "SSHFP Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"tlsa_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNS TLSA Record. DNS TLSA Record",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). TLSA Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"values": schema.ListNestedBlock{
											MarkdownDescription: "TLSA Value.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
								},
								"txt_record": schema.SingleNestedBlock{
									MarkdownDescription: "DNSTXTResourceRecord.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Record Name (Excluding Domain name). TXT Record name, please provide only the specific subdomain or record name without the base domain.",
											Optional: true,
										},
										"values": schema.ListAttribute{
											MarkdownDescription: "Text.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
							},
						},
					},
					"default_soa_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"dnssec_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Disable.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable. DNSSEC enable",
							},
						},
					},
					"rr_set_group": schema.ListNestedBlock{
						MarkdownDescription: "Create and manage set groups, and resource record sets within them, x-ves-io-managed set is managed by F5.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
									Attributes: map[string]schema.Attribute{
										"description": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
											Optional: true,
										},
									},
								},
								"rr_set": schema.ListNestedBlock{
									MarkdownDescription: "Resource Record Sets. Collection of DNS resource record sets",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"description": schema.StringAttribute{
												MarkdownDescription: "Comment.",
												Optional: true,
											},
											"ttl": schema.Int64Attribute{
												MarkdownDescription: "Time to live.",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"a_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSAResourceRecord. A Records",
											},
											"aaaa_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSAAAAResourceRecord. RecordSet for AAAA Records",
											},
											"afsdb_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS AFSDB Record. DNS AFSDB Record",
											},
											"alias_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSAliasResourceRecord.",
											},
											"caa_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSCAAResourceRecord.",
											},
											"cds_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS CDS Record. DNS CDS Record",
											},
											"cert_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS CERT Record. DNS CERT Record",
											},
											"cname_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSCNAMEResourceRecord.",
											},
											"ds_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS DS Record. DNS DS Record",
											},
											"eui48_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS EUI48 Record. DNS EUI48 Record",
											},
											"eui64_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS EUI64 Record. DNS EUI64 Record",
											},
											"lb_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS Load Balancer Record. DNS Load Balancer Record",
											},
											"loc_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS LOC Record. DNS LOC Record",
											},
											"mx_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSMXResourceRecord.",
											},
											"naptr_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS NAPTR Record. DNS NAPTR Record",
											},
											"ns_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSNSResourceRecord.",
											},
											"ptr_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSPTRResourceRecord.",
											},
											"srv_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSSRVResourceRecord.",
											},
											"sshfp_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS SSHFP Record. DNS SSHFP Record",
											},
											"tlsa_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNS TLSA Record. DNS TLSA Record",
											},
											"txt_record": schema.SingleNestedBlock{
												MarkdownDescription: "DNSTXTResourceRecord.",
											},
										},
									},
								},
							},
						},
					},
					"soa_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "SOARecordParameterConfig.",
						Attributes: map[string]schema.Attribute{
							"expire": schema.Int64Attribute{
								MarkdownDescription: "Expire. expire value indicates when secondary nameservers should stop answering request for this zone if primary does not respond",
								Optional: true,
							},
							"negative_ttl": schema.Int64Attribute{
								MarkdownDescription: "Negative TTL. negative ttl value indicates how long to cache non-existent resource record for this zone",
								Optional: true,
							},
							"refresh": schema.Int64Attribute{
								MarkdownDescription: "Refresh interval. refresh value indicates when secondary nameservers should query for the SOA record to detect zone changes",
								Optional: true,
							},
							"retry": schema.Int64Attribute{
								MarkdownDescription: "Retry Interval. retry value indicates when secondary nameservers should retry to request the serial number if primary does not respond",
								Optional: true,
							},
							"ttl": schema.Int64Attribute{
								MarkdownDescription: "TTL. SOA record time to live (in seconds)",
								Optional: true,
							},
						},
					},
				},

			},
			"secondary": schema.SingleNestedBlock{
				MarkdownDescription: "SecondaryDNSCreateSpecType.",
				Attributes: map[string]schema.Attribute{
					"primary_servers": schema.ListAttribute{
						MarkdownDescription: "DNS Primary Server IP.",
						Optional: true,
						ElementType: types.StringType,
					},
					"tsig_key_algorithm": schema.StringAttribute{
						MarkdownDescription: "TSIG Key Algorithm. TSIG key value must be compatible with the specified algorithm - UNDEFINED: UNDEFINED - HMAC_MD5: HMAC_MD5 - HMAC_SHA1: HMAC_SHA1 - HMAC_SHA224: HMAC_SHA224 - HMAC_SHA256: HMAC_SHA256 - HMAC_SHA384: HMAC_SHA384 - HMAC_SHA512: HMAC_SHA512",
						Optional: true,
					},
					"tsig_key_name": schema.StringAttribute{
						MarkdownDescription: "TSIG Key Name. TSIG key name as used in TSIG protocol extension",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"tsig_key_value": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *DNSZoneResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *DNSZoneResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data DNSZoneResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.DNSZone{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.DNSZoneSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateDNSZone(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create DNSZone: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)
	tflog.Trace(ctx, "created DNSZone resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DNSZoneResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data DNSZoneResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource, err := r.client.GetDNSZone(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read DNSZone: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DNSZoneResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data DNSZoneResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.DNSZone{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.DNSZoneSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateDNSZone(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update DNSZone: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DNSZoneResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data DNSZoneResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteDNSZone(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete DNSZone: %s", err))
		return
	}
}

func (r *DNSZoneResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
