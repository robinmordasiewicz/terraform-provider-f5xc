// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &ForwardingClassResource{}
	_ resource.ResourceWithConfigure      = &ForwardingClassResource{}
	_ resource.ResourceWithImportState    = &ForwardingClassResource{}
	_ resource.ResourceWithModifyPlan     = &ForwardingClassResource{}
	_ resource.ResourceWithValidateConfig = &ForwardingClassResource{}
)

func NewForwardingClassResource() resource.Resource {
	return &ForwardingClassResource{}
}

type ForwardingClassResource struct {
	client *client.Client
}

// ForwardingClassEmptyModel represents empty nested blocks
type ForwardingClassEmptyModel struct {
}

// ForwardingClassDscpModel represents dscp block
type ForwardingClassDscpModel struct {
	DropPrecedence types.String `tfsdk:"drop_precedence"`
	DscpClass      types.String `tfsdk:"dscp_class"`
}

// ForwardingClassDscpModelAttrTypes defines the attribute types for ForwardingClassDscpModel
var ForwardingClassDscpModelAttrTypes = map[string]attr.Type{
	"drop_precedence": types.StringType,
	"dscp_class":      types.StringType,
}

// ForwardingClassPolicerModel represents policer block
type ForwardingClassPolicerModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ForwardingClassPolicerModelAttrTypes defines the attribute types for ForwardingClassPolicerModel
var ForwardingClassPolicerModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

type ForwardingClassResourceModel struct {
	Name           types.String                 `tfsdk:"name"`
	Namespace      types.String                 `tfsdk:"namespace"`
	Annotations    types.Map                    `tfsdk:"annotations"`
	Description    types.String                 `tfsdk:"description"`
	Disable        types.Bool                   `tfsdk:"disable"`
	Labels         types.Map                    `tfsdk:"labels"`
	ID             types.String                 `tfsdk:"id"`
	InterfaceGroup types.String                 `tfsdk:"interface_group"`
	QueueIDToUse   types.String                 `tfsdk:"queue_id_to_use"`
	TosValue       types.Int64                  `tfsdk:"tos_value"`
	Timeouts       timeouts.Value               `tfsdk:"timeouts"`
	Dscp           *ForwardingClassDscpModel    `tfsdk:"dscp"`
	DscpBasedQueue *ForwardingClassEmptyModel   `tfsdk:"dscp_based_queue"`
	NoMarking      *ForwardingClassEmptyModel   `tfsdk:"no_marking"`
	NoPolicer      *ForwardingClassEmptyModel   `tfsdk:"no_policer"`
	Policer        *ForwardingClassPolicerModel `tfsdk:"policer"`
}

func (r *ForwardingClassResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_forwarding_class"
}

func (r *ForwardingClassResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Forwarding Class resource in F5 Distributed Cloud for forwarding class is created by users in system namespace. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Forwarding Class. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Forwarding Class will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"interface_group": schema.StringAttribute{
				MarkdownDescription: "[Enum: ANY_AVAILABLE_INTERFACE|INTERFACE_GROUP1|INTERFACE_GROUP2|INTERFACE_GROUP3] Interface group, group membership by adding group label to interface Choose any of the available interfaces Choose all interfaces with label group1 Choose all interfaces with label group2 Choose all interfaces with label group3. Possible values are `ANY_AVAILABLE_INTERFACE`, `INTERFACE_GROUP1`, `INTERFACE_GROUP2`, `INTERFACE_GROUP3`. Defaults to `ANY_AVAILABLE_INTERFACE`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"queue_id_to_use": schema.StringAttribute{
				MarkdownDescription: "[Enum: DSCP_BEST_EFFORT|DSCP_CLASS1|DSCP_CLASS2|DSCP_CLASS3|DSCP_CLASS4|DSCP_EXPRESS_FORWARDING|DSCP_CONTROL_L3|DSCP_CONTROL_L2] DSCP Precedence Level Values Best Effort service will GET any available bandwidth DSCP Class 1 service DSCP Class 2 service DSCP Class 3 service DSCP Class 4 service Express Forwarding is used for low latency traffic Control is used for routing traffic, not recommended Link Layer traffic like.. Possible values are `DSCP_BEST_EFFORT`, `DSCP_CLASS1`, `DSCP_CLASS2`, `DSCP_CLASS3`, `DSCP_CLASS4`, `DSCP_EXPRESS_FORWARDING`, `DSCP_CONTROL_L3`, `DSCP_CONTROL_L2`. Defaults to `DSCP_BEST_EFFORT`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"tos_value": schema.Int64Attribute{
				MarkdownDescription: "Decimal value of raw 8 bit TOS. In above example DSCP 10 = Precedence Class 1 and drop precedence low.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"dscp": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: dscp, no_marking, tos_value; Default: no_marking] DSCP Marking setting. DSCP marking setting as per RFC 2475.",
				Attributes: map[string]schema.Attribute{
					"drop_precedence": schema.StringAttribute{
						MarkdownDescription: "[Enum: DSCP_AF_LOW|DSCP_AF_MEDIUM|DSCP_AF_HIGH|DSCP_AF_POLICER] DSCP Assured forwarding drop precedence DSCP Low drop precedence DSCP Low drop precedence DSCP Low drop precedence DSCP drop precedence value is taken from output of policer. Possible values are `DSCP_AF_LOW`, `DSCP_AF_MEDIUM`, `DSCP_AF_HIGH`, `DSCP_AF_POLICER`. Defaults to `DSCP_AF_FAKE`.",
						Optional:            true,
					},
					"dscp_class": schema.StringAttribute{
						MarkdownDescription: "[Enum: DSCP_BEST_EFFORT|DSCP_CLASS1|DSCP_CLASS2|DSCP_CLASS3|DSCP_CLASS4|DSCP_EXPRESS_FORWARDING|DSCP_CONTROL_L3|DSCP_CONTROL_L2] DSCP Precedence Level Values Best Effort service will GET any available bandwidth DSCP Class 1 service DSCP Class 2 service DSCP Class 3 service DSCP Class 4 service Express Forwarding is used for low latency traffic Control is used for routing traffic, not recommended Link Layer traffic like.. Possible values are `DSCP_BEST_EFFORT`, `DSCP_CLASS1`, `DSCP_CLASS2`, `DSCP_CLASS3`, `DSCP_CLASS4`, `DSCP_EXPRESS_FORWARDING`, `DSCP_CONTROL_L3`, `DSCP_CONTROL_L2`. Defaults to `DSCP_BEST_EFFORT`.",
						Optional:            true,
					},
				},
			},
			"dscp_based_queue": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: dscp_based_queue, queue_id_to_use] Enable this option",
			},
			"no_marking": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_policer": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_policer, policer; Default: no_policer] Enable this option",
			},
			"policer": schema.SingleNestedBlock{
				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
		},
	}
}

func (r *ForwardingClassResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *ForwardingClassResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data ForwardingClassResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *ForwardingClassResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the forwarding_class from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan ForwardingClassResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *ForwardingClassResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data ForwardingClassResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating forwarding_class", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.ForwardingClass{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Dscp != nil {
		dscpMap := make(map[string]interface{})
		if !data.Dscp.DropPrecedence.IsNull() && !data.Dscp.DropPrecedence.IsUnknown() {
			dscpMap["drop_precedence"] = data.Dscp.DropPrecedence.ValueString()
		}
		if !data.Dscp.DscpClass.IsNull() && !data.Dscp.DscpClass.IsUnknown() {
			dscpMap["dscp_class"] = data.Dscp.DscpClass.ValueString()
		}
		createReq.Spec["dscp"] = dscpMap
	}
	if data.DscpBasedQueue != nil {
		dscp_based_queueMap := make(map[string]interface{})
		createReq.Spec["dscp_based_queue"] = dscp_based_queueMap
	}
	if data.NoMarking != nil {
		no_markingMap := make(map[string]interface{})
		createReq.Spec["no_marking"] = no_markingMap
	}
	if data.NoPolicer != nil {
		no_policerMap := make(map[string]interface{})
		createReq.Spec["no_policer"] = no_policerMap
	}
	if data.Policer != nil {
		policerMap := make(map[string]interface{})
		if !data.Policer.Name.IsNull() && !data.Policer.Name.IsUnknown() {
			policerMap["name"] = data.Policer.Name.ValueString()
		}
		if !data.Policer.Namespace.IsNull() && !data.Policer.Namespace.IsUnknown() {
			policerMap["namespace"] = data.Policer.Namespace.ValueString()
		}
		if !data.Policer.Tenant.IsNull() && !data.Policer.Tenant.IsUnknown() {
			policerMap["tenant"] = data.Policer.Tenant.ValueString()
		}
		createReq.Spec["policer"] = policerMap
	}
	if !data.InterfaceGroup.IsNull() && !data.InterfaceGroup.IsUnknown() {
		createReq.Spec["interface_group"] = data.InterfaceGroup.ValueString()
	}
	if !data.QueueIDToUse.IsNull() && !data.QueueIDToUse.IsUnknown() {
		createReq.Spec["queue_id_to_use"] = data.QueueIDToUse.ValueString()
	}
	if !data.TosValue.IsNull() && !data.TosValue.IsUnknown() {
		createReq.Spec["tos_value"] = data.TosValue.ValueInt64()
	}

	apiResource, err := r.client.CreateForwardingClass(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create ForwardingClass: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["dscp"].(map[string]interface{}); ok && (isImport || data.Dscp != nil) {
		data.Dscp = &ForwardingClassDscpModel{
			DropPrecedence: func() types.String {
				if v, ok := blockData["drop_precedence"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DscpClass: func() types.String {
				if v, ok := blockData["dscp_class"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["dscp_based_queue"].(map[string]interface{}); ok && isImport && data.DscpBasedQueue == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DscpBasedQueue = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_marking"].(map[string]interface{}); ok && isImport && data.NoMarking == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoMarking = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_policer"].(map[string]interface{}); ok && isImport && data.NoPolicer == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoPolicer = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["policer"].(map[string]interface{}); ok && (isImport || data.Policer != nil) {
		data.Policer = &ForwardingClassPolicerModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["interface_group"].(string); ok && v != "" {
		data.InterfaceGroup = types.StringValue(v)
	} else {
		data.InterfaceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["queue_id_to_use"].(string); ok && v != "" {
		data.QueueIDToUse = types.StringValue(v)
	} else {
		data.QueueIDToUse = types.StringNull()
	}
	if v, ok := apiResource.Spec["tos_value"].(float64); ok {
		data.TosValue = types.Int64Value(int64(v))
	} else {
		data.TosValue = types.Int64Null()
	}

	tflog.Trace(ctx, "created ForwardingClass resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ForwardingClassResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data ForwardingClassResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetForwardingClass(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "ForwardingClass not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read ForwardingClass: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["dscp"].(map[string]interface{}); ok && (isImport || data.Dscp != nil) {
		data.Dscp = &ForwardingClassDscpModel{
			DropPrecedence: func() types.String {
				if v, ok := blockData["drop_precedence"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DscpClass: func() types.String {
				if v, ok := blockData["dscp_class"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["dscp_based_queue"].(map[string]interface{}); ok && isImport && data.DscpBasedQueue == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DscpBasedQueue = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_marking"].(map[string]interface{}); ok && isImport && data.NoMarking == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoMarking = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_policer"].(map[string]interface{}); ok && isImport && data.NoPolicer == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoPolicer = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["policer"].(map[string]interface{}); ok && (isImport || data.Policer != nil) {
		data.Policer = &ForwardingClassPolicerModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["interface_group"].(string); ok && v != "" {
		data.InterfaceGroup = types.StringValue(v)
	} else {
		data.InterfaceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["queue_id_to_use"].(string); ok && v != "" {
		data.QueueIDToUse = types.StringValue(v)
	} else {
		data.QueueIDToUse = types.StringNull()
	}
	if v, ok := apiResource.Spec["tos_value"].(float64); ok {
		data.TosValue = types.Int64Value(int64(v))
	} else {
		data.TosValue = types.Int64Null()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ForwardingClassResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data ForwardingClassResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.ForwardingClass{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Dscp != nil {
		dscpMap := make(map[string]interface{})
		if !data.Dscp.DropPrecedence.IsNull() && !data.Dscp.DropPrecedence.IsUnknown() {
			dscpMap["drop_precedence"] = data.Dscp.DropPrecedence.ValueString()
		}
		if !data.Dscp.DscpClass.IsNull() && !data.Dscp.DscpClass.IsUnknown() {
			dscpMap["dscp_class"] = data.Dscp.DscpClass.ValueString()
		}
		apiResource.Spec["dscp"] = dscpMap
	}
	if data.DscpBasedQueue != nil {
		dscp_based_queueMap := make(map[string]interface{})
		apiResource.Spec["dscp_based_queue"] = dscp_based_queueMap
	}
	if data.NoMarking != nil {
		no_markingMap := make(map[string]interface{})
		apiResource.Spec["no_marking"] = no_markingMap
	}
	if data.NoPolicer != nil {
		no_policerMap := make(map[string]interface{})
		apiResource.Spec["no_policer"] = no_policerMap
	}
	if data.Policer != nil {
		policerMap := make(map[string]interface{})
		if !data.Policer.Name.IsNull() && !data.Policer.Name.IsUnknown() {
			policerMap["name"] = data.Policer.Name.ValueString()
		}
		if !data.Policer.Namespace.IsNull() && !data.Policer.Namespace.IsUnknown() {
			policerMap["namespace"] = data.Policer.Namespace.ValueString()
		}
		if !data.Policer.Tenant.IsNull() && !data.Policer.Tenant.IsUnknown() {
			policerMap["tenant"] = data.Policer.Tenant.ValueString()
		}
		apiResource.Spec["policer"] = policerMap
	}
	if !data.InterfaceGroup.IsNull() && !data.InterfaceGroup.IsUnknown() {
		apiResource.Spec["interface_group"] = data.InterfaceGroup.ValueString()
	}
	if !data.QueueIDToUse.IsNull() && !data.QueueIDToUse.IsUnknown() {
		apiResource.Spec["queue_id_to_use"] = data.QueueIDToUse.ValueString()
	}
	if !data.TosValue.IsNull() && !data.TosValue.IsUnknown() {
		apiResource.Spec["tos_value"] = data.TosValue.ValueInt64()
	}

	_, err := r.client.UpdateForwardingClass(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update ForwardingClass: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetForwardingClass(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read ForwardingClass after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["interface_group"].(string); ok && v != "" {
		data.InterfaceGroup = types.StringValue(v)
	} else if data.InterfaceGroup.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.InterfaceGroup = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["queue_id_to_use"].(string); ok && v != "" {
		data.QueueIDToUse = types.StringValue(v)
	} else if data.QueueIDToUse.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.QueueIDToUse = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["tos_value"].(float64); ok {
		data.TosValue = types.Int64Value(int64(v))
	} else if data.TosValue.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TosValue = types.Int64Null()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["dscp"].(map[string]interface{}); ok && (isImport || data.Dscp != nil) {
		data.Dscp = &ForwardingClassDscpModel{
			DropPrecedence: func() types.String {
				if v, ok := blockData["drop_precedence"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DscpClass: func() types.String {
				if v, ok := blockData["dscp_class"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["dscp_based_queue"].(map[string]interface{}); ok && isImport && data.DscpBasedQueue == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DscpBasedQueue = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_marking"].(map[string]interface{}); ok && isImport && data.NoMarking == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoMarking = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_policer"].(map[string]interface{}); ok && isImport && data.NoPolicer == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoPolicer = &ForwardingClassEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["policer"].(map[string]interface{}); ok && (isImport || data.Policer != nil) {
		data.Policer = &ForwardingClassPolicerModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["interface_group"].(string); ok && v != "" {
		data.InterfaceGroup = types.StringValue(v)
	} else {
		data.InterfaceGroup = types.StringNull()
	}
	if v, ok := apiResource.Spec["queue_id_to_use"].(string); ok && v != "" {
		data.QueueIDToUse = types.StringValue(v)
	} else {
		data.QueueIDToUse = types.StringNull()
	}
	if v, ok := apiResource.Spec["tos_value"].(float64); ok {
		data.TosValue = types.Int64Value(int64(v))
	} else {
		data.TosValue = types.Int64Null()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ForwardingClassResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data ForwardingClassResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteForwardingClass(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "ForwardingClass already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "ForwardingClass delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete ForwardingClass: %s", err))
		return
	}
}

func (r *ForwardingClassResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
