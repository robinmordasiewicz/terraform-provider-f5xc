// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &GCPVPCSiteResource{}
	_ resource.ResourceWithConfigure      = &GCPVPCSiteResource{}
	_ resource.ResourceWithImportState    = &GCPVPCSiteResource{}
	_ resource.ResourceWithModifyPlan     = &GCPVPCSiteResource{}
	_ resource.ResourceWithUpgradeState   = &GCPVPCSiteResource{}
	_ resource.ResourceWithValidateConfig = &GCPVPCSiteResource{}
)

// gcp_vpc_siteSchemaVersion is the schema version for state upgrades
const gcp_vpc_siteSchemaVersion int64 = 1

func NewGCPVPCSiteResource() resource.Resource {
	return &GCPVPCSiteResource{}
}

type GCPVPCSiteResource struct {
	client *client.Client
}

// GCPVPCSiteEmptyModel represents empty nested blocks
type GCPVPCSiteEmptyModel struct {
}

// GCPVPCSiteAdminPasswordModel represents admin_password block
type GCPVPCSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *GCPVPCSiteAdminPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// GCPVPCSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type GCPVPCSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// GCPVPCSiteBlockedServicesModel represents blocked_services block
type GCPVPCSiteBlockedServicesModel struct {
	BlockedSevice []GCPVPCSiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// GCPVPCSiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type GCPVPCSiteBlockedServicesBlockedSeviceModel struct {
	NetworkType types.String `tfsdk:"network_type"`
	DNS *GCPVPCSiteEmptyModel `tfsdk:"dns"`
	SSH *GCPVPCSiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *GCPVPCSiteEmptyModel `tfsdk:"web_user_interface"`
}

// GCPVPCSiteCloudCredentialsModel represents cloud_credentials block
type GCPVPCSiteCloudCredentialsModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteCoordinatesModel represents coordinates block
type GCPVPCSiteCoordinatesModel struct {
	Latitude types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// GCPVPCSiteCustomDNSModel represents custom_dns block
type GCPVPCSiteCustomDNSModel struct {
	InsideNameserver types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// GCPVPCSiteIngressEgressGwModel represents ingress_egress_gw block
type GCPVPCSiteIngressEgressGwModel struct {
	GCPCertifiedHw types.String `tfsdk:"gcp_certified_hw"`
	GCPZoneNames types.List `tfsdk:"gcp_zone_names"`
	NodeNumber types.Int64 `tfsdk:"node_number"`
	ActiveEnhancedFirewallPolicies *GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies *GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies *GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel `tfsdk:"active_network_policies"`
	DcClusterGroupInsideVn *GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn *GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll *GCPVPCSiteEmptyModel `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList *GCPVPCSiteIngressEgressGwGlobalNetworkListModel `tfsdk:"global_network_list"`
	InsideNetwork *GCPVPCSiteIngressEgressGwInsideNetworkModel `tfsdk:"inside_network"`
	InsideStaticRoutes *GCPVPCSiteIngressEgressGwInsideStaticRoutesModel `tfsdk:"inside_static_routes"`
	InsideSubnet *GCPVPCSiteIngressEgressGwInsideSubnetModel `tfsdk:"inside_subnet"`
	NoDcClusterGroup *GCPVPCSiteEmptyModel `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy *GCPVPCSiteEmptyModel `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork *GCPVPCSiteEmptyModel `tfsdk:"no_global_network"`
	NoInsideStaticRoutes *GCPVPCSiteEmptyModel `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy *GCPVPCSiteEmptyModel `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes *GCPVPCSiteEmptyModel `tfsdk:"no_outside_static_routes"`
	OutsideNetwork *GCPVPCSiteIngressEgressGwOutsideNetworkModel `tfsdk:"outside_network"`
	OutsideStaticRoutes *GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel `tfsdk:"outside_static_routes"`
	OutsideSubnet *GCPVPCSiteIngressEgressGwOutsideSubnetModel `tfsdk:"outside_subnet"`
	PerformanceEnhancementMode *GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP *GCPVPCSiteEmptyModel `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP *GCPVPCSiteEmptyModel `tfsdk:"sm_connection_pvt_ip"`
}

// GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel represents active_network_policies block
type GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel struct {
	NetworkPolicies []GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListModel represents global_network_list block
type GCPVPCSiteIngressEgressGwGlobalNetworkListModel struct {
	GlobalNetworkConnections []GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDr *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel `tfsdk:"sli_to_global_dr"`
	SLOToGlobalDr *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel `tfsdk:"slo_to_global_dr"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel represents sli_to_global_dr block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel struct {
	GlobalVn *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel represents global_vn block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel represents slo_to_global_dr block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel struct {
	GlobalVn *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel represents global_vn block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwInsideNetworkModel represents inside_network block
type GCPVPCSiteIngressEgressGwInsideNetworkModel struct {
	ExistingNetwork *GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork *GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel represents new_network block
type GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesModel represents inside_static_routes block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesModel struct {
	StaticRouteList []GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel represents static_route_list block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String `tfsdk:"simple_static_route"`
	CustomStaticRoute *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs types.List `tfsdk:"attrs"`
	Labels *GCPVPCSiteEmptyModel `tfsdk:"labels"`
	Nexthop *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel `tfsdk:"nexthop"`
	Subnets []GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type types.String `tfsdk:"type"`
	Interface []GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel `tfsdk:"interface"`
	NexthopAddress *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	IPV4 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model `tfsdk:"ipv4"`
	IPV6 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	IPV4 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model `tfsdk:"ipv4"`
	IPV6 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwInsideSubnetModel represents inside_subnet block
type GCPVPCSiteIngressEgressGwInsideSubnetModel struct {
	ExistingSubnet *GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet *GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel `tfsdk:"new_subnet"`
}

// GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel struct {
	PrimaryIPV4 types.String `tfsdk:"primary_ipv4"`
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwOutsideNetworkModel represents outside_network block
type GCPVPCSiteIngressEgressGwOutsideNetworkModel struct {
	ExistingNetwork *GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork *GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel represents new_network block
type GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel represents outside_static_routes block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel struct {
	StaticRouteList []GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String `tfsdk:"simple_static_route"`
	CustomStaticRoute *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs types.List `tfsdk:"attrs"`
	Labels *GCPVPCSiteEmptyModel `tfsdk:"labels"`
	Nexthop *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel `tfsdk:"nexthop"`
	Subnets []GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type types.String `tfsdk:"type"`
	Interface []GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel `tfsdk:"interface"`
	NexthopAddress *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	IPV4 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model `tfsdk:"ipv4"`
	IPV6 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	IPV4 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model `tfsdk:"ipv4"`
	IPV6 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwOutsideSubnetModel represents outside_subnet block
type GCPVPCSiteIngressEgressGwOutsideSubnetModel struct {
	ExistingSubnet *GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet *GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel `tfsdk:"new_subnet"`
}

// GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel struct {
	PrimaryIPV4 types.String `tfsdk:"primary_ipv4"`
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *GCPVPCSiteEmptyModel `tfsdk:"perf_mode_l7_enhanced"`
}

// GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo *GCPVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *GCPVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// GCPVPCSiteIngressGwModel represents ingress_gw block
type GCPVPCSiteIngressGwModel struct {
	GCPCertifiedHw types.String `tfsdk:"gcp_certified_hw"`
	GCPZoneNames types.List `tfsdk:"gcp_zone_names"`
	NodeNumber types.Int64 `tfsdk:"node_number"`
	LocalNetwork *GCPVPCSiteIngressGwLocalNetworkModel `tfsdk:"local_network"`
	LocalSubnet *GCPVPCSiteIngressGwLocalSubnetModel `tfsdk:"local_subnet"`
	PerformanceEnhancementMode *GCPVPCSiteIngressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// GCPVPCSiteIngressGwLocalNetworkModel represents local_network block
type GCPVPCSiteIngressGwLocalNetworkModel struct {
	ExistingNetwork *GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork *GCPVPCSiteIngressGwLocalNetworkNewNetworkModel `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressGwLocalNetworkNewNetworkModel represents new_network block
type GCPVPCSiteIngressGwLocalNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressGwLocalSubnetModel represents local_subnet block
type GCPVPCSiteIngressGwLocalSubnetModel struct {
	ExistingSubnet *GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet *GCPVPCSiteIngressGwLocalSubnetNewSubnetModel `tfsdk:"new_subnet"`
}

// GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressGwLocalSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteIngressGwLocalSubnetNewSubnetModel struct {
	PrimaryIPV4 types.String `tfsdk:"primary_ipv4"`
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type GCPVPCSiteIngressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *GCPVPCSiteEmptyModel `tfsdk:"perf_mode_l7_enhanced"`
}

// GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo *GCPVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *GCPVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// GCPVPCSiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type GCPVPCSiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *GCPVPCSiteEmptyModel `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain *GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64 `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout types.Int64 `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode *GCPVPCSiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode *GCPVPCSiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// GCPVPCSiteLogReceiverModel represents log_receiver block
type GCPVPCSiteLogReceiverModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type GCPVPCSiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *GCPVPCSiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode *GCPVPCSiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// GCPVPCSiteOsModel represents os block
type GCPVPCSiteOsModel struct {
	OperatingSystemVersion types.String `tfsdk:"operating_system_version"`
	DefaultOsVersion *GCPVPCSiteEmptyModel `tfsdk:"default_os_version"`
}

// GCPVPCSitePrivateConnectivityModel represents private_connectivity block
type GCPVPCSitePrivateConnectivityModel struct {
	CloudLink *GCPVPCSitePrivateConnectivityCloudLinkModel `tfsdk:"cloud_link"`
	Inside *GCPVPCSiteEmptyModel `tfsdk:"inside"`
	Outside *GCPVPCSiteEmptyModel `tfsdk:"outside"`
}

// GCPVPCSitePrivateConnectivityCloudLinkModel represents cloud_link block
type GCPVPCSitePrivateConnectivityCloudLinkModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteSwModel represents sw block
type GCPVPCSiteSwModel struct {
	VolterraSoftwareVersion types.String `tfsdk:"volterra_software_version"`
	DefaultSwVersion *GCPVPCSiteEmptyModel `tfsdk:"default_sw_version"`
}

// GCPVPCSiteVoltstackClusterModel represents voltstack_cluster block
type GCPVPCSiteVoltstackClusterModel struct {
	GCPCertifiedHw types.String `tfsdk:"gcp_certified_hw"`
	GCPZoneNames types.List `tfsdk:"gcp_zone_names"`
	NodeNumber types.Int64 `tfsdk:"node_number"`
	ActiveEnhancedFirewallPolicies *GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies *GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies *GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel `tfsdk:"active_network_policies"`
	DcClusterGroup *GCPVPCSiteVoltstackClusterDcClusterGroupModel `tfsdk:"dc_cluster_group"`
	DefaultStorage *GCPVPCSiteEmptyModel `tfsdk:"default_storage"`
	ForwardProxyAllowAll *GCPVPCSiteEmptyModel `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList *GCPVPCSiteVoltstackClusterGlobalNetworkListModel `tfsdk:"global_network_list"`
	K8SCluster *GCPVPCSiteVoltstackClusterK8SClusterModel `tfsdk:"k8s_cluster"`
	NoDcClusterGroup *GCPVPCSiteEmptyModel `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy *GCPVPCSiteEmptyModel `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork *GCPVPCSiteEmptyModel `tfsdk:"no_global_network"`
	NoK8SCluster *GCPVPCSiteEmptyModel `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy *GCPVPCSiteEmptyModel `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes *GCPVPCSiteEmptyModel `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes *GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel `tfsdk:"outside_static_routes"`
	SiteLocalNetwork *GCPVPCSiteVoltstackClusterSiteLocalNetworkModel `tfsdk:"site_local_network"`
	SiteLocalSubnet *GCPVPCSiteVoltstackClusterSiteLocalSubnetModel `tfsdk:"site_local_subnet"`
	SmConnectionPublicIP *GCPVPCSiteEmptyModel `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP *GCPVPCSiteEmptyModel `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList *GCPVPCSiteVoltstackClusterStorageClassListModel `tfsdk:"storage_class_list"`
}

// GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel represents active_network_policies block
type GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel struct {
	NetworkPolicies []GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterDcClusterGroupModel represents dc_cluster_group block
type GCPVPCSiteVoltstackClusterDcClusterGroupModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListModel represents global_network_list block
type GCPVPCSiteVoltstackClusterGlobalNetworkListModel struct {
	GlobalNetworkConnections []GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDr *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel `tfsdk:"sli_to_global_dr"`
	SLOToGlobalDr *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel `tfsdk:"slo_to_global_dr"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel represents sli_to_global_dr block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrModel struct {
	GlobalVn *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel represents global_vn block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel represents slo_to_global_dr block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrModel struct {
	GlobalVn *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel represents global_vn block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLOToGlobalDrGlobalVnModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterK8SClusterModel represents k8s_cluster block
type GCPVPCSiteVoltstackClusterK8SClusterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel represents outside_static_routes block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel struct {
	StaticRouteList []GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String `tfsdk:"simple_static_route"`
	CustomStaticRoute *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs types.List `tfsdk:"attrs"`
	Labels *GCPVPCSiteEmptyModel `tfsdk:"labels"`
	Nexthop *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel `tfsdk:"nexthop"`
	Subnets []GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type types.String `tfsdk:"type"`
	Interface []GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel `tfsdk:"interface"`
	NexthopAddress *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	IPV4 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model `tfsdk:"ipv4"`
	IPV6 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model represents ipv4 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model represents ipv6 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIPV6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	IPV4 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model `tfsdk:"ipv4"`
	IPV6 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model represents ipv4 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV4Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model represents ipv6 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIPV6Model struct {
	Plen types.Int64 `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkModel represents site_local_network block
type GCPVPCSiteVoltstackClusterSiteLocalNetworkModel struct {
	ExistingNetwork *GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork *GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel represents new_network block
type GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetModel represents site_local_subnet block
type GCPVPCSiteVoltstackClusterSiteLocalSubnetModel struct {
	ExistingSubnet *GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet *GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel `tfsdk:"new_subnet"`
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel struct {
	PrimaryIPV4 types.String `tfsdk:"primary_ipv4"`
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteVoltstackClusterStorageClassListModel represents storage_class_list block
type GCPVPCSiteVoltstackClusterStorageClassListModel struct {
	StorageClasses []GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel represents storage_classes block
type GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool `tfsdk:"default_storage_class"`
	StorageClassName types.String `tfsdk:"storage_class_name"`
}

type GCPVPCSiteResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Address types.String `tfsdk:"address"`
	DiskSize types.Int64 `tfsdk:"disk_size"`
	GCPRegion types.String `tfsdk:"gcp_region"`
	InstanceType types.String `tfsdk:"instance_type"`
	SSHKey types.String `tfsdk:"ssh_key"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	AdminPassword *GCPVPCSiteAdminPasswordModel `tfsdk:"admin_password"`
	BlockAllServices *GCPVPCSiteEmptyModel `tfsdk:"block_all_services"`
	BlockedServices *GCPVPCSiteBlockedServicesModel `tfsdk:"blocked_services"`
	CloudCredentials *GCPVPCSiteCloudCredentialsModel `tfsdk:"cloud_credentials"`
	Coordinates *GCPVPCSiteCoordinatesModel `tfsdk:"coordinates"`
	CustomDNS *GCPVPCSiteCustomDNSModel `tfsdk:"custom_dns"`
	DefaultBlockedServices *GCPVPCSiteEmptyModel `tfsdk:"default_blocked_services"`
	GCPLabels *GCPVPCSiteEmptyModel `tfsdk:"gcp_labels"`
	IngressEgressGw *GCPVPCSiteIngressEgressGwModel `tfsdk:"ingress_egress_gw"`
	IngressGw *GCPVPCSiteIngressGwModel `tfsdk:"ingress_gw"`
	KubernetesUpgradeDrain *GCPVPCSiteKubernetesUpgradeDrainModel `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver *GCPVPCSiteLogReceiverModel `tfsdk:"log_receiver"`
	LogsStreamingDisabled *GCPVPCSiteEmptyModel `tfsdk:"logs_streaming_disabled"`
	OfflineSurvivabilityMode *GCPVPCSiteOfflineSurvivabilityModeModel `tfsdk:"offline_survivability_mode"`
	Os *GCPVPCSiteOsModel `tfsdk:"os"`
	PrivateConnectDisabled *GCPVPCSiteEmptyModel `tfsdk:"private_connect_disabled"`
	PrivateConnectivity *GCPVPCSitePrivateConnectivityModel `tfsdk:"private_connectivity"`
	Sw *GCPVPCSiteSwModel `tfsdk:"sw"`
	VoltstackCluster *GCPVPCSiteVoltstackClusterModel `tfsdk:"voltstack_cluster"`
}

func (r *GCPVPCSiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_gcp_vpc_site"
}

func (r *GCPVPCSiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             gcp_vpc_siteSchemaVersion,
		MarkdownDescription: "Manages a GCPVPCSite resource in F5 Distributed Cloud for deploying F5 sites within Google Cloud VPC environments.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the GCPVPCSite. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the GCPVPCSite will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "Geographical Address. Site's geographical address that can be used to determine its latitude and longitude.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"disk_size": schema.Int64Attribute{
				MarkdownDescription: "Cloud Disk Size. Disk size to be used for this instance in GiB. 80 is 80 GiB",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"gcp_region": schema.StringAttribute{
				MarkdownDescription: "GCP Region. Name for GCP Region.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"instance_type": schema.StringAttribute{
				MarkdownDescription: "GCP Instance Type for Node. Select Instance size based on performance needed",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ssh_key": schema.StringAttribute{
				MarkdownDescription: "Public SSH key. Public SSH key for accessing the site.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"admin_password": schema.SingleNestedBlock{
				MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"blindfold_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
						Attributes: map[string]schema.Attribute{
							"decryption_provider": schema.StringAttribute{
								MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
								Optional: true,
							},
							"location": schema.StringAttribute{
								MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
								Optional: true,
							},
							"store_provider": schema.StringAttribute{
								MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
								Optional: true,
							},
						},
					},
					"clear_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
						Attributes: map[string]schema.Attribute{
							"provider_ref": schema.StringAttribute{
								MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
								Optional: true,
							},
							"url": schema.StringAttribute{
								MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
								Optional: true,
							},
						},
					},
				},

			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services] Empty. This can be used for messages where no values are needed",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable Node Local Services. Disable node local services on this site. Note: The chosen services will get disabled on all nodes in the site.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "Virtual Network Type. Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created automatically and present on all sites Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site. It is a secure network and is not connected to public network. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created during provisioning of site User defined per-site virtual network. Scope of this virtual network is limited to the site. This is not yet supported Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on RE sites only It is an internally created by the system. They must not be created by user Virtual Neworks with global scope across different sites in F5XC domain. An example global virtual-network called 'AIN Network' is created for every tenant. for volterra fabric Constraints: It is currently only supported as internally created by the system. vK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant Constraints: It is an internally created by the system. Must not be created by user VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy Constraints: It is an internally created by the system. Must not be created by user Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE Constraints: This network type is only meaningful in an advertise policy When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for an endpoint, VER will try to determine the network based on the provided IP address Constraints: This network type is only meaningful in an endpoint VoltADN Private Network is used on volterra RE(s) to connect to customer private networks This network is created by opening a support ticket This network is per site srv6 network VER IP Fabric network for the site. This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network Constraints: It is an internally created by the system. Must not be created by user Network internally created for a segment Constraints: It is an internally created by the system. Must not be created by user. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
					},
				},

			},
			"cloud_credentials": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Site Coordinates. Coordinates of the site which provides the site physical location",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location",
						Optional: true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. longitude of site location",
						Optional: true,
					},
				},

			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS. Custom DNS is the configured for specify CE site",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Inside Network. Optional DNS server IP to be used for name resolution in inside network",
						Optional: true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "DNS Server for Outside Network. Optional DNS server IP to be used for name resolution in outside network",
						Optional: true,
					},
				},

			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"gcp_labels": schema.SingleNestedBlock{
				MarkdownDescription: "GCP Labels. GCP Label is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in GCP console.",
			},
			"ingress_egress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ingress_egress_gw, ingress_gw, voltstack_cluster] GCP Ingress/Egress Gateway. Two interface GCP ingress/egress site",
				Attributes: map[string]schema.Attribute{
					"gcp_certified_hw": schema.StringAttribute{
						MarkdownDescription: "GCP Certified Hardware. Name for GCP certified hardware.",
						Optional: true,
					},
					"gcp_zone_names": schema.ListAttribute{
						MarkdownDescription: "GCP zone names. x-required List of zones when instances will be created, needs to match with region selected.",
						Optional: true,
						ElementType: types.StringType,
					},
					"node_number": schema.Int64Attribute{
						MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_network": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Manual Parameters. Parameters to create a new GCP VPC Network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Autogenerated Parameters. Create a new GCP VPC Network with autogenerated name",
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional: true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional: true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing gcp subnet",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of your subnet in VPC network",
										Optional: true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for gcp subnet",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 Subnet Prefix. IPv4 prefix for this Subnet. It has to be private address space.",
										Optional: true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of new VPC Subnet, will be autogenerated if empty",
										Optional: true,
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_network": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Manual Parameters. Parameters to create a new GCP VPC Network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Autogenerated Parameters. Create a new GCP VPC Network with autogenerated name",
							},
						},
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional: true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional: true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"outside_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing gcp subnet",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of your subnet in VPC network",
										Optional: true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for gcp subnet",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 Subnet Prefix. IPv4 prefix for this Subnet. It has to be private address space.",
										Optional: true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of new VPC Subnet, will be autogenerated if empty",
										Optional: true,
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"ingress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "GCP Ingress Gateway. Single interface GCP ingress site",
				Attributes: map[string]schema.Attribute{
					"gcp_certified_hw": schema.StringAttribute{
						MarkdownDescription: "GCP Certified Hardware. Name for GCP certified hardware.",
						Optional: true,
					},
					"gcp_zone_names": schema.ListAttribute{
						MarkdownDescription: "GCP zone names. x-required List of zones when instances will be created, needs to match with region selected.",
						Optional: true,
						ElementType: types.StringType,
					},
					"node_number": schema.Int64Attribute{
						MarkdownDescription: "Number of main nodes. Number of main nodes to create, either 1 or 3.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"local_network": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Manual Parameters. Parameters to create a new GCP VPC Network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Autogenerated Parameters. Create a new GCP VPC Network with autogenerated name",
							},
						},
					},
					"local_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing gcp subnet",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of your subnet in VPC network",
										Optional: true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for gcp subnet",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 Subnet Prefix. IPv4 prefix for this Subnet. It has to be private address space.",
										Optional: true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of new VPC Subnet, will be autogenerated if empty",
										Optional: true,
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Node by Node Upgrade. Specify how worker nodes within a site will be upgraded.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable Node by Node Upgrade. Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional: true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Upgrade Wait Time. Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is recommended to use the default value).",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability Mode. Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7 days, even when the site is offline. The certificates needed to keep the services running on this site are signed using a local CA. Secrets would also be cached locally to handle the connectivity loss. When the mode is toggled, services will restart and traffic disruption will be seen.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Operating System Version. Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Operating System Version. Specify a OS version to be used e.g. 9.2024.6.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"private_connect_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: private_connect_disabled, private_connectivity] Empty. This can be used for messages where no values are needed",
			},
			"private_connectivity": schema.SingleNestedBlock{
				MarkdownDescription: "Private Connect Configuration. Private Connect Configuration",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"cloud_link": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"inside": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "F5XC Software Version. Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "F5XC Software Version. Specify a F5XC Software Version to be used e.g. crt-20210329-1002.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"voltstack_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "GCP App Stack Cluster. App Stack cluster of single interface GCP site",
				Attributes: map[string]schema.Attribute{
					"gcp_certified_hw": schema.StringAttribute{
						MarkdownDescription: "GCP Certified Hardware. Name for GCP certified hardware.",
						Optional: true,
					},
					"gcp_zone_names": schema.ListAttribute{
						MarkdownDescription: "GCP zone names. x-required List of zones when instances will be created, needs to match with region selected.",
						Optional: true,
						ElementType: types.StringType,
					},
					"node_number": schema.Int64Attribute{
						MarkdownDescription: "Number of main Nodes. Number of main nodes to create, either 1 or 3.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Firewall Policy. Ordered List of Firewall Policies active for this network firewall",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global Network Connections. Global network connections",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global Network. Global network reference for direct connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Simple Static Route. Use simple static route for prefix pointing to single interface in the network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Static Route. Defines a static route, configuring a list of prefixes and a next-hop to be used for them",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Static Route Labels. Add Labels for this Static Route, these labels can be used in network policy",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "Nexthop Types. Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN private virtual network. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Network Interface. Nexthop is network interface when type is 'Network-Interface'",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address. IP Address used to specify an IPv4 or IPv6 address",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address. IPv4 Address in string form with dot-decimal notation",
																			Optional: true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address. IPv6 Address specified as hexadecimal numbers separated by ':'",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address. IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 Subnet. IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix-length of the IPv4 subnet. Must be <= 32",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv4 subnet in string form with dot-decimal notation",
																		Optional: true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 Subnet. IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix Length. Prefix length of the IPv6 subnet. Must be <= 128",
																		Optional: true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix. Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"site_local_network": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Manual Parameters. Parameters to create a new GCP VPC Network",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "GCP VPC Network Name. Name for your GCP VPC Network",
										Optional: true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "GCP VPC Network Autogenerated Parameters. Create a new GCP VPC Network with autogenerated name",
							},
						},
					},
					"site_local_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "GCP VPC network choice. This defines choice about GCP VPC network for a view",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing gcp subnet",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of your subnet in VPC network",
										Optional: true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for gcp subnet",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 Subnet Prefix. IPv4 prefix for this Subnet. It has to be private address space.",
										Optional: true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "VPC Subnet Name. Name of new VPC Subnet, will be autogenerated if empty",
										Optional: true,
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Storage Class List. Add additional custom storage classes in kubernetes for this site",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Default Storage Class. Make this storage class default storage class for the K8s cluster",
											Optional: true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Storage Class Name. Name of the storage class as it will appear in K8s.",
											Optional: true,
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *GCPVPCSiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *GCPVPCSiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *GCPVPCSiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the gcp_vpc_site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan GCPVPCSiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *GCPVPCSiteResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := GCPVPCSiteResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *GCPVPCSiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating gcp_vpc_site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.GCPVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		apiResource.Spec["admin_password"] = admin_passwordMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.CloudCredentials != nil {
		cloud_credentialsMap := make(map[string]interface{})
		if !data.CloudCredentials.Name.IsNull() && !data.CloudCredentials.Name.IsUnknown() {
			cloud_credentialsMap["name"] = data.CloudCredentials.Name.ValueString()
		}
		if !data.CloudCredentials.Namespace.IsNull() && !data.CloudCredentials.Namespace.IsUnknown() {
			cloud_credentialsMap["namespace"] = data.CloudCredentials.Namespace.ValueString()
		}
		if !data.CloudCredentials.Tenant.IsNull() && !data.CloudCredentials.Tenant.IsUnknown() {
			cloud_credentialsMap["tenant"] = data.CloudCredentials.Tenant.ValueString()
		}
		apiResource.Spec["cloud_credentials"] = cloud_credentialsMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.GCPLabels != nil {
		gcp_labelsMap := make(map[string]interface{})
		apiResource.Spec["gcp_labels"] = gcp_labelsMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.GCPCertifiedHw.IsNull() && !data.IngressEgressGw.GCPCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["gcp_certified_hw"] = data.IngressEgressGw.GCPCertifiedHw.ValueString()
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.InsideNetwork != nil {
			inside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_network"] = inside_networkNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.InsideSubnet != nil {
			inside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_subnet"] = inside_subnetNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.NodeNumber.IsNull() && !data.IngressEgressGw.NodeNumber.IsUnknown() {
			ingress_egress_gwMap["node_number"] = data.IngressEgressGw.NodeNumber.ValueInt64()
		}
		if data.IngressEgressGw.OutsideNetwork != nil {
			outside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_network"] = outside_networkNestedMap
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.OutsideSubnet != nil {
			outside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_subnet"] = outside_subnetNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if !data.IngressGw.GCPCertifiedHw.IsNull() && !data.IngressGw.GCPCertifiedHw.IsUnknown() {
			ingress_gwMap["gcp_certified_hw"] = data.IngressGw.GCPCertifiedHw.ValueString()
		}
		if data.IngressGw.LocalNetwork != nil {
			local_networkNestedMap := make(map[string]interface{})
			ingress_gwMap["local_network"] = local_networkNestedMap
		}
		if data.IngressGw.LocalSubnet != nil {
			local_subnetNestedMap := make(map[string]interface{})
			ingress_gwMap["local_subnet"] = local_subnetNestedMap
		}
		if !data.IngressGw.NodeNumber.IsNull() && !data.IngressGw.NodeNumber.IsUnknown() {
			ingress_gwMap["node_number"] = data.IngressGw.NodeNumber.ValueInt64()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.Os != nil {
		osMap := make(map[string]interface{})
		if data.Os.DefaultOsVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.Os.OperatingSystemVersion.IsNull() && !data.Os.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.Os.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.PrivateConnectDisabled != nil {
		private_connect_disabledMap := make(map[string]interface{})
		apiResource.Spec["private_connect_disabled"] = private_connect_disabledMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		apiResource.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.GCPCertifiedHw.IsNull() && !data.VoltstackCluster.GCPCertifiedHw.IsUnknown() {
			voltstack_clusterMap["gcp_certified_hw"] = data.VoltstackCluster.GCPCertifiedHw.ValueString()
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.NodeNumber.IsNull() && !data.VoltstackCluster.NodeNumber.IsUnknown() {
			voltstack_clusterMap["node_number"] = data.VoltstackCluster.NodeNumber.ValueInt64()
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SiteLocalNetwork != nil {
			site_local_networkNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_network"] = site_local_networkNestedMap
		}
		if data.VoltstackCluster.SiteLocalSubnet != nil {
			site_local_subnetNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_subnet"] = site_local_subnetNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		apiResource.Spec["address"] = data.Address.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		apiResource.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.GCPRegion.IsNull() && !data.GCPRegion.IsUnknown() {
		apiResource.Spec["gcp_region"] = data.GCPRegion.ValueString()
	}
	if !data.InstanceType.IsNull() && !data.InstanceType.IsUnknown() {
		apiResource.Spec["instance_type"] = data.InstanceType.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		apiResource.Spec["ssh_key"] = data.SSHKey.ValueString()
	}


	created, err := r.client.CreateGCPVPCSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create GCPVPCSite: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response
	if v, ok := created.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else if data.Address.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Address = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := created.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else if data.DiskSize.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DiskSize = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := created.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else if data.GCPRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.GCPRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := created.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else if data.InstanceType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.InstanceType = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := created.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else if data.SSHKey.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.SSHKey = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created GCPVPCSite resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GCPVPCSiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetGCPVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "GCPVPCSite not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read GCPVPCSite: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The gcp_vpc_site may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &GCPVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && isImport && data.BlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockedServices = &GCPVPCSiteBlockedServicesModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cloud_credentials"].(map[string]interface{}); ok && (isImport || data.CloudCredentials != nil) {
		data.CloudCredentials = &GCPVPCSiteCloudCredentialsModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &GCPVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &GCPVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["gcp_labels"].(map[string]interface{}); ok && isImport && data.GCPLabels == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.GCPLabels = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &GCPVPCSiteIngressEgressGwModel{
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeNumber: func() types.Int64 {
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &GCPVPCSiteIngressGwModel{
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeNumber: func() types.Int64 {
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &GCPVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &GCPVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &GCPVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.Os != nil) {
		data.Os = &GCPVPCSiteOsModel{
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connect_disabled"].(map[string]interface{}); ok && isImport && data.PrivateConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &GCPVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &GCPVPCSiteSwModel{
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &GCPVPCSiteVoltstackClusterModel{
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeNumber: func() types.Int64 {
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else {
		data.GCPRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GCPVPCSiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.GCPVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		apiResource.Spec["admin_password"] = admin_passwordMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.CloudCredentials != nil {
		cloud_credentialsMap := make(map[string]interface{})
		if !data.CloudCredentials.Name.IsNull() && !data.CloudCredentials.Name.IsUnknown() {
			cloud_credentialsMap["name"] = data.CloudCredentials.Name.ValueString()
		}
		if !data.CloudCredentials.Namespace.IsNull() && !data.CloudCredentials.Namespace.IsUnknown() {
			cloud_credentialsMap["namespace"] = data.CloudCredentials.Namespace.ValueString()
		}
		if !data.CloudCredentials.Tenant.IsNull() && !data.CloudCredentials.Tenant.IsUnknown() {
			cloud_credentialsMap["tenant"] = data.CloudCredentials.Tenant.ValueString()
		}
		apiResource.Spec["cloud_credentials"] = cloud_credentialsMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.GCPLabels != nil {
		gcp_labelsMap := make(map[string]interface{})
		apiResource.Spec["gcp_labels"] = gcp_labelsMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.GCPCertifiedHw.IsNull() && !data.IngressEgressGw.GCPCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["gcp_certified_hw"] = data.IngressEgressGw.GCPCertifiedHw.ValueString()
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.InsideNetwork != nil {
			inside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_network"] = inside_networkNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.InsideSubnet != nil {
			inside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_subnet"] = inside_subnetNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.NodeNumber.IsNull() && !data.IngressEgressGw.NodeNumber.IsUnknown() {
			ingress_egress_gwMap["node_number"] = data.IngressEgressGw.NodeNumber.ValueInt64()
		}
		if data.IngressEgressGw.OutsideNetwork != nil {
			outside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_network"] = outside_networkNestedMap
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.OutsideSubnet != nil {
			outside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_subnet"] = outside_subnetNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if !data.IngressGw.GCPCertifiedHw.IsNull() && !data.IngressGw.GCPCertifiedHw.IsUnknown() {
			ingress_gwMap["gcp_certified_hw"] = data.IngressGw.GCPCertifiedHw.ValueString()
		}
		if data.IngressGw.LocalNetwork != nil {
			local_networkNestedMap := make(map[string]interface{})
			ingress_gwMap["local_network"] = local_networkNestedMap
		}
		if data.IngressGw.LocalSubnet != nil {
			local_subnetNestedMap := make(map[string]interface{})
			ingress_gwMap["local_subnet"] = local_subnetNestedMap
		}
		if !data.IngressGw.NodeNumber.IsNull() && !data.IngressGw.NodeNumber.IsUnknown() {
			ingress_gwMap["node_number"] = data.IngressGw.NodeNumber.ValueInt64()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.Os != nil {
		osMap := make(map[string]interface{})
		if data.Os.DefaultOsVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.Os.OperatingSystemVersion.IsNull() && !data.Os.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.Os.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.PrivateConnectDisabled != nil {
		private_connect_disabledMap := make(map[string]interface{})
		apiResource.Spec["private_connect_disabled"] = private_connect_disabledMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		apiResource.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.GCPCertifiedHw.IsNull() && !data.VoltstackCluster.GCPCertifiedHw.IsUnknown() {
			voltstack_clusterMap["gcp_certified_hw"] = data.VoltstackCluster.GCPCertifiedHw.ValueString()
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.NodeNumber.IsNull() && !data.VoltstackCluster.NodeNumber.IsUnknown() {
			voltstack_clusterMap["node_number"] = data.VoltstackCluster.NodeNumber.ValueInt64()
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SiteLocalNetwork != nil {
			site_local_networkNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_network"] = site_local_networkNestedMap
		}
		if data.VoltstackCluster.SiteLocalSubnet != nil {
			site_local_subnetNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_subnet"] = site_local_subnetNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		apiResource.Spec["address"] = data.Address.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		apiResource.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.GCPRegion.IsNull() && !data.GCPRegion.IsUnknown() {
		apiResource.Spec["gcp_region"] = data.GCPRegion.ValueString()
	}
	if !data.InstanceType.IsNull() && !data.InstanceType.IsUnknown() {
		apiResource.Spec["instance_type"] = data.InstanceType.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		apiResource.Spec["ssh_key"] = data.SSHKey.ValueString()
	}


	updated, err := r.client.UpdateGCPVPCSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update GCPVPCSite: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response
	if v, ok := updated.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else if data.Address.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Address = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else if data.DiskSize.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DiskSize = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else if data.GCPRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.GCPRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else if data.InstanceType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.InstanceType = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else if data.SSHKey.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.SSHKey = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetGCPVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GCPVPCSiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteGCPVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "GCPVPCSite already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "GCPVPCSite delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete GCPVPCSite: %s", err))
		return
	}
}

func (r *GCPVPCSiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
