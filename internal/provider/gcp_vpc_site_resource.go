// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &GCPVPCSiteResource{}
	_ resource.ResourceWithConfigure      = &GCPVPCSiteResource{}
	_ resource.ResourceWithImportState    = &GCPVPCSiteResource{}
	_ resource.ResourceWithModifyPlan     = &GCPVPCSiteResource{}
	_ resource.ResourceWithUpgradeState   = &GCPVPCSiteResource{}
	_ resource.ResourceWithValidateConfig = &GCPVPCSiteResource{}
)

// gcp_vpc_siteSchemaVersion is the schema version for state upgrades
const gcp_vpc_siteSchemaVersion int64 = 1

func NewGCPVPCSiteResource() resource.Resource {
	return &GCPVPCSiteResource{}
}

type GCPVPCSiteResource struct {
	client *client.Client
}

// GCPVPCSiteEmptyModel represents empty nested blocks
type GCPVPCSiteEmptyModel struct {
}

// GCPVPCSiteAdminPasswordModel represents admin_password block
type GCPVPCSiteAdminPasswordModel struct {
	BlindfoldSecretInfo *GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *GCPVPCSiteAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// GCPVPCSiteAdminPasswordModelAttrTypes defines the attribute types for GCPVPCSiteAdminPasswordModel
var GCPVPCSiteAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: GCPVPCSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: GCPVPCSiteAdminPasswordClearSecretInfoModelAttrTypes},
}

// GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// GCPVPCSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for GCPVPCSiteAdminPasswordBlindfoldSecretInfoModel
var GCPVPCSiteAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// GCPVPCSiteAdminPasswordClearSecretInfoModel represents clear_secret_info block
type GCPVPCSiteAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// GCPVPCSiteAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for GCPVPCSiteAdminPasswordClearSecretInfoModel
var GCPVPCSiteAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// GCPVPCSiteBlockedServicesModel represents blocked_services block
type GCPVPCSiteBlockedServicesModel struct {
	BlockedSevice []GCPVPCSiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// GCPVPCSiteBlockedServicesModelAttrTypes defines the attribute types for GCPVPCSiteBlockedServicesModel
var GCPVPCSiteBlockedServicesModelAttrTypes = map[string]attr.Type{
	"blocked_sevice": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteBlockedServicesBlockedSeviceModelAttrTypes}},
}

// GCPVPCSiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type GCPVPCSiteBlockedServicesBlockedSeviceModel struct {
	NetworkType      types.String          `tfsdk:"network_type"`
	DNS              *GCPVPCSiteEmptyModel `tfsdk:"dns"`
	SSH              *GCPVPCSiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *GCPVPCSiteEmptyModel `tfsdk:"web_user_interface"`
}

// GCPVPCSiteBlockedServicesBlockedSeviceModelAttrTypes defines the attribute types for GCPVPCSiteBlockedServicesBlockedSeviceModel
var GCPVPCSiteBlockedServicesBlockedSeviceModelAttrTypes = map[string]attr.Type{
	"network_type":       types.StringType,
	"dns":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ssh":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web_user_interface": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteCloudCredentialsModel represents cloud_credentials block
type GCPVPCSiteCloudCredentialsModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteCloudCredentialsModelAttrTypes defines the attribute types for GCPVPCSiteCloudCredentialsModel
var GCPVPCSiteCloudCredentialsModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteCoordinatesModel represents coordinates block
type GCPVPCSiteCoordinatesModel struct {
	Latitude  types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// GCPVPCSiteCoordinatesModelAttrTypes defines the attribute types for GCPVPCSiteCoordinatesModel
var GCPVPCSiteCoordinatesModelAttrTypes = map[string]attr.Type{
	"latitude":  types.Int64Type,
	"longitude": types.Int64Type,
}

// GCPVPCSiteCustomDNSModel represents custom_dns block
type GCPVPCSiteCustomDNSModel struct {
	InsideNameserver  types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// GCPVPCSiteCustomDNSModelAttrTypes defines the attribute types for GCPVPCSiteCustomDNSModel
var GCPVPCSiteCustomDNSModelAttrTypes = map[string]attr.Type{
	"inside_nameserver":  types.StringType,
	"outside_nameserver": types.StringType,
}

// GCPVPCSiteIngressEgressGwModel represents ingress_egress_gw block
type GCPVPCSiteIngressEgressGwModel struct {
	GCPCertifiedHw                 types.String                                                  `tfsdk:"gcp_certified_hw"`
	GCPZoneNames                   types.List                                                    `tfsdk:"gcp_zone_names"`
	NodeNumber                     types.Int64                                                   `tfsdk:"node_number"`
	ActiveEnhancedFirewallPolicies *GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	DcClusterGroupInsideVn         *GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel         `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn        *GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel        `tfsdk:"dc_cluster_group_outside_vn"`
	ForwardProxyAllowAll           *GCPVPCSiteEmptyModel                                         `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *GCPVPCSiteIngressEgressGwGlobalNetworkListModel              `tfsdk:"global_network_list"`
	InsideNetwork                  *GCPVPCSiteIngressEgressGwInsideNetworkModel                  `tfsdk:"inside_network"`
	InsideStaticRoutes             *GCPVPCSiteIngressEgressGwInsideStaticRoutesModel             `tfsdk:"inside_static_routes"`
	InsideSubnet                   *GCPVPCSiteIngressEgressGwInsideSubnetModel                   `tfsdk:"inside_subnet"`
	NoDcClusterGroup               *GCPVPCSiteEmptyModel                                         `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *GCPVPCSiteEmptyModel                                         `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *GCPVPCSiteEmptyModel                                         `tfsdk:"no_global_network"`
	NoInsideStaticRoutes           *GCPVPCSiteEmptyModel                                         `tfsdk:"no_inside_static_routes"`
	NoNetworkPolicy                *GCPVPCSiteEmptyModel                                         `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *GCPVPCSiteEmptyModel                                         `tfsdk:"no_outside_static_routes"`
	OutsideNetwork                 *GCPVPCSiteIngressEgressGwOutsideNetworkModel                 `tfsdk:"outside_network"`
	OutsideStaticRoutes            *GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	OutsideSubnet                  *GCPVPCSiteIngressEgressGwOutsideSubnetModel                  `tfsdk:"outside_subnet"`
	PerformanceEnhancementMode     *GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel     `tfsdk:"performance_enhancement_mode"`
	SmConnectionPublicIP           *GCPVPCSiteEmptyModel                                         `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *GCPVPCSiteEmptyModel                                         `tfsdk:"sm_connection_pvt_ip"`
}

// GCPVPCSiteIngressEgressGwModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwModel
var GCPVPCSiteIngressEgressGwModelAttrTypes = map[string]attr.Type{
	"gcp_certified_hw":                  types.StringType,
	"gcp_zone_names":                    types.ListType{ElemType: types.StringType},
	"node_number":                       types.Int64Type,
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes},
	"dc_cluster_group_inside_vn":        types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes},
	"dc_cluster_group_outside_vn":       types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwGlobalNetworkListModelAttrTypes},
	"inside_network":                    types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideNetworkModelAttrTypes},
	"inside_static_routes":              types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesModelAttrTypes},
	"inside_subnet":                     types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideSubnetModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_inside_static_routes":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network":                   types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideNetworkModelAttrTypes},
	"outside_static_routes":             types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes},
	"outside_subnet":                    types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideSubnetModelAttrTypes},
	"performance_enhancement_mode":      types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel
var GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel
var GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModel
var GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel represents active_network_policies block
type GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel struct {
	NetworkPolicies []GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel
var GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModel
var GCPVPCSiteIngressEgressGwActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel
var GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel
var GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListModel represents global_network_list block
type GCPVPCSiteIngressEgressGwGlobalNetworkListModel struct {
	GlobalNetworkConnections []GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwGlobalNetworkListModel
var GCPVPCSiteIngressEgressGwGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModel
var GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var GCPVPCSiteIngressEgressGwGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideNetworkModel represents inside_network block
type GCPVPCSiteIngressEgressGwInsideNetworkModel struct {
	ExistingNetwork        *GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork             *GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel      `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel                                       `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteIngressEgressGwInsideNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideNetworkModel
var GCPVPCSiteIngressEgressGwInsideNetworkModelAttrTypes = map[string]attr.Type{
	"existing_network":         types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModelAttrTypes},
	"new_network":              types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModelAttrTypes},
	"new_network_autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModel
var GCPVPCSiteIngressEgressGwInsideNetworkExistingNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel represents new_network block
type GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModel
var GCPVPCSiteIngressEgressGwInsideNetworkNewNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesModel represents inside_static_routes block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesModel struct {
	StaticRouteList []GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel represents static_route_list block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                      `tfsdk:"simple_static_route"`
	CustomStaticRoute *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                `tfsdk:"attrs"`
	Labels  *GCPVPCSiteEmptyModel                                                                     `tfsdk:"labels"`
	Nexthop *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                           `tfsdk:"type"`
	Interface      []GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var GCPVPCSiteIngressEgressGwInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideSubnetModel represents inside_subnet block
type GCPVPCSiteIngressEgressGwInsideSubnetModel struct {
	ExistingSubnet *GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet      *GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel      `tfsdk:"new_subnet"`
}

// GCPVPCSiteIngressEgressGwInsideSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideSubnetModel
var GCPVPCSiteIngressEgressGwInsideSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModelAttrTypes},
	"new_subnet":      types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModel
var GCPVPCSiteIngressEgressGwInsideSubnetExistingSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name": types.StringType,
}

// GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel struct {
	PrimaryIpv4 types.String `tfsdk:"primary_ipv4"`
	SubnetName  types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModel
var GCPVPCSiteIngressEgressGwInsideSubnetNewSubnetModelAttrTypes = map[string]attr.Type{
	"primary_ipv4": types.StringType,
	"subnet_name":  types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideNetworkModel represents outside_network block
type GCPVPCSiteIngressEgressGwOutsideNetworkModel struct {
	ExistingNetwork        *GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork             *GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel      `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel                                        `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteIngressEgressGwOutsideNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideNetworkModel
var GCPVPCSiteIngressEgressGwOutsideNetworkModelAttrTypes = map[string]attr.Type{
	"existing_network":         types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModelAttrTypes},
	"new_network":              types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModelAttrTypes},
	"new_network_autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModel
var GCPVPCSiteIngressEgressGwOutsideNetworkExistingNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel represents new_network block
type GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModel
var GCPVPCSiteIngressEgressGwOutsideNetworkNewNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel represents outside_static_routes block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel struct {
	StaticRouteList []GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                       `tfsdk:"simple_static_route"`
	CustomStaticRoute *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                 `tfsdk:"attrs"`
	Labels  *GCPVPCSiteEmptyModel                                                                      `tfsdk:"labels"`
	Nexthop *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                            `tfsdk:"type"`
	Interface      []GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var GCPVPCSiteIngressEgressGwOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideSubnetModel represents outside_subnet block
type GCPVPCSiteIngressEgressGwOutsideSubnetModel struct {
	ExistingSubnet *GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet      *GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel      `tfsdk:"new_subnet"`
}

// GCPVPCSiteIngressEgressGwOutsideSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideSubnetModel
var GCPVPCSiteIngressEgressGwOutsideSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModelAttrTypes},
	"new_subnet":      types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModelAttrTypes},
}

// GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModel
var GCPVPCSiteIngressEgressGwOutsideSubnetExistingSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name": types.StringType,
}

// GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel struct {
	PrimaryIpv4 types.String `tfsdk:"primary_ipv4"`
	SubnetName  types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModel
var GCPVPCSiteIngressEgressGwOutsideSubnetNewSubnetModelAttrTypes = map[string]attr.Type{
	"primary_ipv4": types.StringType,
	"subnet_name":  types.StringType,
}

// GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *GCPVPCSiteEmptyModel                                                       `tfsdk:"perf_mode_l7_enhanced"`
}

// GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel
var GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *GCPVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *GCPVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModel
var GCPVPCSiteIngressEgressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressGwModel represents ingress_gw block
type GCPVPCSiteIngressGwModel struct {
	GCPCertifiedHw             types.String                                        `tfsdk:"gcp_certified_hw"`
	GCPZoneNames               types.List                                          `tfsdk:"gcp_zone_names"`
	NodeNumber                 types.Int64                                         `tfsdk:"node_number"`
	LocalNetwork               *GCPVPCSiteIngressGwLocalNetworkModel               `tfsdk:"local_network"`
	LocalSubnet                *GCPVPCSiteIngressGwLocalSubnetModel                `tfsdk:"local_subnet"`
	PerformanceEnhancementMode *GCPVPCSiteIngressGwPerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
}

// GCPVPCSiteIngressGwModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwModel
var GCPVPCSiteIngressGwModelAttrTypes = map[string]attr.Type{
	"gcp_certified_hw":             types.StringType,
	"gcp_zone_names":               types.ListType{ElemType: types.StringType},
	"node_number":                  types.Int64Type,
	"local_network":                types.ObjectType{AttrTypes: GCPVPCSiteIngressGwLocalNetworkModelAttrTypes},
	"local_subnet":                 types.ObjectType{AttrTypes: GCPVPCSiteIngressGwLocalSubnetModelAttrTypes},
	"performance_enhancement_mode": types.ObjectType{AttrTypes: GCPVPCSiteIngressGwPerformanceEnhancementModeModelAttrTypes},
}

// GCPVPCSiteIngressGwLocalNetworkModel represents local_network block
type GCPVPCSiteIngressGwLocalNetworkModel struct {
	ExistingNetwork        *GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork             *GCPVPCSiteIngressGwLocalNetworkNewNetworkModel      `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel                                `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteIngressGwLocalNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwLocalNetworkModel
var GCPVPCSiteIngressGwLocalNetworkModelAttrTypes = map[string]attr.Type{
	"existing_network":         types.ObjectType{AttrTypes: GCPVPCSiteIngressGwLocalNetworkExistingNetworkModelAttrTypes},
	"new_network":              types.ObjectType{AttrTypes: GCPVPCSiteIngressGwLocalNetworkNewNetworkModelAttrTypes},
	"new_network_autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressGwLocalNetworkExistingNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwLocalNetworkExistingNetworkModel
var GCPVPCSiteIngressGwLocalNetworkExistingNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteIngressGwLocalNetworkNewNetworkModel represents new_network block
type GCPVPCSiteIngressGwLocalNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteIngressGwLocalNetworkNewNetworkModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwLocalNetworkNewNetworkModel
var GCPVPCSiteIngressGwLocalNetworkNewNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteIngressGwLocalSubnetModel represents local_subnet block
type GCPVPCSiteIngressGwLocalSubnetModel struct {
	ExistingSubnet *GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet      *GCPVPCSiteIngressGwLocalSubnetNewSubnetModel      `tfsdk:"new_subnet"`
}

// GCPVPCSiteIngressGwLocalSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwLocalSubnetModel
var GCPVPCSiteIngressGwLocalSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet": types.ObjectType{AttrTypes: GCPVPCSiteIngressGwLocalSubnetExistingSubnetModelAttrTypes},
	"new_subnet":      types.ObjectType{AttrTypes: GCPVPCSiteIngressGwLocalSubnetNewSubnetModelAttrTypes},
}

// GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressGwLocalSubnetExistingSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwLocalSubnetExistingSubnetModel
var GCPVPCSiteIngressGwLocalSubnetExistingSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name": types.StringType,
}

// GCPVPCSiteIngressGwLocalSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteIngressGwLocalSubnetNewSubnetModel struct {
	PrimaryIpv4 types.String `tfsdk:"primary_ipv4"`
	SubnetName  types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteIngressGwLocalSubnetNewSubnetModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwLocalSubnetNewSubnetModel
var GCPVPCSiteIngressGwLocalSubnetNewSubnetModelAttrTypes = map[string]attr.Type{
	"primary_ipv4": types.StringType,
	"subnet_name":  types.StringType,
}

// GCPVPCSiteIngressGwPerformanceEnhancementModeModel represents performance_enhancement_mode block
type GCPVPCSiteIngressGwPerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *GCPVPCSiteEmptyModel                                                 `tfsdk:"perf_mode_l7_enhanced"`
}

// GCPVPCSiteIngressGwPerformanceEnhancementModeModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwPerformanceEnhancementModeModel
var GCPVPCSiteIngressGwPerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *GCPVPCSiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *GCPVPCSiteEmptyModel `tfsdk:"no_jumbo"`
}

// GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModel
var GCPVPCSiteIngressGwPerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type GCPVPCSiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *GCPVPCSiteEmptyModel                                    `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain  *GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// GCPVPCSiteKubernetesUpgradeDrainModelAttrTypes defines the attribute types for GCPVPCSiteKubernetesUpgradeDrainModel
var GCPVPCSiteKubernetesUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"disable_upgrade_drain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_upgrade_drain":  types.ObjectType{AttrTypes: GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes},
}

// GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64           `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout             types.Int64           `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode       *GCPVPCSiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode        *GCPVPCSiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes defines the attribute types for GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModel
var GCPVPCSiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"drain_max_unavailable_node_count": types.Int64Type,
	"drain_node_timeout":               types.Int64Type,
	"disable_vega_upgrade_mode":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_vega_upgrade_mode":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteLogReceiverModel represents log_receiver block
type GCPVPCSiteLogReceiverModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteLogReceiverModelAttrTypes defines the attribute types for GCPVPCSiteLogReceiverModel
var GCPVPCSiteLogReceiverModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type GCPVPCSiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *GCPVPCSiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode     *GCPVPCSiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// GCPVPCSiteOfflineSurvivabilityModeModelAttrTypes defines the attribute types for GCPVPCSiteOfflineSurvivabilityModeModel
var GCPVPCSiteOfflineSurvivabilityModeModelAttrTypes = map[string]attr.Type{
	"enable_offline_survivability_mode": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_offline_survivability_mode":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteOSModel represents os block
type GCPVPCSiteOSModel struct {
	OperatingSystemVersion types.String          `tfsdk:"operating_system_version"`
	DefaultOSVersion       *GCPVPCSiteEmptyModel `tfsdk:"default_os_version"`
}

// GCPVPCSiteOSModelAttrTypes defines the attribute types for GCPVPCSiteOSModel
var GCPVPCSiteOSModelAttrTypes = map[string]attr.Type{
	"operating_system_version": types.StringType,
	"default_os_version":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSitePrivateConnectivityModel represents private_connectivity block
type GCPVPCSitePrivateConnectivityModel struct {
	CloudLink *GCPVPCSitePrivateConnectivityCloudLinkModel `tfsdk:"cloud_link"`
	Inside    *GCPVPCSiteEmptyModel                        `tfsdk:"inside"`
	Outside   *GCPVPCSiteEmptyModel                        `tfsdk:"outside"`
}

// GCPVPCSitePrivateConnectivityModelAttrTypes defines the attribute types for GCPVPCSitePrivateConnectivityModel
var GCPVPCSitePrivateConnectivityModelAttrTypes = map[string]attr.Type{
	"cloud_link": types.ObjectType{AttrTypes: GCPVPCSitePrivateConnectivityCloudLinkModelAttrTypes},
	"inside":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSitePrivateConnectivityCloudLinkModel represents cloud_link block
type GCPVPCSitePrivateConnectivityCloudLinkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSitePrivateConnectivityCloudLinkModelAttrTypes defines the attribute types for GCPVPCSitePrivateConnectivityCloudLinkModel
var GCPVPCSitePrivateConnectivityCloudLinkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteSwModel represents sw block
type GCPVPCSiteSwModel struct {
	VolterraSoftwareVersion types.String          `tfsdk:"volterra_software_version"`
	DefaultSwVersion        *GCPVPCSiteEmptyModel `tfsdk:"default_sw_version"`
}

// GCPVPCSiteSwModelAttrTypes defines the attribute types for GCPVPCSiteSwModel
var GCPVPCSiteSwModelAttrTypes = map[string]attr.Type{
	"volterra_software_version": types.StringType,
	"default_sw_version":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteVoltstackClusterModel represents voltstack_cluster block
type GCPVPCSiteVoltstackClusterModel struct {
	GCPCertifiedHw                 types.String                                                   `tfsdk:"gcp_certified_hw"`
	GCPZoneNames                   types.List                                                     `tfsdk:"gcp_zone_names"`
	NodeNumber                     types.Int64                                                    `tfsdk:"node_number"`
	ActiveEnhancedFirewallPolicies *GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	DcClusterGroup                 *GCPVPCSiteVoltstackClusterDcClusterGroupModel                 `tfsdk:"dc_cluster_group"`
	DefaultStorage                 *GCPVPCSiteEmptyModel                                          `tfsdk:"default_storage"`
	ForwardProxyAllowAll           *GCPVPCSiteEmptyModel                                          `tfsdk:"forward_proxy_allow_all"`
	GlobalNetworkList              *GCPVPCSiteVoltstackClusterGlobalNetworkListModel              `tfsdk:"global_network_list"`
	K8SCluster                     *GCPVPCSiteVoltstackClusterK8SClusterModel                     `tfsdk:"k8s_cluster"`
	NoDcClusterGroup               *GCPVPCSiteEmptyModel                                          `tfsdk:"no_dc_cluster_group"`
	NoForwardProxy                 *GCPVPCSiteEmptyModel                                          `tfsdk:"no_forward_proxy"`
	NoGlobalNetwork                *GCPVPCSiteEmptyModel                                          `tfsdk:"no_global_network"`
	NoK8SCluster                   *GCPVPCSiteEmptyModel                                          `tfsdk:"no_k8s_cluster"`
	NoNetworkPolicy                *GCPVPCSiteEmptyModel                                          `tfsdk:"no_network_policy"`
	NoOutsideStaticRoutes          *GCPVPCSiteEmptyModel                                          `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes            *GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel            `tfsdk:"outside_static_routes"`
	SiteLocalNetwork               *GCPVPCSiteVoltstackClusterSiteLocalNetworkModel               `tfsdk:"site_local_network"`
	SiteLocalSubnet                *GCPVPCSiteVoltstackClusterSiteLocalSubnetModel                `tfsdk:"site_local_subnet"`
	SmConnectionPublicIP           *GCPVPCSiteEmptyModel                                          `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP              *GCPVPCSiteEmptyModel                                          `tfsdk:"sm_connection_pvt_ip"`
	StorageClassList               *GCPVPCSiteVoltstackClusterStorageClassListModel               `tfsdk:"storage_class_list"`
}

// GCPVPCSiteVoltstackClusterModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterModel
var GCPVPCSiteVoltstackClusterModelAttrTypes = map[string]attr.Type{
	"gcp_certified_hw":                  types.StringType,
	"gcp_zone_names":                    types.ListType{ElemType: types.StringType},
	"node_number":                       types.Int64Type,
	"active_enhanced_firewall_policies": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":     types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":           types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes},
	"dc_cluster_group":                  types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterDcClusterGroupModelAttrTypes},
	"default_storage":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"forward_proxy_allow_all":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"global_network_list":               types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterGlobalNetworkListModelAttrTypes},
	"k8s_cluster":                       types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterK8SClusterModelAttrTypes},
	"no_dc_cluster_group":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_k8s_cluster":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":             types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes},
	"site_local_network":                types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterSiteLocalNetworkModelAttrTypes},
	"site_local_subnet":                 types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterSiteLocalSubnetModelAttrTypes},
	"sm_connection_public_ip":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"storage_class_list":                types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterStorageClassListModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel
var GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel
var GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModel
var GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel represents active_network_policies block
type GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel struct {
	NetworkPolicies []GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel
var GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModel
var GCPVPCSiteVoltstackClusterActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterDcClusterGroupModel represents dc_cluster_group block
type GCPVPCSiteVoltstackClusterDcClusterGroupModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterDcClusterGroupModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterDcClusterGroupModel
var GCPVPCSiteVoltstackClusterDcClusterGroupModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListModel represents global_network_list block
type GCPVPCSiteVoltstackClusterGlobalNetworkListModel struct {
	GlobalNetworkConnections []GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterGlobalNetworkListModel
var GCPVPCSiteVoltstackClusterGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModel
var GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var GCPVPCSiteVoltstackClusterGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterK8SClusterModel represents k8s_cluster block
type GCPVPCSiteVoltstackClusterK8SClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// GCPVPCSiteVoltstackClusterK8SClusterModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterK8SClusterModel
var GCPVPCSiteVoltstackClusterK8SClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel represents outside_static_routes block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel struct {
	StaticRouteList []GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                                        `tfsdk:"simple_static_route"`
	CustomStaticRoute *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                                  `tfsdk:"attrs"`
	Labels  *GCPVPCSiteEmptyModel                                                                       `tfsdk:"labels"`
	Nexthop *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                                             `tfsdk:"type"`
	Interface      []GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var GCPVPCSiteVoltstackClusterOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkModel represents site_local_network block
type GCPVPCSiteVoltstackClusterSiteLocalNetworkModel struct {
	ExistingNetwork        *GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel `tfsdk:"existing_network"`
	NewNetwork             *GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel      `tfsdk:"new_network"`
	NewNetworkAutogenerate *GCPVPCSiteEmptyModel                                           `tfsdk:"new_network_autogenerate"`
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterSiteLocalNetworkModel
var GCPVPCSiteVoltstackClusterSiteLocalNetworkModelAttrTypes = map[string]attr.Type{
	"existing_network":         types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModelAttrTypes},
	"new_network":              types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModelAttrTypes},
	"new_network_autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel represents existing_network block
type GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModel
var GCPVPCSiteVoltstackClusterSiteLocalNetworkExistingNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel represents new_network block
type GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel struct {
	Name types.String `tfsdk:"name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModel
var GCPVPCSiteVoltstackClusterSiteLocalNetworkNewNetworkModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetModel represents site_local_subnet block
type GCPVPCSiteVoltstackClusterSiteLocalSubnetModel struct {
	ExistingSubnet *GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel `tfsdk:"existing_subnet"`
	NewSubnet      *GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel      `tfsdk:"new_subnet"`
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterSiteLocalSubnetModel
var GCPVPCSiteVoltstackClusterSiteLocalSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet": types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModelAttrTypes},
	"new_subnet":      types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModelAttrTypes},
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel represents existing_subnet block
type GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel struct {
	SubnetName types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModel
var GCPVPCSiteVoltstackClusterSiteLocalSubnetExistingSubnetModelAttrTypes = map[string]attr.Type{
	"subnet_name": types.StringType,
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel represents new_subnet block
type GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel struct {
	PrimaryIpv4 types.String `tfsdk:"primary_ipv4"`
	SubnetName  types.String `tfsdk:"subnet_name"`
}

// GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModel
var GCPVPCSiteVoltstackClusterSiteLocalSubnetNewSubnetModelAttrTypes = map[string]attr.Type{
	"primary_ipv4": types.StringType,
	"subnet_name":  types.StringType,
}

// GCPVPCSiteVoltstackClusterStorageClassListModel represents storage_class_list block
type GCPVPCSiteVoltstackClusterStorageClassListModel struct {
	StorageClasses []GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel `tfsdk:"storage_classes"`
}

// GCPVPCSiteVoltstackClusterStorageClassListModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterStorageClassListModel
var GCPVPCSiteVoltstackClusterStorageClassListModelAttrTypes = map[string]attr.Type{
	"storage_classes": types.ListType{ElemType: types.ObjectType{AttrTypes: GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes}},
}

// GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel represents storage_classes block
type GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel struct {
	DefaultStorageClass types.Bool   `tfsdk:"default_storage_class"`
	StorageClassName    types.String `tfsdk:"storage_class_name"`
}

// GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes defines the attribute types for GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModel
var GCPVPCSiteVoltstackClusterStorageClassListStorageClassesModelAttrTypes = map[string]attr.Type{
	"default_storage_class": types.BoolType,
	"storage_class_name":    types.StringType,
}

type GCPVPCSiteResourceModel struct {
	Name                     types.String                             `tfsdk:"name"`
	Namespace                types.String                             `tfsdk:"namespace"`
	Annotations              types.Map                                `tfsdk:"annotations"`
	Description              types.String                             `tfsdk:"description"`
	Disable                  types.Bool                               `tfsdk:"disable"`
	Labels                   types.Map                                `tfsdk:"labels"`
	ID                       types.String                             `tfsdk:"id"`
	Address                  types.String                             `tfsdk:"address"`
	DiskSize                 types.Int64                              `tfsdk:"disk_size"`
	GCPRegion                types.String                             `tfsdk:"gcp_region"`
	InstanceType             types.String                             `tfsdk:"instance_type"`
	SSHKey                   types.String                             `tfsdk:"ssh_key"`
	Timeouts                 timeouts.Value                           `tfsdk:"timeouts"`
	AdminPassword            *GCPVPCSiteAdminPasswordModel            `tfsdk:"admin_password"`
	BlockAllServices         *GCPVPCSiteEmptyModel                    `tfsdk:"block_all_services"`
	BlockedServices          *GCPVPCSiteBlockedServicesModel          `tfsdk:"blocked_services"`
	CloudCredentials         *GCPVPCSiteCloudCredentialsModel         `tfsdk:"cloud_credentials"`
	Coordinates              *GCPVPCSiteCoordinatesModel              `tfsdk:"coordinates"`
	CustomDNS                *GCPVPCSiteCustomDNSModel                `tfsdk:"custom_dns"`
	DefaultBlockedServices   *GCPVPCSiteEmptyModel                    `tfsdk:"default_blocked_services"`
	GCPLabels                *GCPVPCSiteEmptyModel                    `tfsdk:"gcp_labels"`
	IngressEgressGw          *GCPVPCSiteIngressEgressGwModel          `tfsdk:"ingress_egress_gw"`
	IngressGw                *GCPVPCSiteIngressGwModel                `tfsdk:"ingress_gw"`
	KubernetesUpgradeDrain   *GCPVPCSiteKubernetesUpgradeDrainModel   `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver              *GCPVPCSiteLogReceiverModel              `tfsdk:"log_receiver"`
	LogsStreamingDisabled    *GCPVPCSiteEmptyModel                    `tfsdk:"logs_streaming_disabled"`
	OfflineSurvivabilityMode *GCPVPCSiteOfflineSurvivabilityModeModel `tfsdk:"offline_survivability_mode"`
	OS                       *GCPVPCSiteOSModel                       `tfsdk:"os"`
	PrivateConnectDisabled   *GCPVPCSiteEmptyModel                    `tfsdk:"private_connect_disabled"`
	PrivateConnectivity      *GCPVPCSitePrivateConnectivityModel      `tfsdk:"private_connectivity"`
	Sw                       *GCPVPCSiteSwModel                       `tfsdk:"sw"`
	VoltstackCluster         *GCPVPCSiteVoltstackClusterModel         `tfsdk:"voltstack_cluster"`
}

func (r *GCPVPCSiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_gcp_vpc_site"
}

func (r *GCPVPCSiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             gcp_vpc_siteSchemaVersion,
		MarkdownDescription: "Manages a GCP VPC Site resource in F5 Distributed Cloud for deploying F5 sites within Google Cloud VPC environments.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the GCP VPC Site. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the GCP VPC Site will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "Site's geographical address that can be used to determine its latitude and longitude.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"disk_size": schema.Int64Attribute{
				MarkdownDescription: "Disk size to be used for this instance in GiB. 80 is 80 GiB.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"gcp_region": schema.StringAttribute{
				MarkdownDescription: "GCP Region. Name for GCP Region.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"instance_type": schema.StringAttribute{
				MarkdownDescription: "Select Instance size based on performance needed .",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ssh_key": schema.StringAttribute{
				MarkdownDescription: "Public SSH key for accessing the site.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"admin_password": schema.SingleNestedBlock{
				MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blindfold_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
						Attributes: map[string]schema.Attribute{
							"decryption_provider": schema.StringAttribute{
								MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
								Optional:            true,
							},
							"location": schema.StringAttribute{
								MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
								Optional:            true,
							},
							"store_provider": schema.StringAttribute{
								MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
								Optional:            true,
							},
						},
					},
					"clear_secret_info": schema.SingleNestedBlock{
						MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
						Attributes: map[string]schema.Attribute{
							"provider_ref": schema.StringAttribute{
								MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
								Optional:            true,
							},
							"url": schema.StringAttribute{
								MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
								Optional:            true,
							},
						},
					},
				},
			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services; Default: default_blocked_services] Enable this option",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable node local services on this site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services. Blocking or denial configuration",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "[Enum: VIRTUAL_NETWORK_SITE_LOCAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE|VIRTUAL_NETWORK_PER_SITE|VIRTUAL_NETWORK_PUBLIC|VIRTUAL_NETWORK_GLOBAL|VIRTUAL_NETWORK_SITE_SERVICE|VIRTUAL_NETWORK_VER_INTERNAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE|VIRTUAL_NETWORK_IP_AUTO|VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK|VIRTUAL_NETWORK_SRV6_NETWORK|VIRTUAL_NETWORK_IP_FABRIC|VIRTUAL_NETWORK_SEGMENT] Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to.. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
				},
			},
			"cloud_credentials": schema.SingleNestedBlock{
				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Coordinates of the site which provides the site physical location.",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location.",
						Optional:            true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. Longitude of site location.",
						Optional:            true,
					},
				},
			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS is the configured for specify CE site.",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "Optional DNS server IP to be used for name resolution in inside network.",
						Optional:            true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "Optional DNS server IP to be used for name resolution in outside network.",
						Optional:            true,
					},
				},
			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"gcp_labels": schema.SingleNestedBlock{
				MarkdownDescription: "GCP Label is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in GCP console.",
			},
			"ingress_egress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ingress_egress_gw, ingress_gw, voltstack_cluster] GCP Ingress/Egress Gateway. Two interface GCP ingress/egress site.",
				Attributes: map[string]schema.Attribute{
					"gcp_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Name for GCP certified hardware.",
						Optional:            true,
					},
					"gcp_zone_names": schema.ListAttribute{
						MarkdownDescription: "X-required List of zones when instances will be created, needs to match with region selected.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"node_number": schema.Int64Attribute{
						MarkdownDescription: "Number of main nodes to create, either 1 or 3.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_network": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "Parameters to create a new GCP VPC Network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Create a new GCP VPC Network with autogenerated name.",
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of your subnet in VPC network .",
										Optional:            true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 prefix for this Subnet. It has to be private address space.",
										Optional:            true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of new VPC Subnet, will be autogenerated if empty.",
										Optional:            true,
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_network": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "Parameters to create a new GCP VPC Network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Create a new GCP VPC Network with autogenerated name.",
							},
						},
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"outside_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of your subnet in VPC network .",
										Optional:            true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 prefix for this Subnet. It has to be private address space.",
										Optional:            true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of new VPC Subnet, will be autogenerated if empty.",
										Optional:            true,
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"ingress_gw": schema.SingleNestedBlock{
				MarkdownDescription: "GCP Ingress Gateway. Single interface GCP ingress site.",
				Attributes: map[string]schema.Attribute{
					"gcp_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Name for GCP certified hardware.",
						Optional:            true,
					},
					"gcp_zone_names": schema.ListAttribute{
						MarkdownDescription: "X-required List of zones when instances will be created, needs to match with region selected.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"node_number": schema.Int64Attribute{
						MarkdownDescription: "Number of main nodes to create, either 1 or 3.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"local_network": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "Parameters to create a new GCP VPC Network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Create a new GCP VPC Network with autogenerated name.",
							},
						},
					},
					"local_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of your subnet in VPC network .",
										Optional:            true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 prefix for this Subnet. It has to be private address space.",
										Optional:            true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of new VPC Subnet, will be autogenerated if empty.",
										Optional:            true,
									},
								},
							},
						},
					},
					"performance_enhancement_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"perf_mode_l3_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"no_jumbo": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"perf_mode_l7_enhanced": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Specify how worker nodes within a site will be upgraded.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional:            true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is..",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7..",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Specify a OS version to be used e.g. 9.2024.6.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"private_connect_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: private_connect_disabled, private_connectivity] Enable this option",
			},
			"private_connectivity": schema.SingleNestedBlock{
				MarkdownDescription: "Private Connect Configuration. Private Connect Configuration.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"cloud_link": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"inside": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "Specify a F5XC Software Version to be used e.g. Crt-20210329-1002.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"voltstack_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "App Stack cluster of single interface GCP site.",
				Attributes: map[string]schema.Attribute{
					"gcp_certified_hw": schema.StringAttribute{
						MarkdownDescription: "Name for GCP certified hardware.",
						Optional:            true,
					},
					"gcp_zone_names": schema.ListAttribute{
						MarkdownDescription: "X-required List of zones when instances will be created, needs to match with region selected.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"node_number": schema.Int64Attribute{
						MarkdownDescription: "Number of main nodes to create, either 1 or 3.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"default_storage": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_k8s_cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"site_local_network": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_network": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing VPC network Type. Name of existing VPC network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network": schema.SingleNestedBlock{
								MarkdownDescription: "Parameters to create a new GCP VPC Network.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name for your GCP VPC Network .",
										Optional:            true,
									},
								},
							},
							"new_network_autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Create a new GCP VPC Network with autogenerated name.",
							},
						},
					},
					"site_local_subnet": schema.SingleNestedBlock{
						MarkdownDescription: "Defines choice about GCP VPC network for a view.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"existing_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP existing subnet Type. Name of existing GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of your subnet in VPC network .",
										Optional:            true,
									},
								},
							},
							"new_subnet": schema.SingleNestedBlock{
								MarkdownDescription: "GCP subnet parameters Type. Parameters for GCP subnet.",
								Attributes: map[string]schema.Attribute{
									"primary_ipv4": schema.StringAttribute{
										MarkdownDescription: "IPv4 prefix for this Subnet. It has to be private address space.",
										Optional:            true,
									},
									"subnet_name": schema.StringAttribute{
										MarkdownDescription: "Name of new VPC Subnet, will be autogenerated if empty.",
										Optional:            true,
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"storage_class_list": schema.SingleNestedBlock{
						MarkdownDescription: "Add additional custom storage classes in Kubernetes for this site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"storage_classes": schema.ListNestedBlock{
								MarkdownDescription: "List of Storage Classes. List of custom storage classes.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"default_storage_class": schema.BoolAttribute{
											MarkdownDescription: "Make this storage class default storage class for the K8s cluster.",
											Optional:            true,
										},
										"storage_class_name": schema.StringAttribute{
											MarkdownDescription: "Name of the storage class as it will appear in K8s.",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *GCPVPCSiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *GCPVPCSiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *GCPVPCSiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the gcp_vpc_site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan GCPVPCSiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *GCPVPCSiteResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := GCPVPCSiteResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *GCPVPCSiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating gcp_vpc_site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.GCPVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		createReq.Spec["admin_password"] = admin_passwordMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		createReq.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		createReq.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.CloudCredentials != nil {
		cloud_credentialsMap := make(map[string]interface{})
		if !data.CloudCredentials.Name.IsNull() && !data.CloudCredentials.Name.IsUnknown() {
			cloud_credentialsMap["name"] = data.CloudCredentials.Name.ValueString()
		}
		if !data.CloudCredentials.Namespace.IsNull() && !data.CloudCredentials.Namespace.IsUnknown() {
			cloud_credentialsMap["namespace"] = data.CloudCredentials.Namespace.ValueString()
		}
		if !data.CloudCredentials.Tenant.IsNull() && !data.CloudCredentials.Tenant.IsUnknown() {
			cloud_credentialsMap["tenant"] = data.CloudCredentials.Tenant.ValueString()
		}
		createReq.Spec["cloud_credentials"] = cloud_credentialsMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		createReq.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		createReq.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		createReq.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.GCPLabels != nil {
		gcp_labelsMap := make(map[string]interface{})
		createReq.Spec["gcp_labels"] = gcp_labelsMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.GCPCertifiedHw.IsNull() && !data.IngressEgressGw.GCPCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["gcp_certified_hw"] = data.IngressEgressGw.GCPCertifiedHw.ValueString()
		}
		if !data.IngressEgressGw.GCPZoneNames.IsNull() && !data.IngressEgressGw.GCPZoneNames.IsUnknown() {
			var gcp_zone_namesItems []string
			diags := data.IngressEgressGw.GCPZoneNames.ElementsAs(ctx, &gcp_zone_namesItems, false)
			if !diags.HasError() {
				ingress_egress_gwMap["gcp_zone_names"] = gcp_zone_namesItems
			}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.InsideNetwork != nil {
			inside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_network"] = inside_networkNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.InsideSubnet != nil {
			inside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_subnet"] = inside_subnetNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.NodeNumber.IsNull() && !data.IngressEgressGw.NodeNumber.IsUnknown() {
			ingress_egress_gwMap["node_number"] = data.IngressEgressGw.NodeNumber.ValueInt64()
		}
		if data.IngressEgressGw.OutsideNetwork != nil {
			outside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_network"] = outside_networkNestedMap
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.OutsideSubnet != nil {
			outside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_subnet"] = outside_subnetNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if !data.IngressGw.GCPCertifiedHw.IsNull() && !data.IngressGw.GCPCertifiedHw.IsUnknown() {
			ingress_gwMap["gcp_certified_hw"] = data.IngressGw.GCPCertifiedHw.ValueString()
		}
		if !data.IngressGw.GCPZoneNames.IsNull() && !data.IngressGw.GCPZoneNames.IsUnknown() {
			var gcp_zone_namesItems []string
			diags := data.IngressGw.GCPZoneNames.ElementsAs(ctx, &gcp_zone_namesItems, false)
			if !diags.HasError() {
				ingress_gwMap["gcp_zone_names"] = gcp_zone_namesItems
			}
		}
		if data.IngressGw.LocalNetwork != nil {
			local_networkNestedMap := make(map[string]interface{})
			ingress_gwMap["local_network"] = local_networkNestedMap
		}
		if data.IngressGw.LocalSubnet != nil {
			local_subnetNestedMap := make(map[string]interface{})
			ingress_gwMap["local_subnet"] = local_subnetNestedMap
		}
		if !data.IngressGw.NodeNumber.IsNull() && !data.IngressGw.NodeNumber.IsUnknown() {
			ingress_gwMap["node_number"] = data.IngressGw.NodeNumber.ValueInt64()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		createReq.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		createReq.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		createReq.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		createReq.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		createReq.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		createReq.Spec["os"] = osMap
	}
	if data.PrivateConnectDisabled != nil {
		private_connect_disabledMap := make(map[string]interface{})
		createReq.Spec["private_connect_disabled"] = private_connect_disabledMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		createReq.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		createReq.Spec["sw"] = swMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.GCPCertifiedHw.IsNull() && !data.VoltstackCluster.GCPCertifiedHw.IsUnknown() {
			voltstack_clusterMap["gcp_certified_hw"] = data.VoltstackCluster.GCPCertifiedHw.ValueString()
		}
		if !data.VoltstackCluster.GCPZoneNames.IsNull() && !data.VoltstackCluster.GCPZoneNames.IsUnknown() {
			var gcp_zone_namesItems []string
			diags := data.VoltstackCluster.GCPZoneNames.ElementsAs(ctx, &gcp_zone_namesItems, false)
			if !diags.HasError() {
				voltstack_clusterMap["gcp_zone_names"] = gcp_zone_namesItems
			}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.NodeNumber.IsNull() && !data.VoltstackCluster.NodeNumber.IsUnknown() {
			voltstack_clusterMap["node_number"] = data.VoltstackCluster.NodeNumber.ValueInt64()
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SiteLocalNetwork != nil {
			site_local_networkNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_network"] = site_local_networkNestedMap
		}
		if data.VoltstackCluster.SiteLocalSubnet != nil {
			site_local_subnetNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_subnet"] = site_local_subnetNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		createReq.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		createReq.Spec["address"] = data.Address.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		createReq.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.GCPRegion.IsNull() && !data.GCPRegion.IsUnknown() {
		createReq.Spec["gcp_region"] = data.GCPRegion.ValueString()
	}
	if !data.InstanceType.IsNull() && !data.InstanceType.IsUnknown() {
		createReq.Spec["instance_type"] = data.InstanceType.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		createReq.Spec["ssh_key"] = data.SSHKey.ValueString()
	}

	apiResource, err := r.client.CreateGCPVPCSite(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create GCPVPCSite: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &GCPVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &GCPVPCSiteBlockedServicesModel{
			BlockedSevice: func() []GCPVPCSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []GCPVPCSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, GCPVPCSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cloud_credentials"].(map[string]interface{}); ok && (isImport || data.CloudCredentials != nil) {
		data.CloudCredentials = &GCPVPCSiteCloudCredentialsModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &GCPVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.Coordinates.Latitude
				}
				// Import case: read from API
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.Coordinates.Longitude
				}
				// Import case: read from API
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &GCPVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["gcp_labels"].(map[string]interface{}); ok && isImport && data.GCPLabels == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.GCPLabels = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &GCPVPCSiteIngressEgressGwModel{
			ActiveEnhancedFirewallPolicies: func() *GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			DcClusterGroupInsideVn: func() *GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			GlobalNetworkList: func() *GCPVPCSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			InsideNetwork: func() *GCPVPCSiteIngressEgressGwInsideNetworkModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["inside_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideNetworkModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *GCPVPCSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			InsideSubnet: func() *GCPVPCSiteIngressEgressGwInsideSubnetModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideSubnet
				}
				// Import case: read from API
				if _, ok := blockData["inside_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideSubnetModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.IngressEgressGw.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OutsideNetwork: func() *GCPVPCSiteIngressEgressGwOutsideNetworkModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["outside_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideNetworkModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			OutsideSubnet: func() *GCPVPCSiteIngressEgressGwOutsideSubnetModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideSubnet
				}
				// Import case: read from API
				if _, ok := blockData["outside_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideSubnetModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &GCPVPCSiteIngressGwModel{
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			LocalNetwork: func() *GCPVPCSiteIngressGwLocalNetworkModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.LocalNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.LocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["local_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwLocalNetworkModel{}
				}
				return nil
			}(),
			LocalSubnet: func() *GCPVPCSiteIngressGwLocalSubnetModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.LocalSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.LocalSubnet
				}
				// Import case: read from API
				if _, ok := blockData["local_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwLocalSubnetModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.IngressGw != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.IngressGw.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PerformanceEnhancementMode: func() *GCPVPCSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &GCPVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &GCPVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &GCPVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &GCPVPCSiteOSModel{
			DefaultOSVersion: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connect_disabled"].(map[string]interface{}); ok && isImport && data.PrivateConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &GCPVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &GCPVPCSiteSwModel{
			DefaultSwVersion: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &GCPVPCSiteVoltstackClusterModel{
			ActiveEnhancedFirewallPolicies: func() *GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			DcClusterGroup: func() *GCPVPCSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			GlobalNetworkList: func() *GCPVPCSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *GCPVPCSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.VoltstackCluster.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OutsideStaticRoutes: func() *GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *GCPVPCSiteVoltstackClusterSiteLocalNetworkModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.SiteLocalNetwork != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterSiteLocalNetworkModel{}
				}
				return nil
			}(),
			SiteLocalSubnet: func() *GCPVPCSiteVoltstackClusterSiteLocalSubnetModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.SiteLocalSubnet != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.SiteLocalSubnet
				}
				// Import case: read from API
				if _, ok := blockData["site_local_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterSiteLocalSubnetModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *GCPVPCSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else {
		data.GCPRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created GCPVPCSite resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GCPVPCSiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetGCPVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "GCPVPCSite not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read GCPVPCSite: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The gcp_vpc_site may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &GCPVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &GCPVPCSiteBlockedServicesModel{
			BlockedSevice: func() []GCPVPCSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []GCPVPCSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, GCPVPCSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cloud_credentials"].(map[string]interface{}); ok && (isImport || data.CloudCredentials != nil) {
		data.CloudCredentials = &GCPVPCSiteCloudCredentialsModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &GCPVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.Coordinates.Latitude
				}
				// Import case: read from API
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.Coordinates.Longitude
				}
				// Import case: read from API
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &GCPVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["gcp_labels"].(map[string]interface{}); ok && isImport && data.GCPLabels == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.GCPLabels = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &GCPVPCSiteIngressEgressGwModel{
			ActiveEnhancedFirewallPolicies: func() *GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			DcClusterGroupInsideVn: func() *GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			GlobalNetworkList: func() *GCPVPCSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			InsideNetwork: func() *GCPVPCSiteIngressEgressGwInsideNetworkModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["inside_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideNetworkModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *GCPVPCSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			InsideSubnet: func() *GCPVPCSiteIngressEgressGwInsideSubnetModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideSubnet
				}
				// Import case: read from API
				if _, ok := blockData["inside_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideSubnetModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.IngressEgressGw.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OutsideNetwork: func() *GCPVPCSiteIngressEgressGwOutsideNetworkModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["outside_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideNetworkModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			OutsideSubnet: func() *GCPVPCSiteIngressEgressGwOutsideSubnetModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideSubnet
				}
				// Import case: read from API
				if _, ok := blockData["outside_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideSubnetModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &GCPVPCSiteIngressGwModel{
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			LocalNetwork: func() *GCPVPCSiteIngressGwLocalNetworkModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.LocalNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.LocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["local_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwLocalNetworkModel{}
				}
				return nil
			}(),
			LocalSubnet: func() *GCPVPCSiteIngressGwLocalSubnetModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.LocalSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.LocalSubnet
				}
				// Import case: read from API
				if _, ok := blockData["local_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwLocalSubnetModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.IngressGw != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.IngressGw.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PerformanceEnhancementMode: func() *GCPVPCSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &GCPVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &GCPVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &GCPVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &GCPVPCSiteOSModel{
			DefaultOSVersion: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connect_disabled"].(map[string]interface{}); ok && isImport && data.PrivateConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &GCPVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &GCPVPCSiteSwModel{
			DefaultSwVersion: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &GCPVPCSiteVoltstackClusterModel{
			ActiveEnhancedFirewallPolicies: func() *GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			DcClusterGroup: func() *GCPVPCSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			GlobalNetworkList: func() *GCPVPCSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *GCPVPCSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.VoltstackCluster.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OutsideStaticRoutes: func() *GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *GCPVPCSiteVoltstackClusterSiteLocalNetworkModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.SiteLocalNetwork != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterSiteLocalNetworkModel{}
				}
				return nil
			}(),
			SiteLocalSubnet: func() *GCPVPCSiteVoltstackClusterSiteLocalSubnetModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.SiteLocalSubnet != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.SiteLocalSubnet
				}
				// Import case: read from API
				if _, ok := blockData["site_local_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterSiteLocalSubnetModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *GCPVPCSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else {
		data.GCPRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GCPVPCSiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.GCPVPCSite{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdminPassword != nil {
		admin_passwordMap := make(map[string]interface{})
		if data.AdminPassword.BlindfoldSecretInfo != nil {
			blindfold_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["decryption_provider"] = data.AdminPassword.BlindfoldSecretInfo.DecryptionProvider.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.Location.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.Location.IsUnknown() {
				blindfold_secret_infoNestedMap["location"] = data.AdminPassword.BlindfoldSecretInfo.Location.ValueString()
			}
			if !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsNull() && !data.AdminPassword.BlindfoldSecretInfo.StoreProvider.IsUnknown() {
				blindfold_secret_infoNestedMap["store_provider"] = data.AdminPassword.BlindfoldSecretInfo.StoreProvider.ValueString()
			}
			admin_passwordMap["blindfold_secret_info"] = blindfold_secret_infoNestedMap
		}
		if data.AdminPassword.ClearSecretInfo != nil {
			clear_secret_infoNestedMap := make(map[string]interface{})
			if !data.AdminPassword.ClearSecretInfo.Provider.IsNull() && !data.AdminPassword.ClearSecretInfo.Provider.IsUnknown() {
				clear_secret_infoNestedMap["provider"] = data.AdminPassword.ClearSecretInfo.Provider.ValueString()
			}
			if !data.AdminPassword.ClearSecretInfo.URL.IsNull() && !data.AdminPassword.ClearSecretInfo.URL.IsUnknown() {
				clear_secret_infoNestedMap["url"] = data.AdminPassword.ClearSecretInfo.URL.ValueString()
			}
			admin_passwordMap["clear_secret_info"] = clear_secret_infoNestedMap
		}
		apiResource.Spec["admin_password"] = admin_passwordMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.CloudCredentials != nil {
		cloud_credentialsMap := make(map[string]interface{})
		if !data.CloudCredentials.Name.IsNull() && !data.CloudCredentials.Name.IsUnknown() {
			cloud_credentialsMap["name"] = data.CloudCredentials.Name.ValueString()
		}
		if !data.CloudCredentials.Namespace.IsNull() && !data.CloudCredentials.Namespace.IsUnknown() {
			cloud_credentialsMap["namespace"] = data.CloudCredentials.Namespace.ValueString()
		}
		if !data.CloudCredentials.Tenant.IsNull() && !data.CloudCredentials.Tenant.IsUnknown() {
			cloud_credentialsMap["tenant"] = data.CloudCredentials.Tenant.ValueString()
		}
		apiResource.Spec["cloud_credentials"] = cloud_credentialsMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.GCPLabels != nil {
		gcp_labelsMap := make(map[string]interface{})
		apiResource.Spec["gcp_labels"] = gcp_labelsMap
	}
	if data.IngressEgressGw != nil {
		ingress_egress_gwMap := make(map[string]interface{})
		if data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.IngressEgressGw.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.IngressEgressGw.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			ingress_egress_gwMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.IngressEgressGw.ForwardProxyAllowAll != nil {
			ingress_egress_gwMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.GCPCertifiedHw.IsNull() && !data.IngressEgressGw.GCPCertifiedHw.IsUnknown() {
			ingress_egress_gwMap["gcp_certified_hw"] = data.IngressEgressGw.GCPCertifiedHw.ValueString()
		}
		if !data.IngressEgressGw.GCPZoneNames.IsNull() && !data.IngressEgressGw.GCPZoneNames.IsUnknown() {
			var gcp_zone_namesItems []string
			diags := data.IngressEgressGw.GCPZoneNames.ElementsAs(ctx, &gcp_zone_namesItems, false)
			if !diags.HasError() {
				ingress_egress_gwMap["gcp_zone_names"] = gcp_zone_namesItems
			}
		}
		if data.IngressEgressGw.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["global_network_list"] = global_network_listNestedMap
		}
		if data.IngressEgressGw.InsideNetwork != nil {
			inside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_network"] = inside_networkNestedMap
		}
		if data.IngressEgressGw.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.IngressEgressGw.InsideSubnet != nil {
			inside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["inside_subnet"] = inside_subnetNestedMap
		}
		if data.IngressEgressGw.NoDcClusterGroup != nil {
			ingress_egress_gwMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoForwardProxy != nil {
			ingress_egress_gwMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoGlobalNetwork != nil {
			ingress_egress_gwMap["no_global_network"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoInsideStaticRoutes != nil {
			ingress_egress_gwMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoNetworkPolicy != nil {
			ingress_egress_gwMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.NoOutsideStaticRoutes != nil {
			ingress_egress_gwMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.IngressEgressGw.NodeNumber.IsNull() && !data.IngressEgressGw.NodeNumber.IsUnknown() {
			ingress_egress_gwMap["node_number"] = data.IngressEgressGw.NodeNumber.ValueInt64()
		}
		if data.IngressEgressGw.OutsideNetwork != nil {
			outside_networkNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_network"] = outside_networkNestedMap
		}
		if data.IngressEgressGw.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.IngressEgressGw.OutsideSubnet != nil {
			outside_subnetNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["outside_subnet"] = outside_subnetNestedMap
		}
		if data.IngressEgressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_egress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		if data.IngressEgressGw.SmConnectionPublicIP != nil {
			ingress_egress_gwMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.IngressEgressGw.SmConnectionPvtIP != nil {
			ingress_egress_gwMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["ingress_egress_gw"] = ingress_egress_gwMap
	}
	if data.IngressGw != nil {
		ingress_gwMap := make(map[string]interface{})
		if !data.IngressGw.GCPCertifiedHw.IsNull() && !data.IngressGw.GCPCertifiedHw.IsUnknown() {
			ingress_gwMap["gcp_certified_hw"] = data.IngressGw.GCPCertifiedHw.ValueString()
		}
		if !data.IngressGw.GCPZoneNames.IsNull() && !data.IngressGw.GCPZoneNames.IsUnknown() {
			var gcp_zone_namesItems []string
			diags := data.IngressGw.GCPZoneNames.ElementsAs(ctx, &gcp_zone_namesItems, false)
			if !diags.HasError() {
				ingress_gwMap["gcp_zone_names"] = gcp_zone_namesItems
			}
		}
		if data.IngressGw.LocalNetwork != nil {
			local_networkNestedMap := make(map[string]interface{})
			ingress_gwMap["local_network"] = local_networkNestedMap
		}
		if data.IngressGw.LocalSubnet != nil {
			local_subnetNestedMap := make(map[string]interface{})
			ingress_gwMap["local_subnet"] = local_subnetNestedMap
		}
		if !data.IngressGw.NodeNumber.IsNull() && !data.IngressGw.NodeNumber.IsUnknown() {
			ingress_gwMap["node_number"] = data.IngressGw.NodeNumber.ValueInt64()
		}
		if data.IngressGw.PerformanceEnhancementMode != nil {
			performance_enhancement_modeNestedMap := make(map[string]interface{})
			ingress_gwMap["performance_enhancement_mode"] = performance_enhancement_modeNestedMap
		}
		apiResource.Spec["ingress_gw"] = ingress_gwMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.PrivateConnectDisabled != nil {
		private_connect_disabledMap := make(map[string]interface{})
		apiResource.Spec["private_connect_disabled"] = private_connect_disabledMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		apiResource.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.VoltstackCluster != nil {
		voltstack_clusterMap := make(map[string]interface{})
		if data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.VoltstackCluster.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.VoltstackCluster.DcClusterGroup != nil {
			dc_cluster_groupNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.DcClusterGroup.Name.IsNull() && !data.VoltstackCluster.DcClusterGroup.Name.IsUnknown() {
				dc_cluster_groupNestedMap["name"] = data.VoltstackCluster.DcClusterGroup.Name.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Namespace.IsNull() && !data.VoltstackCluster.DcClusterGroup.Namespace.IsUnknown() {
				dc_cluster_groupNestedMap["namespace"] = data.VoltstackCluster.DcClusterGroup.Namespace.ValueString()
			}
			if !data.VoltstackCluster.DcClusterGroup.Tenant.IsNull() && !data.VoltstackCluster.DcClusterGroup.Tenant.IsUnknown() {
				dc_cluster_groupNestedMap["tenant"] = data.VoltstackCluster.DcClusterGroup.Tenant.ValueString()
			}
			voltstack_clusterMap["dc_cluster_group"] = dc_cluster_groupNestedMap
		}
		if data.VoltstackCluster.DefaultStorage != nil {
			voltstack_clusterMap["default_storage"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.ForwardProxyAllowAll != nil {
			voltstack_clusterMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.GCPCertifiedHw.IsNull() && !data.VoltstackCluster.GCPCertifiedHw.IsUnknown() {
			voltstack_clusterMap["gcp_certified_hw"] = data.VoltstackCluster.GCPCertifiedHw.ValueString()
		}
		if !data.VoltstackCluster.GCPZoneNames.IsNull() && !data.VoltstackCluster.GCPZoneNames.IsUnknown() {
			var gcp_zone_namesItems []string
			diags := data.VoltstackCluster.GCPZoneNames.ElementsAs(ctx, &gcp_zone_namesItems, false)
			if !diags.HasError() {
				voltstack_clusterMap["gcp_zone_names"] = gcp_zone_namesItems
			}
		}
		if data.VoltstackCluster.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VoltstackCluster.K8SCluster != nil {
			k8s_clusterNestedMap := make(map[string]interface{})
			if !data.VoltstackCluster.K8SCluster.Name.IsNull() && !data.VoltstackCluster.K8SCluster.Name.IsUnknown() {
				k8s_clusterNestedMap["name"] = data.VoltstackCluster.K8SCluster.Name.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Namespace.IsNull() && !data.VoltstackCluster.K8SCluster.Namespace.IsUnknown() {
				k8s_clusterNestedMap["namespace"] = data.VoltstackCluster.K8SCluster.Namespace.ValueString()
			}
			if !data.VoltstackCluster.K8SCluster.Tenant.IsNull() && !data.VoltstackCluster.K8SCluster.Tenant.IsUnknown() {
				k8s_clusterNestedMap["tenant"] = data.VoltstackCluster.K8SCluster.Tenant.ValueString()
			}
			voltstack_clusterMap["k8s_cluster"] = k8s_clusterNestedMap
		}
		if data.VoltstackCluster.NoDcClusterGroup != nil {
			voltstack_clusterMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoForwardProxy != nil {
			voltstack_clusterMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoGlobalNetwork != nil {
			voltstack_clusterMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoK8SCluster != nil {
			voltstack_clusterMap["no_k8s_cluster"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoNetworkPolicy != nil {
			voltstack_clusterMap["no_network_policy"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.NoOutsideStaticRoutes != nil {
			voltstack_clusterMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if !data.VoltstackCluster.NodeNumber.IsNull() && !data.VoltstackCluster.NodeNumber.IsUnknown() {
			voltstack_clusterMap["node_number"] = data.VoltstackCluster.NodeNumber.ValueInt64()
		}
		if data.VoltstackCluster.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			voltstack_clusterMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VoltstackCluster.SiteLocalNetwork != nil {
			site_local_networkNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_network"] = site_local_networkNestedMap
		}
		if data.VoltstackCluster.SiteLocalSubnet != nil {
			site_local_subnetNestedMap := make(map[string]interface{})
			voltstack_clusterMap["site_local_subnet"] = site_local_subnetNestedMap
		}
		if data.VoltstackCluster.SmConnectionPublicIP != nil {
			voltstack_clusterMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.SmConnectionPvtIP != nil {
			voltstack_clusterMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		if data.VoltstackCluster.StorageClassList != nil {
			storage_class_listNestedMap := make(map[string]interface{})
			voltstack_clusterMap["storage_class_list"] = storage_class_listNestedMap
		}
		apiResource.Spec["voltstack_cluster"] = voltstack_clusterMap
	}
	if !data.Address.IsNull() && !data.Address.IsUnknown() {
		apiResource.Spec["address"] = data.Address.ValueString()
	}
	if !data.DiskSize.IsNull() && !data.DiskSize.IsUnknown() {
		apiResource.Spec["disk_size"] = data.DiskSize.ValueInt64()
	}
	if !data.GCPRegion.IsNull() && !data.GCPRegion.IsUnknown() {
		apiResource.Spec["gcp_region"] = data.GCPRegion.ValueString()
	}
	if !data.InstanceType.IsNull() && !data.InstanceType.IsUnknown() {
		apiResource.Spec["instance_type"] = data.InstanceType.ValueString()
	}
	if !data.SSHKey.IsNull() && !data.SSHKey.IsUnknown() {
		apiResource.Spec["ssh_key"] = data.SSHKey.ValueString()
	}

	_, err := r.client.UpdateGCPVPCSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update GCPVPCSite: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetGCPVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read GCPVPCSite after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else if data.Address.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Address = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else if data.DiskSize.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DiskSize = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else if data.GCPRegion.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.GCPRegion = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else if data.InstanceType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.InstanceType = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else if data.SSHKey.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.SSHKey = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["admin_password"].(map[string]interface{}); ok && isImport && data.AdminPassword == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdminPassword = &GCPVPCSiteAdminPasswordModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &GCPVPCSiteBlockedServicesModel{
			BlockedSevice: func() []GCPVPCSiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []GCPVPCSiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, GCPVPCSiteBlockedServicesBlockedSeviceModel{
								DNS: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *GCPVPCSiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &GCPVPCSiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cloud_credentials"].(map[string]interface{}); ok && (isImport || data.CloudCredentials != nil) {
		data.CloudCredentials = &GCPVPCSiteCloudCredentialsModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &GCPVPCSiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.Coordinates.Latitude
				}
				// Import case: read from API
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.Coordinates.Longitude
				}
				// Import case: read from API
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &GCPVPCSiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["gcp_labels"].(map[string]interface{}); ok && isImport && data.GCPLabels == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.GCPLabels = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ingress_egress_gw"].(map[string]interface{}); ok && (isImport || data.IngressEgressGw != nil) {
		data.IngressEgressGw = &GCPVPCSiteIngressEgressGwModel{
			ActiveEnhancedFirewallPolicies: func() *GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			DcClusterGroupInsideVn: func() *GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupInsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupInsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_inside_vn"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwDcClusterGroupInsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DcClusterGroupOutsideVn: func() *GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.DcClusterGroupOutsideVn != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.DcClusterGroupOutsideVn
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group_outside_vn"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwDcClusterGroupOutsideVnModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			GlobalNetworkList: func() *GCPVPCSiteIngressEgressGwGlobalNetworkListModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwGlobalNetworkListModel{}
				}
				return nil
			}(),
			InsideNetwork: func() *GCPVPCSiteIngressEgressGwInsideNetworkModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["inside_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideNetworkModel{}
				}
				return nil
			}(),
			InsideStaticRoutes: func() *GCPVPCSiteIngressEgressGwInsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["inside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideStaticRoutesModel{}
				}
				return nil
			}(),
			InsideSubnet: func() *GCPVPCSiteIngressEgressGwInsideSubnetModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.InsideSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.InsideSubnet
				}
				// Import case: read from API
				if _, ok := blockData["inside_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwInsideSubnetModel{}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoInsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoInsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_inside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.IngressEgressGw.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OutsideNetwork: func() *GCPVPCSiteIngressEgressGwOutsideNetworkModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["outside_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideNetworkModel{}
				}
				return nil
			}(),
			OutsideStaticRoutes: func() *GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			OutsideSubnet: func() *GCPVPCSiteIngressEgressGwOutsideSubnetModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.OutsideSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.OutsideSubnet
				}
				// Import case: read from API
				if _, ok := blockData["outside_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwOutsideSubnetModel{}
				}
				return nil
			}(),
			PerformanceEnhancementMode: func() *GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressEgressGw != nil && data.IngressEgressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressEgressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressEgressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.IngressEgressGw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.IngressEgressGw.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ingress_gw"].(map[string]interface{}); ok && (isImport || data.IngressGw != nil) {
		data.IngressGw = &GCPVPCSiteIngressGwModel{
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			LocalNetwork: func() *GCPVPCSiteIngressGwLocalNetworkModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.LocalNetwork != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.LocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["local_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwLocalNetworkModel{}
				}
				return nil
			}(),
			LocalSubnet: func() *GCPVPCSiteIngressGwLocalSubnetModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.LocalSubnet != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.LocalSubnet
				}
				// Import case: read from API
				if _, ok := blockData["local_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwLocalSubnetModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.IngressGw != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.IngressGw.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PerformanceEnhancementMode: func() *GCPVPCSiteIngressGwPerformanceEnhancementModeModel {
				if !isImport && data.IngressGw != nil && data.IngressGw.PerformanceEnhancementMode != nil {
					// Normal Read: preserve existing state value
					return data.IngressGw.PerformanceEnhancementMode
				}
				// Import case: read from API
				if _, ok := blockData["performance_enhancement_mode"].(map[string]interface{}); ok {
					return &GCPVPCSiteIngressGwPerformanceEnhancementModeModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &GCPVPCSiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &GCPVPCSiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &GCPVPCSiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &GCPVPCSiteOSModel{
			DefaultOSVersion: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["private_connect_disabled"].(map[string]interface{}); ok && isImport && data.PrivateConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectDisabled = &GCPVPCSiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &GCPVPCSitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &GCPVPCSiteSwModel{
			DefaultSwVersion: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["voltstack_cluster"].(map[string]interface{}); ok && (isImport || data.VoltstackCluster != nil) {
		data.VoltstackCluster = &GCPVPCSiteVoltstackClusterModel{
			ActiveEnhancedFirewallPolicies: func() *GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveEnhancedFirewallPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveEnhancedFirewallPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_enhanced_firewall_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveEnhancedFirewallPoliciesModel{}
				}
				return nil
			}(),
			ActiveForwardProxyPolicies: func() *GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveForwardProxyPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveForwardProxyPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_forward_proxy_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveForwardProxyPoliciesModel{}
				}
				return nil
			}(),
			ActiveNetworkPolicies: func() *GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.ActiveNetworkPolicies != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.ActiveNetworkPolicies
				}
				// Import case: read from API
				if _, ok := blockData["active_network_policies"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterActiveNetworkPoliciesModel{}
				}
				return nil
			}(),
			DcClusterGroup: func() *GCPVPCSiteVoltstackClusterDcClusterGroupModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.DcClusterGroup != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.DcClusterGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterDcClusterGroupModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DefaultStorage: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.DefaultStorage
				}
				// Import case: read from API
				if _, ok := blockData["default_storage"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			ForwardProxyAllowAll: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.ForwardProxyAllowAll
				}
				// Import case: read from API
				if _, ok := blockData["forward_proxy_allow_all"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			GCPCertifiedHw: func() types.String {
				if v, ok := blockData["gcp_certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			GCPZoneNames: func() types.List {
				if v, ok := blockData["gcp_zone_names"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			GlobalNetworkList: func() *GCPVPCSiteVoltstackClusterGlobalNetworkListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.GlobalNetworkList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.GlobalNetworkList
				}
				// Import case: read from API
				if _, ok := blockData["global_network_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterGlobalNetworkListModel{}
				}
				return nil
			}(),
			K8SCluster: func() *GCPVPCSiteVoltstackClusterK8SClusterModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.K8SCluster != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.K8SCluster
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["k8s_cluster"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterK8SClusterModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoDcClusterGroup: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoDcClusterGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_dc_cluster_group"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoForwardProxy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoForwardProxy
				}
				// Import case: read from API
				if _, ok := blockData["no_forward_proxy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoGlobalNetwork: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoGlobalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["no_global_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoK8SCluster: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoK8SCluster
				}
				// Import case: read from API
				if _, ok := blockData["no_k8s_cluster"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoNetworkPolicy: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoNetworkPolicy
				}
				// Import case: read from API
				if _, ok := blockData["no_network_policy"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NoOutsideStaticRoutes: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.NoOutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["no_outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			NodeNumber: func() types.Int64 {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.VoltstackCluster.NodeNumber
				}
				// Import case: read from API
				if v, ok := blockData["node_number"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OutsideStaticRoutes: func() *GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.OutsideStaticRoutes != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.OutsideStaticRoutes
				}
				// Import case: read from API
				if _, ok := blockData["outside_static_routes"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterOutsideStaticRoutesModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *GCPVPCSiteVoltstackClusterSiteLocalNetworkModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.SiteLocalNetwork != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterSiteLocalNetworkModel{}
				}
				return nil
			}(),
			SiteLocalSubnet: func() *GCPVPCSiteVoltstackClusterSiteLocalSubnetModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.SiteLocalSubnet != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.SiteLocalSubnet
				}
				// Import case: read from API
				if _, ok := blockData["site_local_subnet"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterSiteLocalSubnetModel{}
				}
				return nil
			}(),
			SmConnectionPublicIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPublicIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_public_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			SmConnectionPvtIP: func() *GCPVPCSiteEmptyModel {
				if !isImport && data.VoltstackCluster != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.VoltstackCluster.SmConnectionPvtIP
				}
				// Import case: read from API
				if _, ok := blockData["sm_connection_pvt_ip"].(map[string]interface{}); ok {
					return &GCPVPCSiteEmptyModel{}
				}
				return nil
			}(),
			StorageClassList: func() *GCPVPCSiteVoltstackClusterStorageClassListModel {
				if !isImport && data.VoltstackCluster != nil && data.VoltstackCluster.StorageClassList != nil {
					// Normal Read: preserve existing state value
					return data.VoltstackCluster.StorageClassList
				}
				// Import case: read from API
				if _, ok := blockData["storage_class_list"].(map[string]interface{}); ok {
					return &GCPVPCSiteVoltstackClusterStorageClassListModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["address"].(string); ok && v != "" {
		data.Address = types.StringValue(v)
	} else {
		data.Address = types.StringNull()
	}
	if v, ok := apiResource.Spec["disk_size"].(float64); ok {
		data.DiskSize = types.Int64Value(int64(v))
	} else {
		data.DiskSize = types.Int64Null()
	}
	if v, ok := apiResource.Spec["gcp_region"].(string); ok && v != "" {
		data.GCPRegion = types.StringValue(v)
	} else {
		data.GCPRegion = types.StringNull()
	}
	if v, ok := apiResource.Spec["instance_type"].(string); ok && v != "" {
		data.InstanceType = types.StringValue(v)
	} else {
		data.InstanceType = types.StringNull()
	}
	if v, ok := apiResource.Spec["ssh_key"].(string); ok && v != "" {
		data.SSHKey = types.StringValue(v)
	} else {
		data.SSHKey = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GCPVPCSiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data GCPVPCSiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteGCPVPCSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "GCPVPCSite already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "GCPVPCSite delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete GCPVPCSite: %s", err))
		return
	}
}

func (r *GCPVPCSiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
