// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

var (
	_ resource.Resource                = &GlobalLogReceiverResource{}
	_ resource.ResourceWithConfigure   = &GlobalLogReceiverResource{}
	_ resource.ResourceWithImportState = &GlobalLogReceiverResource{}
)

func NewGlobalLogReceiverResource() resource.Resource {
	return &GlobalLogReceiverResource{}
}

type GlobalLogReceiverResource struct {
	client *client.Client
}

type GlobalLogReceiverResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
}

func (r *GlobalLogReceiverResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_global_log_receiver"
}

func (r *GlobalLogReceiverResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a GlobalLogReceiver resource in F5 Distributed Cloud for global log aggregation settings.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the GlobalLogReceiver. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the GlobalLogReceiver will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"audit_logs": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: audit_logs, dns_logs, request_logs, security_events] Empty. This can be used for messages where no values are needed",
			},
			"aws_cloud_watch_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: aws_cloud_watch_receiver, azure_event_hubs_receiver, azure_receiver, datadog_receiver, gcp_bucket_receiver, http_receiver, kafka_receiver, new_relic_receiver, qradar_receiver, s3_receiver, splunk_receiver, sumo_logic_receiver] AWS Cloudwatch Logs Configuration. AWS Cloudwatch Logs Configuration for Global Log Receiver",
				Attributes: map[string]schema.Attribute{
					"aws_region": schema.StringAttribute{
						MarkdownDescription: "AWS Region. AWS Region Name",
						Optional: true,
					},
					"group_name": schema.StringAttribute{
						MarkdownDescription: "Group Name. The group name of the target Cloudwatch Logs stream",
						Optional: true,
					},
					"stream_name": schema.StringAttribute{
						MarkdownDescription: "Stream Name. The stream name of the target Cloudwatch Logs stream. Note that there can only be one writer to a log stream at a time",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"aws_cred": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"azure_event_hubs_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Event Hubs Configuration. Azure Event Hubs Configuration for Global Log Receiver",
				Attributes: map[string]schema.Attribute{
					"instance": schema.StringAttribute{
						MarkdownDescription: "Event Hubs Instance. Event Hubs Instance name into which logs should be stored",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Event Hubs Namespace. Event Hubs Namespace is namespace with instance into which logs should be stored",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"connection_string": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
			"azure_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Blob Configuration. Azure Blob Configuration for Global Log Receiver",
				Attributes: map[string]schema.Attribute{
					"container_name": schema.StringAttribute{
						MarkdownDescription: "Container Name. Container Name is the name of the container into which logs should be stored",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"connection_string": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
					"filename_options": schema.SingleNestedBlock{
						MarkdownDescription: "Filename Options. Filename Options allow customization of filename and folder paths used by a destination endpoint bucket or file",
						Attributes: map[string]schema.Attribute{
							"custom_folder": schema.StringAttribute{
								MarkdownDescription: "Custom Folder. Use your own folder name as the name of the folder in the endpoint bucket or file The folder name must match `/^[a-z_][a-z0-9\\-\\._]*$/i`",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"log_type_folder": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_folder": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"datadog_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "Datadog Configuration. Configuration for Datadog endpoint",
				Attributes: map[string]schema.Attribute{
					"endpoint": schema.StringAttribute{
						MarkdownDescription: "Datadog Endpoint. Datadog Endpoint, example: `example.com:9000`",
						Optional: true,
					},
					"site": schema.StringAttribute{
						MarkdownDescription: "Datadog Site. Datadog Site, example: `datadoghq.com`",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"datadog_api_key": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters Endpoint. TLS Parameters for client connection to the endpoint",
						Attributes: map[string]schema.Attribute{
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Server CA Certificates. The URL or value for trusted Server CA certificate or certificate chain Certificates in PEM format including the PEM headers.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_enable": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Client Config. mTLS Client config allows configuration of mtls client options",
								Attributes: map[string]schema.Attribute{
									"certificate": schema.StringAttribute{
										MarkdownDescription: "Client Certificate. Client certificate is PEM-encoded certificate or certificate-chain.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"key_url": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									},
								},
							},
							"no_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"dns_logs": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"gcp_bucket_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "GCP BucketConfiguration. GCP Bucket Configuration for Global Log Receiver",
				Attributes: map[string]schema.Attribute{
					"bucket": schema.StringAttribute{
						MarkdownDescription: "GCP Bucket Name. GCP Bucket Name",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"filename_options": schema.SingleNestedBlock{
						MarkdownDescription: "Filename Options. Filename Options allow customization of filename and folder paths used by a destination endpoint bucket or file",
						Attributes: map[string]schema.Attribute{
							"custom_folder": schema.StringAttribute{
								MarkdownDescription: "Custom Folder. Use your own folder name as the name of the folder in the endpoint bucket or file The folder name must match `/^[a-z_][a-z0-9\\-\\._]*$/i`",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"log_type_folder": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_folder": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"gcp_cred": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"http_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "HTTP Configuration. Configuration for HTTP endpoint",
				Attributes: map[string]schema.Attribute{
					"uri": schema.StringAttribute{
						MarkdownDescription: "HTTP Uri. HTTP Uri is the Uri of the HTTP endpoint to send logs to, example: `http://example.com:9000/logs`",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"auth_basic": schema.SingleNestedBlock{
						MarkdownDescription: "Basic Authentication Credentials. Authentication parameters to access HTPP Log Receiver Endpoint.",
						Attributes: map[string]schema.Attribute{
							"user_name": schema.StringAttribute{
								MarkdownDescription: "User Name. HTTP Basic Auth User Name",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
									},
								},
							},
						},
					},
					"auth_none": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"auth_token": schema.SingleNestedBlock{
						MarkdownDescription: "Access Token. Authentication Token for access",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"token": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
									},
								},
							},
						},
					},
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters Endpoint. TLS Parameters for client connection to the endpoint",
						Attributes: map[string]schema.Attribute{
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Server CA Certificates. The URL or value for trusted Server CA certificate or certificate chain Certificates in PEM format including the PEM headers.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_enable": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Client Config. mTLS Client config allows configuration of mtls client options",
								Attributes: map[string]schema.Attribute{
									"certificate": schema.StringAttribute{
										MarkdownDescription: "Client Certificate. Client certificate is PEM-encoded certificate or certificate-chain.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"key_url": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									},
								},
							},
							"no_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"kafka_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "Kafka Configuration. Kafka Configuration for Global Log Receiver",
				Attributes: map[string]schema.Attribute{
					"bootstrap_servers": schema.ListAttribute{
						MarkdownDescription: "Kafka Bootstrap Servers List. List of host:port pairs of the Kafka brokers",
						Optional: true,
						ElementType: types.StringType,
					},
					"kafka_topic": schema.StringAttribute{
						MarkdownDescription: "Kafka Topic. The Kafka topic name to write events to",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters Endpoint. TLS Parameters for client connection to the endpoint",
						Attributes: map[string]schema.Attribute{
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Server CA Certificates. The URL or value for trusted Server CA certificate or certificate chain Certificates in PEM format including the PEM headers.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_enable": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Client Config. mTLS Client config allows configuration of mtls client options",
								Attributes: map[string]schema.Attribute{
									"certificate": schema.StringAttribute{
										MarkdownDescription: "Client Certificate. Client certificate is PEM-encoded certificate or certificate-chain.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"key_url": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									},
								},
							},
							"no_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"new_relic_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "NewRelic Configuration. Configuration for NewRelic endpoint",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_key": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
					"eu": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"us": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"ns_all": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: ns_all, ns_current, ns_list] Empty. This can be used for messages where no values are needed",
			},
			"ns_current": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"ns_list": schema.SingleNestedBlock{
				MarkdownDescription: "Namespace List. Namespace List",
				Attributes: map[string]schema.Attribute{
					"namespaces": schema.ListAttribute{
						MarkdownDescription: "namespaces. List of namespaces to stream logs for",
						Optional: true,
						ElementType: types.StringType,
					},
				},

			},
			"qradar_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "IBM QRadar Configuration. Configuration for IBM QRadar endpoint",
				Attributes: map[string]schema.Attribute{
					"uri": schema.StringAttribute{
						MarkdownDescription: "Log Source Collector URL. Log Source Collector URL is the URL of the IBM QRadar Log Source Collector to send logs to, example: `http://example.com:9000`",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters Endpoint. TLS Parameters for client connection to the endpoint",
						Attributes: map[string]schema.Attribute{
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Server CA Certificates. The URL or value for trusted Server CA certificate or certificate chain Certificates in PEM format including the PEM headers.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_enable": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Client Config. mTLS Client config allows configuration of mtls client options",
								Attributes: map[string]schema.Attribute{
									"certificate": schema.StringAttribute{
										MarkdownDescription: "Client Certificate. Client certificate is PEM-encoded certificate or certificate-chain.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"key_url": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									},
								},
							},
							"no_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"request_logs": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"s3_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "S3 Configuration. S3 Configuration for Global Log Receiver",
				Attributes: map[string]schema.Attribute{
					"aws_region": schema.StringAttribute{
						MarkdownDescription: "AWS Region. AWS Region Name",
						Optional: true,
					},
					"bucket": schema.StringAttribute{
						MarkdownDescription: "S3 Bucket Name. S3 Bucket Name",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"aws_cred": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"filename_options": schema.SingleNestedBlock{
						MarkdownDescription: "Filename Options. Filename Options allow customization of filename and folder paths used by a destination endpoint bucket or file",
						Attributes: map[string]schema.Attribute{
							"custom_folder": schema.StringAttribute{
								MarkdownDescription: "Custom Folder. Use your own folder name as the name of the folder in the endpoint bucket or file The folder name must match `/^[a-z_][a-z0-9\\-\\._]*$/i`",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"log_type_folder": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_folder": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"security_events": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"splunk_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "Splunk HEC Logs Configuration. Configuration for Splunk HEC Logs endpoint",
				Attributes: map[string]schema.Attribute{
					"endpoint": schema.StringAttribute{
						MarkdownDescription: "Splunk HEC Logs Endpoint. Splunk HEC Logs Endpoint, example: `https://http-input-hec.splunkcloud.com` (Note: must not contain `/services/collector`)",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"batch": schema.SingleNestedBlock{
						MarkdownDescription: "Batch Options. Batch Options allow tuning for how batches of logs are sent to an endpoint",
						Attributes: map[string]schema.Attribute{
							"max_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Bytes. Send batch to endpoint after the batch is equal to or larger than this many bytes",
								Optional: true,
							},
							"max_events": schema.Int64Attribute{
								MarkdownDescription: "Max Events. Send batch to endpoint after this many log messages are in the batch",
								Optional: true,
							},
							"timeout_seconds": schema.StringAttribute{
								MarkdownDescription: "Timeout Seconds. Send batch to the endpoint after this many seconds",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"max_bytes_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"max_events_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"timeout_seconds_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"compression": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Type. Compression Type",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"compression_default": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_gzip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"compression_none": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"splunk_hec_token": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters Endpoint. TLS Parameters for client connection to the endpoint",
						Attributes: map[string]schema.Attribute{
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Server CA Certificates. The URL or value for trusted Server CA certificate or certificate chain Certificates in PEM format including the PEM headers.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_certificate": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_verify_hostname": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"mtls_enable": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Client Config. mTLS Client config allows configuration of mtls client options",
								Attributes: map[string]schema.Attribute{
									"certificate": schema.StringAttribute{
										MarkdownDescription: "Client Certificate. Client certificate is PEM-encoded certificate or certificate-chain.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"key_url": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									},
								},
							},
							"no_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"sumo_logic_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "SumoLogic Configuration. Configuration for SumoLogic endpoint",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"url": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *GlobalLogReceiverResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *GlobalLogReceiverResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data GlobalLogReceiverResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.GlobalLogReceiver{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.GlobalLogReceiverSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateGlobalLogReceiver(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create GlobalLogReceiver: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)
	tflog.Trace(ctx, "created GlobalLogReceiver resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GlobalLogReceiverResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data GlobalLogReceiverResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource, err := r.client.GetGlobalLogReceiver(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read GlobalLogReceiver: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GlobalLogReceiverResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data GlobalLogReceiverResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.GlobalLogReceiver{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.GlobalLogReceiverSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateGlobalLogReceiver(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update GlobalLogReceiver: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *GlobalLogReceiverResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data GlobalLogReceiverResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteGlobalLogReceiver(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete GlobalLogReceiver: %s", err))
		return
	}
}

func (r *GlobalLogReceiverResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
