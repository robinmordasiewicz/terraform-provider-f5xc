// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &HealthcheckResource{}
	_ resource.ResourceWithConfigure      = &HealthcheckResource{}
	_ resource.ResourceWithImportState    = &HealthcheckResource{}
	_ resource.ResourceWithModifyPlan     = &HealthcheckResource{}
	_ resource.ResourceWithUpgradeState   = &HealthcheckResource{}
	_ resource.ResourceWithValidateConfig = &HealthcheckResource{}
)

// healthcheckSchemaVersion is the schema version for state upgrades
const healthcheckSchemaVersion int64 = 1

func NewHealthcheckResource() resource.Resource {
	return &HealthcheckResource{}
}

type HealthcheckResource struct {
	client *client.Client
}

// HealthcheckEmptyModel represents empty nested blocks
type HealthcheckEmptyModel struct {
}

// HealthcheckHTTPHealthCheckModel represents http_health_check block
type HealthcheckHTTPHealthCheckModel struct {
	ExpectedStatusCodes    types.List             `tfsdk:"expected_status_codes"`
	HostHeader             types.String           `tfsdk:"host_header"`
	Path                   types.String           `tfsdk:"path"`
	RequestHeadersToRemove types.List             `tfsdk:"request_headers_to_remove"`
	UseHttp2               types.Bool             `tfsdk:"use_http2"`
	Headers                *HealthcheckEmptyModel `tfsdk:"headers"`
	UseOriginServerName    *HealthcheckEmptyModel `tfsdk:"use_origin_server_name"`
}

// HealthcheckTCPHealthCheckModel represents tcp_health_check block
type HealthcheckTCPHealthCheckModel struct {
	ExpectedResponse types.String `tfsdk:"expected_response"`
	SendPayload      types.String `tfsdk:"send_payload"`
}

type HealthcheckResourceModel struct {
	Name               types.String                     `tfsdk:"name"`
	Namespace          types.String                     `tfsdk:"namespace"`
	Annotations        types.Map                        `tfsdk:"annotations"`
	Description        types.String                     `tfsdk:"description"`
	Disable            types.Bool                       `tfsdk:"disable"`
	Labels             types.Map                        `tfsdk:"labels"`
	ID                 types.String                     `tfsdk:"id"`
	HealthyThreshold   types.Int64                      `tfsdk:"healthy_threshold"`
	Interval           types.Int64                      `tfsdk:"interval"`
	JitterPercent      types.Int64                      `tfsdk:"jitter_percent"`
	Timeout            types.Int64                      `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                      `tfsdk:"unhealthy_threshold"`
	Timeouts           timeouts.Value                   `tfsdk:"timeouts"`
	HTTPHealthCheck    *HealthcheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *HealthcheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
	UDPIcmpHealthCheck *HealthcheckEmptyModel           `tfsdk:"udp_icmp_health_check"`
}

func (r *HealthcheckResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_healthcheck"
}

func (r *HealthcheckResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             healthcheckSchemaVersion,
		MarkdownDescription: "Manages a Healthcheck resource in F5 Distributed Cloud for healthcheck object defines method to determine if the given endpoint is healthy. single healthcheck object can be referred to by one or many cluster objects. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Healthcheck. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Healthcheck will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"healthy_threshold": schema.Int64Attribute{
				MarkdownDescription: "Healthy Threshold. Number of successful responses before declaring healthy. In other words, this is the number of healthy health checks required before a host is marked healthy. Note that during startup, only a single successful health check is required to mark a host healthy.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"interval": schema.Int64Attribute{
				MarkdownDescription: "Interval. Time interval in seconds between two healthcheck requests.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"jitter_percent": schema.Int64Attribute{
				MarkdownDescription: "Jitter Percent. Add a random amount of time as a percent value to the interval between successive healthcheck requests.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"timeout": schema.Int64Attribute{
				MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"unhealthy_threshold": schema.Int64Attribute{
				MarkdownDescription: "Unhealthy Threshold. Number of failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a host is marked unhealthy. Note that for http health checking if a host responds with 503 this threshold is ignored and the host is considered unhealthy immediately.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"http_health_check": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: http_health_check, tcp_health_check, udp_icmp_health_check] HTTP Health Check. Healthy if 'get' method on URL 'http(s)://<host>/<path>' with optional '<header>' returns success. 'host' is not used for DNS resolution. It is used as HTTP Header in the request.",
				Attributes: map[string]schema.Attribute{
					"expected_status_codes": schema.ListAttribute{
						MarkdownDescription: "Expected Status Codes. Specifies a list of HTTP response status codes considered healthy. To treat default HTTP expected status code 200 as healthy, user has to configure it explicitly. This is a list of strings, each of which is single HTTP status code or a range with start and end values separated by '-'.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"host_header": schema.StringAttribute{
						MarkdownDescription: "Host Header Value. The value of the host header.",
						Optional:            true,
					},
					"path": schema.StringAttribute{
						MarkdownDescription: "Path. Specifies the HTTP path that will be requested during health checking.",
						Optional:            true,
					},
					"request_headers_to_remove": schema.ListAttribute{
						MarkdownDescription: "Request Headers to Remove. Specifies a list of HTTP headers that should be removed from each request that is sent to the health checked cluster. This is a list of keys of headers.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"use_http2": schema.BoolAttribute{
						MarkdownDescription: "Use HTTP2. If set, health checks will be made using http/2.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"headers": schema.SingleNestedBlock{
						MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked cluster. This is a list of key-value pairs.",
					},
					"use_origin_server_name": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"tcp_health_check": schema.SingleNestedBlock{
				MarkdownDescription: "TCP Health Check. Healthy if TCP connection is successful and response payload matches <expected_response>",
				Attributes: map[string]schema.Attribute{
					"expected_response": schema.StringAttribute{
						MarkdownDescription: "Expected Response. raw bytes expected in the request. Describes the encoding of the payload bytes in the payload. Hex encoded payload.",
						Optional:            true,
					},
					"send_payload": schema.StringAttribute{
						MarkdownDescription: "Send Payload. raw bytes sent in the request. Empty payloads imply a connect-only health check. Describes the encoding of the payload bytes in the payload. Hex encoded payload.",
						Optional:            true,
					},
				},
			},
			"udp_icmp_health_check": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
		},
	}
}

func (r *HealthcheckResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *HealthcheckResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data HealthcheckResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *HealthcheckResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the healthcheck from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan HealthcheckResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *HealthcheckResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := HealthcheckResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *HealthcheckResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data HealthcheckResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating healthcheck", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Healthcheck{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.HTTPHealthCheck != nil {
		http_health_checkMap := make(map[string]interface{})
		if !data.HTTPHealthCheck.ExpectedStatusCodes.IsNull() && !data.HTTPHealthCheck.ExpectedStatusCodes.IsUnknown() {
			var expected_status_codesItems []string
			diags := data.HTTPHealthCheck.ExpectedStatusCodes.ElementsAs(ctx, &expected_status_codesItems, false)
			if !diags.HasError() {
				http_health_checkMap["expected_status_codes"] = expected_status_codesItems
			}
		}
		if data.HTTPHealthCheck.Headers != nil {
			http_health_checkMap["headers"] = map[string]interface{}{}
		}
		if !data.HTTPHealthCheck.HostHeader.IsNull() && !data.HTTPHealthCheck.HostHeader.IsUnknown() {
			http_health_checkMap["host_header"] = data.HTTPHealthCheck.HostHeader.ValueString()
		}
		if !data.HTTPHealthCheck.Path.IsNull() && !data.HTTPHealthCheck.Path.IsUnknown() {
			http_health_checkMap["path"] = data.HTTPHealthCheck.Path.ValueString()
		}
		if !data.HTTPHealthCheck.RequestHeadersToRemove.IsNull() && !data.HTTPHealthCheck.RequestHeadersToRemove.IsUnknown() {
			var request_headers_to_removeItems []string
			diags := data.HTTPHealthCheck.RequestHeadersToRemove.ElementsAs(ctx, &request_headers_to_removeItems, false)
			if !diags.HasError() {
				http_health_checkMap["request_headers_to_remove"] = request_headers_to_removeItems
			}
		}
		if !data.HTTPHealthCheck.UseHttp2.IsNull() && !data.HTTPHealthCheck.UseHttp2.IsUnknown() {
			http_health_checkMap["use_http2"] = data.HTTPHealthCheck.UseHttp2.ValueBool()
		}
		if data.HTTPHealthCheck.UseOriginServerName != nil {
			http_health_checkMap["use_origin_server_name"] = map[string]interface{}{}
		}
		createReq.Spec["http_health_check"] = http_health_checkMap
	}
	if data.TCPHealthCheck != nil {
		tcp_health_checkMap := make(map[string]interface{})
		if !data.TCPHealthCheck.ExpectedResponse.IsNull() && !data.TCPHealthCheck.ExpectedResponse.IsUnknown() {
			tcp_health_checkMap["expected_response"] = data.TCPHealthCheck.ExpectedResponse.ValueString()
		}
		if !data.TCPHealthCheck.SendPayload.IsNull() && !data.TCPHealthCheck.SendPayload.IsUnknown() {
			tcp_health_checkMap["send_payload"] = data.TCPHealthCheck.SendPayload.ValueString()
		}
		createReq.Spec["tcp_health_check"] = tcp_health_checkMap
	}
	if data.UDPIcmpHealthCheck != nil {
		udp_icmp_health_checkMap := make(map[string]interface{})
		createReq.Spec["udp_icmp_health_check"] = udp_icmp_health_checkMap
	}
	if !data.HealthyThreshold.IsNull() && !data.HealthyThreshold.IsUnknown() {
		createReq.Spec["healthy_threshold"] = data.HealthyThreshold.ValueInt64()
	}
	if !data.Interval.IsNull() && !data.Interval.IsUnknown() {
		createReq.Spec["interval"] = data.Interval.ValueInt64()
	}
	if !data.JitterPercent.IsNull() && !data.JitterPercent.IsUnknown() {
		createReq.Spec["jitter_percent"] = data.JitterPercent.ValueInt64()
	}
	if !data.Timeout.IsNull() && !data.Timeout.IsUnknown() {
		createReq.Spec["timeout"] = data.Timeout.ValueInt64()
	}
	if !data.UnhealthyThreshold.IsNull() && !data.UnhealthyThreshold.IsUnknown() {
		createReq.Spec["unhealthy_threshold"] = data.UnhealthyThreshold.ValueInt64()
	}

	apiResource, err := r.client.CreateHealthcheck(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Healthcheck: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["http_health_check"].(map[string]interface{}); ok && (isImport || data.HTTPHealthCheck != nil) {
		data.HTTPHealthCheck = &HealthcheckHTTPHealthCheckModel{
			ExpectedStatusCodes: func() types.List {
				if v, ok := blockData["expected_status_codes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Headers: func() *HealthcheckEmptyModel {
				if !isImport && data.HTTPHealthCheck != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPHealthCheck.Headers
				}
				// Import case: read from API
				if _, ok := blockData["headers"].(map[string]interface{}); ok {
					return &HealthcheckEmptyModel{}
				}
				return nil
			}(),
			HostHeader: func() types.String {
				if v, ok := blockData["host_header"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Path: func() types.String {
				if v, ok := blockData["path"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			RequestHeadersToRemove: func() types.List {
				if v, ok := blockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			UseHttp2: func() types.Bool {
				if !isImport && data.HTTPHealthCheck != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPHealthCheck.UseHttp2
				}
				// Import case: read from API
				if v, ok := blockData["use_http2"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			UseOriginServerName: func() *HealthcheckEmptyModel {
				if !isImport && data.HTTPHealthCheck != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPHealthCheck.UseOriginServerName
				}
				// Import case: read from API
				if _, ok := blockData["use_origin_server_name"].(map[string]interface{}); ok {
					return &HealthcheckEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tcp_health_check"].(map[string]interface{}); ok && (isImport || data.TCPHealthCheck != nil) {
		data.TCPHealthCheck = &HealthcheckTCPHealthCheckModel{
			ExpectedResponse: func() types.String {
				if v, ok := blockData["expected_response"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SendPayload: func() types.String {
				if v, ok := blockData["send_payload"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["udp_icmp_health_check"].(map[string]interface{}); ok && isImport && data.UDPIcmpHealthCheck == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UDPIcmpHealthCheck = &HealthcheckEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["healthy_threshold"].(float64); ok {
		data.HealthyThreshold = types.Int64Value(int64(v))
	} else {
		data.HealthyThreshold = types.Int64Null()
	}
	if v, ok := apiResource.Spec["interval"].(float64); ok {
		data.Interval = types.Int64Value(int64(v))
	} else {
		data.Interval = types.Int64Null()
	}
	if v, ok := apiResource.Spec["jitter_percent"].(float64); ok {
		data.JitterPercent = types.Int64Value(int64(v))
	} else {
		data.JitterPercent = types.Int64Null()
	}
	if v, ok := apiResource.Spec["timeout"].(float64); ok {
		data.Timeout = types.Int64Value(int64(v))
	} else {
		data.Timeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["unhealthy_threshold"].(float64); ok {
		data.UnhealthyThreshold = types.Int64Value(int64(v))
	} else {
		data.UnhealthyThreshold = types.Int64Null()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Healthcheck resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HealthcheckResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data HealthcheckResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetHealthcheck(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Healthcheck not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Healthcheck: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The healthcheck may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["http_health_check"].(map[string]interface{}); ok && (isImport || data.HTTPHealthCheck != nil) {
		data.HTTPHealthCheck = &HealthcheckHTTPHealthCheckModel{
			ExpectedStatusCodes: func() types.List {
				if v, ok := blockData["expected_status_codes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Headers: func() *HealthcheckEmptyModel {
				if !isImport && data.HTTPHealthCheck != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPHealthCheck.Headers
				}
				// Import case: read from API
				if _, ok := blockData["headers"].(map[string]interface{}); ok {
					return &HealthcheckEmptyModel{}
				}
				return nil
			}(),
			HostHeader: func() types.String {
				if v, ok := blockData["host_header"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Path: func() types.String {
				if v, ok := blockData["path"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			RequestHeadersToRemove: func() types.List {
				if v, ok := blockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			UseHttp2: func() types.Bool {
				if !isImport && data.HTTPHealthCheck != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPHealthCheck.UseHttp2
				}
				// Import case: read from API
				if v, ok := blockData["use_http2"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			UseOriginServerName: func() *HealthcheckEmptyModel {
				if !isImport && data.HTTPHealthCheck != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPHealthCheck.UseOriginServerName
				}
				// Import case: read from API
				if _, ok := blockData["use_origin_server_name"].(map[string]interface{}); ok {
					return &HealthcheckEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tcp_health_check"].(map[string]interface{}); ok && (isImport || data.TCPHealthCheck != nil) {
		data.TCPHealthCheck = &HealthcheckTCPHealthCheckModel{
			ExpectedResponse: func() types.String {
				if v, ok := blockData["expected_response"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SendPayload: func() types.String {
				if v, ok := blockData["send_payload"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["udp_icmp_health_check"].(map[string]interface{}); ok && isImport && data.UDPIcmpHealthCheck == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UDPIcmpHealthCheck = &HealthcheckEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["healthy_threshold"].(float64); ok {
		data.HealthyThreshold = types.Int64Value(int64(v))
	} else {
		data.HealthyThreshold = types.Int64Null()
	}
	if v, ok := apiResource.Spec["interval"].(float64); ok {
		data.Interval = types.Int64Value(int64(v))
	} else {
		data.Interval = types.Int64Null()
	}
	if v, ok := apiResource.Spec["jitter_percent"].(float64); ok {
		data.JitterPercent = types.Int64Value(int64(v))
	} else {
		data.JitterPercent = types.Int64Null()
	}
	if v, ok := apiResource.Spec["timeout"].(float64); ok {
		data.Timeout = types.Int64Value(int64(v))
	} else {
		data.Timeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["unhealthy_threshold"].(float64); ok {
		data.UnhealthyThreshold = types.Int64Value(int64(v))
	} else {
		data.UnhealthyThreshold = types.Int64Null()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HealthcheckResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data HealthcheckResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Healthcheck{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.HTTPHealthCheck != nil {
		http_health_checkMap := make(map[string]interface{})
		if !data.HTTPHealthCheck.ExpectedStatusCodes.IsNull() && !data.HTTPHealthCheck.ExpectedStatusCodes.IsUnknown() {
			var expected_status_codesItems []string
			diags := data.HTTPHealthCheck.ExpectedStatusCodes.ElementsAs(ctx, &expected_status_codesItems, false)
			if !diags.HasError() {
				http_health_checkMap["expected_status_codes"] = expected_status_codesItems
			}
		}
		if data.HTTPHealthCheck.Headers != nil {
			http_health_checkMap["headers"] = map[string]interface{}{}
		}
		if !data.HTTPHealthCheck.HostHeader.IsNull() && !data.HTTPHealthCheck.HostHeader.IsUnknown() {
			http_health_checkMap["host_header"] = data.HTTPHealthCheck.HostHeader.ValueString()
		}
		if !data.HTTPHealthCheck.Path.IsNull() && !data.HTTPHealthCheck.Path.IsUnknown() {
			http_health_checkMap["path"] = data.HTTPHealthCheck.Path.ValueString()
		}
		if !data.HTTPHealthCheck.RequestHeadersToRemove.IsNull() && !data.HTTPHealthCheck.RequestHeadersToRemove.IsUnknown() {
			var request_headers_to_removeItems []string
			diags := data.HTTPHealthCheck.RequestHeadersToRemove.ElementsAs(ctx, &request_headers_to_removeItems, false)
			if !diags.HasError() {
				http_health_checkMap["request_headers_to_remove"] = request_headers_to_removeItems
			}
		}
		if !data.HTTPHealthCheck.UseHttp2.IsNull() && !data.HTTPHealthCheck.UseHttp2.IsUnknown() {
			http_health_checkMap["use_http2"] = data.HTTPHealthCheck.UseHttp2.ValueBool()
		}
		if data.HTTPHealthCheck.UseOriginServerName != nil {
			http_health_checkMap["use_origin_server_name"] = map[string]interface{}{}
		}
		apiResource.Spec["http_health_check"] = http_health_checkMap
	}
	if data.TCPHealthCheck != nil {
		tcp_health_checkMap := make(map[string]interface{})
		if !data.TCPHealthCheck.ExpectedResponse.IsNull() && !data.TCPHealthCheck.ExpectedResponse.IsUnknown() {
			tcp_health_checkMap["expected_response"] = data.TCPHealthCheck.ExpectedResponse.ValueString()
		}
		if !data.TCPHealthCheck.SendPayload.IsNull() && !data.TCPHealthCheck.SendPayload.IsUnknown() {
			tcp_health_checkMap["send_payload"] = data.TCPHealthCheck.SendPayload.ValueString()
		}
		apiResource.Spec["tcp_health_check"] = tcp_health_checkMap
	}
	if data.UDPIcmpHealthCheck != nil {
		udp_icmp_health_checkMap := make(map[string]interface{})
		apiResource.Spec["udp_icmp_health_check"] = udp_icmp_health_checkMap
	}
	if !data.HealthyThreshold.IsNull() && !data.HealthyThreshold.IsUnknown() {
		apiResource.Spec["healthy_threshold"] = data.HealthyThreshold.ValueInt64()
	}
	if !data.Interval.IsNull() && !data.Interval.IsUnknown() {
		apiResource.Spec["interval"] = data.Interval.ValueInt64()
	}
	if !data.JitterPercent.IsNull() && !data.JitterPercent.IsUnknown() {
		apiResource.Spec["jitter_percent"] = data.JitterPercent.ValueInt64()
	}
	if !data.Timeout.IsNull() && !data.Timeout.IsUnknown() {
		apiResource.Spec["timeout"] = data.Timeout.ValueInt64()
	}
	if !data.UnhealthyThreshold.IsNull() && !data.UnhealthyThreshold.IsUnknown() {
		apiResource.Spec["unhealthy_threshold"] = data.UnhealthyThreshold.ValueInt64()
	}

	updated, err := r.client.UpdateHealthcheck(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Healthcheck: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response
	if v, ok := updated.Spec["healthy_threshold"].(float64); ok {
		data.HealthyThreshold = types.Int64Value(int64(v))
	} else if data.HealthyThreshold.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.HealthyThreshold = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["interval"].(float64); ok {
		data.Interval = types.Int64Value(int64(v))
	} else if data.Interval.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Interval = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["jitter_percent"].(float64); ok {
		data.JitterPercent = types.Int64Value(int64(v))
	} else if data.JitterPercent.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.JitterPercent = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["timeout"].(float64); ok {
		data.Timeout = types.Int64Value(int64(v))
	} else if data.Timeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Timeout = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["unhealthy_threshold"].(float64); ok {
		data.UnhealthyThreshold = types.Int64Value(int64(v))
	} else if data.UnhealthyThreshold.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.UnhealthyThreshold = types.Int64Null()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetHealthcheck(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HealthcheckResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data HealthcheckResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteHealthcheck(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Healthcheck already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Healthcheck delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Healthcheck: %s", err))
		return
	}
}

func (r *HealthcheckResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
