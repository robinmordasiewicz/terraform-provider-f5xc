// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &HTTPLoadBalancerResource{}
)

// http_loadbalancerSchemaVersion is the schema version for state upgrades
const http_loadbalancerSchemaVersion int64 = 1

func NewHTTPLoadBalancerResource() resource.Resource {
	return &HTTPLoadBalancerResource{}
}

type HTTPLoadBalancerResource struct {
	client *client.Client
}

// HTTPLoadBalancerEmptyModel represents empty nested blocks
type HTTPLoadBalancerEmptyModel struct {
}

// HTTPLoadBalancerActiveServicePoliciesModel represents active_service_policies block
type HTTPLoadBalancerActiveServicePoliciesModel struct {
	Policies []HTTPLoadBalancerActiveServicePoliciesPoliciesModel `tfsdk:"policies"`
}

// HTTPLoadBalancerActiveServicePoliciesPoliciesModel represents policies block
type HTTPLoadBalancerActiveServicePoliciesPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomModel represents advertise_custom block
type HTTPLoadBalancerAdvertiseCustomModel struct {
	AdvertiseWhere []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	AdvertiseOnPublic *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel `tfsdk:"advertise_on_public"`
	Site *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel `tfsdk:"site"`
	UseDefaultPort *HTTPLoadBalancerEmptyModel `tfsdk:"use_default_port"`
	VirtualNetwork *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel `tfsdk:"virtual_network"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel `tfsdk:"virtual_site"`
	VirtualSiteWithVip *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipModel `tfsdk:"virtual_site_with_vip"`
	Vk8sService *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel `tfsdk:"vk8s_service"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel represents advertise_on_public block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel struct {
	PublicIP *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel represents public_ip block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel represents site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP types.String `tfsdk:"ip"`
	Network types.String `tfsdk:"network"`
	Site *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel represents virtual_network block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel struct {
	SpecificV6Vip types.String `tfsdk:"specific_v6_vip"`
	SpecificVip types.String `tfsdk:"specific_vip"`
	DefaultV6Vip *HTTPLoadBalancerEmptyModel `tfsdk:"default_v6_vip"`
	DefaultVip *HTTPLoadBalancerEmptyModel `tfsdk:"default_vip"`
	VirtualNetwork *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel `tfsdk:"virtual_network"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel represents virtual_network block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network types.String `tfsdk:"network"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipModel represents virtual_site_with_vip block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipModel struct {
	IP types.String `tfsdk:"ip"`
	Network types.String `tfsdk:"network"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseOnPublicModel represents advertise_on_public block
type HTTPLoadBalancerAdvertiseOnPublicModel struct {
	PublicIP *HTTPLoadBalancerAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// HTTPLoadBalancerAdvertiseOnPublicPublicIPModel represents public_ip block
type HTTPLoadBalancerAdvertiseOnPublicPublicIPModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIProtectionRulesModel represents api_protection_rules block
type HTTPLoadBalancerAPIProtectionRulesModel struct {
	APIEndpointRules []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel `tfsdk:"api_endpoint_rules"`
	APIGroupsRules []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel `tfsdk:"api_groups_rules"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel represents api_endpoint_rules block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel struct {
	APIEndpointPath types.String `tfsdk:"api_endpoint_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	Action *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel `tfsdk:"action"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	APIEndpointMethod *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel `tfsdk:"api_endpoint_method"`
	ClientMatcher *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel `tfsdk:"client_matcher"`
	Metadata *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel `tfsdk:"metadata"`
	RequestMatcher *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel represents action block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel struct {
	Allow *HTTPLoadBalancerEmptyModel `tfsdk:"allow"`
	Deny *HTTPLoadBalancerEmptyModel `tfsdk:"deny"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel represents api_endpoint_method block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods types.List `tfsdk:"methods"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel struct {
	AnyClient *HTTPLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJwtClaimsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel represents api_groups_rules block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	Action *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel `tfsdk:"action"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	ClientMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel `tfsdk:"client_matcher"`
	Metadata *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel `tfsdk:"metadata"`
	RequestMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel represents action block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel struct {
	Allow *HTTPLoadBalancerEmptyModel `tfsdk:"allow"`
	Deny *HTTPLoadBalancerEmptyModel `tfsdk:"deny"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel struct {
	AnyClient *HTTPLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJwtClaimsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitModel represents api_rate_limit block
type HTTPLoadBalancerAPIRateLimitModel struct {
	APIEndpointRules []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel `tfsdk:"api_endpoint_rules"`
	BypassRateLimitingRules *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
	CustomIPAllowedList *HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList *HTTPLoadBalancerAPIRateLimitIPAllowedListModel `tfsdk:"ip_allowed_list"`
	NoIPAllowedList *HTTPLoadBalancerEmptyModel `tfsdk:"no_ip_allowed_list"`
	ServerURLRules []HTTPLoadBalancerAPIRateLimitServerURLRulesModel `tfsdk:"server_url_rules"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel represents api_endpoint_rules block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel struct {
	APIEndpointPath types.String `tfsdk:"api_endpoint_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	APIEndpointMethod *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel `tfsdk:"api_endpoint_method"`
	ClientMatcher *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel `tfsdk:"client_matcher"`
	InlineRateLimiter *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel `tfsdk:"ref_rate_limiter"`
	RequestMatcher *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel represents api_endpoint_method block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods types.List `tfsdk:"methods"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel struct {
	AnyClient *HTTPLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel represents inline_rate_limiter block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel struct {
	Threshold types.Int64 `tfsdk:"threshold"`
	Unit types.String `tfsdk:"unit"`
	RefUserID *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLbUserID *HTTPLoadBalancerEmptyModel `tfsdk:"use_http_lb_user_id"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel represents ref_rate_limiter block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel struct {
	BypassRateLimitingRules []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel struct {
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	AnyURL *HTTPLoadBalancerEmptyModel `tfsdk:"any_url"`
	APIEndpoint *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	APIGroups *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel `tfsdk:"api_groups"`
	ClientMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel `tfsdk:"client_matcher"`
	RequestMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel represents api_groups block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel struct {
	AnyClient *HTTPLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitIPAllowedListModel represents ip_allowed_list block
type HTTPLoadBalancerAPIRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesModel represents server_url_rules block
type HTTPLoadBalancerAPIRateLimitServerURLRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	ClientMatcher *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel `tfsdk:"client_matcher"`
	InlineRateLimiter *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter *HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel `tfsdk:"ref_rate_limiter"`
	RequestMatcher *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel struct {
	AnyClient *HTTPLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel represents inline_rate_limiter block
type HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel struct {
	Threshold types.Int64 `tfsdk:"threshold"`
	Unit types.String `tfsdk:"unit"`
	RefUserID *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLbUserID *HTTPLoadBalancerEmptyModel `tfsdk:"use_http_lb_user_id"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel represents ref_rate_limiter block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel `tfsdk:"headers"`
	JwtClaims []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsModel `tfsdk:"jwt_claims"`
	QueryParams []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJwtClaimsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPISpecificationModel represents api_specification block
type HTTPLoadBalancerAPISpecificationModel struct {
	APIDefinition *HTTPLoadBalancerAPISpecificationAPIDefinitionModel `tfsdk:"api_definition"`
	ValidationAllSpecEndpoints *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel `tfsdk:"validation_all_spec_endpoints"`
	ValidationCustomList *HTTPLoadBalancerAPISpecificationValidationCustomListModel `tfsdk:"validation_custom_list"`
	ValidationDisabled *HTTPLoadBalancerEmptyModel `tfsdk:"validation_disabled"`
}

// HTTPLoadBalancerAPISpecificationAPIDefinitionModel represents api_definition block
type HTTPLoadBalancerAPISpecificationAPIDefinitionModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel represents validation_all_spec_endpoints block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel struct {
	FallThroughMode *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel `tfsdk:"fall_through_mode"`
	Settings *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel `tfsdk:"settings"`
	ValidationMode *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel `tfsdk:"validation_mode"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel represents fall_through_mode block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel struct {
	FallThroughModeAllow *HTTPLoadBalancerEmptyModel `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	ActionBlock *HTTPLoadBalancerEmptyModel `tfsdk:"action_block"`
	ActionReport *HTTPLoadBalancerEmptyModel `tfsdk:"action_report"`
	ActionSkip *HTTPLoadBalancerEmptyModel `tfsdk:"action_skip"`
	APIEndpoint *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel `tfsdk:"metadata"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel represents settings block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel struct {
	OversizedBodyFailValidation *HTTPLoadBalancerEmptyModel `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation *HTTPLoadBalancerEmptyModel `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *HTTPLoadBalancerEmptyModel `tfsdk:"property_validation_settings_default"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters *HTTPLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *HTTPLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel represents validation_mode block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel struct {
	ResponseValidationModeActive *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation *HTTPLoadBalancerEmptyModel `tfsdk:"skip_response_validation"`
	SkipValidation *HTTPLoadBalancerEmptyModel `tfsdk:"skip_validation"`
	ValidationModeActive *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel `tfsdk:"validation_mode_active"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List `tfsdk:"response_validation_properties"`
	EnforcementBlock *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel represents validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List `tfsdk:"request_validation_properties"`
	EnforcementBlock *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListModel represents validation_custom_list block
type HTTPLoadBalancerAPISpecificationValidationCustomListModel struct {
	FallThroughMode *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel `tfsdk:"fall_through_mode"`
	OpenAPIValidationRules []HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
	Settings *HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel `tfsdk:"settings"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel represents fall_through_mode block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel struct {
	FallThroughModeAllow *HTTPLoadBalancerEmptyModel `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	ActionBlock *HTTPLoadBalancerEmptyModel `tfsdk:"action_block"`
	ActionReport *HTTPLoadBalancerEmptyModel `tfsdk:"action_report"`
	ActionSkip *HTTPLoadBalancerEmptyModel `tfsdk:"action_skip"`
	APIEndpoint *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel `tfsdk:"metadata"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel represents open_api_validation_rules block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel struct {
	APIGroup types.String `tfsdk:"api_group"`
	BasePath types.String `tfsdk:"base_path"`
	SpecificDomain types.String `tfsdk:"specific_domain"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	APIEndpoint *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel `tfsdk:"metadata"`
	ValidationMode *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel `tfsdk:"validation_mode"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel represents validation_mode block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel struct {
	ResponseValidationModeActive *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation *HTTPLoadBalancerEmptyModel `tfsdk:"skip_response_validation"`
	SkipValidation *HTTPLoadBalancerEmptyModel `tfsdk:"skip_validation"`
	ValidationModeActive *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel `tfsdk:"validation_mode_active"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List `tfsdk:"response_validation_properties"`
	EnforcementBlock *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel represents validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List `tfsdk:"request_validation_properties"`
	EnforcementBlock *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel represents settings block
type HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel struct {
	OversizedBodyFailValidation *HTTPLoadBalancerEmptyModel `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation *HTTPLoadBalancerEmptyModel `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom *HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *HTTPLoadBalancerEmptyModel `tfsdk:"property_validation_settings_default"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters *HTTPLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *HTTPLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// HTTPLoadBalancerAPITestingModel represents api_testing block
type HTTPLoadBalancerAPITestingModel struct {
	CustomHeaderValue types.String `tfsdk:"custom_header_value"`
	Domains []HTTPLoadBalancerAPITestingDomainsModel `tfsdk:"domains"`
	EveryDay *HTTPLoadBalancerEmptyModel `tfsdk:"every_day"`
	EveryMonth *HTTPLoadBalancerEmptyModel `tfsdk:"every_month"`
	EveryWeek *HTTPLoadBalancerEmptyModel `tfsdk:"every_week"`
}

// HTTPLoadBalancerAPITestingDomainsModel represents domains block
type HTTPLoadBalancerAPITestingDomainsModel struct {
	AllowDestructiveMethods types.Bool `tfsdk:"allow_destructive_methods"`
	Domain types.String `tfsdk:"domain"`
	Credentials []HTTPLoadBalancerAPITestingDomainsCredentialsModel `tfsdk:"credentials"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsModel represents credentials block
type HTTPLoadBalancerAPITestingDomainsCredentialsModel struct {
	CredentialName types.String `tfsdk:"credential_name"`
	Admin *HTTPLoadBalancerEmptyModel `tfsdk:"admin"`
	APIKey *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel `tfsdk:"api_key"`
	BasicAuth *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel `tfsdk:"basic_auth"`
	BearerToken *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel `tfsdk:"bearer_token"`
	LoginEndpoint *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel `tfsdk:"login_endpoint"`
	Standard *HTTPLoadBalancerEmptyModel `tfsdk:"standard"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel represents api_key block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel struct {
	Key types.String `tfsdk:"key"`
	Value *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel `tfsdk:"value"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel represents value block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel represents basic_auth block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel struct {
	User types.String `tfsdk:"user"`
	Password *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel `tfsdk:"password"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel represents password block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel represents bearer_token block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel struct {
	Token *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel `tfsdk:"token"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel represents token block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel represents login_endpoint block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel struct {
	Method types.String `tfsdk:"method"`
	Path types.String `tfsdk:"path"`
	TokenResponseKey types.String `tfsdk:"token_response_key"`
	JsonPayload *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadModel `tfsdk:"json_payload"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadModel represents json_payload block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJsonPayloadClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAppFirewallModel represents app_firewall block
type HTTPLoadBalancerAppFirewallModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerBlockedClientsModel represents blocked_clients block
type HTTPLoadBalancerBlockedClientsModel struct {
	Actions types.List `tfsdk:"actions"`
	AsNumber types.Int64 `tfsdk:"as_number"`
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	IPPrefix types.String `tfsdk:"ip_prefix"`
	IPV6Prefix types.String `tfsdk:"ipv6_prefix"`
	UserIdentifier types.String `tfsdk:"user_identifier"`
	BotSkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"bot_skip_processing"`
	HTTPHeader *HTTPLoadBalancerBlockedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata *HTTPLoadBalancerBlockedClientsMetadataModel `tfsdk:"metadata"`
	SkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"skip_processing"`
	WAFSkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"waf_skip_processing"`
}

// HTTPLoadBalancerBlockedClientsHTTPHeaderModel represents http_header block
type HTTPLoadBalancerBlockedClientsHTTPHeaderModel struct {
	Headers []HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel represents headers block
type HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBlockedClientsMetadataModel represents metadata block
type HTTPLoadBalancerBlockedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseModel represents bot_defense block
type HTTPLoadBalancerBotDefenseModel struct {
	RegionalEndpoint types.String `tfsdk:"regional_endpoint"`
	Timeout types.Int64 `tfsdk:"timeout"`
	DisableCorsSupport *HTTPLoadBalancerEmptyModel `tfsdk:"disable_cors_support"`
	EnableCorsSupport *HTTPLoadBalancerEmptyModel `tfsdk:"enable_cors_support"`
	Policy *HTTPLoadBalancerBotDefensePolicyModel `tfsdk:"policy"`
}

// HTTPLoadBalancerBotDefensePolicyModel represents policy block
type HTTPLoadBalancerBotDefensePolicyModel struct {
	JavascriptMode types.String `tfsdk:"javascript_mode"`
	JsDownloadPath types.String `tfsdk:"js_download_path"`
	DisableJsInsert *HTTPLoadBalancerEmptyModel `tfsdk:"disable_js_insert"`
	DisableMobileSdk *HTTPLoadBalancerEmptyModel `tfsdk:"disable_mobile_sdk"`
	JsInsertAllPages *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel `tfsdk:"js_insertion_rules"`
	MobileSdkConfig *HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel `tfsdk:"mobile_sdk_config"`
	ProtectedAppEndpoints []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel `tfsdk:"protected_app_endpoints"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel represents js_insert_all_pages block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	ExcludeList []HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules []HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel represents rules block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel represents mobile_sdk_config block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel struct {
	MobileIdentifier *HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel `tfsdk:"mobile_identifier"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel represents mobile_identifier block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel struct {
	Headers []HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel represents headers block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel struct {
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel represents item block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel represents protected_app_endpoints block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel struct {
	HTTPMethods types.List `tfsdk:"http_methods"`
	Protocol types.String `tfsdk:"protocol"`
	AllowGoodBots *HTTPLoadBalancerEmptyModel `tfsdk:"allow_good_bots"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel `tfsdk:"domain"`
	FlowLabel *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel `tfsdk:"flow_label"`
	Headers []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel `tfsdk:"headers"`
	Metadata *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel `tfsdk:"metadata"`
	MitigateGoodBots *HTTPLoadBalancerEmptyModel `tfsdk:"mitigate_good_bots"`
	Mitigation *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel `tfsdk:"mitigation"`
	Mobile *HTTPLoadBalancerEmptyModel `tfsdk:"mobile"`
	Path *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel `tfsdk:"path"`
	QueryParams []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel `tfsdk:"query_params"`
	UndefinedFlowLabel *HTTPLoadBalancerEmptyModel `tfsdk:"undefined_flow_label"`
	Web *HTTPLoadBalancerEmptyModel `tfsdk:"web"`
	WebMobile *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel `tfsdk:"web_mobile"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel represents flow_label block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel struct {
	AccountManagement *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel `tfsdk:"account_management"`
	Authentication *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel `tfsdk:"authentication"`
	FinancialServices *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel `tfsdk:"financial_services"`
	Flight *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel `tfsdk:"flight"`
	ProfileManagement *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel `tfsdk:"profile_management"`
	Search *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel `tfsdk:"search"`
	ShoppingGiftCards *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel `tfsdk:"shopping_gift_cards"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel represents account_management block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel struct {
	Create *HTTPLoadBalancerEmptyModel `tfsdk:"create"`
	PasswordReset *HTTPLoadBalancerEmptyModel `tfsdk:"password_reset"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel represents authentication block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel struct {
	Login *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel `tfsdk:"login"`
	LoginMfa *HTTPLoadBalancerEmptyModel `tfsdk:"login_mfa"`
	LoginPartner *HTTPLoadBalancerEmptyModel `tfsdk:"login_partner"`
	Logout *HTTPLoadBalancerEmptyModel `tfsdk:"logout"`
	TokenRefresh *HTTPLoadBalancerEmptyModel `tfsdk:"token_refresh"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel represents login block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel struct {
	DisableTransactionResult *HTTPLoadBalancerEmptyModel `tfsdk:"disable_transaction_result"`
	TransactionResult *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel `tfsdk:"transaction_result"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel represents transaction_result block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel struct {
	FailureConditions []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel `tfsdk:"failure_conditions"`
	SuccessConditions []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel `tfsdk:"success_conditions"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel represents failure_conditions block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel struct {
	Name types.String `tfsdk:"name"`
	RegexValues types.List `tfsdk:"regex_values"`
	Status types.String `tfsdk:"status"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel represents success_conditions block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel struct {
	Name types.String `tfsdk:"name"`
	RegexValues types.List `tfsdk:"regex_values"`
	Status types.String `tfsdk:"status"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel represents financial_services block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel struct {
	Apply *HTTPLoadBalancerEmptyModel `tfsdk:"apply"`
	MoneyTransfer *HTTPLoadBalancerEmptyModel `tfsdk:"money_transfer"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel represents flight block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel struct {
	Checkin *HTTPLoadBalancerEmptyModel `tfsdk:"checkin"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel represents profile_management block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel struct {
	Create *HTTPLoadBalancerEmptyModel `tfsdk:"create"`
	Update *HTTPLoadBalancerEmptyModel `tfsdk:"update"`
	View *HTTPLoadBalancerEmptyModel `tfsdk:"view"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel represents search block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel struct {
	FlightSearch *HTTPLoadBalancerEmptyModel `tfsdk:"flight_search"`
	ProductSearch *HTTPLoadBalancerEmptyModel `tfsdk:"product_search"`
	ReservationSearch *HTTPLoadBalancerEmptyModel `tfsdk:"reservation_search"`
	RoomSearch *HTTPLoadBalancerEmptyModel `tfsdk:"room_search"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel represents shopping_gift_cards block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel struct {
	GiftCardMakePurchaseWithGiftCard *HTTPLoadBalancerEmptyModel `tfsdk:"gift_card_make_purchase_with_gift_card"`
	GiftCardValidation *HTTPLoadBalancerEmptyModel `tfsdk:"gift_card_validation"`
	ShopAddToCart *HTTPLoadBalancerEmptyModel `tfsdk:"shop_add_to_cart"`
	ShopCheckout *HTTPLoadBalancerEmptyModel `tfsdk:"shop_checkout"`
	ShopChooseSeat *HTTPLoadBalancerEmptyModel `tfsdk:"shop_choose_seat"`
	ShopEnterDrawingSubmission *HTTPLoadBalancerEmptyModel `tfsdk:"shop_enter_drawing_submission"`
	ShopMakePayment *HTTPLoadBalancerEmptyModel `tfsdk:"shop_make_payment"`
	ShopOrder *HTTPLoadBalancerEmptyModel `tfsdk:"shop_order"`
	ShopPriceInquiry *HTTPLoadBalancerEmptyModel `tfsdk:"shop_price_inquiry"`
	ShopPromoCodeValidation *HTTPLoadBalancerEmptyModel `tfsdk:"shop_promo_code_validation"`
	ShopPurchaseGiftCard *HTTPLoadBalancerEmptyModel `tfsdk:"shop_purchase_gift_card"`
	ShopUpdateQuantity *HTTPLoadBalancerEmptyModel `tfsdk:"shop_update_quantity"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel represents headers block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel represents item block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel represents mitigation block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel struct {
	Block *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel `tfsdk:"block"`
	Flag *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel `tfsdk:"flag"`
	Redirect *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel `tfsdk:"redirect"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel represents block block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel struct {
	Body types.String `tfsdk:"body"`
	Status types.String `tfsdk:"status"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel represents flag block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel struct {
	AppendHeaders *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel `tfsdk:"append_headers"`
	NoHeaders *HTTPLoadBalancerEmptyModel `tfsdk:"no_headers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel represents append_headers block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel struct {
	AutoTypeHeaderName types.String `tfsdk:"auto_type_header_name"`
	InferenceHeaderName types.String `tfsdk:"inference_header_name"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel represents redirect block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel struct {
	URI types.String `tfsdk:"uri"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel represents query_params block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel represents item block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel represents web_mobile block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel struct {
	MobileIdentifier types.String `tfsdk:"mobile_identifier"`
}

// HTTPLoadBalancerBotDefenseAdvancedModel represents bot_defense_advanced block
type HTTPLoadBalancerBotDefenseAdvancedModel struct {
	DisableJsInsert *HTTPLoadBalancerEmptyModel `tfsdk:"disable_js_insert"`
	DisableMobileSdk *HTTPLoadBalancerEmptyModel `tfsdk:"disable_mobile_sdk"`
	JsInsertAllPages *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel `tfsdk:"js_insertion_rules"`
	Mobile *HTTPLoadBalancerBotDefenseAdvancedMobileModel `tfsdk:"mobile"`
	MobileSdkConfig *HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel `tfsdk:"mobile_sdk_config"`
	Web *HTTPLoadBalancerBotDefenseAdvancedWebModel `tfsdk:"web"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel represents js_insert_all_pages block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	ExcludeList []HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel represents js_insertion_rules block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel struct {
	ExcludeList []HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules []HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel represents rules block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel represents domain block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel represents path block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileModel represents mobile block
type HTTPLoadBalancerBotDefenseAdvancedMobileModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel represents mobile_sdk_config block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel struct {
	MobileIdentifier *HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel `tfsdk:"mobile_identifier"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel represents mobile_identifier block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel struct {
	Headers []HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel represents headers block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel struct {
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel represents item block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefenseAdvancedWebModel represents web block
type HTTPLoadBalancerBotDefenseAdvancedWebModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerCachingPolicyModel represents caching_policy block
type HTTPLoadBalancerCachingPolicyModel struct {
	CustomCacheRule *HTTPLoadBalancerCachingPolicyCustomCacheRuleModel `tfsdk:"custom_cache_rule"`
	DefaultCacheAction *HTTPLoadBalancerCachingPolicyDefaultCacheActionModel `tfsdk:"default_cache_action"`
}

// HTTPLoadBalancerCachingPolicyCustomCacheRuleModel represents custom_cache_rule block
type HTTPLoadBalancerCachingPolicyCustomCacheRuleModel struct {
	CDNCacheRules []HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel `tfsdk:"cdn_cache_rules"`
}

// HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel represents cdn_cache_rules block
type HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerCachingPolicyDefaultCacheActionModel represents default_cache_action block
type HTTPLoadBalancerCachingPolicyDefaultCacheActionModel struct {
	CacheTtlDefault types.String `tfsdk:"cache_ttl_default"`
	CacheTtlOverride types.String `tfsdk:"cache_ttl_override"`
	CacheDisabled *HTTPLoadBalancerEmptyModel `tfsdk:"cache_disabled"`
}

// HTTPLoadBalancerCaptchaChallengeModel represents captcha_challenge block
type HTTPLoadBalancerCaptchaChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerClientSideDefenseModel represents client_side_defense block
type HTTPLoadBalancerClientSideDefenseModel struct {
	Policy *HTTPLoadBalancerClientSideDefensePolicyModel `tfsdk:"policy"`
}

// HTTPLoadBalancerClientSideDefensePolicyModel represents policy block
type HTTPLoadBalancerClientSideDefensePolicyModel struct {
	DisableJsInsert *HTTPLoadBalancerEmptyModel `tfsdk:"disable_js_insert"`
	JsInsertAllPages *HTTPLoadBalancerEmptyModel `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel `tfsdk:"js_insertion_rules"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel struct {
	ExcludeList []HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules []HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel represents rules block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel represents path block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerCookieStickinessModel represents cookie_stickiness block
type HTTPLoadBalancerCookieStickinessModel struct {
	Name types.String `tfsdk:"name"`
	Path types.String `tfsdk:"path"`
	Ttl types.Int64 `tfsdk:"ttl"`
	AddHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerCorsPolicyModel represents cors_policy block
type HTTPLoadBalancerCorsPolicyModel struct {
	AllowCredentials types.Bool `tfsdk:"allow_credentials"`
	AllowHeaders types.String `tfsdk:"allow_headers"`
	AllowMethods types.String `tfsdk:"allow_methods"`
	AllowOrigin types.List `tfsdk:"allow_origin"`
	AllowOriginRegex types.List `tfsdk:"allow_origin_regex"`
	Disabled types.Bool `tfsdk:"disabled"`
	ExposeHeaders types.String `tfsdk:"expose_headers"`
	MaximumAge types.Int64 `tfsdk:"maximum_age"`
}

// HTTPLoadBalancerCsrfPolicyModel represents csrf_policy block
type HTTPLoadBalancerCsrfPolicyModel struct {
	AllLoadBalancerDomains *HTTPLoadBalancerEmptyModel `tfsdk:"all_load_balancer_domains"`
	CustomDomainList *HTTPLoadBalancerCsrfPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled *HTTPLoadBalancerEmptyModel `tfsdk:"disabled"`
}

// HTTPLoadBalancerCsrfPolicyCustomDomainListModel represents custom_domain_list block
type HTTPLoadBalancerCsrfPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// HTTPLoadBalancerDataGuardRulesModel represents data_guard_rules block
type HTTPLoadBalancerDataGuardRulesModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	ApplyDataGuard *HTTPLoadBalancerEmptyModel `tfsdk:"apply_data_guard"`
	Metadata *HTTPLoadBalancerDataGuardRulesMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerDataGuardRulesPathModel `tfsdk:"path"`
	SkipDataGuard *HTTPLoadBalancerEmptyModel `tfsdk:"skip_data_guard"`
}

// HTTPLoadBalancerDataGuardRulesMetadataModel represents metadata block
type HTTPLoadBalancerDataGuardRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerDataGuardRulesPathModel represents path block
type HTTPLoadBalancerDataGuardRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerDdosMitigationRulesModel represents ddos_mitigation_rules block
type HTTPLoadBalancerDdosMitigationRulesModel struct {
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	Block *HTTPLoadBalancerEmptyModel `tfsdk:"block"`
	DdosClientSource *HTTPLoadBalancerDdosMitigationRulesDdosClientSourceModel `tfsdk:"ddos_client_source"`
	IPPrefixList *HTTPLoadBalancerDdosMitigationRulesIPPrefixListModel `tfsdk:"ip_prefix_list"`
	Metadata *HTTPLoadBalancerDdosMitigationRulesMetadataModel `tfsdk:"metadata"`
}

// HTTPLoadBalancerDdosMitigationRulesDdosClientSourceModel represents ddos_client_source block
type HTTPLoadBalancerDdosMitigationRulesDdosClientSourceModel struct {
	CountryList types.List `tfsdk:"country_list"`
	AsnList *HTTPLoadBalancerDdosMitigationRulesDdosClientSourceAsnListModel `tfsdk:"asn_list"`
	Ja4TLSFingerprintMatcher *HTTPLoadBalancerDdosMitigationRulesDdosClientSourceJa4TLSFingerprintMatcherModel `tfsdk:"ja4_tls_fingerprint_matcher"`
	TLSFingerprintMatcher *HTTPLoadBalancerDdosMitigationRulesDdosClientSourceTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerDdosMitigationRulesDdosClientSourceAsnListModel represents asn_list block
type HTTPLoadBalancerDdosMitigationRulesDdosClientSourceAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerDdosMitigationRulesDdosClientSourceJa4TLSFingerprintMatcherModel represents ja4_tls_fingerprint_matcher block
type HTTPLoadBalancerDdosMitigationRulesDdosClientSourceJa4TLSFingerprintMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
}

// HTTPLoadBalancerDdosMitigationRulesDdosClientSourceTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerDdosMitigationRulesDdosClientSourceTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerDdosMitigationRulesIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerDdosMitigationRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerDdosMitigationRulesMetadataModel represents metadata block
type HTTPLoadBalancerDdosMitigationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerDefaultPoolModel represents default_pool block
type HTTPLoadBalancerDefaultPoolModel struct {
	EndpointSelection types.String `tfsdk:"endpoint_selection"`
	HealthCheckPort types.Int64 `tfsdk:"health_check_port"`
	LoadBalancerAlgorithm types.String `tfsdk:"loadbalancer_algorithm"`
	Port types.Int64 `tfsdk:"port"`
	AdvancedOptions *HTTPLoadBalancerDefaultPoolAdvancedOptionsModel `tfsdk:"advanced_options"`
	AutomaticPort *HTTPLoadBalancerEmptyModel `tfsdk:"automatic_port"`
	Healthcheck []HTTPLoadBalancerDefaultPoolHealthcheckModel `tfsdk:"healthcheck"`
	LbPort *HTTPLoadBalancerEmptyModel `tfsdk:"lb_port"`
	NoTLS *HTTPLoadBalancerEmptyModel `tfsdk:"no_tls"`
	OriginServers []HTTPLoadBalancerDefaultPoolOriginServersModel `tfsdk:"origin_servers"`
	SameAsEndpointPort *HTTPLoadBalancerEmptyModel `tfsdk:"same_as_endpoint_port"`
	UpstreamConnPoolReuseType *HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel `tfsdk:"upstream_conn_pool_reuse_type"`
	UseTLS *HTTPLoadBalancerDefaultPoolUseTLSModel `tfsdk:"use_tls"`
	ViewInternal *HTTPLoadBalancerDefaultPoolViewInternalModel `tfsdk:"view_internal"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsModel represents advanced_options block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsModel struct {
	ConnectionTimeout types.Int64 `tfsdk:"connection_timeout"`
	HTTPIdleTimeout types.Int64 `tfsdk:"http_idle_timeout"`
	PanicThreshold types.Int64 `tfsdk:"panic_threshold"`
	AutoHTTPConfig *HTTPLoadBalancerEmptyModel `tfsdk:"auto_http_config"`
	CircuitBreaker *HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel `tfsdk:"circuit_breaker"`
	DefaultCircuitBreaker *HTTPLoadBalancerEmptyModel `tfsdk:"default_circuit_breaker"`
	DisableCircuitBreaker *HTTPLoadBalancerEmptyModel `tfsdk:"disable_circuit_breaker"`
	DisableLbSourceIPPersistance *HTTPLoadBalancerEmptyModel `tfsdk:"disable_lb_source_ip_persistance"`
	DisableOutlierDetection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_outlier_detection"`
	DisableProxyProtocol *HTTPLoadBalancerEmptyModel `tfsdk:"disable_proxy_protocol"`
	DisableSubsets *HTTPLoadBalancerEmptyModel `tfsdk:"disable_subsets"`
	EnableLbSourceIPPersistance *HTTPLoadBalancerEmptyModel `tfsdk:"enable_lb_source_ip_persistance"`
	EnableSubsets *HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel `tfsdk:"enable_subsets"`
	Http1Config *HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel `tfsdk:"http1_config"`
	Http2Options *HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel `tfsdk:"http2_options"`
	NoPanicThreshold *HTTPLoadBalancerEmptyModel `tfsdk:"no_panic_threshold"`
	OutlierDetection *HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel `tfsdk:"outlier_detection"`
	ProxyProtocolV1 *HTTPLoadBalancerEmptyModel `tfsdk:"proxy_protocol_v1"`
	ProxyProtocolV2 *HTTPLoadBalancerEmptyModel `tfsdk:"proxy_protocol_v2"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel represents circuit_breaker block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel struct {
	ConnectionLimit types.Int64 `tfsdk:"connection_limit"`
	MaxRequests types.Int64 `tfsdk:"max_requests"`
	PendingRequests types.Int64 `tfsdk:"pending_requests"`
	Priority types.String `tfsdk:"priority"`
	Retries types.Int64 `tfsdk:"retries"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel represents enable_subsets block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel struct {
	AnyEndpoint *HTTPLoadBalancerEmptyModel `tfsdk:"any_endpoint"`
	DefaultSubset *HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel `tfsdk:"default_subset"`
	EndpointSubsets []HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel `tfsdk:"endpoint_subsets"`
	FailRequest *HTTPLoadBalancerEmptyModel `tfsdk:"fail_request"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel represents default_subset block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel struct {
	DefaultSubset *HTTPLoadBalancerEmptyModel `tfsdk:"default_subset"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel represents endpoint_subsets block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel struct {
	Keys types.List `tfsdk:"keys"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel represents http1_config block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel struct {
	HeaderTransformation *HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel `tfsdk:"header_transformation"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel represents header_transformation block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel struct {
	DefaultHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel represents http2_options block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel struct {
	Enabled types.Bool `tfsdk:"enabled"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel represents outlier_detection block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel struct {
	BaseEjectionTime types.Int64 `tfsdk:"base_ejection_time"`
	Consecutive5xx types.Int64 `tfsdk:"consecutive_5xx"`
	ConsecutiveGatewayFailure types.Int64 `tfsdk:"consecutive_gateway_failure"`
	Interval types.Int64 `tfsdk:"interval"`
	MaxEjectionPercent types.Int64 `tfsdk:"max_ejection_percent"`
}

// HTTPLoadBalancerDefaultPoolHealthcheckModel represents healthcheck block
type HTTPLoadBalancerDefaultPoolHealthcheckModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersModel represents origin_servers block
type HTTPLoadBalancerDefaultPoolOriginServersModel struct {
	CbipService *HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel `tfsdk:"cbip_service"`
	ConsulService *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel `tfsdk:"consul_service"`
	CustomEndpointObject *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel `tfsdk:"custom_endpoint_object"`
	K8SService *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel `tfsdk:"k8s_service"`
	Labels *HTTPLoadBalancerEmptyModel `tfsdk:"labels"`
	PrivateIP *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel `tfsdk:"private_ip"`
	PrivateName *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel `tfsdk:"private_name"`
	PublicIP *HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel `tfsdk:"public_ip"`
	PublicName *HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel `tfsdk:"public_name"`
	VnPrivateIP *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel `tfsdk:"vn_private_ip"`
	VnPrivateName *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel `tfsdk:"vn_private_name"`
}

// HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel represents cbip_service block
type HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel struct {
	ServiceName types.String `tfsdk:"service_name"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel represents consul_service block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel struct {
	ServiceName types.String `tfsdk:"service_name"`
	InsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"outside_network"`
	SiteLocator *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel struct {
	Site *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel `tfsdk:"no_snat_pool"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel represents custom_endpoint_object block
type HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel struct {
	Endpoint *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel `tfsdk:"endpoint"`
}

// HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel represents endpoint block
type HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel represents k8s_service block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel struct {
	Protocol types.String `tfsdk:"protocol"`
	ServiceName types.String `tfsdk:"service_name"`
	InsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"outside_network"`
	SiteLocator *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel `tfsdk:"snat_pool"`
	Vk8sNetworks *HTTPLoadBalancerEmptyModel `tfsdk:"vk8s_networks"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel struct {
	Site *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel `tfsdk:"no_snat_pool"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel represents private_ip block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel struct {
	IP types.String `tfsdk:"ip"`
	InsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"outside_network"`
	Segment *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel `tfsdk:"segment"`
	SiteLocator *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel represents segment block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel struct {
	Site *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel `tfsdk:"no_snat_pool"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel represents private_name block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel struct {
	DNSName types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64 `tfsdk:"refresh_interval"`
	InsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel `tfsdk:"outside_network"`
	Segment *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel `tfsdk:"segment"`
	SiteLocator *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel represents segment block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel struct {
	Site *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel `tfsdk:"no_snat_pool"`
	SnatPool *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel represents public_ip block
type HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel struct {
	IP types.String `tfsdk:"ip"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel represents public_name block
type HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel struct {
	DNSName types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64 `tfsdk:"refresh_interval"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel represents vn_private_ip block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel struct {
	IP types.String `tfsdk:"ip"`
	VirtualNetwork *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel `tfsdk:"virtual_network"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel represents virtual_network block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel represents vn_private_name block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel struct {
	DNSName types.String `tfsdk:"dns_name"`
	PrivateNetwork *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel `tfsdk:"private_network"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel represents private_network block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel represents upstream_conn_pool_reuse_type block
type HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel struct {
	DisableConnPoolReuse *HTTPLoadBalancerEmptyModel `tfsdk:"disable_conn_pool_reuse"`
	EnableConnPoolReuse *HTTPLoadBalancerEmptyModel `tfsdk:"enable_conn_pool_reuse"`
}

// HTTPLoadBalancerDefaultPoolUseTLSModel represents use_tls block
type HTTPLoadBalancerDefaultPoolUseTLSModel struct {
	MaxSessionKeys types.Int64 `tfsdk:"max_session_keys"`
	Sni types.String `tfsdk:"sni"`
	DefaultSessionKeyCaching *HTTPLoadBalancerEmptyModel `tfsdk:"default_session_key_caching"`
	DisableSessionKeyCaching *HTTPLoadBalancerEmptyModel `tfsdk:"disable_session_key_caching"`
	DisableSni *HTTPLoadBalancerEmptyModel `tfsdk:"disable_sni"`
	NoMtls *HTTPLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	SkipServerVerification *HTTPLoadBalancerEmptyModel `tfsdk:"skip_server_verification"`
	TLSConfig *HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel `tfsdk:"tls_config"`
	UseHostHeaderAsSni *HTTPLoadBalancerEmptyModel `tfsdk:"use_host_header_as_sni"`
	UseMtls *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel `tfsdk:"use_mtls"`
	UseMtlsObj *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel `tfsdk:"use_mtls_obj"`
	UseServerVerification *HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel `tfsdk:"use_server_verification"`
	VolterraTrustedCa *HTTPLoadBalancerEmptyModel `tfsdk:"volterra_trusted_ca"`
}

// HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel represents tls_config block
type HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel struct {
	CustomSecurity *HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel represents use_mtls block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel struct {
	TLSCertificates []HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel `tfsdk:"tls_certificates"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel represents tls_certificates block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *HTTPLoadBalancerEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *HTTPLoadBalancerEmptyModel `tfsdk:"use_system_defaults"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel represents private_key block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel represents use_mtls_obj block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel represents use_server_verification block
type HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel struct {
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	TrustedCa *HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCaModel `tfsdk:"trusted_ca"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCaModel represents trusted_ca block
type HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolViewInternalModel represents view_internal block
type HTTPLoadBalancerDefaultPoolViewInternalModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolListModel represents default_pool_list block
type HTTPLoadBalancerDefaultPoolListModel struct {
	Pools []HTTPLoadBalancerDefaultPoolListPoolsModel `tfsdk:"pools"`
}

// HTTPLoadBalancerDefaultPoolListPoolsModel represents pools block
type HTTPLoadBalancerDefaultPoolListPoolsModel struct {
	Priority types.Int64 `tfsdk:"priority"`
	Weight types.Int64 `tfsdk:"weight"`
	Cluster *HTTPLoadBalancerDefaultPoolListPoolsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel `tfsdk:"endpoint_subsets"`
	Pool *HTTPLoadBalancerDefaultPoolListPoolsPoolModel `tfsdk:"pool"`
}

// HTTPLoadBalancerDefaultPoolListPoolsClusterModel represents cluster block
type HTTPLoadBalancerDefaultPoolListPoolsClusterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolListPoolsPoolModel represents pool block
type HTTPLoadBalancerDefaultPoolListPoolsPoolModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultRoutePoolsModel represents default_route_pools block
type HTTPLoadBalancerDefaultRoutePoolsModel struct {
	Priority types.Int64 `tfsdk:"priority"`
	Weight types.Int64 `tfsdk:"weight"`
	Cluster *HTTPLoadBalancerDefaultRoutePoolsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel `tfsdk:"endpoint_subsets"`
	Pool *HTTPLoadBalancerDefaultRoutePoolsPoolModel `tfsdk:"pool"`
}

// HTTPLoadBalancerDefaultRoutePoolsClusterModel represents cluster block
type HTTPLoadBalancerDefaultRoutePoolsClusterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultRoutePoolsPoolModel represents pool block
type HTTPLoadBalancerDefaultRoutePoolsPoolModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableAPIDiscoveryModel represents enable_api_discovery block
type HTTPLoadBalancerEnableAPIDiscoveryModel struct {
	APICrawler *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel `tfsdk:"api_crawler"`
	APIDiscoveryFromCodeScan *HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel `tfsdk:"api_discovery_from_code_scan"`
	CustomAPIAuthDiscovery *HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel `tfsdk:"custom_api_auth_discovery"`
	DefaultAPIAuthDiscovery *HTTPLoadBalancerEmptyModel `tfsdk:"default_api_auth_discovery"`
	DisableLearnFromRedirectTraffic *HTTPLoadBalancerEmptyModel `tfsdk:"disable_learn_from_redirect_traffic"`
	DiscoveredAPISettings *HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel `tfsdk:"discovered_api_settings"`
	EnableLearnFromRedirectTraffic *HTTPLoadBalancerEmptyModel `tfsdk:"enable_learn_from_redirect_traffic"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel represents api_crawler block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel struct {
	APICrawlerConfig *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel `tfsdk:"api_crawler_config"`
	DisableAPICrawler *HTTPLoadBalancerEmptyModel `tfsdk:"disable_api_crawler"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel represents api_crawler_config block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel struct {
	Domains []HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel `tfsdk:"domains"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel represents domains block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel struct {
	Domain types.String `tfsdk:"domain"`
	SimpleLogin *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel `tfsdk:"simple_login"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel represents simple_login block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel struct {
	User types.String `tfsdk:"user"`
	Password *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel `tfsdk:"password"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel represents password block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel represents api_discovery_from_code_scan block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel struct {
	CodeBaseIntegrations []HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel `tfsdk:"code_base_integrations"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel represents code_base_integrations block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel struct {
	AllRepos *HTTPLoadBalancerEmptyModel `tfsdk:"all_repos"`
	CodeBaseIntegration *HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel `tfsdk:"code_base_integration"`
	SelectedRepos *HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel `tfsdk:"selected_repos"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel represents code_base_integration block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel represents selected_repos block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel struct {
	APICodeRepo types.List `tfsdk:"api_code_repo"`
}

// HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel represents custom_api_auth_discovery block
type HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel struct {
	APIDiscoveryRef *HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel `tfsdk:"api_discovery_ref"`
}

// HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel represents api_discovery_ref block
type HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel represents discovered_api_settings block
type HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel struct {
	PurgeDurationForInactiveDiscoveredApis types.Int64 `tfsdk:"purge_duration_for_inactive_discovered_apis"`
}

// HTTPLoadBalancerEnableChallengeModel represents enable_challenge block
type HTTPLoadBalancerEnableChallengeModel struct {
	CaptchaChallengeParameters *HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters *HTTPLoadBalancerEmptyModel `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters *HTTPLoadBalancerEmptyModel `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings *HTTPLoadBalancerEmptyModel `tfsdk:"default_mitigation_settings"`
	JsChallengeParameters *HTTPLoadBalancerEnableChallengeJsChallengeParametersModel `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation *HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel `tfsdk:"malicious_user_mitigation"`
}

// HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerEnableChallengeJsChallengeParametersModel represents js_challenge_parameters block
type HTTPLoadBalancerEnableChallengeJsChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableIPReputationModel represents enable_ip_reputation block
type HTTPLoadBalancerEnableIPReputationModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerEnableTrustClientIPHeadersModel represents enable_trust_client_ip_headers block
type HTTPLoadBalancerEnableTrustClientIPHeadersModel struct {
	ClientIPHeaders types.List `tfsdk:"client_ip_headers"`
}

// HTTPLoadBalancerGraphqlRulesModel represents graphql_rules block
type HTTPLoadBalancerGraphqlRulesModel struct {
	ExactPath types.String `tfsdk:"exact_path"`
	ExactValue types.String `tfsdk:"exact_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	GraphqlSettings *HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel `tfsdk:"graphql_settings"`
	Metadata *HTTPLoadBalancerGraphqlRulesMetadataModel `tfsdk:"metadata"`
	MethodGet *HTTPLoadBalancerEmptyModel `tfsdk:"method_get"`
	MethodPost *HTTPLoadBalancerEmptyModel `tfsdk:"method_post"`
}

// HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel represents graphql_settings block
type HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel struct {
	MaxBatchedQueries types.Int64 `tfsdk:"max_batched_queries"`
	MaxDepth types.Int64 `tfsdk:"max_depth"`
	MaxTotalLength types.Int64 `tfsdk:"max_total_length"`
	DisableIntrospection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_introspection"`
	EnableIntrospection *HTTPLoadBalancerEmptyModel `tfsdk:"enable_introspection"`
}

// HTTPLoadBalancerGraphqlRulesMetadataModel represents metadata block
type HTTPLoadBalancerGraphqlRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerHTTPModel represents http block
type HTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// HTTPLoadBalancerHTTPSModel represents https block
type HTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *HTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *HTTPLoadBalancerEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *HTTPLoadBalancerEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *HTTPLoadBalancerEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *HTTPLoadBalancerEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *HTTPLoadBalancerEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *HTTPLoadBalancerEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *HTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *HTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// HTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type HTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *HTTPLoadBalancerEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *HTTPLoadBalancerEmptyModel `tfsdk:"strict_coalescing"`
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *HTTPLoadBalancerEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *HTTPLoadBalancerEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type HTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *HTTPLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *HTTPLoadBalancerEmptyModel `tfsdk:"no_crl"`
	TrustedCa *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *HTTPLoadBalancerEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// HTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type HTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *HTTPLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *HTTPLoadBalancerEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *HTTPLoadBalancerEmptyModel `tfsdk:"use_system_defaults"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *HTTPLoadBalancerEmptyModel `tfsdk:"no_crl"`
	TrustedCa *HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *HTTPLoadBalancerEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// HTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type HTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *HTTPLoadBalancerEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *HTTPLoadBalancerEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *HTTPLoadBalancerEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *HTTPLoadBalancerEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *HTTPLoadBalancerEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *HTTPLoadBalancerEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *HTTPLoadBalancerEmptyModel `tfsdk:"pass_through"`
	TLSConfig *HTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *HTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *HTTPLoadBalancerEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *HTTPLoadBalancerEmptyModel `tfsdk:"strict_coalescing"`
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *HTTPLoadBalancerEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *HTTPLoadBalancerEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// HTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type HTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"default_security"`
	LowSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"low_security"`
	MediumSecurity *HTTPLoadBalancerEmptyModel `tfsdk:"medium_security"`
}

// HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *HTTPLoadBalancerEmptyModel `tfsdk:"no_crl"`
	TrustedCa *HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *HTTPLoadBalancerEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// HTTPLoadBalancerJsChallengeModel represents js_challenge block
type HTTPLoadBalancerJsChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerJwtValidationModel represents jwt_validation block
type HTTPLoadBalancerJwtValidationModel struct {
	Action *HTTPLoadBalancerJwtValidationActionModel `tfsdk:"action"`
	JwksConfig *HTTPLoadBalancerJwtValidationJwksConfigModel `tfsdk:"jwks_config"`
	MandatoryClaims *HTTPLoadBalancerJwtValidationMandatoryClaimsModel `tfsdk:"mandatory_claims"`
	ReservedClaims *HTTPLoadBalancerJwtValidationReservedClaimsModel `tfsdk:"reserved_claims"`
	Target *HTTPLoadBalancerJwtValidationTargetModel `tfsdk:"target"`
	TokenLocation *HTTPLoadBalancerJwtValidationTokenLocationModel `tfsdk:"token_location"`
}

// HTTPLoadBalancerJwtValidationActionModel represents action block
type HTTPLoadBalancerJwtValidationActionModel struct {
	Block *HTTPLoadBalancerEmptyModel `tfsdk:"block"`
	Report *HTTPLoadBalancerEmptyModel `tfsdk:"report"`
}

// HTTPLoadBalancerJwtValidationJwksConfigModel represents jwks_config block
type HTTPLoadBalancerJwtValidationJwksConfigModel struct {
	Cleartext types.String `tfsdk:"cleartext"`
}

// HTTPLoadBalancerJwtValidationMandatoryClaimsModel represents mandatory_claims block
type HTTPLoadBalancerJwtValidationMandatoryClaimsModel struct {
	ClaimNames types.List `tfsdk:"claim_names"`
}

// HTTPLoadBalancerJwtValidationReservedClaimsModel represents reserved_claims block
type HTTPLoadBalancerJwtValidationReservedClaimsModel struct {
	Issuer types.String `tfsdk:"issuer"`
	Audience *HTTPLoadBalancerJwtValidationReservedClaimsAudienceModel `tfsdk:"audience"`
	AudienceDisable *HTTPLoadBalancerEmptyModel `tfsdk:"audience_disable"`
	IssuerDisable *HTTPLoadBalancerEmptyModel `tfsdk:"issuer_disable"`
	ValidatePeriodDisable *HTTPLoadBalancerEmptyModel `tfsdk:"validate_period_disable"`
	ValidatePeriodEnable *HTTPLoadBalancerEmptyModel `tfsdk:"validate_period_enable"`
}

// HTTPLoadBalancerJwtValidationReservedClaimsAudienceModel represents audience block
type HTTPLoadBalancerJwtValidationReservedClaimsAudienceModel struct {
	Audiences types.List `tfsdk:"audiences"`
}

// HTTPLoadBalancerJwtValidationTargetModel represents target block
type HTTPLoadBalancerJwtValidationTargetModel struct {
	AllEndpoint *HTTPLoadBalancerEmptyModel `tfsdk:"all_endpoint"`
	APIGroups *HTTPLoadBalancerJwtValidationTargetAPIGroupsModel `tfsdk:"api_groups"`
	BasePaths *HTTPLoadBalancerJwtValidationTargetBasePathsModel `tfsdk:"base_paths"`
}

// HTTPLoadBalancerJwtValidationTargetAPIGroupsModel represents api_groups block
type HTTPLoadBalancerJwtValidationTargetAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// HTTPLoadBalancerJwtValidationTargetBasePathsModel represents base_paths block
type HTTPLoadBalancerJwtValidationTargetBasePathsModel struct {
	BasePaths types.List `tfsdk:"base_paths"`
}

// HTTPLoadBalancerJwtValidationTokenLocationModel represents token_location block
type HTTPLoadBalancerJwtValidationTokenLocationModel struct {
	BearerToken *HTTPLoadBalancerEmptyModel `tfsdk:"bearer_token"`
}

// HTTPLoadBalancerL7DdosActionJsChallengeModel represents l7_ddos_action_js_challenge block
type HTTPLoadBalancerL7DdosActionJsChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerL7DdosProtectionModel represents l7_ddos_protection block
type HTTPLoadBalancerL7DdosProtectionModel struct {
	RpsThreshold types.Int64 `tfsdk:"rps_threshold"`
	ClientsideActionCaptchaChallenge *HTTPLoadBalancerL7DdosProtectionClientsideActionCaptchaChallengeModel `tfsdk:"clientside_action_captcha_challenge"`
	ClientsideActionJsChallenge *HTTPLoadBalancerL7DdosProtectionClientsideActionJsChallengeModel `tfsdk:"clientside_action_js_challenge"`
	ClientsideActionNone *HTTPLoadBalancerEmptyModel `tfsdk:"clientside_action_none"`
	DdosPolicyCustom *HTTPLoadBalancerL7DdosProtectionDdosPolicyCustomModel `tfsdk:"ddos_policy_custom"`
	DdosPolicyNone *HTTPLoadBalancerEmptyModel `tfsdk:"ddos_policy_none"`
	DefaultRpsThreshold *HTTPLoadBalancerEmptyModel `tfsdk:"default_rps_threshold"`
	MitigationBlock *HTTPLoadBalancerEmptyModel `tfsdk:"mitigation_block"`
	MitigationCaptchaChallenge *HTTPLoadBalancerL7DdosProtectionMitigationCaptchaChallengeModel `tfsdk:"mitigation_captcha_challenge"`
	MitigationJsChallenge *HTTPLoadBalancerL7DdosProtectionMitigationJsChallengeModel `tfsdk:"mitigation_js_challenge"`
}

// HTTPLoadBalancerL7DdosProtectionClientsideActionCaptchaChallengeModel represents clientside_action_captcha_challenge block
type HTTPLoadBalancerL7DdosProtectionClientsideActionCaptchaChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerL7DdosProtectionClientsideActionJsChallengeModel represents clientside_action_js_challenge block
type HTTPLoadBalancerL7DdosProtectionClientsideActionJsChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerL7DdosProtectionDdosPolicyCustomModel represents ddos_policy_custom block
type HTTPLoadBalancerL7DdosProtectionDdosPolicyCustomModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerL7DdosProtectionMitigationCaptchaChallengeModel represents mitigation_captcha_challenge block
type HTTPLoadBalancerL7DdosProtectionMitigationCaptchaChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerL7DdosProtectionMitigationJsChallengeModel represents mitigation_js_challenge block
type HTTPLoadBalancerL7DdosProtectionMitigationJsChallengeModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerMalwareProtectionSettingsModel represents malware_protection_settings block
type HTTPLoadBalancerMalwareProtectionSettingsModel struct {
	MalwareProtectionRules []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel `tfsdk:"malware_protection_rules"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel represents malware_protection_rules block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel struct {
	HTTPMethods types.List `tfsdk:"http_methods"`
	Action *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel `tfsdk:"action"`
	Domain *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel `tfsdk:"domain"`
	Metadata *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel `tfsdk:"metadata"`
	Path *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel `tfsdk:"path"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel represents action block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel struct {
	Block *HTTPLoadBalancerEmptyModel `tfsdk:"block"`
	Report *HTTPLoadBalancerEmptyModel `tfsdk:"report"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel represents domain block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	Domain *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel `tfsdk:"domain"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel represents domain block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	RegexValue types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel represents metadata block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel represents path block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerMoreOptionModel represents more_option block
type HTTPLoadBalancerMoreOptionModel struct {
	DisableDefaultErrorPages types.Bool `tfsdk:"disable_default_error_pages"`
	IdleTimeout types.Int64 `tfsdk:"idle_timeout"`
	MaxRequestHeaderSize types.Int64 `tfsdk:"max_request_header_size"`
	RequestCookiesToRemove types.List `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove types.List `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove types.List `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove types.List `tfsdk:"response_headers_to_remove"`
	BufferPolicy *HTTPLoadBalancerMoreOptionBufferPolicyModel `tfsdk:"buffer_policy"`
	CompressionParams *HTTPLoadBalancerMoreOptionCompressionParamsModel `tfsdk:"compression_params"`
	CustomErrors *HTTPLoadBalancerEmptyModel `tfsdk:"custom_errors"`
	DisablePathNormalize *HTTPLoadBalancerEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *HTTPLoadBalancerEmptyModel `tfsdk:"enable_path_normalize"`
	RequestCookiesToAdd []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// HTTPLoadBalancerMoreOptionBufferPolicyModel represents buffer_policy block
type HTTPLoadBalancerMoreOptionBufferPolicyModel struct {
	Disabled types.Bool `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// HTTPLoadBalancerMoreOptionCompressionParamsModel represents compression_params block
type HTTPLoadBalancerMoreOptionCompressionParamsModel struct {
	ContentLength types.Int64 `tfsdk:"content_length"`
	ContentType types.List `tfsdk:"content_type"`
	DisableOnEtagHeader types.Bool `tfsdk:"disable_on_etag_header"`
	RemoveAcceptEncodingHeader types.Bool `tfsdk:"remove_accept_encoding_header"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddModel represents request_cookies_to_add block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddModel struct {
	Name types.String `tfsdk:"name"`
	Overwrite types.Bool `tfsdk:"overwrite"`
	Value types.String `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddModel represents request_headers_to_add block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddModel struct {
	Append types.Bool `tfsdk:"append"`
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddModel represents response_cookies_to_add block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddModel struct {
	AddDomain types.String `tfsdk:"add_domain"`
	AddExpiry types.String `tfsdk:"add_expiry"`
	AddPath types.String `tfsdk:"add_path"`
	MaxAgeValue types.Int64 `tfsdk:"max_age_value"`
	Name types.String `tfsdk:"name"`
	Overwrite types.Bool `tfsdk:"overwrite"`
	Value types.String `tfsdk:"value"`
	AddHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddPartitioned *HTTPLoadBalancerEmptyModel `tfsdk:"add_partitioned"`
	AddSecure *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreDomain *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_domain"`
	IgnoreExpiry *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_expiry"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreMaxAge *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_max_age"`
	IgnorePartitioned *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_partitioned"`
	IgnorePath *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_path"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	IgnoreValue *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_value"`
	SamesiteLax *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
	SecretValue *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddModel represents response_headers_to_add block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddModel struct {
	Append types.Bool `tfsdk:"append"`
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListModel represents origin_server_subset_rule_list block
type HTTPLoadBalancerOriginServerSubsetRuleListModel struct {
	OriginServerSubsetRules []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel `tfsdk:"origin_server_subset_rules"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel represents origin_server_subset_rules block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel struct {
	CountryCodes types.List `tfsdk:"country_codes"`
	ReNameList types.List `tfsdk:"re_name_list"`
	AnyAsn *HTTPLoadBalancerEmptyModel `tfsdk:"any_asn"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	AsnList *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel `tfsdk:"asn_matcher"`
	ClientSelector *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel `tfsdk:"ip_prefix_list"`
	Metadata *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel `tfsdk:"metadata"`
	None *HTTPLoadBalancerEmptyModel `tfsdk:"none"`
	OriginServerSubsetsAction *HTTPLoadBalancerEmptyModel `tfsdk:"origin_server_subsets_action"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel represents asn_list block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel represents client_selector block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel represents metadata block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerPolicyBasedChallengeModel represents policy_based_challenge block
type HTTPLoadBalancerPolicyBasedChallengeModel struct {
	AlwaysEnableCaptchaChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"always_enable_captcha_challenge"`
	AlwaysEnableJsChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"always_enable_js_challenge"`
	CaptchaChallengeParameters *HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters *HTTPLoadBalancerEmptyModel `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters *HTTPLoadBalancerEmptyModel `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings *HTTPLoadBalancerEmptyModel `tfsdk:"default_mitigation_settings"`
	DefaultTemporaryBlockingParameters *HTTPLoadBalancerEmptyModel `tfsdk:"default_temporary_blocking_parameters"`
	JsChallengeParameters *HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation *HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel `tfsdk:"malicious_user_mitigation"`
	NoChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"no_challenge"`
	RuleList *HTTPLoadBalancerPolicyBasedChallengeRuleListModel `tfsdk:"rule_list"`
	TemporaryUserBlocking *HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel `tfsdk:"temporary_user_blocking"`
}

// HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel represents js_challenge_parameters block
type HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel struct {
	CookieExpiry types.Int64 `tfsdk:"cookie_expiry"`
	CustomPage types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64 `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListModel represents rule_list block
type HTTPLoadBalancerPolicyBasedChallengeRuleListModel struct {
	Rules []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel represents rules block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel struct {
	Metadata *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel `tfsdk:"metadata"`
	Spec *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel `tfsdk:"spec"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel represents metadata block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel represents spec block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel struct {
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	AnyAsn *HTTPLoadBalancerEmptyModel `tfsdk:"any_asn"`
	AnyClient *HTTPLoadBalancerEmptyModel `tfsdk:"any_client"`
	AnyIP *HTTPLoadBalancerEmptyModel `tfsdk:"any_ip"`
	ArgMatchers []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel `tfsdk:"arg_matchers"`
	AsnList *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel `tfsdk:"asn_list"`
	AsnMatcher *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel `tfsdk:"asn_matcher"`
	BodyMatcher *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel `tfsdk:"body_matcher"`
	ClientSelector *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel `tfsdk:"client_selector"`
	CookieMatchers []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel `tfsdk:"cookie_matchers"`
	DisableChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"disable_challenge"`
	DomainMatcher *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel `tfsdk:"domain_matcher"`
	EnableCaptchaChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"enable_captcha_challenge"`
	EnableJavascriptChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"enable_javascript_challenge"`
	Headers []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel `tfsdk:"headers"`
	HTTPMethod *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel `tfsdk:"http_method"`
	IPMatcher *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel `tfsdk:"ip_matcher"`
	IPPrefixList *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel `tfsdk:"ip_prefix_list"`
	Path *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel `tfsdk:"path"`
	QueryParams []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel `tfsdk:"query_params"`
	TLSFingerprintMatcher *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel represents arg_matchers block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel represents asn_list block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel represents body_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel represents client_selector block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel represents domain_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel represents headers block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Name types.String `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel represents http_method block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods types.List `tfsdk:"methods"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixSets []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel represents path block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixValues types.List `tfsdk:"prefix_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	SuffixValues types.List `tfsdk:"suffix_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel represents query_params block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Key types.String `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_not_present"`
	CheckPresent *HTTPLoadBalancerEmptyModel `tfsdk:"check_present"`
	Item *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel struct {
	Classes types.List `tfsdk:"classes"`
	ExactValues types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel represents temporary_user_blocking block
type HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel struct {
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerProtectedCookiesModel represents protected_cookies block
type HTTPLoadBalancerProtectedCookiesModel struct {
	MaxAgeValue types.Int64 `tfsdk:"max_age_value"`
	Name types.String `tfsdk:"name"`
	AddHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	DisableTamperingProtection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_tampering_protection"`
	EnableTamperingProtection *HTTPLoadBalancerEmptyModel `tfsdk:"enable_tampering_protection"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreMaxAge *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_max_age"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerRateLimitModel represents rate_limit block
type HTTPLoadBalancerRateLimitModel struct {
	CustomIPAllowedList *HTTPLoadBalancerRateLimitCustomIPAllowedListModel `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList *HTTPLoadBalancerRateLimitIPAllowedListModel `tfsdk:"ip_allowed_list"`
	NoIPAllowedList *HTTPLoadBalancerEmptyModel `tfsdk:"no_ip_allowed_list"`
	NoPolicies *HTTPLoadBalancerEmptyModel `tfsdk:"no_policies"`
	Policies *HTTPLoadBalancerRateLimitPoliciesModel `tfsdk:"policies"`
	RateLimiter *HTTPLoadBalancerRateLimitRateLimiterModel `tfsdk:"rate_limiter"`
}

// HTTPLoadBalancerRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type HTTPLoadBalancerRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRateLimitIPAllowedListModel represents ip_allowed_list block
type HTTPLoadBalancerRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerRateLimitPoliciesModel represents policies block
type HTTPLoadBalancerRateLimitPoliciesModel struct {
	Policies []HTTPLoadBalancerRateLimitPoliciesPoliciesModel `tfsdk:"policies"`
}

// HTTPLoadBalancerRateLimitPoliciesPoliciesModel represents policies block
type HTTPLoadBalancerRateLimitPoliciesPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRateLimitRateLimiterModel represents rate_limiter block
type HTTPLoadBalancerRateLimitRateLimiterModel struct {
	BurstMultiplier types.Int64 `tfsdk:"burst_multiplier"`
	PeriodMultiplier types.Int64 `tfsdk:"period_multiplier"`
	TotalNumber types.Int64 `tfsdk:"total_number"`
	Unit types.String `tfsdk:"unit"`
	ActionBlock *HTTPLoadBalancerRateLimitRateLimiterActionBlockModel `tfsdk:"action_block"`
	Disabled *HTTPLoadBalancerEmptyModel `tfsdk:"disabled"`
	LeakyBucket *HTTPLoadBalancerEmptyModel `tfsdk:"leaky_bucket"`
	TokenBucket *HTTPLoadBalancerEmptyModel `tfsdk:"token_bucket"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockModel represents action_block block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockModel struct {
	Hours *HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel `tfsdk:"hours"`
	Minutes *HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel `tfsdk:"minutes"`
	Seconds *HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel `tfsdk:"seconds"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel represents hours block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel represents minutes block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel represents seconds block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// HTTPLoadBalancerRingHashModel represents ring_hash block
type HTTPLoadBalancerRingHashModel struct {
	HashPolicy []HTTPLoadBalancerRingHashHashPolicyModel `tfsdk:"hash_policy"`
}

// HTTPLoadBalancerRingHashHashPolicyModel represents hash_policy block
type HTTPLoadBalancerRingHashHashPolicyModel struct {
	HeaderName types.String `tfsdk:"header_name"`
	SourceIP types.Bool `tfsdk:"source_ip"`
	Terminal types.Bool `tfsdk:"terminal"`
	Cookie *HTTPLoadBalancerRingHashHashPolicyCookieModel `tfsdk:"cookie"`
}

// HTTPLoadBalancerRingHashHashPolicyCookieModel represents cookie block
type HTTPLoadBalancerRingHashHashPolicyCookieModel struct {
	Name types.String `tfsdk:"name"`
	Path types.String `tfsdk:"path"`
	Ttl types.Int64 `tfsdk:"ttl"`
	AddHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerRoutesModel represents routes block
type HTTPLoadBalancerRoutesModel struct {
	CustomRouteObject *HTTPLoadBalancerRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *HTTPLoadBalancerRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *HTTPLoadBalancerRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *HTTPLoadBalancerRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// HTTPLoadBalancerRoutesCustomRouteObjectModel represents custom_route_object block
type HTTPLoadBalancerRoutesCustomRouteObjectModel struct {
	RouteRef *HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel represents route_ref block
type HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteModel represents direct_response_route block
type HTTPLoadBalancerRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *HTTPLoadBalancerRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel represents headers block
type HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *HTTPLoadBalancerEmptyModel `tfsdk:"no_port_match"`
}

// HTTPLoadBalancerRoutesDirectResponseRoutePathModel represents path block
type HTTPLoadBalancerRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// HTTPLoadBalancerRoutesRedirectRouteModel represents redirect_route block
type HTTPLoadBalancerRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []HTTPLoadBalancerRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *HTTPLoadBalancerRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// HTTPLoadBalancerRoutesRedirectRouteHeadersModel represents headers block
type HTTPLoadBalancerRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel represents incoming_port block
type HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *HTTPLoadBalancerEmptyModel `tfsdk:"no_port_match"`
}

// HTTPLoadBalancerRoutesRedirectRoutePathModel represents path block
type HTTPLoadBalancerRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"retain_all_params"`
}

// HTTPLoadBalancerRoutesSimpleRouteModel represents simple_route block
type HTTPLoadBalancerRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AdvancedOptions *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel `tfsdk:"advanced_options"`
	AutoHostRewrite *HTTPLoadBalancerEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *HTTPLoadBalancerEmptyModel `tfsdk:"disable_host_rewrite"`
	Headers []HTTPLoadBalancerRoutesSimpleRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel `tfsdk:"incoming_port"`
	OriginPools []HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel `tfsdk:"origin_pools"`
	Path *HTTPLoadBalancerRoutesSimpleRoutePathModel `tfsdk:"path"`
	QueryParams *HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel `tfsdk:"query_params"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel represents advanced_options block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel struct {
	DisableLocationAdd types.Bool `tfsdk:"disable_location_add"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	Priority types.String `tfsdk:"priority"`
	RequestCookiesToRemove types.List `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove types.List `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove types.List `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove types.List `tfsdk:"response_headers_to_remove"`
	Timeout types.Int64 `tfsdk:"timeout"`
	AppFirewall *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel `tfsdk:"app_firewall"`
	BotDefenseJavascriptInjection *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel `tfsdk:"bot_defense_javascript_injection"`
	BufferPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel `tfsdk:"buffer_policy"`
	CommonBuffering *HTTPLoadBalancerEmptyModel `tfsdk:"common_buffering"`
	CommonHashPolicy *HTTPLoadBalancerEmptyModel `tfsdk:"common_hash_policy"`
	CorsPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCorsPolicyModel `tfsdk:"cors_policy"`
	CsrfPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCsrfPolicyModel `tfsdk:"csrf_policy"`
	DefaultRetryPolicy *HTTPLoadBalancerEmptyModel `tfsdk:"default_retry_policy"`
	DisableMirroring *HTTPLoadBalancerEmptyModel `tfsdk:"disable_mirroring"`
	DisablePrefixRewrite *HTTPLoadBalancerEmptyModel `tfsdk:"disable_prefix_rewrite"`
	DisableSpdy *HTTPLoadBalancerEmptyModel `tfsdk:"disable_spdy"`
	DisableWAF *HTTPLoadBalancerEmptyModel `tfsdk:"disable_waf"`
	DisableWebSocketConfig *HTTPLoadBalancerEmptyModel `tfsdk:"disable_web_socket_config"`
	DoNotRetractCluster *HTTPLoadBalancerEmptyModel `tfsdk:"do_not_retract_cluster"`
	EnableSpdy *HTTPLoadBalancerEmptyModel `tfsdk:"enable_spdy"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel `tfsdk:"endpoint_subsets"`
	InheritedBotDefenseJavascriptInjection *HTTPLoadBalancerEmptyModel `tfsdk:"inherited_bot_defense_javascript_injection"`
	InheritedWAF *HTTPLoadBalancerEmptyModel `tfsdk:"inherited_waf"`
	InheritedWAFExclusion *HTTPLoadBalancerEmptyModel `tfsdk:"inherited_waf_exclusion"`
	MirrorPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel `tfsdk:"mirror_policy"`
	NoRetryPolicy *HTTPLoadBalancerEmptyModel `tfsdk:"no_retry_policy"`
	RegexRewrite *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel `tfsdk:"regex_rewrite"`
	RequestCookiesToAdd []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
	RetractCluster *HTTPLoadBalancerEmptyModel `tfsdk:"retract_cluster"`
	RetryPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel `tfsdk:"retry_policy"`
	SpecificHashPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel `tfsdk:"specific_hash_policy"`
	WAFExclusionPolicy *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel `tfsdk:"waf_exclusion_policy"`
	WebSocketConfig *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel `tfsdk:"web_socket_config"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel represents app_firewall block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel represents bot_defense_javascript_injection block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
	JavascriptTags []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel `tfsdk:"javascript_tags"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel represents javascript_tags block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel struct {
	JavascriptURL types.String `tfsdk:"javascript_url"`
	TagAttributes []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel `tfsdk:"tag_attributes"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel represents tag_attributes block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel struct {
	JavascriptTag types.String `tfsdk:"javascript_tag"`
	TagValue types.String `tfsdk:"tag_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel represents buffer_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel struct {
	Disabled types.Bool `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCorsPolicyModel represents cors_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCorsPolicyModel struct {
	AllowCredentials types.Bool `tfsdk:"allow_credentials"`
	AllowHeaders types.String `tfsdk:"allow_headers"`
	AllowMethods types.String `tfsdk:"allow_methods"`
	AllowOrigin types.List `tfsdk:"allow_origin"`
	AllowOriginRegex types.List `tfsdk:"allow_origin_regex"`
	Disabled types.Bool `tfsdk:"disabled"`
	ExposeHeaders types.String `tfsdk:"expose_headers"`
	MaximumAge types.Int64 `tfsdk:"maximum_age"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCsrfPolicyModel represents csrf_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCsrfPolicyModel struct {
	AllLoadBalancerDomains *HTTPLoadBalancerEmptyModel `tfsdk:"all_load_balancer_domains"`
	CustomDomainList *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCsrfPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled *HTTPLoadBalancerEmptyModel `tfsdk:"disabled"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCsrfPolicyCustomDomainListModel represents custom_domain_list block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCsrfPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel represents mirror_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel struct {
	OriginPool *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel `tfsdk:"origin_pool"`
	Percent *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel `tfsdk:"percent"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel represents origin_pool block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel represents percent block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel struct {
	Denominator types.String `tfsdk:"denominator"`
	Numerator types.Int64 `tfsdk:"numerator"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel represents regex_rewrite block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel struct {
	Pattern types.String `tfsdk:"pattern"`
	Substitution types.String `tfsdk:"substitution"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel represents request_cookies_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel struct {
	Name types.String `tfsdk:"name"`
	Overwrite types.Bool `tfsdk:"overwrite"`
	Value types.String `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel represents request_headers_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel struct {
	Append types.Bool `tfsdk:"append"`
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel represents response_cookies_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel struct {
	AddDomain types.String `tfsdk:"add_domain"`
	AddExpiry types.String `tfsdk:"add_expiry"`
	AddPath types.String `tfsdk:"add_path"`
	MaxAgeValue types.Int64 `tfsdk:"max_age_value"`
	Name types.String `tfsdk:"name"`
	Overwrite types.Bool `tfsdk:"overwrite"`
	Value types.String `tfsdk:"value"`
	AddHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddPartitioned *HTTPLoadBalancerEmptyModel `tfsdk:"add_partitioned"`
	AddSecure *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreDomain *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_domain"`
	IgnoreExpiry *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_expiry"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreMaxAge *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_max_age"`
	IgnorePartitioned *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_partitioned"`
	IgnorePath *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_path"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	IgnoreValue *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_value"`
	SamesiteLax *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel represents response_headers_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel struct {
	Append types.Bool `tfsdk:"append"`
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel represents retry_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel struct {
	NumRetries types.Int64 `tfsdk:"num_retries"`
	PerTryTimeout types.Int64 `tfsdk:"per_try_timeout"`
	RetriableStatusCodes types.List `tfsdk:"retriable_status_codes"`
	RetryCondition types.List `tfsdk:"retry_condition"`
	BackOff *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel `tfsdk:"back_off"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel represents back_off block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel struct {
	BaseInterval types.Int64 `tfsdk:"base_interval"`
	MaxInterval types.Int64 `tfsdk:"max_interval"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel represents specific_hash_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel struct {
	HashPolicy []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel `tfsdk:"hash_policy"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel represents hash_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel struct {
	HeaderName types.String `tfsdk:"header_name"`
	SourceIP types.Bool `tfsdk:"source_ip"`
	Terminal types.Bool `tfsdk:"terminal"`
	Cookie *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel `tfsdk:"cookie"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel represents cookie block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel struct {
	Name types.String `tfsdk:"name"`
	Path types.String `tfsdk:"path"`
	Ttl types.Int64 `tfsdk:"ttl"`
	AddHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel represents waf_exclusion_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel represents web_socket_config block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel struct {
	UseWebsocket types.Bool `tfsdk:"use_websocket"`
}

// HTTPLoadBalancerRoutesSimpleRouteHeadersModel represents headers block
type HTTPLoadBalancerRoutesSimpleRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel represents incoming_port block
type HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *HTTPLoadBalancerEmptyModel `tfsdk:"no_port_match"`
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel represents origin_pools block
type HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel struct {
	Priority types.Int64 `tfsdk:"priority"`
	Weight types.Int64 `tfsdk:"weight"`
	Cluster *HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel `tfsdk:"endpoint_subsets"`
	Pool *HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel `tfsdk:"pool"`
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel represents cluster block
type HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel represents pool block
type HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRoutePathModel represents path block
type HTTPLoadBalancerRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel represents query_params block
type HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel struct {
	ReplaceParams types.String `tfsdk:"replace_params"`
	RemoveAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"retain_all_params"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesModel represents sensitive_data_disclosure_rules block
type HTTPLoadBalancerSensitiveDataDisclosureRulesModel struct {
	SensitiveDataTypesInResponse []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel `tfsdk:"sensitive_data_types_in_response"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel represents sensitive_data_types_in_response block
type HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel struct {
	APIEndpoint *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel `tfsdk:"api_endpoint"`
	Body *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel `tfsdk:"body"`
	Mask *HTTPLoadBalancerEmptyModel `tfsdk:"mask"`
	Report *HTTPLoadBalancerEmptyModel `tfsdk:"report"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel struct {
	Methods types.List `tfsdk:"methods"`
	Path types.String `tfsdk:"path"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel represents body block
type HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel struct {
	Fields types.List `tfsdk:"fields"`
}

// HTTPLoadBalancerSensitiveDataPolicyModel represents sensitive_data_policy block
type HTTPLoadBalancerSensitiveDataPolicyModel struct {
	SensitiveDataPolicyRef *HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel `tfsdk:"sensitive_data_policy_ref"`
}

// HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel represents sensitive_data_policy_ref block
type HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerSingleLbAppModel represents single_lb_app block
type HTTPLoadBalancerSingleLbAppModel struct {
	DisableDiscovery *HTTPLoadBalancerEmptyModel `tfsdk:"disable_discovery"`
	DisableMaliciousUserDetection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_malicious_user_detection"`
	EnableDiscovery *HTTPLoadBalancerSingleLbAppEnableDiscoveryModel `tfsdk:"enable_discovery"`
	EnableMaliciousUserDetection *HTTPLoadBalancerEmptyModel `tfsdk:"enable_malicious_user_detection"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryModel represents enable_discovery block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryModel struct {
	APICrawler *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerModel `tfsdk:"api_crawler"`
	APIDiscoveryFromCodeScan *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanModel `tfsdk:"api_discovery_from_code_scan"`
	CustomAPIAuthDiscovery *HTTPLoadBalancerSingleLbAppEnableDiscoveryCustomAPIAuthDiscoveryModel `tfsdk:"custom_api_auth_discovery"`
	DefaultAPIAuthDiscovery *HTTPLoadBalancerEmptyModel `tfsdk:"default_api_auth_discovery"`
	DisableLearnFromRedirectTraffic *HTTPLoadBalancerEmptyModel `tfsdk:"disable_learn_from_redirect_traffic"`
	DiscoveredAPISettings *HTTPLoadBalancerSingleLbAppEnableDiscoveryDiscoveredAPISettingsModel `tfsdk:"discovered_api_settings"`
	EnableLearnFromRedirectTraffic *HTTPLoadBalancerEmptyModel `tfsdk:"enable_learn_from_redirect_traffic"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerModel represents api_crawler block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerModel struct {
	APICrawlerConfig *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel `tfsdk:"api_crawler_config"`
	DisableAPICrawler *HTTPLoadBalancerEmptyModel `tfsdk:"disable_api_crawler"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel represents api_crawler_config block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel struct {
	Domains []HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel `tfsdk:"domains"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel represents domains block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel struct {
	Domain types.String `tfsdk:"domain"`
	SimpleLogin *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel `tfsdk:"simple_login"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel represents simple_login block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel struct {
	User types.String `tfsdk:"user"`
	Password *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel `tfsdk:"password"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel represents password block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanModel represents api_discovery_from_code_scan block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanModel struct {
	CodeBaseIntegrations []HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel `tfsdk:"code_base_integrations"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel represents code_base_integrations block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel struct {
	AllRepos *HTTPLoadBalancerEmptyModel `tfsdk:"all_repos"`
	CodeBaseIntegration *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel `tfsdk:"code_base_integration"`
	SelectedRepos *HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel `tfsdk:"selected_repos"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel represents code_base_integration block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel represents selected_repos block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel struct {
	APICodeRepo types.List `tfsdk:"api_code_repo"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryCustomAPIAuthDiscoveryModel represents custom_api_auth_discovery block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryCustomAPIAuthDiscoveryModel struct {
	APIDiscoveryRef *HTTPLoadBalancerSingleLbAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel `tfsdk:"api_discovery_ref"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel represents api_discovery_ref block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerSingleLbAppEnableDiscoveryDiscoveredAPISettingsModel represents discovered_api_settings block
type HTTPLoadBalancerSingleLbAppEnableDiscoveryDiscoveredAPISettingsModel struct {
	PurgeDurationForInactiveDiscoveredApis types.Int64 `tfsdk:"purge_duration_for_inactive_discovered_apis"`
}

// HTTPLoadBalancerSlowDdosMitigationModel represents slow_ddos_mitigation block
type HTTPLoadBalancerSlowDdosMitigationModel struct {
	RequestHeadersTimeout types.Int64 `tfsdk:"request_headers_timeout"`
	RequestTimeout types.Int64 `tfsdk:"request_timeout"`
	DisableRequestTimeout *HTTPLoadBalancerEmptyModel `tfsdk:"disable_request_timeout"`
}

// HTTPLoadBalancerTrustedClientsModel represents trusted_clients block
type HTTPLoadBalancerTrustedClientsModel struct {
	Actions types.List `tfsdk:"actions"`
	AsNumber types.Int64 `tfsdk:"as_number"`
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	IPPrefix types.String `tfsdk:"ip_prefix"`
	IPV6Prefix types.String `tfsdk:"ipv6_prefix"`
	UserIdentifier types.String `tfsdk:"user_identifier"`
	BotSkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"bot_skip_processing"`
	HTTPHeader *HTTPLoadBalancerTrustedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata *HTTPLoadBalancerTrustedClientsMetadataModel `tfsdk:"metadata"`
	SkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"skip_processing"`
	WAFSkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"waf_skip_processing"`
}

// HTTPLoadBalancerTrustedClientsHTTPHeaderModel represents http_header block
type HTTPLoadBalancerTrustedClientsHTTPHeaderModel struct {
	Headers []HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel represents headers block
type HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerTrustedClientsMetadataModel represents metadata block
type HTTPLoadBalancerTrustedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerUserIdentificationModel represents user_identification block
type HTTPLoadBalancerUserIdentificationModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerWAFExclusionModel represents waf_exclusion block
type HTTPLoadBalancerWAFExclusionModel struct {
	WAFExclusionInlineRules *HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel `tfsdk:"waf_exclusion_inline_rules"`
	WAFExclusionPolicy *HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel `tfsdk:"waf_exclusion_policy"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel represents waf_exclusion_inline_rules block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel struct {
	Rules []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel represents rules block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel struct {
	ExactValue types.String `tfsdk:"exact_value"`
	ExpirationTimestamp types.String `tfsdk:"expiration_timestamp"`
	Methods types.List `tfsdk:"methods"`
	PathPrefix types.String `tfsdk:"path_prefix"`
	PathRegex types.String `tfsdk:"path_regex"`
	SuffixValue types.String `tfsdk:"suffix_value"`
	AnyDomain *HTTPLoadBalancerEmptyModel `tfsdk:"any_domain"`
	AnyPath *HTTPLoadBalancerEmptyModel `tfsdk:"any_path"`
	AppFirewallDetectionControl *HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel `tfsdk:"app_firewall_detection_control"`
	Metadata *HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel `tfsdk:"metadata"`
	WAFSkipProcessing *HTTPLoadBalancerEmptyModel `tfsdk:"waf_skip_processing"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel represents app_firewall_detection_control block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel struct {
	ExcludeAttackTypeContexts []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel `tfsdk:"exclude_attack_type_contexts"`
	ExcludeBotNameContexts []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel `tfsdk:"exclude_bot_name_contexts"`
	ExcludeSignatureContexts []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel `tfsdk:"exclude_signature_contexts"`
	ExcludeViolationContexts []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel `tfsdk:"exclude_violation_contexts"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel represents exclude_attack_type_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel struct {
	Context types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	ExcludeAttackType types.String `tfsdk:"exclude_attack_type"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel represents exclude_bot_name_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel struct {
	BotName types.String `tfsdk:"bot_name"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel represents exclude_signature_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel struct {
	Context types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	SignatureID types.Int64 `tfsdk:"signature_id"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel represents exclude_violation_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel struct {
	Context types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	ExcludeViolation types.String `tfsdk:"exclude_violation"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name types.String `tfsdk:"name"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel represents waf_exclusion_policy block
type HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

type HTTPLoadBalancerResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Domains types.List `tfsdk:"domains"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	AddLocation types.Bool `tfsdk:"add_location"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	ActiveServicePolicies *HTTPLoadBalancerActiveServicePoliciesModel `tfsdk:"active_service_policies"`
	AdvertiseCustom *HTTPLoadBalancerAdvertiseCustomModel `tfsdk:"advertise_custom"`
	AdvertiseOnPublic *HTTPLoadBalancerAdvertiseOnPublicModel `tfsdk:"advertise_on_public"`
	AdvertiseOnPublicDefaultVip *HTTPLoadBalancerEmptyModel `tfsdk:"advertise_on_public_default_vip"`
	APIProtectionRules *HTTPLoadBalancerAPIProtectionRulesModel `tfsdk:"api_protection_rules"`
	APIRateLimit *HTTPLoadBalancerAPIRateLimitModel `tfsdk:"api_rate_limit"`
	APISpecification *HTTPLoadBalancerAPISpecificationModel `tfsdk:"api_specification"`
	APITesting *HTTPLoadBalancerAPITestingModel `tfsdk:"api_testing"`
	AppFirewall *HTTPLoadBalancerAppFirewallModel `tfsdk:"app_firewall"`
	BlockedClients []HTTPLoadBalancerBlockedClientsModel `tfsdk:"blocked_clients"`
	BotDefense *HTTPLoadBalancerBotDefenseModel `tfsdk:"bot_defense"`
	BotDefenseAdvanced *HTTPLoadBalancerBotDefenseAdvancedModel `tfsdk:"bot_defense_advanced"`
	CachingPolicy *HTTPLoadBalancerCachingPolicyModel `tfsdk:"caching_policy"`
	CaptchaChallenge *HTTPLoadBalancerCaptchaChallengeModel `tfsdk:"captcha_challenge"`
	ClientSideDefense *HTTPLoadBalancerClientSideDefenseModel `tfsdk:"client_side_defense"`
	CookieStickiness *HTTPLoadBalancerCookieStickinessModel `tfsdk:"cookie_stickiness"`
	CorsPolicy *HTTPLoadBalancerCorsPolicyModel `tfsdk:"cors_policy"`
	CsrfPolicy *HTTPLoadBalancerCsrfPolicyModel `tfsdk:"csrf_policy"`
	DataGuardRules []HTTPLoadBalancerDataGuardRulesModel `tfsdk:"data_guard_rules"`
	DdosMitigationRules []HTTPLoadBalancerDdosMitigationRulesModel `tfsdk:"ddos_mitigation_rules"`
	DefaultPool *HTTPLoadBalancerDefaultPoolModel `tfsdk:"default_pool"`
	DefaultPoolList *HTTPLoadBalancerDefaultPoolListModel `tfsdk:"default_pool_list"`
	DefaultRoutePools []HTTPLoadBalancerDefaultRoutePoolsModel `tfsdk:"default_route_pools"`
	DefaultSensitiveDataPolicy *HTTPLoadBalancerEmptyModel `tfsdk:"default_sensitive_data_policy"`
	DisableAPIDefinition *HTTPLoadBalancerEmptyModel `tfsdk:"disable_api_definition"`
	DisableAPIDiscovery *HTTPLoadBalancerEmptyModel `tfsdk:"disable_api_discovery"`
	DisableAPITesting *HTTPLoadBalancerEmptyModel `tfsdk:"disable_api_testing"`
	DisableBotDefense *HTTPLoadBalancerEmptyModel `tfsdk:"disable_bot_defense"`
	DisableCaching *HTTPLoadBalancerEmptyModel `tfsdk:"disable_caching"`
	DisableClientSideDefense *HTTPLoadBalancerEmptyModel `tfsdk:"disable_client_side_defense"`
	DisableIPReputation *HTTPLoadBalancerEmptyModel `tfsdk:"disable_ip_reputation"`
	DisableMaliciousUserDetection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_malicious_user_detection"`
	DisableMalwareProtection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_malware_protection"`
	DisableRateLimit *HTTPLoadBalancerEmptyModel `tfsdk:"disable_rate_limit"`
	DisableThreatMesh *HTTPLoadBalancerEmptyModel `tfsdk:"disable_threat_mesh"`
	DisableTrustClientIPHeaders *HTTPLoadBalancerEmptyModel `tfsdk:"disable_trust_client_ip_headers"`
	DisableWAF *HTTPLoadBalancerEmptyModel `tfsdk:"disable_waf"`
	DoNotAdvertise *HTTPLoadBalancerEmptyModel `tfsdk:"do_not_advertise"`
	EnableAPIDiscovery *HTTPLoadBalancerEnableAPIDiscoveryModel `tfsdk:"enable_api_discovery"`
	EnableChallenge *HTTPLoadBalancerEnableChallengeModel `tfsdk:"enable_challenge"`
	EnableIPReputation *HTTPLoadBalancerEnableIPReputationModel `tfsdk:"enable_ip_reputation"`
	EnableMaliciousUserDetection *HTTPLoadBalancerEmptyModel `tfsdk:"enable_malicious_user_detection"`
	EnableThreatMesh *HTTPLoadBalancerEmptyModel `tfsdk:"enable_threat_mesh"`
	EnableTrustClientIPHeaders *HTTPLoadBalancerEnableTrustClientIPHeadersModel `tfsdk:"enable_trust_client_ip_headers"`
	GraphqlRules []HTTPLoadBalancerGraphqlRulesModel `tfsdk:"graphql_rules"`
	HTTP *HTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *HTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *HTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	JsChallenge *HTTPLoadBalancerJsChallengeModel `tfsdk:"js_challenge"`
	JwtValidation *HTTPLoadBalancerJwtValidationModel `tfsdk:"jwt_validation"`
	L7DdosActionBlock *HTTPLoadBalancerEmptyModel `tfsdk:"l7_ddos_action_block"`
	L7DdosActionDefault *HTTPLoadBalancerEmptyModel `tfsdk:"l7_ddos_action_default"`
	L7DdosActionJsChallenge *HTTPLoadBalancerL7DdosActionJsChallengeModel `tfsdk:"l7_ddos_action_js_challenge"`
	L7DdosProtection *HTTPLoadBalancerL7DdosProtectionModel `tfsdk:"l7_ddos_protection"`
	LeastActive *HTTPLoadBalancerEmptyModel `tfsdk:"least_active"`
	MalwareProtectionSettings *HTTPLoadBalancerMalwareProtectionSettingsModel `tfsdk:"malware_protection_settings"`
	MoreOption *HTTPLoadBalancerMoreOptionModel `tfsdk:"more_option"`
	MultiLbApp *HTTPLoadBalancerEmptyModel `tfsdk:"multi_lb_app"`
	NoChallenge *HTTPLoadBalancerEmptyModel `tfsdk:"no_challenge"`
	NoServicePolicies *HTTPLoadBalancerEmptyModel `tfsdk:"no_service_policies"`
	OriginServerSubsetRuleList *HTTPLoadBalancerOriginServerSubsetRuleListModel `tfsdk:"origin_server_subset_rule_list"`
	PolicyBasedChallenge *HTTPLoadBalancerPolicyBasedChallengeModel `tfsdk:"policy_based_challenge"`
	ProtectedCookies []HTTPLoadBalancerProtectedCookiesModel `tfsdk:"protected_cookies"`
	Random *HTTPLoadBalancerEmptyModel `tfsdk:"random"`
	RateLimit *HTTPLoadBalancerRateLimitModel `tfsdk:"rate_limit"`
	RingHash *HTTPLoadBalancerRingHashModel `tfsdk:"ring_hash"`
	RoundRobin *HTTPLoadBalancerEmptyModel `tfsdk:"round_robin"`
	Routes []HTTPLoadBalancerRoutesModel `tfsdk:"routes"`
	SensitiveDataDisclosureRules *HTTPLoadBalancerSensitiveDataDisclosureRulesModel `tfsdk:"sensitive_data_disclosure_rules"`
	SensitiveDataPolicy *HTTPLoadBalancerSensitiveDataPolicyModel `tfsdk:"sensitive_data_policy"`
	ServicePoliciesFromNamespace *HTTPLoadBalancerEmptyModel `tfsdk:"service_policies_from_namespace"`
	SingleLbApp *HTTPLoadBalancerSingleLbAppModel `tfsdk:"single_lb_app"`
	SlowDdosMitigation *HTTPLoadBalancerSlowDdosMitigationModel `tfsdk:"slow_ddos_mitigation"`
	SourceIPStickiness *HTTPLoadBalancerEmptyModel `tfsdk:"source_ip_stickiness"`
	SystemDefaultTimeouts *HTTPLoadBalancerEmptyModel `tfsdk:"system_default_timeouts"`
	TrustedClients []HTTPLoadBalancerTrustedClientsModel `tfsdk:"trusted_clients"`
	UserIDClientIP *HTTPLoadBalancerEmptyModel `tfsdk:"user_id_client_ip"`
	UserIdentification *HTTPLoadBalancerUserIdentificationModel `tfsdk:"user_identification"`
	WAFExclusion *HTTPLoadBalancerWAFExclusionModel `tfsdk:"waf_exclusion"`
}

func (r *HTTPLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_http_loadbalancer"
}

func (r *HTTPLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             http_loadbalancerSchemaVersion,
		MarkdownDescription: "Manages a HTTPLoadBalancer resource in F5 Distributed Cloud for load balancing HTTP/HTTPS traffic with advanced routing and security.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the HTTPLoadBalancer. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the HTTPLoadBalancer will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "Domains. A list of Domains (host/authority header) that will be matched to load balancer. Supported Domains and search order: 1. Exact Domain names: www.foo.com. 2. Domains starting with a Wildcard: *.foo.com. Not supported Domains: - Just a Wildcard: * - A Wildcard and TLD with no root Domain: *.com. - A Wildcard not matching a whole DNS label. e.g. *.foo.com and *.bar.foo.com are valid Wildcards however *bar.foo.com, *-bar.foo.com, and bar*.foo.com are all invalid. Additional notes: A Wildcard will not match empty string. e.g. *.foo.com will match bar.foo.com and baz-bar.foo.com but not .foo.com. The longest Wildcards match first. Only a single virtual host in the entire route configuration can match on *. Also a Domain must be unique across all virtual hosts within an advertise policy. Domains are also used for SNI matching if the Loadbalancer type is HTTPS. Domains also indicate the list of names for which DNS resolution will be automatically resolved to IP addresses by the system.",
				Optional: true,
				ElementType: types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"add_location": schema.BoolAttribute{
				MarkdownDescription: "Add Location. x-example: true Appends header x-volterra-location = <re-site-name> in responses. This configuration is ignored on CE sites.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_service_policies, no_service_policies, service_policies_from_namespace] Service Policy List. List of service policies.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"policies": schema.ListNestedBlock{
						MarkdownDescription: "Policies. Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the correct order (policies evaluated from top to bottom in the list) for service policies, to get the intended result. For each request, its characteristics are evaluated based on the match criteria in each service policy starting at the top. If there is a match in the current policy, then the policy takes effect, and no more policies are evaluated. Otherwise, the next policy is evaluated. If all policies are evaluated and none match, then the request will be denied by default.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},
				},

			},
			"advertise_custom": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: advertise_custom, advertise_on_public, advertise_on_public_default_vip, do_not_advertise] Advertise Custom. This defines a way to advertise a VIP on specific sites",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"advertise_where": schema.ListNestedBlock{
						MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Listen Port. Port to Listen.",
									Optional: true,
								},
								"port_ranges": schema.StringAttribute{
									MarkdownDescription: "Listen Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"advertise_on_public": schema.SingleNestedBlock{
									MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"public_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"site": schema.SingleNestedBlock{
									MarkdownDescription: "Site. This defines a reference to a CE site along with network type and an optional ip address where a load balancer could be advertised",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
											Optional: true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"use_default_port": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"virtual_network": schema.SingleNestedBlock{
									MarkdownDescription: "Virtual Network. Parameters to advertise on a given virtual network",
									Attributes: map[string]schema.Attribute{
										"specific_v6_vip": schema.StringAttribute{
											MarkdownDescription: "Specific V6 VIP. Use given IPV6 address as VIP on virtual Network",
											Optional: true,
										},
										"specific_vip": schema.StringAttribute{
											MarkdownDescription: "Specific V4 VIP. Use given IPV4 address as VIP on virtual Network",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"default_v6_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"default_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"virtual_site": schema.SingleNestedBlock{
									MarkdownDescription: "Virtual Site. This defines a reference to a customer site virtual site along with network type where a load balancer could be advertised",
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"virtual_site_with_vip": schema.SingleNestedBlock{
									MarkdownDescription: "Virtual Site with Specified VIP. This defines a reference to a customer site virtual site along with network type and IP where a load balancer could be advertised",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
											Optional: true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "Site Network. This defines network types to be used on virtual-site with specified VIP All outside networks. All inside networks. Possible values are `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`, `SITE_NETWORK_SPECIFIED_VIP_INSIDE`. Defaults to `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"vk8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "vK8s Services on RE. This defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"advertise_on_public": schema.SingleNestedBlock{
				MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"advertise_on_public_default_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"api_protection_rules": schema.SingleNestedBlock{
				MarkdownDescription: "API Protection Rules. API Protection Rules",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_endpoint_rules": schema.ListNestedBlock{
						MarkdownDescription: "API Endpoints. This category defines specific rules per API endpoints. If request matches any of these rules, skipping second category rules.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_endpoint_path": schema.StringAttribute{
									MarkdownDescription: "API Endpoint. The endpoint (path) of the request.",
									Optional: true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "Specific Domain. The rule will apply for a specific domain. For example: api.example.com",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"action": schema.SingleNestedBlock{
									MarkdownDescription: "API Protection Rule Action. The action to take if the input request matches the rule.",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"allow": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"deny": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"api_endpoint_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP Method Matcher. A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional: true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "Method List. List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional: true,
													ElementType: types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional: true,
													ElementType: types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
											Optional: true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"api_groups_rules": schema.ListNestedBlock{
						MarkdownDescription: "Server URLs and API Groups. This category includes rules per API group or Server URL. For API groups, refer to API Definition which includes API groups derived from uploaded swaggers.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_group": schema.StringAttribute{
									MarkdownDescription: "API Group. API groups derived from API Definition swaggers. For example oas-all-operations including all paths and methods from the swaggers, oas-base-urls covering all requests under base-paths from the swaggers. Custom groups can be created if user tags paths or operations with 'x-volterra-api-group' extensions inside swaggers.",
									Optional: true,
								},
								"base_path": schema.StringAttribute{
									MarkdownDescription: "Base Path. Prefix of the request path. For example: /v1",
									Optional: true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "Specific Domain. The rule will apply for a specific domain. For example: api.example.com",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"action": schema.SingleNestedBlock{
									MarkdownDescription: "API Protection Rule Action. The action to take if the input request matches the rule.",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"allow": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"deny": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional: true,
													ElementType: types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional: true,
													ElementType: types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
											Optional: true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"api_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_rate_limit, disable_rate_limit, rate_limit] APIRateLimit.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_endpoint_rules": schema.ListNestedBlock{
						MarkdownDescription: "API Endpoints. Sets of rules for a specific endpoints. Order is matter as it uses first match policy. For creating rule that contain a whole domain or group of endpoints, please use the server URL rules above.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_endpoint_path": schema.StringAttribute{
									MarkdownDescription: "API Endpoint. The endpoint (path) of the request.",
									Optional: true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "Specific Domain. The rule will apply for a specific domain.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"api_endpoint_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP Method Matcher. A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional: true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "Method List. List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional: true,
													ElementType: types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional: true,
													ElementType: types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "Threshold. The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional: true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "Rate Limit Period Unit. Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"bypass_rate_limiting_rules": schema.SingleNestedBlock{
						MarkdownDescription: "Bypass Rate Limiting. This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"bypass_rate_limiting_rules": schema.ListNestedBlock{
								MarkdownDescription: "Bypass Rate Limiting. This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"base_path": schema.StringAttribute{
											MarkdownDescription: "Base Path. The base path which this validation applies to",
											Optional: true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "Specific Domain. The rule will apply for a specific domain. For example: api.example.com",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_url": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines api endpoint",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched",
													Optional: true,
												},
											},
										},
										"api_groups": schema.SingleNestedBlock{
											MarkdownDescription: "API Groups.",
											Attributes: map[string]schema.Attribute{
												"api_groups": schema.ListAttribute{
													MarkdownDescription: "API Groups.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"client_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional: true,
															ElementType: types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional: true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"ip_threat_category_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
													Attributes: map[string]schema.Attribute{
														"ip_threat_categories": schema.ListAttribute{
															MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
										"request_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"jwt_claims": schema.ListNestedBlock{
													MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert the match result.",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "JWT Claim Name. JWT claim name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional: true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom IP Allowed List. IP Allowed list using existing ip_prefix_set objects",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "List of IP Prefix Sets. References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"server_url_rules": schema.ListNestedBlock{
						MarkdownDescription: "Server URLs. Set of rules for entire domain or base path that contain multiple endpoints. Order is matter as it uses first match policy. For matching also specific endpoints you can use the API endpoint rules set bellow.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_group": schema.StringAttribute{
									MarkdownDescription: "API Group. API groups derived from API Definition swaggers. For example oas-all-operations including all paths and methods from the swaggers, oas-base-urls covering all requests under base-paths from the swaggers. Custom groups can be created if user tags paths or operations with 'x-volterra-api-group' extensions inside swaggers.",
									Optional: true,
								},
								"base_path": schema.StringAttribute{
									MarkdownDescription: "Base Path. Prefix of the request path.",
									Optional: true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "Specific Domain. The rule will apply for a specific domain.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional: true,
													ElementType: types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																Optional: true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																Optional: true,
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																Optional: true,
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of ip threat categories",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "List of IP Threat Categories to choose. The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional: true,
													ElementType: types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "Threshold. The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional: true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "Rate Limit Period Unit. Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "Cookie Matchers. A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "JWT Claims. A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings. Note that all specified JWT claim predicates must evaluate to true. Note that this feature only works on LBs with JWT Validation feature enabled.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"api_specification": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_specification, disable_api_definition] API Specification and Validation. Settings for api specification (api definition, OpenAPI validation, etc.)",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_definition": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"validation_all_spec_endpoints": schema.SingleNestedBlock{
						MarkdownDescription: "API Inventory. Settings for API Inventory validation",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Fall Through Mode. x-required Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "API Group. The API group which this validation applies to",
															Optional: true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "Base Path. The base path which this validation applies to",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines api endpoint",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched",
																	Optional: true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional: true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "Common Settings. OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Validation Settings For Query Parameters. Custom settings for query parameters validation",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"validation_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Validation Mode. x-required Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"response_validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response",
										Attributes: map[string]schema.Attribute{
											"response_validation_properties": schema.ListAttribute{
												MarkdownDescription: "Response Validation Properties. List of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
									"skip_response_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request",
										Attributes: map[string]schema.Attribute{
											"request_validation_properties": schema.ListAttribute{
												MarkdownDescription: "Request Validation Properties. List of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
						},
					},
					"validation_custom_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom List. Define API groups, base paths, or API endpoints and their OpenAPI validation modes. Any other api-endpoint not listed will act according to 'Fall Through Mode'.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Fall Through Mode. x-required Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "API Group. The API group which this validation applies to",
															Optional: true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "Base Path. The base path which this validation applies to",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines api endpoint",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched",
																	Optional: true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional: true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"open_api_validation_rules": schema.ListNestedBlock{
								MarkdownDescription: "Validation List.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"api_group": schema.StringAttribute{
											MarkdownDescription: "API Group. The API group which this validation applies to",
											Optional: true,
										},
										"base_path": schema.StringAttribute{
											MarkdownDescription: "Base Path. The base path which this validation applies to",
											Optional: true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "Specific Domain. The rule will apply for a specific domain.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines api endpoint",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched",
													Optional: true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"validation_mode": schema.SingleNestedBlock{
											MarkdownDescription: "Validation Mode. x-required Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"response_validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response",
													Attributes: map[string]schema.Attribute{
														"response_validation_properties": schema.ListAttribute{
															MarkdownDescription: "Response Validation Properties. List of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"skip_response_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"skip_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request",
													Attributes: map[string]schema.Attribute{
														"request_validation_properties": schema.ListAttribute{
															MarkdownDescription: "Request Validation Properties. List of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger). Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "Common Settings. OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Validation Settings For Query Parameters. Custom settings for query parameters validation",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
						},
					},
					"validation_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"api_testing": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_testing, disable_api_testing] API Testing.",
				Attributes: map[string]schema.Attribute{
					"custom_header_value": schema.StringAttribute{
						MarkdownDescription: "Custom Header. Add x-f5-api-testing-identifier header value to prevent security flags on API testing traffic",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"domains": schema.ListNestedBlock{
						MarkdownDescription: "Testing Environments. Add and configure testing domains and credentials",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"allow_destructive_methods": schema.BoolAttribute{
									MarkdownDescription: "Use Destructive Methods (e.g., DELETE, PUT). Enable to allow API test to execute destructive methods. Be cautious as these can alter or delete data.",
									Optional: true,
								},
								"domain": schema.StringAttribute{
									MarkdownDescription: "Domain. Add your testing environment domain. Be aware that running tests on a production domain can impact live applications, as API testing cannot distinguish between production and testing environments.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"credentials": schema.ListNestedBlock{
									MarkdownDescription: "Credentials. Add credentials for API testing to use in the selected environment.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"credential_name": schema.StringAttribute{
												MarkdownDescription: "Name. Enter a unique name for the credentials used in API testing",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"admin": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"api_key": schema.SingleNestedBlock{
												MarkdownDescription: "Api Key.",
												Attributes: map[string]schema.Attribute{
													"key": schema.StringAttribute{
														MarkdownDescription: "Key.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"value": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
											"basic_auth": schema.SingleNestedBlock{
												MarkdownDescription: "Basic Authentication.",
												Attributes: map[string]schema.Attribute{
													"user": schema.StringAttribute{
														MarkdownDescription: "User.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"password": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
											"bearer_token": schema.SingleNestedBlock{
												MarkdownDescription: "Bearer.",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"token": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
											"login_endpoint": schema.SingleNestedBlock{
												MarkdownDescription: "Login Endpoint.",
												Attributes: map[string]schema.Attribute{
													"method": schema.StringAttribute{
														MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
														Optional: true,
													},
													"path": schema.StringAttribute{
														MarkdownDescription: "Path.",
														Optional: true,
													},
													"token_response_key": schema.StringAttribute{
														MarkdownDescription: "Token Response Key. Specifies how to handle the API response, extracting authentication tokens.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"json_payload": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
											"standard": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
						},
					},
					"every_day": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"every_month": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"every_week": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"app_firewall": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: app_firewall, disable_waf] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"blocked_clients": schema.ListNestedBlock{
				MarkdownDescription: "Client Blocking Rules. Define rules to block IP Prefixes or AS numbers.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "Actions. Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional: true,
							ElementType: types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "AS Number. RFC 6793 defined 4-byte AS number",
							Optional: true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional: true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 Prefix. IPv4 prefix string.",
							Optional: true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 Prefix. IPv6 prefix string.",
							Optional: true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "User Identifier. Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs",
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "HTTP Headers. List of HTTP header name and value pairs",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"bot_defense": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: bot_defense, bot_defense_advanced, disable_bot_defense] Bot Defense. This defines various configuration options for Bot Defense Policy.",
				Attributes: map[string]schema.Attribute{
					"regional_endpoint": schema.StringAttribute{
						MarkdownDescription: "Bot Defense Region. Defines a selection for Bot Defense region - AUTO: AUTO Automatic selection based on client IP address - US: US US region - EU: EU European Union region - ASIA: ASIA Asia region. Possible values are `AUTO`, `US`, `EU`, `ASIA`. Defaults to `AUTO`.",
						Optional: true,
					},
					"timeout": schema.Int64Attribute{
						MarkdownDescription: "Timeout. The timeout for the inference check, in milliseconds.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Bot Defense Policy. This defines various configuration options for Bot Defense policy.",
						Attributes: map[string]schema.Attribute{
							"javascript_mode": schema.StringAttribute{
								MarkdownDescription: "Web Client JavaScript Mode. Web Client JavaScript Mode. Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable Bot Defense JavaScript for telemetry collection is requested synchronously, and it is non-cacheable Bot Defense JavaScript for telemetry collection is requested synchronously, and it is cacheable. Possible values are `ASYNC_JS_NO_CACHING`, `ASYNC_JS_CACHING`, `SYNC_JS_NO_CACHING`, `SYNC_JS_CACHING`. Defaults to `ASYNC_JS_NO_CACHING`.",
								Optional: true,
							},
							"js_download_path": schema.StringAttribute{
								MarkdownDescription: "JavaScript Download Path. Customize Bot Defense Client JavaScript path. If not specified, default `/common.js`",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_mobile_sdk": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Bot Defense JavaScript in All Pages. Insert Bot Defense JavaScript in all pages",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional: true,
									},
								},
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert JavaScript in All Pages with the Exceptions. Insert Bot Defense JavaScript in all pages with the exceptions",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Pages. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "JavaScript Custom Insertion Rules. This defines custom JavaScript insertion rules for Bot Defense Policy.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Paths. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "JavaScript Insertions. Required list of pages to insert Bot Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"javascript_location": schema.StringAttribute{
													MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"mobile_sdk_config": schema.SingleNestedBlock{
								MarkdownDescription: "Mobile SDK Configuration. Mobile SDK configuration.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"mobile_identifier": schema.SingleNestedBlock{
										MarkdownDescription: "Mobile Traffic Identifier. Mobile traffic identifier type.",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"headers": schema.ListNestedBlock{
												MarkdownDescription: "Headers. Headers that can be used to identify mobile traffic.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"check_not_present": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"check_present": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"item": schema.SingleNestedBlock{
															MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
															Attributes: map[string]schema.Attribute{
																"exact_values": schema.ListAttribute{
																	MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"regex_values": schema.ListAttribute{
																	MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"transformers": schema.ListAttribute{
																	MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																	Optional: true,
																	ElementType: types.StringType,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"protected_app_endpoints": schema.ListNestedBlock{
								MarkdownDescription: "App Endpoint Type. List of protected endpoints. Limit: Approx '128 endpoints per Load Balancer (LB)' upto 4 LBs, '32 endpoints per LB' after 4 LBs.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"http_methods": schema.ListAttribute{
											MarkdownDescription: "HTTP Methods. List of HTTP methods. Possible values are `METHOD_ANY`, `METHOD_GET`, `METHOD_POST`, `METHOD_PUT`, `METHOD_PATCH`, `METHOD_DELETE`, `METHOD_GET_DOCUMENT`. Defaults to `METHOD_ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"protocol": schema.StringAttribute{
											MarkdownDescription: "URL Scheme. SchemeType is used to indicate URL scheme. - BOTH: BOTH URL scheme for https:// or http://. - HTTP: HTTP URL scheme http:// only. - HTTPS: HTTPS URL scheme https:// only. Possible values are `BOTH`, `HTTP`, `HTTPS`. Defaults to `BOTH`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"allow_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact Value. Exact domain name.",
													Optional: true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
													Optional: true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
													Optional: true,
												},
											},
										},
										"flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Defense Flow Label Category. Bot Defense Flow Label Category allows to associate traffic with selected category",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"account_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Account Management Category. Bot Defense Flow Label Account Management Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"password_reset": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"authentication": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Authentication Category. Bot Defense Flow Label Authentication Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"login": schema.SingleNestedBlock{
															MarkdownDescription: "Bot Defense Transaction Result. Bot Defense Transaction Result",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"disable_transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Bot Defense Transaction Result Type. Bot Defense Transaction ResultType",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"failure_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Failure Conditions. Failure Conditions",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional: true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional: true,
																					},
																				},
																			},
																		},
																		"success_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Success Conditions. Success Conditions",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional: true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"login_mfa": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"login_partner": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"logout": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"token_refresh": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"financial_services": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Financial Services Category. Bot Defense Flow Label Financial Services Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"apply": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"money_transfer": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"flight": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Flight Category. Bot Defense Flow Label Flight Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"checkin": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"profile_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Profile Management Category. Bot Defense Flow Label Profile Management Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"update": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"view": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"search": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Search Category. Bot Defense Flow Label Search Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"flight_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"product_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"reservation_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"room_search": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"shopping_gift_cards": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Shopping & Gift Cards Category. Bot Defense Flow Label Shopping & Gift Cards Category",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"gift_card_make_purchase_with_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"gift_card_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_add_to_cart": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_checkout": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_choose_seat": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_enter_drawing_submission": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_make_payment": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_order": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_price_inquiry": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_promo_code_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_purchase_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
														"shop_update_quantity": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Headers. A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"mitigate_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"mitigation": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Mitigation Action. Modify Bot Defense behavior for a matching request.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"block": schema.SingleNestedBlock{
													MarkdownDescription: "Block bot mitigation. Block request and respond with custom content.",
													Attributes: map[string]schema.Attribute{
														"body": schema.StringAttribute{
															MarkdownDescription: "Body. Custom body message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Your request was blocked' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Your request was blocked </p>'. Base64 encoded string for this html is 'LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg=='",
															Optional: true,
														},
														"status": schema.StringAttribute{
															MarkdownDescription: "HTTP Status Code. HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status status code Already Reported status code Im Used status code Multiple Choices status code Moved Permanently status code Found status code See Other status code Not Modified status code Use Proxy status code Temporary Redirect status code Permanent Redirect status code Bad Request status code Unauthorized status code Payment Required status code Forbidden status code Not Found status code Method Not Allowed status code Not Acceptable status code Proxy Authentication Required status code Request Timeout status code Conflict status code Gone status code Length Required status code Precondition Failed status code Payload Too Large status code Uri Too Long status code Unsupported Media Type status code Range Not Satisfiable status code Expectation Failed status code Misdirected Request status code Unprocessable Entity status code Locked status code Failed Dependency status code Upgrade Required status code Precondition Required status code Too Many Requests status code Request Header Fields Too Large status code Internal Server Error status code Not Implemented status code Bad Gateway status code Service Unavailable status code Gateway Timeout status code Http Version Not Supported status code Variant Also Negotiates status code Insufficient Storage status code Loop Detected status code Not Extended status code Network Authentication Required status code. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
															Optional: true,
														},
													},
												},
												"flag": schema.SingleNestedBlock{
													MarkdownDescription: "Select Flag Bot Mitigation Action. Flag mitigation action.",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"append_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Append Flag Mitigation Headers. Append flag mitigation headers to forwarded request.",
															Attributes: map[string]schema.Attribute{
																"auto_type_header_name": schema.StringAttribute{
																	MarkdownDescription: "Automation Type Header Name. A case-insensitive HTTP header name.",
																	Optional: true,
																},
																"inference_header_name": schema.StringAttribute{
																	MarkdownDescription: "Inference Header Name. A case-insensitive HTTP header name.",
																	Optional: true,
																},
															},
														},
														"no_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Empty. This can be used for messages where no values are needed",
														},
													},
												},
												"redirect": schema.SingleNestedBlock{
													MarkdownDescription: "Redirect bot mitigation. Redirect request to a custom URI.",
													Attributes: map[string]schema.Attribute{
														"uri": schema.StringAttribute{
															MarkdownDescription: "URI. URI location for redirect may be relative or absolute.",
															Optional: true,
														},
													},
												},
											},
										},
										"mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact. Exact path value to match",
													Optional: true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
													Optional: true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
													Optional: true,
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "HTTP Query Parameters. A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional: true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																Optional: true,
																ElementType: types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional: true,
																ElementType: types.StringType,
															},
														},
													},
												},
											},
										},
										"undefined_flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"web": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"web_mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Web and Mobile traffic type. Web and Mobile traffic type",
											Attributes: map[string]schema.Attribute{
												"mobile_identifier": schema.StringAttribute{
													MarkdownDescription: "Mobile Identifier. Mobile identifier type - HEADERS: Headers Headers. The only possible value is `HEADERS`. Defaults to `HEADERS`.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"bot_defense_advanced": schema.SingleNestedBlock{
				MarkdownDescription: "Bot Defense Advanced. Bot Defense Advanced",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"disable_js_insert": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_mobile_sdk": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"js_insert_all_pages": schema.SingleNestedBlock{
						MarkdownDescription: "Insert Bot Defense JavaScript in All Pages. Insert Bot Defense JavaScript in all pages",
						Attributes: map[string]schema.Attribute{
							"javascript_location": schema.StringAttribute{
								MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
								Optional: true,
							},
						},
					},
					"js_insert_all_pages_except": schema.SingleNestedBlock{
						MarkdownDescription: "Insert JavaScript in All Pages with the Exceptions. Insert Bot Defense JavaScript in all pages with the exceptions",
						Attributes: map[string]schema.Attribute{
							"javascript_location": schema.StringAttribute{
								MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"exclude_list": schema.ListNestedBlock{
								MarkdownDescription: "Exclude Pages. Optional JavaScript insertions exclude list of domain and path matchers.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact Value. Exact domain name.",
													Optional: true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
													Optional: true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
													Optional: true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact. Exact path value to match",
													Optional: true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
													Optional: true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"js_insertion_rules": schema.SingleNestedBlock{
						MarkdownDescription: "JavaScript Custom Insertion Rules. This defines custom JavaScript insertion rules for Bot Defense Policy.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"exclude_list": schema.ListNestedBlock{
								MarkdownDescription: "Exclude Paths. Optional JavaScript insertions exclude list of domain and path matchers.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact Value. Exact domain name.",
													Optional: true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
													Optional: true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
													Optional: true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact. Exact path value to match",
													Optional: true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
													Optional: true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "JavaScript Insertions. Required list of pages to insert Bot Defense client JavaScript.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"javascript_location": schema.StringAttribute{
											MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact Value. Exact domain name.",
													Optional: true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
													Optional: true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
													Optional: true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact. Exact path value to match",
													Optional: true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
													Optional: true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"mobile": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"mobile_sdk_config": schema.SingleNestedBlock{
						MarkdownDescription: "Mobile Request Identifier Headers. Mobile Request Identifier Headers.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"mobile_identifier": schema.SingleNestedBlock{
								MarkdownDescription: "Mobile Traffic Identifier. Mobile traffic identifier type.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"headers": schema.ListNestedBlock{
										MarkdownDescription: "Headers. Headers that can be used to identify mobile traffic.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"check_not_present": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"check_present": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"item": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"web": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"caching_policy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: caching_policy, disable_caching] Caching Policies. x-required Caching Policies for the CDN",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"custom_cache_rule": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Cache Rules. Caching policies for CDN",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"cdn_cache_rules": schema.ListNestedBlock{
								MarkdownDescription: "CDN Cache Rule. Reference to CDN Cache Rule configuration object",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"default_cache_action": schema.SingleNestedBlock{
						MarkdownDescription: "Default Cache Behaviour. This defines a Default Cache Action",
						Attributes: map[string]schema.Attribute{
							"cache_ttl_default": schema.StringAttribute{
								MarkdownDescription: "Fallback Cache TTL (d/ h/ m). Use Cache TTL Provided by Origin, and set a contigency TTL value in case one is not provided",
								Optional: true,
							},
							"cache_ttl_override": schema.StringAttribute{
								MarkdownDescription: "Override Cache TTL (d/ h/ m/ s). Always override the Cahce TTL provided by Origin",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"cache_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"captcha_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: captcha_challenge, enable_challenge, js_challenge, no_challenge, policy_based_challenge] Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional: true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
						Optional: true,
					},
				},

			},
			"client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: client_side_defense, disable_client_side_defense] Client-Side Defense. This defines various configuration options for Client-Side Defense Policy.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Client-Side Defense Policy. This defines various configuration options for Client-Side Defense policy.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert JavaScript in All Pages with the Exceptions. Insert Client-Side Defense JavaScript in all pages with the exceptions",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Pages. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "JavaScript Custom Insertion Rules. This defines custom JavaScript insertion rules for Client-Side Defense Policy.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Exclude Paths. Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "JavaScript Insertions. Required list of pages to insert Client-Side Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact Value. Exact domain name.",
															Optional: true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
															Optional: true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
															Optional: true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional: true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
															Optional: true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact. Exact path value to match",
															Optional: true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
															Optional: true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"cookie_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: cookie_stickiness, least_active, random, ring_hash, round_robin, source_ip_stickiness] Hashing using Cookie. Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets sent to. The client then presents this on the next and all subsequent requests. The hash of this is sufficient to ensure these requests get sent to the same endpoint. The cookie is generated by hashing the source and destination ports and addresses so that multiple independent HTTP2 streams on the same connection will independently receive the same cookie, even if they arrive simultaneously.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced",
						Optional: true,
					},
					"path": schema.StringAttribute{
						MarkdownDescription: "Path. The name of the path for the cookie. If no path is specified here, no path will be set for the cookie",
						Optional: true,
					},
					"ttl": schema.Int64Attribute{
						MarkdownDescription: "TTL. If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"add_httponly": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"add_secure": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"ignore_httponly": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"ignore_samesite": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"ignore_secure": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"samesite_lax": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"samesite_none": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"samesite_strict": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"cors_policy": schema.SingleNestedBlock{
				MarkdownDescription: "CORS Policy. Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html Origin: http://foo.example HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2.0.61 Access-Control-Allow-Origin: * Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml An example for cross origin HTTP OPTIONS request with Access-Control-Request-* header OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type HTTP/1.1 204 No Content Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Keep-Alive: timeout=2, max=100 Connection: Keep-Alive",
				Attributes: map[string]schema.Attribute{
					"allow_credentials": schema.BoolAttribute{
						MarkdownDescription: "Allow Credentials. Specifies whether the resource allows credentials",
						Optional: true,
					},
					"allow_headers": schema.StringAttribute{
						MarkdownDescription: "Allow Headers. Specifies the content for the access-control-allow-headers header",
						Optional: true,
					},
					"allow_methods": schema.StringAttribute{
						MarkdownDescription: "Allow Methods. Specifies the content for the access-control-allow-methods header",
						Optional: true,
					},
					"allow_origin": schema.ListAttribute{
						MarkdownDescription: "Allow Origin. Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match",
						Optional: true,
						ElementType: types.StringType,
					},
					"allow_origin_regex": schema.ListAttribute{
						MarkdownDescription: "Allow Origin Regex. Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match",
						Optional: true,
						ElementType: types.StringType,
					},
					"disabled": schema.BoolAttribute{
						MarkdownDescription: "Disabled. Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host",
						Optional: true,
					},
					"expose_headers": schema.StringAttribute{
						MarkdownDescription: "Expose Headers. Specifies the content for the access-control-expose-headers header",
						Optional: true,
					},
					"maximum_age": schema.Int64Attribute{
						MarkdownDescription: "Maximum Age. Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours)",
						Optional: true,
					},
				},

			},
			"csrf_policy": schema.SingleNestedBlock{
				MarkdownDescription: "CSRF Policy. To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.The policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to issue the request (source origin). 2. The origin that the request is going to (target origin). When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being if the source-origin has been added to they policy as valid. Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"all_load_balancer_domains": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"custom_domain_list": schema.SingleNestedBlock{
						MarkdownDescription: "Domain name list. List of domain names used for Host header matching",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "Domain names. A list of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"data_guard_rules": schema.ListNestedBlock{
				MarkdownDescription: "Data Guard Rules. Data Guard prevents responses from exposing sensitive information by masking the data. The system masks credit card numbers and social security numbers leaked from the application from within the http response with a string of asterisks (*). Note: App Firewall should be enabled, to use Data Guard feature.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact Value. Exact domain name",
							Optional: true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"apply_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"path": schema.SingleNestedBlock{
							MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
							Attributes: map[string]schema.Attribute{
								"path": schema.StringAttribute{
									MarkdownDescription: "Exact. Exact path value to match",
									Optional: true,
								},
								"prefix": schema.StringAttribute{
									MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
									Optional: true,
								},
								"regex": schema.StringAttribute{
									MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
									Optional: true,
								},
							},
						},
						"skip_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"ddos_mitigation_rules": schema.ListNestedBlock{
				MarkdownDescription: "DDoS Mitigation Rules. Define manual mitigation rules to block L7 DDoS attacks.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"block": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ddos_client_source": schema.SingleNestedBlock{
							MarkdownDescription: "DDoS Client Source Choice. DDoS Mitigation sources to be blocked",
							Attributes: map[string]schema.Attribute{
								"country_list": schema.ListAttribute{
									MarkdownDescription: "Country List. Sources that are located in one of the countries in the given list. Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
									Optional: true,
									ElementType: types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional: true,
											ElementType: types.Int64Type,
										},
									},
								},
								"ja4_tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "JA4 TLS Fingerprint Matcher. An extended version of JA3 that includes additional fields for more comprehensive fingerprinting of SSL/TLS clients and potentially has a different structure and length.",
									Attributes: map[string]schema.Attribute{
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "Exact Values. A list of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
									Attributes: map[string]schema.Attribute{
										"classes": schema.ListAttribute{
											MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
											Optional: true,
											ElementType: types.StringType,
										},
										"excluded_values": schema.ListAttribute{
											MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
							},
						},
						"ip_prefix_list": schema.SingleNestedBlock{
							MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
							Attributes: map[string]schema.Attribute{
								"invert_match": schema.BoolAttribute{
									MarkdownDescription: "Invert Match Result. Invert the match result.",
									Optional: true,
								},
								"ip_prefixes": schema.ListAttribute{
									MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
									Optional: true,
									ElementType: types.StringType,
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
					},

				},
			},
			"default_pool": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_pool, default_pool_list] Global Specification. Shape of the origin pool specification",
				Attributes: map[string]schema.Attribute{
					"endpoint_selection": schema.StringAttribute{
						MarkdownDescription: "Endpoint Selection Policy. Policy for selection of endpoints from local site/remote site/both Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing Enable this policy to load balance ONLY among locally discovered endpoints Prefer the local endpoints for load balancing. If local endpoints are not present remote endpoints will be considered. Possible values are `DISTRIBUTED`, `LOCAL_ONLY`, `LOCAL_PREFERRED`. Defaults to `DISTRIBUTED`.",
						Optional: true,
					},
					"health_check_port": schema.Int64Attribute{
						MarkdownDescription: "Health check port. Port used for performing health check",
						Optional: true,
					},
					"loadbalancer_algorithm": schema.StringAttribute{
						MarkdownDescription: "Load Balancer Algorithm. Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load balancer uses loadbalancer_algorithm to determine which host is selected. - ROUND_ROBIN: ROUND_ROBIN Policy in which each healthy/available upstream endpoint is selected in round robin order. - LEAST_REQUEST: LEAST_REQUEST Policy in which loadbalancer picks the upstream endpoint which has the fewest active requests - RING_HASH: RING_HASH Policy implements consistent hashing to upstream endpoints using ring hash of endpoint names Hash of the incoming request is calculated using request hash policy. The ring/modulo hash load balancer implements consistent hashing to upstream hosts. The algorithm is based on mapping all hosts onto a circle such that the addition or removal of a host from the host set changes only affect 1/N requests. This technique is also commonly known as ketama hashing. A consistent hashing load balancer is only effective when protocol routing is used that specifies a value to hash on. The minimum ring size governs the replication factor for each host in the ring. For example, if the minimum ring size is 1024 and there are 16 hosts, each host will be replicated 64 times. - RANDOM: RANDOM Policy in which each available upstream endpoint is selected in random order. The random load balancer selects a random healthy host. The random load balancer generally performs better than round robin if no health checking policy is configured. Random selection avoids bias towards the host in the set that comes after a failed host. - LB_OVERRIDE: Load Balancer Override Hash policy is taken from from the load balancer which is using this origin pool. Possible values are `ROUND_ROBIN`, `LEAST_REQUEST`, `RING_HASH`, `RANDOM`, `LB_OVERRIDE`. Defaults to `ROUND_ROBIN`.",
						Optional: true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "Port. Endpoint service is available on this port",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advanced_options": schema.SingleNestedBlock{
						MarkdownDescription: "Origin Pool Advanced Options. Configure Advanced options for origin pool",
						Attributes: map[string]schema.Attribute{
							"connection_timeout": schema.Int64Attribute{
								MarkdownDescription: "Connection Timeout. The timeout for new network connections to endpoints in the cluster. This is specified in milliseconds. The  seconds. Defaults to `2`.",
								Optional: true,
							},
							"http_idle_timeout": schema.Int64Attribute{
								MarkdownDescription: "HTTP Idle Timeout. The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `5`.",
								Optional: true,
							},
							"panic_threshold": schema.Int64Attribute{
								MarkdownDescription: "Panic threshold. x-example:'25' Configure a threshold (percentage of unhealthy endpoints) below which all endpoints will be considered for load balancing ignoring its health status.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"auto_http_config": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"circuit_breaker": schema.SingleNestedBlock{
								MarkdownDescription: "Circuit Breaker. CircuitBreaker provides a mechanism for watching failures in upstream connections or requests and if the failures reach a certain threshold, automatically fail subsequent requests which allows to apply back pressure on downstream quickly.",
								Attributes: map[string]schema.Attribute{
									"connection_limit": schema.Int64Attribute{
										MarkdownDescription: "Connection Limit. The maximum number of connections that loadbalancer will establish to all hosts in an upstream cluster. In practice this is only applicable to TCP and HTTP/1.1 clusters since HTTP/2 uses a single connection to each host. Remove endpoint out of load balancing decision, if number of connections reach connection limit.",
										Optional: true,
									},
									"max_requests": schema.Int64Attribute{
										MarkdownDescription: "Maximum Request Count. The maximum number of requests that can be outstanding to all hosts in a cluster at any given time. In practice this is applicable to HTTP/2 clusters since HTTP/1.1 clusters are governed by the maximum connections (connection_limit). Remove endpoint out of load balancing decision, if requests exceed this count.",
										Optional: true,
									},
									"pending_requests": schema.Int64Attribute{
										MarkdownDescription: "Pending Requests. The maximum number of requests that will be queued while waiting for a ready connection pool connection. Since HTTP/2 requests are sent over a single connection, this circuit breaker only comes into play as the initial connection is created, as requests will be multiplexed immediately afterwards. For HTTP/1.1, requests are added to the list of pending requests whenever there arent enough upstream connections available to immediately dispatch the request, so this circuit breaker will remain in play for the lifetime of the process. Remove endpoint out of load balancing decision, if pending request reach pending_request.",
										Optional: true,
									},
									"priority": schema.StringAttribute{
										MarkdownDescription: "Routing Priority. Priority routing for each request. Different connection pools are used based on the priority selected for the request. Also, circuit-breaker configuration at destination cluster is chosen based on selected priority. Default routing mechanism High-Priority routing mechanism. Possible values are `DEFAULT`, `HIGH`. Defaults to `DEFAULT`.",
										Optional: true,
									},
									"retries": schema.Int64Attribute{
										MarkdownDescription: "Retry Count. The maximum number of retries that can be outstanding to all hosts in a cluster at any given time. Remove endpoint out of load balancing decision, if retries for request exceed this count.",
										Optional: true,
									},
								},
							},
							"default_circuit_breaker": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_circuit_breaker": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_lb_source_ip_persistance": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_outlier_detection": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_proxy_protocol": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_subsets": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_lb_source_ip_persistance": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_subsets": schema.SingleNestedBlock{
								MarkdownDescription: "Origin Pool Subset Options. Configure subset options for origin pool",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"any_endpoint": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"default_subset": schema.SingleNestedBlock{
										MarkdownDescription: "Origin Pool Default Subset. Default Subset definition",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"default_subset": schema.SingleNestedBlock{
												MarkdownDescription: "Default Subset for Origin Pool. List of key-value pairs that define default subset. which gets used when route specifies no metadata or no subset matching the metadata exists.",
											},
										},
									},
									"endpoint_subsets": schema.ListNestedBlock{
										MarkdownDescription: "Origin Server Subsets Classes. List of subset class. Subsets class is defined using list of keys. Every unique combination of values of these keys form a subset withing the class.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"keys": schema.ListAttribute{
													MarkdownDescription: "Keys. List of keys that define a cluster subset class.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
									"fail_request": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"http1_config": schema.SingleNestedBlock{
								MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for upstream connections",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"default_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"legacy_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"preserve_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"proper_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
							"http2_options": schema.SingleNestedBlock{
								MarkdownDescription: "Http2 Protocol Options. Http2 Protocol options for upstream connections",
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										MarkdownDescription: "HTTP2 Enabled. Enable/disable HTTP2 Protocol for upstream connections",
										Optional: true,
									},
								},
							},
							"no_panic_threshold": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"outlier_detection": schema.SingleNestedBlock{
								MarkdownDescription: "Outlier Detection. Outlier detection and ejection is the process of dynamically determining whether some number of hosts in an upstream cluster are performing unlike the others and removing them from the healthy load balancing set. Outlier detection is a form of passive health checking. Algorithm 1. A endpoint is determined to be an outlier (based on configured number of consecutive_5xx or consecutive_gateway_failures) . 2. If no endpoints have been ejected, loadbalancer will eject the host immediately. Otherwise, it checks to make sure the number of ejected hosts is below the allowed threshold (specified via max_ejection_percent setting). If the number of ejected hosts is above the threshold, the host is not ejected. 3. The endpoint is ejected for some number of milliseconds. Ejection means that the endpoint is marked unhealthy and will not be used during load balancing. The number of milliseconds is equal to the base_ejection_time value multiplied by the number of times the host has been ejected. 4. An ejected endpoint will automatically be brought back into service after the ejection time has been satisfied",
								Attributes: map[string]schema.Attribute{
									"base_ejection_time": schema.Int64Attribute{
										MarkdownDescription: "Base Ejection Time. The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the host has been ejected. This causes hosts to get ejected for longer periods if they continue to fail. Specified in milliseconds. Defaults to `30000ms`.",
										Optional: true,
									},
									"consecutive_5xx": schema.Int64Attribute{
										MarkdownDescription: "Consecutive 5xx Count. If an upstream endpoint returns some number of consecutive 5xx, it will be ejected. Note that in this case a 5xx means an actual 5xx respond code, or an event that would cause the HTTP router to return one on the upstreams behalf(reset, connection failure, etc.) consecutive_5xx indicates the number of consecutive 5xx responses required before a consecutive 5xx ejection occurs. Defaults to `5`.",
										Optional: true,
									},
									"consecutive_gateway_failure": schema.Int64Attribute{
										MarkdownDescription: "Consecutive Gateway Failure. If an upstream endpoint returns some number of consecutive gateway errors (502, 503 or 504 status code), it will be ejected. Note that this includes events that would cause the HTTP router to return one of these status codes on the upstreams behalf (reset, connection failure, etc.). consecutive_gateway_failure indicates the number of consecutive gateway failures before a consecutive gateway failure ejection occurs. Defaults to `5`.",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. The time interval between ejection analysis sweeps. This can result in both new ejections as well as endpoints being returned to service. Specified in milliseconds. Defaults to `10000ms`.",
										Optional: true,
									},
									"max_ejection_percent": schema.Int64Attribute{
										MarkdownDescription: "Max Ejection Percentage. The maximum % of an upstream cluster that can be ejected due to outlier detection.  but will eject at least one host regardless of the value. Defaults to `10%`.",
										Optional: true,
									},
								},
							},
							"proxy_protocol_v1": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"proxy_protocol_v2": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"automatic_port": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"healthcheck": schema.ListNestedBlock{
						MarkdownDescription: "Health Check object. Reference to healthcheck configuration objects",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},
					"lb_port": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"origin_servers": schema.ListNestedBlock{
						MarkdownDescription: "Origin Servers. List of origin servers in this pool",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"cbip_service": schema.SingleNestedBlock{
									MarkdownDescription: "Discovered Classic BIG-IP Service Name. Specify origin server with Classic BIG-IP Service (Virtual Server)",
									Attributes: map[string]schema.Attribute{
										"service_name": schema.StringAttribute{
											MarkdownDescription: "Service Name. Name of the discovered Classic BIG-IP virtual server to be used as origin.",
											Optional: true,
										},
									},
								},
								"consul_service": schema.SingleNestedBlock{
									MarkdownDescription: "Consul Service Name on given Sites. Specify origin server with Hashi Corp Consul service name and site information",
									Attributes: map[string]schema.Attribute{
										"service_name": schema.StringAttribute{
											MarkdownDescription: "Service Name. Consul service name of this origin server will be listed, including cluster-id. The format is servicename:cluster-id.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Site or Virtual Site. This message defines a reference to a site or virtual site object",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Snat Pool. Snat Pool configuration",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
								"custom_endpoint_object": schema.SingleNestedBlock{
									MarkdownDescription: "Custom Endpoint Object for Origin Server. Specify origin server with a reference to endpoint object",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"k8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "K8s Service Name on given Sites. Specify origin server with K8s service name and site information",
									Attributes: map[string]schema.Attribute{
										"protocol": schema.StringAttribute{
											MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP - PROTOCOL_UDP: UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
											Optional: true,
										},
										"service_name": schema.StringAttribute{
											MarkdownDescription: "Service Name. K8s service name of the origin server will be listed, including the namespace and cluster-id. For vK8s services, you need to enter a string with the format servicename.namespace:cluster-id. If the servicename is 'frontend', namespace is 'speedtest' and cluster-id is 'prod', then you will enter 'frontend.speedtest:prod'. Both namespace and cluster-id are optional.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Site or Virtual Site. This message defines a reference to a site or virtual site object",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Snat Pool. Snat Pool configuration",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
										"vk8s_networks": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"labels": schema.SingleNestedBlock{
									MarkdownDescription: "Origin Server Labels. Add Labels for this origin server, these labels can be used to form subset.",
								},
								"private_ip": schema.SingleNestedBlock{
									MarkdownDescription: "IP address on given Sites. Specify origin server with private or public IP address and site information",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IP. Private IPV4 address",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"segment": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Site or Virtual Site. This message defines a reference to a site or virtual site object",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Snat Pool. Snat Pool configuration",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
								"private_name": schema.SingleNestedBlock{
									MarkdownDescription: "DNS Name on given Sites. Specify origin server with private or public DNS name and site information",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name",
											Optional: true,
										},
										"refresh_interval": schema.Int64Attribute{
											MarkdownDescription: "DNS Refresh Interval. Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"segment": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Site or Virtual Site. This message defines a reference to a site or virtual site object",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Snat Pool. Snat Pool configuration",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
								"public_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Public IP. Specify origin server with public IP address",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Public IPV4. Public IPV4 address",
											Optional: true,
										},
									},
								},
								"public_name": schema.SingleNestedBlock{
									MarkdownDescription: "Public DNS Name. Specify origin server with public DNS name",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name",
											Optional: true,
										},
										"refresh_interval": schema.Int64Attribute{
											MarkdownDescription: "DNS Refresh Interval. Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767",
											Optional: true,
										},
									},
								},
								"vn_private_ip": schema.SingleNestedBlock{
									MarkdownDescription: "IP address Virtual Network. Specify origin server with IP on Virtual Network",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IPV4. IPV4 address",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
								"vn_private_name": schema.SingleNestedBlock{
									MarkdownDescription: "DNS Name on Virtual Network. Specify origin server with DNS name on Virtual Network",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"private_network": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"same_as_endpoint_port": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"upstream_conn_pool_reuse_type": schema.SingleNestedBlock{
						MarkdownDescription: "Select upstream connection pool reuse state. Select upstream connection pool reuse state for every downstream connection. This configuration choice is for HTTP(S) LB only.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"disable_conn_pool_reuse": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_conn_pool_reuse": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters for Origin Servers. Upstream TLS Parameters",
						Attributes: map[string]schema.Attribute{
							"max_session_keys": schema.Int64Attribute{
								MarkdownDescription: "Max Session Keys Cached. x-example:'25' Number of session keys that are cached.",
								Optional: true,
							},
							"sni": schema.StringAttribute{
								MarkdownDescription: "SNI Value. SNI value to be used.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"default_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"skip_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_host_header_as_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "mTLS Certificate. mTLS Client Certificate",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "mTLS Client Certificate. mTLS Client Certificate",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional: true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional: true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																	Optional: true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																	Optional: true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																	Optional: true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																	Optional: true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
							"use_mtls_obj": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"use_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Validation Context for Origin Servers. Upstream TLS Validation Context",
								Attributes: map[string]schema.Attribute{
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Origin Pool for verification of server's certificate",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
								},
							},
							"volterra_trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"view_internal": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"default_pool_list": schema.SingleNestedBlock{
				MarkdownDescription: "Origin Pool List Type. List of Origin Pools",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"pools": schema.ListNestedBlock{
						MarkdownDescription: "Origin Pools. List of Origin Pools",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"priority": schema.Int64Attribute{
									MarkdownDescription: "Priority. Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the increasing priority.",
									Optional: true,
								},
								"weight": schema.Int64Attribute{
									MarkdownDescription: "Weight. Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"cluster": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"endpoint_subsets": schema.SingleNestedBlock{
									MarkdownDescription: "Origin Servers Subsets. Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8S or Consul cluster, the label of the service is merged with endpoint's labels. In case of Consul, the label is derived from the 'Tag' field. For labels that are common between configured endpoint and discovered service, labels from discovered service takes precedence. List of key-value pairs that will be used as matching metadata. Only those origin servers of upstream origin pool which match this metadata will be selected for load balancing",
								},
								"pool": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
				},

			},
			"default_route_pools": schema.ListNestedBlock{
				MarkdownDescription: "Origin Pools. Origin Pools used when no route is specified (default route)",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"priority": schema.Int64Attribute{
							MarkdownDescription: "Priority. Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the increasing priority.",
							Optional: true,
						},
						"weight": schema.Int64Attribute{
							MarkdownDescription: "Weight. Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"cluster": schema.SingleNestedBlock{
							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
						"endpoint_subsets": schema.SingleNestedBlock{
							MarkdownDescription: "Origin Servers Subsets. Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8S or Consul cluster, the label of the service is merged with endpoint's labels. In case of Consul, the label is derived from the 'Tag' field. For labels that are common between configured endpoint and discovered service, labels from discovered service takes precedence. List of key-value pairs that will be used as matching metadata. Only those origin servers of upstream origin pool which match this metadata will be selected for load balancing",
						},
						"pool": schema.SingleNestedBlock{
							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},

				},
			},
			"default_sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_sensitive_data_policy, sensitive_data_policy] Empty. This can be used for messages where no values are needed",
			},
			"disable_api_definition": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_api_discovery, enable_api_discovery] Empty. This can be used for messages where no values are needed",
			},
			"disable_api_testing": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_bot_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_caching": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ip_reputation, enable_ip_reputation] Empty. This can be used for messages where no values are needed",
			},
			"disable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_malicious_user_detection, enable_malicious_user_detection] Empty. This can be used for messages where no values are needed",
			},
			"disable_malware_protection": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_malware_protection, malware_protection_settings] Empty. This can be used for messages where no values are needed",
			},
			"disable_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"disable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_threat_mesh, enable_threat_mesh] Empty. This can be used for messages where no values are needed",
			},
			"disable_trust_client_ip_headers": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_trust_client_ip_headers, enable_trust_client_ip_headers] Empty. This can be used for messages where no values are needed",
			},
			"disable_waf": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"do_not_advertise": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"enable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "API Discovery Setting. Specifies the settings used for API discovery",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"api_crawler": schema.SingleNestedBlock{
						MarkdownDescription: "API Crawling. Api Crawler message",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"api_crawler_config": schema.SingleNestedBlock{
								MarkdownDescription: "Crawler Configure.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"domains": schema.ListNestedBlock{
										MarkdownDescription: "Domains to Crawl. Enter domains and their credentials to allow authenticated API crawling. You can only include domains you own that are associated with this Load Balancer.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"domain": schema.StringAttribute{
													MarkdownDescription: "Domain. Select the domain to execute API Crawling with given credentials.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"simple_login": schema.SingleNestedBlock{
													MarkdownDescription: "Simple Login.",
													Attributes: map[string]schema.Attribute{
														"user": schema.StringAttribute{
															MarkdownDescription: "User. Enter the username to assign credentials for the selected domain to crawl",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"password": schema.SingleNestedBlock{
															MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional: true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																			Optional: true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional: true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																			Optional: true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"disable_api_crawler": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"api_discovery_from_code_scan": schema.SingleNestedBlock{
						MarkdownDescription: "Select Code Base and Repositories. x-required",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"code_base_integrations": schema.ListNestedBlock{
								MarkdownDescription: "Select Code Base Integrations.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"all_repos": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"code_base_integration": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"selected_repos": schema.SingleNestedBlock{
											MarkdownDescription: "API Code Repositories. Select which API repositories represent the LB applications",
											Attributes: map[string]schema.Attribute{
												"api_code_repo": schema.ListAttribute{
													MarkdownDescription: "API Code Repository. Code repository which contain API endpoints",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "API Discovery Advanced Settings. API Discovery Advanced settings",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"api_discovery_ref": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
						},
					},
					"default_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"discovered_api_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Discovered API Settings. x-example: '2' Configure Discovered API Settings.",
						Attributes: map[string]schema.Attribute{
							"purge_duration_for_inactive_discovered_apis": schema.Int64Attribute{
								MarkdownDescription: "Purge Duration for Inactive Discovered APIs from Traffic. Inactive discovered API will be deleted after configured duration.",
								Optional: true,
							},
						},
					},
					"enable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"enable_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enable Malicious User Challenge. Configure auto mitigation i.e risk based challenges for malicious users",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
								Optional: true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"enable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "IP Threat Category List. List of ip threat categories",
				Attributes: map[string]schema.Attribute{
					"ip_threat_categories": schema.ListAttribute{
						MarkdownDescription: "List of IP Threat Categories to choose. If the source IP matches on atleast one of the enabled IP threat categories, the request will be denied. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
						Optional: true,
						ElementType: types.StringType,
					},
				},

			},
			"enable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"enable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"enable_trust_client_ip_headers": schema.SingleNestedBlock{
				MarkdownDescription: "Trust Client IP Headers List. List of Client IP Headers",
				Attributes: map[string]schema.Attribute{
					"client_ip_headers": schema.ListAttribute{
						MarkdownDescription: "Client IP Headers. Define the list of one or more Client IP Headers. Headers will be used in order from top to bottom, meaning if the first header is not present in the request, the system will proceed to check for the second header, and so on, until one of the listed headers is found. If none of the defined headers exist, or the value is not an IP address, then the system will use the source IP of the packet. If multiple defined headers with different names are present in the request, the value of the first header name in the configuration will be used. If multiple defined headers with the same name are present in the request, values of all those headers will be combined. The system will read the right-most IP address from header, if there are multiple ip addresses in the header value. For X-Forwarded-For header, the system will read the IP address(rightmost - 1), as the client ip",
						Optional: true,
						ElementType: types.StringType,
					},
				},

			},
			"graphql_rules": schema.ListNestedBlock{
				MarkdownDescription: "GraphQL Inspection. GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it easier to evolve APIs over time, and enables powerful developer tools. Policy configuration to analyze GraphQL queries and prevent GraphQL tailored attacks.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_path": schema.StringAttribute{
							MarkdownDescription: "Path. Specifies the exact path to GraphQL endpoint. Defaults to `/graphql`.",
							Optional: true,
						},
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact Value. Exact domain name",
							Optional: true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"graphql_settings": schema.SingleNestedBlock{
							MarkdownDescription: "GraphQL Settings. GraphQL configuration.",
							Attributes: map[string]schema.Attribute{
								"max_batched_queries": schema.Int64Attribute{
									MarkdownDescription: "Maximum Batched Queries. Specify maximum number of queries in a single batched request.",
									Optional: true,
								},
								"max_depth": schema.Int64Attribute{
									MarkdownDescription: "Maximum Structure Depth. Specify maximum depth for the GraphQL query.",
									Optional: true,
								},
								"max_total_length": schema.Int64Attribute{
									MarkdownDescription: "Maximum Total Length. Specify maximum length in bytes for the GraphQL query.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"disable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"enable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"method_get": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"method_post": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"http": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: http, https, https_auto_cert] HTTP Choice. Choice for selecting HTTP proxy",
				Attributes: map[string]schema.Attribute{
					"dns_volterra_managed": schema.BoolAttribute{
						MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
						Optional: true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
						Optional: true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional: true,
					},
				},

			},
			"https": schema.SingleNestedBlock{
				MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
						Optional: true,
					},
					"append_server_name": schema.StringAttribute{
						MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
						Optional: true,
					},
					"connection_idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
						Optional: true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
						Optional: true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
						Optional: true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional: true,
					},
					"server_name": schema.StringAttribute{
						MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"coalescing_options": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"default_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"strict_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"default_header": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"http_protocol_options": schema.SingleNestedBlock{
						MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"http_protocol_enable_v1_only": schema.SingleNestedBlock{
								MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"default_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"legacy_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"preserve_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"proper_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
							"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"http_protocol_enable_v2_only": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"non_default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"pass_through": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"tls_cert_params": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"certificates": schema.ListNestedBlock{
								MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional: true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"tls_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional: true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional: true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional: true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional: true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional: true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional: true,
												ElementType: types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional: true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional: true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"https_auto_cert": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
						Optional: true,
					},
					"append_server_name": schema.StringAttribute{
						MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
						Optional: true,
					},
					"connection_idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
						Optional: true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
						Optional: true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
						Optional: true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional: true,
					},
					"server_name": schema.StringAttribute{
						MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"coalescing_options": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"default_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"strict_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"default_header": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"http_protocol_options": schema.SingleNestedBlock{
						MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"http_protocol_enable_v1_only": schema.SingleNestedBlock{
								MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"default_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"legacy_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"preserve_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
											"proper_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
							"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"http_protocol_enable_v2_only": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"no_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"non_default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"pass_through": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"custom_security": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
								Attributes: map[string]schema.Attribute{
									"cipher_suites": schema.ListAttribute{
										MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
										Optional: true,
										ElementType: types.StringType,
									},
									"max_version": schema.StringAttribute{
										MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional: true,
									},
									"min_version": schema.StringAttribute{
										MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional: true,
									},
								},
							},
							"default_security": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"low_security": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"medium_security": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"use_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
						Attributes: map[string]schema.Attribute{
							"client_certificate_optional": schema.BoolAttribute{
								MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
								Optional: true,
							},
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"crl": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"no_crl": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"xfcc_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"xfcc_options": schema.SingleNestedBlock{
								MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
								Attributes: map[string]schema.Attribute{
									"xfcc_header_elements": schema.ListAttribute{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
						},
					},
				},

			},
			"js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional: true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
						Optional: true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
						Optional: true,
					},
				},

			},
			"jwt_validation": schema.SingleNestedBlock{
				MarkdownDescription: "JWT Validation. JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming JWTs before they are passed to your API origin. JWT Validation will also stop requests with expired tokens or tokens that are not yet valid.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"action": schema.SingleNestedBlock{
						MarkdownDescription: "Action.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"block": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"report": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"jwks_config": schema.SingleNestedBlock{
						MarkdownDescription: "JSON Web Key Set (JWKS). The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
						Attributes: map[string]schema.Attribute{
							"cleartext": schema.StringAttribute{
								MarkdownDescription: "JSON Web Key Set (JWKS). The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
								Optional: true,
							},
						},
					},
					"mandatory_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Mandatory Claims. Configurable Validation of mandatory Claims.",
						Attributes: map[string]schema.Attribute{
							"claim_names": schema.ListAttribute{
								MarkdownDescription: "Claim Names.",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"reserved_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Reserved claims configuration. Configurable Validation of reserved Claims",
						Attributes: map[string]schema.Attribute{
							"issuer": schema.StringAttribute{
								MarkdownDescription: "Exact Match.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"audience": schema.SingleNestedBlock{
								MarkdownDescription: "Audiences.",
								Attributes: map[string]schema.Attribute{
									"audiences": schema.ListAttribute{
										MarkdownDescription: "Values.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
							"audience_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"issuer_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"validate_period_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"validate_period_enable": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"target": schema.SingleNestedBlock{
						MarkdownDescription: "Target. Define endpoints for which JWT token validation will be performed",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_endpoint": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"api_groups": schema.SingleNestedBlock{
								MarkdownDescription: "API Groups.",
								Attributes: map[string]schema.Attribute{
									"api_groups": schema.ListAttribute{
										MarkdownDescription: "API Groups.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
							"base_paths": schema.SingleNestedBlock{
								MarkdownDescription: "Base Paths.",
								Attributes: map[string]schema.Attribute{
									"base_paths": schema.ListAttribute{
										MarkdownDescription: "Prefix Values.",
										Optional: true,
										ElementType: types.StringType,
									},
								},
							},
						},
					},
					"token_location": schema.SingleNestedBlock{
						MarkdownDescription: "Token Location. Location of JWT in Http request",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"bearer_token": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"l7_ddos_action_block": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: l7_ddos_action_block, l7_ddos_action_default, l7_ddos_action_js_challenge] Empty. This can be used for messages where no values are needed",
			},
			"l7_ddos_action_default": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"l7_ddos_action_js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional: true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
						Optional: true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
						Optional: true,
					},
				},

			},
			"l7_ddos_protection": schema.SingleNestedBlock{
				MarkdownDescription: "L7 DDoS Protection Settings. L7 DDoS protection is critical for safeguarding web applications, APIs, and services that are exposed to the internet from sophisticated, volumetric, application-level threats. Configure actions, thresholds and policies to apply during L7 DDoS attack",
				Attributes: map[string]schema.Attribute{
					"rps_threshold": schema.Int64Attribute{
						MarkdownDescription: "Custom. Configure custom RPS threshold",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"clientside_action_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
					"clientside_action_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
								Optional: true,
							},
						},
					},
					"clientside_action_none": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"ddos_policy_custom": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"ddos_policy_none": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_rps_threshold": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"mitigation_block": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"mitigation_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
					"mitigation_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
								Optional: true,
							},
						},
					},
				},

			},
			"least_active": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"malware_protection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Malware Protection Policy. Malware Protection protects Web Apps and APIs, from malicious file uploads by scanning files in real-time.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"malware_protection_rules": schema.ListNestedBlock{
						MarkdownDescription: "Malware Detection Rules. Configure the match criteria to trigger Malware Protection Scan",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"http_methods": schema.ListAttribute{
									MarkdownDescription: "HTTP Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional: true,
									ElementType: types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"action": schema.SingleNestedBlock{
									MarkdownDescription: "Action.",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"block": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"report": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"domain": schema.SingleNestedBlock{
									MarkdownDescription: "Domain to Match. Domain to be matched",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact Value. Exact domain name.",
													Optional: true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regex Values of Domains. Regular Expression value for the domain name",
													Optional: true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
													Optional: true,
												},
											},
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
											Optional: true,
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact. Exact path value to match",
											Optional: true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
											Optional: true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
											Optional: true,
										},
									},
								},
							},
						},
					},
				},

			},
			"more_option": schema.SingleNestedBlock{
				MarkdownDescription: "Advanced Options. This defines various options to define a route",
				Attributes: map[string]schema.Attribute{
					"disable_default_error_pages": schema.BoolAttribute{
						MarkdownDescription: "Disable Default Error Pages. Disable the use of default F5XC error pages.",
						Optional: true,
					},
					"idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "Idle Timeout. The amount of time that a stream can exist without upstream or downstream activity, in milliseconds. The stream is terminated with a HTTP 504 (Gateway Timeout) error code if no upstream response header has been received, otherwise the stream is reset.",
						Optional: true,
					},
					"max_request_header_size": schema.Int64Attribute{
						MarkdownDescription: "Maximum Request Header Size. The maximum request header size for downstream connections, in KiB. A HTTP 431 (Request Header Fields Too Large) error code is sent for requests that exceed this size. If multiple load balancers share the same advertise_policy, the highest value configured across all such load balancers is used for all the load balancers in question.",
						Optional: true,
					},
					"request_cookies_to_remove": schema.ListAttribute{
						MarkdownDescription: "Remove Cookies from Cookie Header. List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
						Optional: true,
						ElementType: types.StringType,
					},
					"request_headers_to_remove": schema.ListAttribute{
						MarkdownDescription: "Remove Request Headers. List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
						Optional: true,
						ElementType: types.StringType,
					},
					"response_cookies_to_remove": schema.ListAttribute{
						MarkdownDescription: "Remove Cookies from Set-Cookie Headers. List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed",
						Optional: true,
						ElementType: types.StringType,
					},
					"response_headers_to_remove": schema.ListAttribute{
						MarkdownDescription: "Remove Response Headers. List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
						Optional: true,
						ElementType: types.StringType,
					},
				},
				Blocks: map[string]schema.Block{
					"buffer_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Buffer Configuration. Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config. Buffering can be enabled and disabled at VirtualHost and Route levels Route level buffer configuration takes precedence.",
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								MarkdownDescription: "Disable. Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host",
								Optional: true,
							},
							"max_request_bytes": schema.Int64Attribute{
								MarkdownDescription: "Max Request Bytes. The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
								Optional: true,
							},
						},
					},
					"compression_params": schema.SingleNestedBlock{
						MarkdownDescription: "Compression Parameters. Enables loadbalancer to compress dispatched data from an upstream service upon client request. The content is compressed and then sent to the client with the appropriate headers if either response and request allow. Only GZIP compression is supported. By default compression will be skipped when: A request does NOT contain accept-encoding header. A request includes accept-encoding header, but it does not contain gzip or *. A request includes accept-encoding with gzip or * with the weight q=0. Note that the gzip will have a higher weight then *. For example, if accept-encoding is gzip;q=0,*;q=1, the filter will not compress. But if the header is set to *;q=0,gzip;q=1, the filter will compress. A request whose accept-encoding header includes identity. A response contains a content-encoding header. A response contains a cache-control header whose value includes no-transform. A response contains a transfer-encoding header whose value includes gzip. A response does not contain a content-type value that matches one of the selected mime-types, which default to application/javascript, application/json, application/xhtml+xml, image/svg+xml, text/css, text/html, text/plain, text/xml. Neither content-length nor transfer-encoding headers are present in the response. Response size is smaller than 30 bytes (only applicable when transfer-encoding is not chunked). When compression is applied: The content-length is removed from response headers. Response headers contain transfer-encoding: chunked and do not contain content-encoding header. The vary: accept-encoding header is inserted on every response. GZIP Compression Level: A value which is optimal balance between speed of compression and amount of compression is chosen.",
						Attributes: map[string]schema.Attribute{
							"content_length": schema.Int64Attribute{
								MarkdownDescription: "Content Length. Minimum response length, in bytes, which will trigger compression. The. Defaults to `30`.",
								Optional: true,
							},
							"content_type": schema.ListAttribute{
								MarkdownDescription: "Content Type. Set of strings that allows specifying which mime-types yield compression When this field is not defined, compression will be applied to the following mime-types: 'application/javascript' 'application/json', 'application/xhtml+xml' 'image/svg+xml' 'text/css' 'text/html' 'text/plain' 'text/xml'",
								Optional: true,
								ElementType: types.StringType,
							},
							"disable_on_etag_header": schema.BoolAttribute{
								MarkdownDescription: "Disable On Etag Header. If true, disables compression when the response contains an etag header. When it is false, weak etags will be preserved and the ones that require strong validation will be removed.",
								Optional: true,
							},
							"remove_accept_encoding_header": schema.BoolAttribute{
								MarkdownDescription: "Remove Accept-Encoding Header. If true, removes accept-encoding from the request headers before dispatching it to the upstream so that responses do not get compressed before reaching the filter.",
								Optional: true,
							},
						},
					},
					"custom_errors": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Error Responses. Map of integer error codes as keys and string values that can be used to provide custom http pages for each error code. Key of the map can be either response code class or HTTP Error code. Response code classes for key is configured as follows 3 -- for 3xx response code class 4 -- for 4xx response code class 5 -- for 5xx response code class Value of the map is string which represents custom HTTP responses. Specific response code takes preference when both response code and response code class matches for a request.",
					},
					"disable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"request_cookies_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Add Cookies in Cookie Header. Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the cookie in Cookie header.",
									Optional: true,
								},
								"overwrite": schema.BoolAttribute{
									MarkdownDescription: "Overwrite. Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
									Optional: true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value. Value of the Cookie header.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional: true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
													Optional: true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"request_headers_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Add Request Headers. Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"append": schema.BoolAttribute{
									MarkdownDescription: "Append. Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the HTTP header.",
									Optional: true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value. Value of the HTTP header.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional: true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
													Optional: true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"response_cookies_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Add Set-Cookie Headers. Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"add_domain": schema.StringAttribute{
									MarkdownDescription: "Add Domain. Add domain attribute",
									Optional: true,
								},
								"add_expiry": schema.StringAttribute{
									MarkdownDescription: "Add expiry. Add expiry attribute",
									Optional: true,
								},
								"add_path": schema.StringAttribute{
									MarkdownDescription: "Add path. Add path attribute",
									Optional: true,
								},
								"max_age_value": schema.Int64Attribute{
									MarkdownDescription: "Add Max Age. Add max age attribute",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the cookie in Cookie header.",
									Optional: true,
								},
								"overwrite": schema.BoolAttribute{
									MarkdownDescription: "Overwrite. Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
									Optional: true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value. Value of the Cookie header.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"add_httponly": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"add_partitioned": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"add_secure": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_expiry": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_httponly": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_max_age": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_partitioned": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_path": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_samesite": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_secure": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ignore_value": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"samesite_lax": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"samesite_none": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"samesite_strict": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional: true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
													Optional: true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"response_headers_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Add Response Headers. Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"append": schema.BoolAttribute{
									MarkdownDescription: "Append. Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the HTTP header.",
									Optional: true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value. Value of the HTTP header.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional: true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
													Optional: true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
													Optional: true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"multi_lb_app": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: multi_lb_app, single_lb_app] Empty. This can be used for messages where no values are needed",
			},
			"no_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"origin_server_subset_rule_list": schema.SingleNestedBlock{
				MarkdownDescription: "Origin Server Subset Rule List Type. List of Origin Pools",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"origin_server_subset_rules": schema.ListNestedBlock{
						MarkdownDescription: "Origin Server Subset Rules. Origin Server Subset Rules allow users to define match condition on Client (IP address, ASN, Country), IP Reputation, Regional Edge names, Request for subset selection of origin servers. Origin Server Subset is a sequential engine where rules are evaluated one after the other. It's important to define the correct order for Origin Server Subset to get the intended result, rules are evaluated from top to bottom in the list. When an Origin server subset rule is matched, then this selection rule takes effect and no more rules are evaluated.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"country_codes": schema.ListAttribute{
									MarkdownDescription: "Country Codes List. List of Country Codes. Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
									Optional: true,
									ElementType: types.StringType,
								},
								"re_name_list": schema.ListAttribute{
									MarkdownDescription: "RE Names. List of RE names for match",
									Optional: true,
									ElementType: types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"any_asn": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"any_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional: true,
											ElementType: types.Int64Type,
										},
									},
								},
								"asn_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"asn_sets": schema.ListNestedBlock{
											MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
														Optional: true,
													},
												},
											},
										},
									},
								},
								"client_selector": schema.SingleNestedBlock{
									MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
									Attributes: map[string]schema.Attribute{
										"expressions": schema.ListAttribute{
											MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"ip_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert IP Matcher. Invert the match result.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"prefix_sets": schema.ListNestedBlock{
											MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
														Optional: true,
													},
												},
											},
										},
									},
								},
								"ip_prefix_list": schema.SingleNestedBlock{
									MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
									Attributes: map[string]schema.Attribute{
										"invert_match": schema.BoolAttribute{
											MarkdownDescription: "Invert Match Result. Invert the match result.",
											Optional: true,
										},
										"ip_prefixes": schema.ListAttribute{
											MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
											Optional: true,
										},
									},
								},
								"none": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"origin_server_subsets_action": schema.SingleNestedBlock{
									MarkdownDescription: "Action. Add labels to select one or more origin servers. Note: The pre-requisite settings to be configured in the origin pool are: 1. Add labels to origin servers 2. Enable subset load balancing in the Origin Server Subsets section and configure keys in origin server subsets classes",
								},
							},
						},
					},
				},

			},
			"policy_based_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Policy Based Challenge. Specifies the settings for policy rule based challenge",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"always_enable_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"always_enable_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Captcha Challenge Parameters. Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it. Client will be allowed to make the request only if the captcha challenge is successful. Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests. CAPTCHA is mainly used as a security check to ensure only human users can pass through. Generally, computers or bots are not capable of solving a captcha. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message for Captcha Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_temporary_blocking_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Javascript Challenge Parameters. Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an HTML page on every new HTTP request. This HTML page will have Javascript embedded in it. Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an encrypted answer with the request such that it embed these numbers as input in the Javascript. Javascript will run on the requestor browser and perform a complex Math operation. Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow the request to the upstream server only if the answer is correct. Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests. Javascript challenge serves following purposes * Validate that the request is coming via a browser that is capable for running Javascript * Force the browser to run a complex operation, f(X), that requires it to spend a large number of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch a large request flood without having to spend even larger CPU cost at their end. You can enable either Javascript challenge or Captcha challenge on a virtual host",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie Expiration Period. Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional: true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Javascript Challenge. Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Please Wait.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Please Wait </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Javascript Delay. Delay introduced by Javascript, in milliseconds.",
								Optional: true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"no_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"rule_list": schema.SingleNestedBlock{
						MarkdownDescription: "Challenge Rule List. List of challenge rules to be used in policy based challenge",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Rules. Rules that specify the match conditions and challenge type to be launched. When a challenge type is selected to be always enabled, these rules can be used to disable challenge or launch a different challenge for requests that match the specified conditions",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"spec": schema.SingleNestedBlock{
											MarkdownDescription: "Challenge Rule Specification. A Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from or derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that request. Any predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a challenge rule, the configured challenge is enforced.",
											Attributes: map[string]schema.Attribute{
												"expiration_timestamp": schema.StringAttribute{
													MarkdownDescription: "The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_asn": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"arg_matchers": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name. Note that all specified arg matcher predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Argument Name. x-example: 'phones[_]' x-example: 'cars.make.toyota.models[1]' x-example: 'cars.make.honda.models[_]' x-example: 'cars.make[_].models[_]' A case-sensitive JSON path in the HTTP request body.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Match List. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "AS Numbers. An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional: true,
															ElementType: types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "ASN Matcher. Match any AS number contained in the list of bgp_asn_sets.",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "BGP ASN Sets. A list of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"body_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Label Selector. This type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A null label selector matches no objects. Label selector is immutable. expressions is a list of strings of label selection expression. Each string has ',' separated values which are 'AND' and all strings are logically 'OR'. BNF for expression string <selector-syntax> ::= <requirement> | <requirement> ',' <selector-syntax> <requirement> ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ] <set-based-restriction> ::= '' | <inclusion-exclusion> <value-set> <inclusion-exclusion> ::= <inclusion> | <exclusion> <exclusion> ::= 'notin' <inclusion> ::= 'in' <value-set> ::= '(' <values> ')' <values> ::= VALUE | VALUE ',' <values> <exact-match-restriction> ::= ['='|'=='|'!='] VALUE",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Selector Expression. expressions contains the kubernetes style label expression for selections.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name. Note that all specified cookie matcher predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Cookie Name. A case-sensitive cookie name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"disable_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"domain_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"enable_captcha_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"enable_javascript_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type. Note that all specified header predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"http_method": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP Method Matcher. A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Method Matcher. Invert the match result.",
															Optional: true,
														},
														"methods": schema.ListAttribute{
															MarkdownDescription: "Method List. List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Matcher. Match any ip prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "IP Prefix Sets. A list of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																		Optional: true,
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																		Optional: true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																		Optional: true,
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																		Optional: true,
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Prefix Match List. List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional: true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path Matcher. A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact path values to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Path Matcher. Invert the match result.",
															Optional: true,
														},
														"prefix_values": schema.ListAttribute{
															MarkdownDescription: "Prefix Values. A list of path prefix values to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "Regex Values. A list of regular expressions to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"suffix_values": schema.ListAttribute{
															MarkdownDescription: "Suffix Values. A list of path suffix values to match the input HTTP path against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name. Note that all specified query parameter predicates must evaluate to true.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional: true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Query Parameter Name. A case-sensitive HTTP query parameter name.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher. A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "Exact Values. A list of exact values to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "Regex Values. A list of regular expressions to match the input against.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "Transformers. An ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional: true,
																		ElementType: types.StringType,
																	},
																},
															},
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS Fingerprint Matcher. A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input fingerprint is not one of the excluded values.",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "TLS fingerprint classes. A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional: true,
															ElementType: types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "Exact Values. A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional: true,
															ElementType: types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "Excluded Values. A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"temporary_user_blocking": schema.SingleNestedBlock{
						MarkdownDescription: "Temporary User Blocking. Specifies configuration for temporary user blocking resulting from user behavior analysis. When Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for malicious activity and the configured mitigation actions will be taken on identified malicious users. These mitigation actions include setting up temporary blocking on that user. This configuration specifies settings on how that blocking should be done by the loadbalancer.",
						Attributes: map[string]schema.Attribute{
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom Message for Temporary Blocking. Custom message is of type `uri_ref`. Currently supported URL schemes is `string:///`. For `string:///` scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Blocked.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Blocked </p>'. Base64 encoded string for this html is 'PHA+IFBsZWFzZSBXYWl0IDwvcD4='",
								Optional: true,
							},
						},
					},
				},

			},
			"protected_cookies": schema.ListNestedBlock{
				MarkdownDescription: "Cookie Protection. Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses. Cookie Tampering Protection prevents attackers from modifying the value of session cookies. For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite. The configured mode of WAF (monitoring or blocking) will be enforced on the request when cookie tampering is identified. Note: We recommend enabling Secure and HttpOnly attributes along with cookie tampering protection.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"max_age_value": schema.Int64Attribute{
							MarkdownDescription: "Add Max Age. Add max age attribute",
							Optional: true,
						},
						"name": schema.StringAttribute{
							MarkdownDescription: "Cookie Name. Name of the Cookie",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"add_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"add_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"disable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"enable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_max_age": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_samesite": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"ignore_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"samesite_lax": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"samesite_none": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"samesite_strict": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"random": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "RateLimitConfigType.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Custom IP Allowed List. IP Allowed list using existing ip_prefix_set objects",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "List of IP Prefix Sets. References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IPv4 Prefix List. x-example: '192.168.20.0/24' List of IPv4 prefixes that represent an endpoint",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefixes that represent an endpoint",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"policies": schema.SingleNestedBlock{
						MarkdownDescription: "Rate Limiter Policy List. List of rate limiter policies to be applied.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"policies": schema.ListNestedBlock{
								MarkdownDescription: "Rate Limiter Policies. Ordered list of rate limiter policies.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"rate_limiter": schema.SingleNestedBlock{
						MarkdownDescription: "Rate Limit Value. A tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
						Attributes: map[string]schema.Attribute{
							"burst_multiplier": schema.Int64Attribute{
								MarkdownDescription: "Burst Multiplier. The maximum burst of requests to accommodate, expressed as a multiple of the rate.",
								Optional: true,
							},
							"period_multiplier": schema.Int64Attribute{
								MarkdownDescription: "Periods. This setting, combined with Per Period units, provides a duration",
								Optional: true,
							},
							"total_number": schema.Int64Attribute{
								MarkdownDescription: "Number Of Requests. The total number of allowed requests per rate-limiting period.",
								Optional: true,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: "Rate Limit Period Unit. Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"action_block": schema.SingleNestedBlock{
								MarkdownDescription: "Rate Limit Block Action. Action where a user is blocked from making further requests after exceeding rate limit threshold.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"hours": schema.SingleNestedBlock{
										MarkdownDescription: "Hours. Input Duration Hours",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration.",
												Optional: true,
											},
										},
									},
									"minutes": schema.SingleNestedBlock{
										MarkdownDescription: "Minutes. Input Duration Minutes",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration.",
												Optional: true,
											},
										},
									},
									"seconds": schema.SingleNestedBlock{
										MarkdownDescription: "Seconds. Input Duration Seconds",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration.",
												Optional: true,
											},
										},
									},
								},
							},
							"disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"leaky_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Leaky Bucket Rate Limiter. Leaky-Bucket is the default rate limiter algorithm for F5",
							},
							"token_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Token Bucket Rate Limiter. Token-Bucket is a rate limiter algorithm that is stricter with enforcing limits",
							},
						},
					},
				},

			},
			"ring_hash": schema.SingleNestedBlock{
				MarkdownDescription: "Hash Policy List. List of hash policy rules",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"hash_policy": schema.ListNestedBlock{
						MarkdownDescription: "Hash Policy. Specifies a list of hash policies to use for ring hash load balancing. Each hash policy is evaluated individually and the combined result is used to route the request",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"header_name": schema.StringAttribute{
									MarkdownDescription: "Header Name. The name or key of the request header that will be used to obtain the hash key",
									Optional: true,
								},
								"source_ip": schema.BoolAttribute{
									MarkdownDescription: "Source IP. Hash based on source IP address",
									Optional: true,
								},
								"terminal": schema.BoolAttribute{
									MarkdownDescription: "Terminal. Specify if its a terminal policy",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"cookie": schema.SingleNestedBlock{
									MarkdownDescription: "Hashing using Cookie. Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets sent to. The client then presents this on the next and all subsequent requests. The hash of this is sufficient to ensure these requests get sent to the same endpoint. The cookie is generated by hashing the source and destination ports and addresses so that multiple independent HTTP2 streams on the same connection will independently receive the same cookie, even if they arrive simultaneously.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced",
											Optional: true,
										},
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. The name of the path for the cookie. If no path is specified here, no path will be set for the cookie",
											Optional: true,
										},
										"ttl": schema.Int64Attribute{
											MarkdownDescription: "TTL. If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"add_httponly": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"add_secure": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"ignore_httponly": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"ignore_samesite": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"ignore_secure": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"samesite_lax": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"samesite_none": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"samesite_strict": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
					},
				},

			},
			"round_robin": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"routes": schema.ListNestedBlock{
				MarkdownDescription: "Routes. Routes allow users to define match condition on a path and/or HTTP method to either forward matching traffic to origin pool or redirect matching traffic to a different URL or respond directly to matching traffic",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
					},
					Blocks: map[string]schema.Block{
						"custom_route_object": schema.SingleNestedBlock{
							MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"route_ref": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
							},
						},
						"direct_response_route": schema.SingleNestedBlock{
							MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
							Attributes: map[string]schema.Attribute{
								"http_method": schema.StringAttribute{
									MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "Headers. List of (key, value) headers",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
								"incoming_port": schema.SingleNestedBlock{
									MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
									Attributes: map[string]schema.Attribute{
										"port": schema.Int64Attribute{
											MarkdownDescription: "Port. Exact Port to match",
											Optional: true,
										},
										"port_ranges": schema.StringAttribute{
											MarkdownDescription: "Port range. Port range to match",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"no_port_match": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact. Exact path value to match",
											Optional: true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
											Optional: true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
											Optional: true,
										},
									},
								},
								"route_direct_response": schema.SingleNestedBlock{
									MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
									Attributes: map[string]schema.Attribute{
										"response_body_encoded": schema.StringAttribute{
											MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
											Optional: true,
										},
										"response_code": schema.Int64Attribute{
											MarkdownDescription: "Response Code. response code to send",
											Optional: true,
										},
									},
								},
							},
						},
						"redirect_route": schema.SingleNestedBlock{
							MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
							Attributes: map[string]schema.Attribute{
								"http_method": schema.StringAttribute{
									MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "Headers. List of (key, value) headers",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
								"incoming_port": schema.SingleNestedBlock{
									MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
									Attributes: map[string]schema.Attribute{
										"port": schema.Int64Attribute{
											MarkdownDescription: "Port. Exact Port to match",
											Optional: true,
										},
										"port_ranges": schema.StringAttribute{
											MarkdownDescription: "Port range. Port range to match",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"no_port_match": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact. Exact path value to match",
											Optional: true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
											Optional: true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
											Optional: true,
										},
									},
								},
								"route_redirect": schema.SingleNestedBlock{
									MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
									Attributes: map[string]schema.Attribute{
										"host_redirect": schema.StringAttribute{
											MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
											Optional: true,
										},
										"path_redirect": schema.StringAttribute{
											MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
											Optional: true,
										},
										"prefix_rewrite": schema.StringAttribute{
											MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
											Optional: true,
										},
										"proto_redirect": schema.StringAttribute{
											MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
											Optional: true,
										},
										"replace_params": schema.StringAttribute{
											MarkdownDescription: "Replace All Parameters.",
											Optional: true,
										},
										"response_code": schema.Int64Attribute{
											MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"remove_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"retain_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
						"simple_route": schema.SingleNestedBlock{
							MarkdownDescription: "Simple Route. A simple route matches on path, incoming header, incoming port and/or HTTP method and forwards the matching traffic to the associated pools",
							Attributes: map[string]schema.Attribute{
								"host_rewrite": schema.StringAttribute{
									MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
									Optional: true,
								},
								"http_method": schema.StringAttribute{
									MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"advanced_options": schema.SingleNestedBlock{
									MarkdownDescription: "Advanced Route Options. Configure advanced options for route like path rewrite, hash policy, etc.",
									Attributes: map[string]schema.Attribute{
										"disable_location_add": schema.BoolAttribute{
											MarkdownDescription: "Disable Location Addition. disables append of x-volterra-location = <re-site-name> at route level, if it is configured at virtual-host level. This configuration is ignored on CE sites.",
											Optional: true,
										},
										"prefix_rewrite": schema.StringAttribute{
											MarkdownDescription: "Enable Prefix Rewrite. prefix_rewrite indicates that during forwarding, the matched prefix (or path) should be swapped with its value. When using regex path matching, the entire path (not including the query string) will be swapped with this value.",
											Optional: true,
										},
										"priority": schema.StringAttribute{
											MarkdownDescription: "Routing Priority. Priority routing for each request. Different connection pools are used based on the priority selected for the request. Also, circuit-breaker configuration at destination cluster is chosen based on selected priority. Default routing mechanism High-Priority routing mechanism. Possible values are `DEFAULT`, `HIGH`. Defaults to `DEFAULT`.",
											Optional: true,
										},
										"request_cookies_to_remove": schema.ListAttribute{
											MarkdownDescription: "Remove Cookies from Cookie Header. List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
											Optional: true,
											ElementType: types.StringType,
										},
										"request_headers_to_remove": schema.ListAttribute{
											MarkdownDescription: "Remove Request Headers. List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
											Optional: true,
											ElementType: types.StringType,
										},
										"response_cookies_to_remove": schema.ListAttribute{
											MarkdownDescription: "Remove Cookies from Set-Cookie Headers. List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed",
											Optional: true,
											ElementType: types.StringType,
										},
										"response_headers_to_remove": schema.ListAttribute{
											MarkdownDescription: "Remove Response Headers. List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
											Optional: true,
											ElementType: types.StringType,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. The timeout for the route including all retries, in milliseconds. Should be set to a high value or 0 (infinite timeout) for server-side streaming.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"app_firewall": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"bot_defense_javascript_injection": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Defense Javascript Injection Configuration for inline deployments. Bot Defense Javascript Injection Configuration for inline bot defense deployments",
											Attributes: map[string]schema.Attribute{
												"javascript_location": schema.StringAttribute{
													MarkdownDescription: "JavaScript Location. All inside networks. Insert JavaScript after <head> tag Insert JavaScript after </title> tag. Insert JavaScript before first <script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"javascript_tags": schema.ListNestedBlock{
													MarkdownDescription: "JavaScript Tags. Select Add item to configure your javascript tag. If adding both Bot Adv and Fraud, the Bot Javascript should be added first.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"javascript_url": schema.StringAttribute{
																MarkdownDescription: "URL. Please enter the full URL (include domain and path), or relative path.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"tag_attributes": schema.ListNestedBlock{
																MarkdownDescription: "Tag Attributes. Add the tag attributes you want to include in your Javascript tag.",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"javascript_tag": schema.StringAttribute{
																			MarkdownDescription: "Tag Attribute Name. Select from one of the predefined tag attributes. Possible values are `JS_ATTR_ID`, `JS_ATTR_CID`, `JS_ATTR_CN`, `JS_ATTR_API_DOMAIN`, `JS_ATTR_API_URL`, `JS_ATTR_API_PATH`, `JS_ATTR_ASYNC`, `JS_ATTR_DEFER`. Defaults to `JS_ATTR_ID`.",
																			Optional: true,
																		},
																		"tag_value": schema.StringAttribute{
																			MarkdownDescription: "Value. Add the tag attribute value.",
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										"buffer_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Buffer Configuration. Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config. Buffering can be enabled and disabled at VirtualHost and Route levels Route level buffer configuration takes precedence.",
											Attributes: map[string]schema.Attribute{
												"disabled": schema.BoolAttribute{
													MarkdownDescription: "Disable. Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host",
													Optional: true,
												},
												"max_request_bytes": schema.Int64Attribute{
													MarkdownDescription: "Max Request Bytes. The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
													Optional: true,
												},
											},
										},
										"common_buffering": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"common_hash_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"cors_policy": schema.SingleNestedBlock{
											MarkdownDescription: "CORS Policy. Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html Origin: http://foo.example HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2.0.61 Access-Control-Allow-Origin: * Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml An example for cross origin HTTP OPTIONS request with Access-Control-Request-* header OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type HTTP/1.1 204 No Content Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Keep-Alive: timeout=2, max=100 Connection: Keep-Alive",
											Attributes: map[string]schema.Attribute{
												"allow_credentials": schema.BoolAttribute{
													MarkdownDescription: "Allow Credentials. Specifies whether the resource allows credentials",
													Optional: true,
												},
												"allow_headers": schema.StringAttribute{
													MarkdownDescription: "Allow Headers. Specifies the content for the access-control-allow-headers header",
													Optional: true,
												},
												"allow_methods": schema.StringAttribute{
													MarkdownDescription: "Allow Methods. Specifies the content for the access-control-allow-methods header",
													Optional: true,
												},
												"allow_origin": schema.ListAttribute{
													MarkdownDescription: "Allow Origin. Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match",
													Optional: true,
													ElementType: types.StringType,
												},
												"allow_origin_regex": schema.ListAttribute{
													MarkdownDescription: "Allow Origin Regex. Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match",
													Optional: true,
													ElementType: types.StringType,
												},
												"disabled": schema.BoolAttribute{
													MarkdownDescription: "Disabled. Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host",
													Optional: true,
												},
												"expose_headers": schema.StringAttribute{
													MarkdownDescription: "Expose Headers. Specifies the content for the access-control-expose-headers header",
													Optional: true,
												},
												"maximum_age": schema.Int64Attribute{
													MarkdownDescription: "Maximum Age. Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours)",
													Optional: true,
												},
											},
										},
										"csrf_policy": schema.SingleNestedBlock{
											MarkdownDescription: "CSRF Policy. To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.The policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to issue the request (source origin). 2. The origin that the request is going to (target origin). When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being if the source-origin has been added to they policy as valid. Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"all_load_balancer_domains": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"custom_domain_list": schema.SingleNestedBlock{
													MarkdownDescription: "Domain name list. List of domain names used for Host header matching",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domain names. A list of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
												"disabled": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
										"default_retry_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"disable_mirroring": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"disable_prefix_rewrite": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"disable_spdy": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"disable_waf": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"disable_web_socket_config": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"do_not_retract_cluster": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"enable_spdy": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"endpoint_subsets": schema.SingleNestedBlock{
											MarkdownDescription: "Origin Servers Subsets. Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8S or Consul cluster, the label of the service is merged with endpoint's labels. In case of Consul, the label is derived from the 'Tag' field. For labels that are common between configured endpoint and discovered service, labels from discovered service takes precedence. List of key-value pairs that will be used as matching metadata. Only those origin servers of upstream origin pool which match this metadata will be selected for load balancing",
										},
										"inherited_bot_defense_javascript_injection": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"inherited_waf": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"inherited_waf_exclusion": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"mirror_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Mirror Policy. MirrorPolicy is used for shadowing traffic from one origin pool to another. The approach used is 'fire and forget', meaning it will not wait for the shadow origin pool to respond before returning the response from the primary origin pool. All normal statistics are collected for the shadow origin pool making this feature useful for testing and troubleshooting.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"origin_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
												"percent": schema.SingleNestedBlock{
													MarkdownDescription: "Fractional Percent. Fraction used where sampling percentages are needed. example sampled requests",
													Attributes: map[string]schema.Attribute{
														"denominator": schema.StringAttribute{
															MarkdownDescription: "Denominator. Denominator used in fraction where sampling percentages are needed. example sampled requests Use hundred as denominator Use ten thousand as denominator Use million as denominator. Possible values are `HUNDRED`, `TEN_THOUSAND`, `MILLION`. Defaults to `HUNDRED`.",
															Optional: true,
														},
														"numerator": schema.Int64Attribute{
															MarkdownDescription: "Numerator. sampled parts per denominator. If denominator was 10000, then value of 5 will be 5 in 10000",
															Optional: true,
														},
													},
												},
											},
										},
										"no_retry_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"regex_rewrite": schema.SingleNestedBlock{
											MarkdownDescription: "Regex Match Rewrite. RegexMatchRewrite describes how to match a string and then produce a new string using a regular expression and a substitution string.",
											Attributes: map[string]schema.Attribute{
												"pattern": schema.StringAttribute{
													MarkdownDescription: "Pattern. The regular expression used to find portions of a string that should be replaced.",
													Optional: true,
												},
												"substitution": schema.StringAttribute{
													MarkdownDescription: "Substitution. The string that should be substituted into matching portions of the subject string during a substitution operation to produce a new string.",
													Optional: true,
												},
											},
										},
										"request_cookies_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Add Cookies in Cookie Header. Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. Name of the cookie in Cookie header.",
														Optional: true,
													},
													"overwrite": schema.BoolAttribute{
														MarkdownDescription: "Overwrite. Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
														Optional: true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value. Value of the Cookie header.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"request_headers_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Add Request Headers. Headers are key-value pairs to be added to HTTP request being routed towards upstream.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"append": schema.BoolAttribute{
														MarkdownDescription: "Append. Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. Name of the HTTP header.",
														Optional: true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value. Value of the HTTP header.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"response_cookies_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Add Set-Cookie Headers. Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"add_domain": schema.StringAttribute{
														MarkdownDescription: "Add Domain. Add domain attribute",
														Optional: true,
													},
													"add_expiry": schema.StringAttribute{
														MarkdownDescription: "Add expiry. Add expiry attribute",
														Optional: true,
													},
													"add_path": schema.StringAttribute{
														MarkdownDescription: "Add path. Add path attribute",
														Optional: true,
													},
													"max_age_value": schema.Int64Attribute{
														MarkdownDescription: "Add Max Age. Add max age attribute",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. Name of the cookie in Cookie header.",
														Optional: true,
													},
													"overwrite": schema.BoolAttribute{
														MarkdownDescription: "Overwrite. Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
														Optional: true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value. Value of the Cookie header.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"add_httponly": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"add_partitioned": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"add_secure": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_domain": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_expiry": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_httponly": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_max_age": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_partitioned": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_path": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_samesite": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_secure": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ignore_value": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"samesite_lax": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"samesite_none": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"samesite_strict": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"response_headers_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Add Response Headers. Headers are key-value pairs to be added to HTTP response being sent towards downstream.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"append": schema.BoolAttribute{
														MarkdownDescription: "Append. Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. Name of the HTTP header.",
														Optional: true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value. Value of the HTTP header.",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional: true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																		Optional: true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																		Optional: true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																		Optional: true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"retract_cluster": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"retry_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Retry Policy. Retry policy configuration for route destination.",
											Attributes: map[string]schema.Attribute{
												"num_retries": schema.Int64Attribute{
													MarkdownDescription: "Number of Retries. Specifies the allowed number of retries. Retries can be done any number of times. An exponential back-off algorithm is used between each retry. Defaults to `1`.",
													Optional: true,
												},
												"per_try_timeout": schema.Int64Attribute{
													MarkdownDescription: "Per Try Timeout. Specifies a non-zero timeout per retry attempt. In milliseconds",
													Optional: true,
												},
												"retriable_status_codes": schema.ListAttribute{
													MarkdownDescription: "Status Code to Retry. HTTP status codes that should trigger a retry in addition to those specified by retry_on.",
													Optional: true,
													ElementType: types.Int64Type,
												},
												"retry_condition": schema.ListAttribute{
													MarkdownDescription: "Retry Condition. Specifies the conditions under which retry takes place. Retries can be on different types of condition depending on application requirements. For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc The possible values are '5xx' : Retry will be done if the upstream server responds with any 5xx response code, or does not respond at all (disconnect/reset/read timeout). 'gateway-error' : Retry will be done only if the upstream server responds with 502, 503 or 504 responses (Included in 5xx) 'connect-failure' : Retry will be done if the request fails because of a connection failure to the upstream server (connect timeout, etc.). (Included in 5xx) 'refused-stream' : Retry is done if the upstream server resets the stream with a REFUSED_STREAM error code (Included in 5xx) 'retriable-4xx' : Retry is done if the upstream server responds with a retriable 4xx response code. The only response code in this category is HTTP CONFLICT (409) 'retriable-status-codes' : Retry is done if the upstream server responds with any response code matching one defined in retriable_status_codes field 'reset' : Retry is done if the upstream server does not respond at all (disconnect/reset/read timeout.)",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"back_off": schema.SingleNestedBlock{
													MarkdownDescription: "Retry BackOff Interval. Specifies parameters that control retry back off.",
													Attributes: map[string]schema.Attribute{
														"base_interval": schema.Int64Attribute{
															MarkdownDescription: "Base Retry Interval. Specifies the base interval between retries in milliseconds",
															Optional: true,
														},
														"max_interval": schema.Int64Attribute{
															MarkdownDescription: "Maximum Retry Interval. Specifies the maximum interval between retries in milliseconds. This parameter is optional, but must be greater than or equal to the base_interval if set. The  times the base_interval. Defaults to `10`.",
															Optional: true,
														},
													},
												},
											},
										},
										"specific_hash_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Policy List. List of hash policy rules",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"hash_policy": schema.ListNestedBlock{
													MarkdownDescription: "Hash Policy. Specifies a list of hash policies to use for ring hash load balancing. Each hash policy is evaluated individually and the combined result is used to route the request",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"header_name": schema.StringAttribute{
																MarkdownDescription: "Header Name. The name or key of the request header that will be used to obtain the hash key",
																Optional: true,
															},
															"source_ip": schema.BoolAttribute{
																MarkdownDescription: "Source IP. Hash based on source IP address",
																Optional: true,
															},
															"terminal": schema.BoolAttribute{
																MarkdownDescription: "Terminal. Specify if its a terminal policy",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"cookie": schema.SingleNestedBlock{
																MarkdownDescription: "Hashing using Cookie. Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets sent to. The client then presents this on the next and all subsequent requests. The hash of this is sufficient to ensure these requests get sent to the same endpoint. The cookie is generated by hashing the source and destination ports and addresses so that multiple independent HTTP2 streams on the same connection will independently receive the same cookie, even if they arrive simultaneously.",
																Attributes: map[string]schema.Attribute{
																	"name": schema.StringAttribute{
																		MarkdownDescription: "Name. The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced",
																		Optional: true,
																	},
																	"path": schema.StringAttribute{
																		MarkdownDescription: "Path. The name of the path for the cookie. If no path is specified here, no path will be set for the cookie",
																		Optional: true,
																	},
																	"ttl": schema.Int64Attribute{
																		MarkdownDescription: "TTL. If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"add_httponly": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"add_secure": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"ignore_httponly": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"ignore_samesite": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"ignore_secure": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"samesite_lax": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"samesite_none": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"samesite_strict": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
														},
													},
												},
											},
										},
										"waf_exclusion_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"web_socket_config": schema.SingleNestedBlock{
											MarkdownDescription: "Websocket Configuration. Configuration to allow Websocket Request headers of such upgrade looks like below 'connection', 'Upgrade' 'upgrade', 'websocket' With configuration to allow websocket upgrade, ADC will produce following response 'HTTP/1.1 101 Switching Protocols 'Upgrade': 'websocket' 'Connection': 'Upgrade'",
											Attributes: map[string]schema.Attribute{
												"use_websocket": schema.BoolAttribute{
													MarkdownDescription: "Use Websocket. Specifies that the HTTP client connection to this route is allowed to upgrade to a WebSocket connection",
													Optional: true,
												},
											},
										},
									},
								},
								"auto_host_rewrite": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"disable_host_rewrite": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "Headers. List of (key, value) headers",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
								"incoming_port": schema.SingleNestedBlock{
									MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
									Attributes: map[string]schema.Attribute{
										"port": schema.Int64Attribute{
											MarkdownDescription: "Port. Exact Port to match",
											Optional: true,
										},
										"port_ranges": schema.StringAttribute{
											MarkdownDescription: "Port range. Port range to match",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"no_port_match": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"origin_pools": schema.ListNestedBlock{
									MarkdownDescription: "Origin Pools. Origin Pools for this route",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"priority": schema.Int64Attribute{
												MarkdownDescription: "Priority. Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the increasing priority.",
												Optional: true,
											},
											"weight": schema.Int64Attribute{
												MarkdownDescription: "Weight. Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"cluster": schema.SingleNestedBlock{
												MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
												},
											},
											"endpoint_subsets": schema.SingleNestedBlock{
												MarkdownDescription: "Origin Servers Subsets. Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8S or Consul cluster, the label of the service is merged with endpoint's labels. In case of Consul, the label is derived from the 'Tag' field. For labels that are common between configured endpoint and discovered service, labels from discovered service takes precedence. List of key-value pairs that will be used as matching metadata. Only those origin servers of upstream origin pool which match this metadata will be selected for load balancing",
											},
											"pool": schema.SingleNestedBlock{
												MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
														Optional: true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
														Optional: true,
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
														Optional: true,
													},
												},
											},
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact. Exact path value to match",
											Optional: true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
											Optional: true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
											Optional: true,
										},
									},
								},
								"query_params": schema.SingleNestedBlock{
									MarkdownDescription: "Query Parameters. Handling of incoming query parameters in simple route.",
									Attributes: map[string]schema.Attribute{
										"replace_params": schema.StringAttribute{
											MarkdownDescription: "Replace All Parameters.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"remove_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"retain_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
					},

				},
			},
			"sensitive_data_disclosure_rules": schema.SingleNestedBlock{
				MarkdownDescription: "Sensitive Data Exposure Rules. Sensitive Data Exposure Rules allows specifying rules to mask sensitive data fields in API responses",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"sensitive_data_types_in_response": schema.ListNestedBlock{
						MarkdownDescription: "Sensitive Data Exposure Rules. Sensitive Data Exposure Rules allows specifying rules to mask sensitive data fields in API responses",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"api_endpoint": schema.SingleNestedBlock{
									MarkdownDescription: "API Endpoint. This defines api endpoint",
									Attributes: map[string]schema.Attribute{
										"methods": schema.ListAttribute{
											MarkdownDescription: "Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path to be matched",
											Optional: true,
										},
									},
								},
								"body": schema.SingleNestedBlock{
									MarkdownDescription: "Body Section Masking Options. Options for HTTP Body Masking",
									Attributes: map[string]schema.Attribute{
										"fields": schema.ListAttribute{
											MarkdownDescription: "Values. List of JSON Path field values. Use square brackets with an underscore [_] to indicate array elements (e.g., person.emails[_]). To reference JSON keys that contain spaces, enclose the entire path in double quotes. For example: 'person.first name'.",
											Optional: true,
											ElementType: types.StringType,
										},
									},
								},
								"mask": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"report": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
					},
				},

			},
			"sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Sensitive Data Discovery. Settings for data type policy",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"sensitive_data_policy_ref": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
			"service_policies_from_namespace": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"single_lb_app": schema.SingleNestedBlock{
				MarkdownDescription: "Single Load Balancer App Setting. Specific settings for Machine learning analysis on this HTTP LB, independently from other LBs.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"disable_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"disable_malicious_user_detection": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "API Discovery Setting. Specifies the settings used for API discovery",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"api_crawler": schema.SingleNestedBlock{
								MarkdownDescription: "API Crawling. Api Crawler message",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"api_crawler_config": schema.SingleNestedBlock{
										MarkdownDescription: "Crawler Configure.",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"domains": schema.ListNestedBlock{
												MarkdownDescription: "Domains to Crawl. Enter domains and their credentials to allow authenticated API crawling. You can only include domains you own that are associated with this Load Balancer.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"domain": schema.StringAttribute{
															MarkdownDescription: "Domain. Select the domain to execute API Crawling with given credentials.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"simple_login": schema.SingleNestedBlock{
															MarkdownDescription: "Simple Login.",
															Attributes: map[string]schema.Attribute{
																"user": schema.StringAttribute{
																	MarkdownDescription: "User. Enter the username to assign credentials for the selected domain to crawl",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"password": schema.SingleNestedBlock{
																	MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"blindfold_secret_info": schema.SingleNestedBlock{
																			MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																			Attributes: map[string]schema.Attribute{
																				"decryption_provider": schema.StringAttribute{
																					MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																					Optional: true,
																				},
																				"location": schema.StringAttribute{
																					MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																					Optional: true,
																				},
																				"store_provider": schema.StringAttribute{
																					MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																					Optional: true,
																				},
																			},
																		},
																		"clear_secret_info": schema.SingleNestedBlock{
																			MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																			Attributes: map[string]schema.Attribute{
																				"provider_ref": schema.StringAttribute{
																					MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																					Optional: true,
																				},
																				"url": schema.StringAttribute{
																					MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																					Optional: true,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"disable_api_crawler": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"api_discovery_from_code_scan": schema.SingleNestedBlock{
								MarkdownDescription: "Select Code Base and Repositories. x-required",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"code_base_integrations": schema.ListNestedBlock{
										MarkdownDescription: "Select Code Base Integrations.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"all_repos": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"code_base_integration": schema.SingleNestedBlock{
													MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
															Optional: true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
															Optional: true,
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
															Optional: true,
														},
													},
												},
												"selected_repos": schema.SingleNestedBlock{
													MarkdownDescription: "API Code Repositories. Select which API repositories represent the LB applications",
													Attributes: map[string]schema.Attribute{
														"api_code_repo": schema.ListAttribute{
															MarkdownDescription: "API Code Repository. Code repository which contain API endpoints",
															Optional: true,
															ElementType: types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
							"custom_api_auth_discovery": schema.SingleNestedBlock{
								MarkdownDescription: "API Discovery Advanced Settings. API Discovery Advanced settings",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"api_discovery_ref": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
								},
							},
							"default_api_auth_discovery": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_learn_from_redirect_traffic": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"discovered_api_settings": schema.SingleNestedBlock{
								MarkdownDescription: "Discovered API Settings. x-example: '2' Configure Discovered API Settings.",
								Attributes: map[string]schema.Attribute{
									"purge_duration_for_inactive_discovered_apis": schema.Int64Attribute{
										MarkdownDescription: "Purge Duration for Inactive Discovered APIs from Traffic. Inactive discovered API will be deleted after configured duration.",
										Optional: true,
									},
								},
							},
							"enable_learn_from_redirect_traffic": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"enable_malicious_user_detection": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"slow_ddos_mitigation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: slow_ddos_mitigation, system_default_timeouts] Slow DDoS Mitigation. 'Slow and low' attacks tie up server resources, leaving none available for servicing requests from actual users.",
				Attributes: map[string]schema.Attribute{
					"request_headers_timeout": schema.Int64Attribute{
						MarkdownDescription: "Request Headers Timeout. The amount of time the client has to send only the headers on the request stream before the stream is cancelled. The  milliseconds. This setting provides protection against Slowloris attacks. Defaults to `10000`.",
						Optional: true,
					},
					"request_timeout": schema.Int64Attribute{
						MarkdownDescription: "Custom Timeout.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_request_timeout": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"source_ip_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"system_default_timeouts": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"trusted_clients": schema.ListNestedBlock{
				MarkdownDescription: "Trusted Client Rules. Define rules to skip processing of one or more features such as WAF, Bot Defense etc. for clients.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "Actions. Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional: true,
							ElementType: types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "AS Number. RFC 6793 defined 4-byte AS number",
							Optional: true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional: true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 Prefix. IPv4 prefix string.",
							Optional: true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 Prefix. IPv6 prefix string.",
							Optional: true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "User Identifier. Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs",
							Attributes: map[string]schema.Attribute{
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "HTTP Headers. List of HTTP header name and value pairs",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Exact. Header value to match exactly",
												Optional: true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
												Optional: true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header",
												Optional: true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "Presence. If true, check for presence of header",
												Optional: true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex. Regex match of the header value in re2 format",
												Optional: true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
									Optional: true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
						},
					},

				},
			},
			"user_id_client_ip": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: user_id_client_ip, user_identification] Empty. This can be used for messages where no values are needed",
			},
			"user_identification": schema.SingleNestedBlock{
				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"waf_exclusion": schema.SingleNestedBlock{
				MarkdownDescription: "WAF Exclusion.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"waf_exclusion_inline_rules": schema.SingleNestedBlock{
						MarkdownDescription: "WAF Exclusion Inline Rules. A list of WAF exclusion rules that will be applied inline",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "WAF Exclusion Rules. An ordered list of WAF Exclusions specific to this Load Balancer.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"exact_value": schema.StringAttribute{
											MarkdownDescription: "Exact Value. Exact domain name",
											Optional: true,
										},
										"expiration_timestamp": schema.StringAttribute{
											MarkdownDescription: "Expiration Timestamp. The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
											Optional: true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "Methods. methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional: true,
											ElementType: types.StringType,
										},
										"path_prefix": schema.StringAttribute{
											MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
											Optional: true,
										},
										"path_regex": schema.StringAttribute{
											MarkdownDescription: "Path Regex. Define the regex for the path. For example, the regex ^/.*$ will match on all paths",
											Optional: true,
										},
										"suffix_value": schema.StringAttribute{
											MarkdownDescription: "Suffix Value. Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"any_path": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"app_firewall_detection_control": schema.SingleNestedBlock{
											MarkdownDescription: "App Firewall Detection Control. Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"exclude_attack_type_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Attack Types. Attack Types to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "WAF Exclusion Context Options. The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE: CONTEXT_RESPONSE - CONTEXT_PARAMETER: CONTEXT_PARAMETER Detection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters. - CONTEXT_HEADER: CONTEXT_HEADER Detection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers. - CONTEXT_COOKIE: CONTEXT_COOKIE Detection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies. - CONTEXT_URL: CONTEXT_URL Detection will be excluded for the request URL. - CONTEXT_URI: CONTEXT_URI. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional: true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Context Name. Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional: true,
															},
															"exclude_attack_type": schema.StringAttribute{
																MarkdownDescription: "Attack Types. List of all Attack Types ATTACK_TYPE_NONE ATTACK_TYPE_NON_BROWSER_CLIENT ATTACK_TYPE_OTHER_APPLICATION_ATTACKS ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE ATTACK_TYPE_DETECTION_EVASION ATTACK_TYPE_VULNERABILITY_SCAN ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS ATTACK_TYPE_BUFFER_OVERFLOW ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION ATTACK_TYPE_INFORMATION_LEAKAGE ATTACK_TYPE_DIRECTORY_INDEXING ATTACK_TYPE_PATH_TRAVERSAL ATTACK_TYPE_XPATH_INJECTION ATTACK_TYPE_LDAP_INJECTION ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION ATTACK_TYPE_COMMAND_EXECUTION ATTACK_TYPE_SQL_INJECTION ATTACK_TYPE_CROSS_SITE_SCRIPTING ATTACK_TYPE_DENIAL_OF_SERVICE ATTACK_TYPE_HTTP_PARSER_ATTACK ATTACK_TYPE_SESSION_HIJACKING ATTACK_TYPE_HTTP_RESPONSE_SPLITTING ATTACK_TYPE_FORCEFUL_BROWSING ATTACK_TYPE_REMOTE_FILE_INCLUDE ATTACK_TYPE_MALICIOUS_FILE_UPLOAD ATTACK_TYPE_GRAPHQL_PARSER_ATTACK. Possible values are `ATTACK_TYPE_NONE`, `ATTACK_TYPE_NON_BROWSER_CLIENT`, `ATTACK_TYPE_OTHER_APPLICATION_ATTACKS`, `ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE`, `ATTACK_TYPE_DETECTION_EVASION`, `ATTACK_TYPE_VULNERABILITY_SCAN`, `ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY`, `ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS`, `ATTACK_TYPE_BUFFER_OVERFLOW`, `ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION`, `ATTACK_TYPE_INFORMATION_LEAKAGE`, `ATTACK_TYPE_DIRECTORY_INDEXING`, `ATTACK_TYPE_PATH_TRAVERSAL`, `ATTACK_TYPE_XPATH_INJECTION`, `ATTACK_TYPE_LDAP_INJECTION`, `ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION`, `ATTACK_TYPE_COMMAND_EXECUTION`, `ATTACK_TYPE_SQL_INJECTION`, `ATTACK_TYPE_CROSS_SITE_SCRIPTING`, `ATTACK_TYPE_DENIAL_OF_SERVICE`, `ATTACK_TYPE_HTTP_PARSER_ATTACK`, `ATTACK_TYPE_SESSION_HIJACKING`, `ATTACK_TYPE_HTTP_RESPONSE_SPLITTING`, `ATTACK_TYPE_FORCEFUL_BROWSING`, `ATTACK_TYPE_REMOTE_FILE_INCLUDE`, `ATTACK_TYPE_MALICIOUS_FILE_UPLOAD`, `ATTACK_TYPE_GRAPHQL_PARSER_ATTACK`. Defaults to `ATTACK_TYPE_NONE`.",
																Optional: true,
															},
														},
													},
												},
												"exclude_bot_name_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Bot Names. Bot Names to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"bot_name": schema.StringAttribute{
																MarkdownDescription: "Bot Name.",
																Optional: true,
															},
														},
													},
												},
												"exclude_signature_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Signature IDs. Signature IDs to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "WAF Exclusion Context Options. The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE: CONTEXT_RESPONSE - CONTEXT_PARAMETER: CONTEXT_PARAMETER Detection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters. - CONTEXT_HEADER: CONTEXT_HEADER Detection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers. - CONTEXT_COOKIE: CONTEXT_COOKIE Detection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies. - CONTEXT_URL: CONTEXT_URL Detection will be excluded for the request URL. - CONTEXT_URI: CONTEXT_URI. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional: true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Context Name. Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional: true,
															},
															"signature_id": schema.Int64Attribute{
																MarkdownDescription: "SignatureID. The allowed values for signature id are 0 and in the range of 200000001-299999999. 0 implies that all signatures will be excluded for the specified context.",
																Optional: true,
															},
														},
													},
												},
												"exclude_violation_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Violations. Violations to be excluded for the defined match criteria",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "WAF Exclusion Context Options. The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE: CONTEXT_RESPONSE - CONTEXT_PARAMETER: CONTEXT_PARAMETER Detection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters. - CONTEXT_HEADER: CONTEXT_HEADER Detection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers. - CONTEXT_COOKIE: CONTEXT_COOKIE Detection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies. - CONTEXT_URL: CONTEXT_URL Detection will be excluded for the request URL. - CONTEXT_URI: CONTEXT_URI. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional: true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Context Name. Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional: true,
															},
															"exclude_violation": schema.StringAttribute{
																MarkdownDescription: "App Firewall Violation Type. List of all supported Violation Types VIOL_NONE VIOL_FILETYPE VIOL_METHOD VIOL_MANDATORY_HEADER VIOL_HTTP_RESPONSE_STATUS VIOL_REQUEST_MAX_LENGTH VIOL_FILE_UPLOAD VIOL_FILE_UPLOAD_IN_BODY VIOL_XML_MALFORMED VIOL_JSON_MALFORMED VIOL_ASM_COOKIE_MODIFIED VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER VIOL_EVASION_DIRECTORY_TRAVERSALS VIOL_MALFORMED_REQUEST VIOL_EVASION_MULTIPLE_DECODING VIOL_DATA_GUARD VIOL_EVASION_APACHE_WHITESPACE VIOL_COOKIE_MODIFIED VIOL_EVASION_IIS_UNICODE_CODEPOINTS VIOL_EVASION_IIS_BACKSLASHES VIOL_EVASION_PERCENT_U_DECODING VIOL_EVASION_BARE_BYTE_DECODING VIOL_EVASION_BAD_UNESCAPE VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS VIOL_ENCODING VIOL_COOKIE_MALFORMED VIOL_GRAPHQL_FORMAT VIOL_GRAPHQL_MALFORMED VIOL_GRAPHQL_INTROSPECTION_QUERY. Possible values are `VIOL_NONE`, `VIOL_FILETYPE`, `VIOL_METHOD`, `VIOL_MANDATORY_HEADER`, `VIOL_HTTP_RESPONSE_STATUS`, `VIOL_REQUEST_MAX_LENGTH`, `VIOL_FILE_UPLOAD`, `VIOL_FILE_UPLOAD_IN_BODY`, `VIOL_XML_MALFORMED`, `VIOL_JSON_MALFORMED`, `VIOL_ASM_COOKIE_MODIFIED`, `VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS`, `VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE`, `VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT`, `VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST`, `VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION`, `VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS`, `VIOL_EVASION_DIRECTORY_TRAVERSALS`, `VIOL_MALFORMED_REQUEST`, `VIOL_EVASION_MULTIPLE_DECODING`, `VIOL_DATA_GUARD`, `VIOL_EVASION_APACHE_WHITESPACE`, `VIOL_COOKIE_MODIFIED`, `VIOL_EVASION_IIS_UNICODE_CODEPOINTS`, `VIOL_EVASION_IIS_BACKSLASHES`, `VIOL_EVASION_PERCENT_U_DECODING`, `VIOL_EVASION_BARE_BYTE_DECODING`, `VIOL_EVASION_BAD_UNESCAPE`, `VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST`, `VIOL_ENCODING`, `VIOL_COOKIE_MALFORMED`, `VIOL_GRAPHQL_FORMAT`, `VIOL_GRAPHQL_MALFORMED`, `VIOL_GRAPHQL_INTROSPECTION_QUERY`. Defaults to `VIOL_NONE`.",
																Optional: true,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "Message Metadata. MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create and replace APIs.",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. This is the name of the message. The value of name has to follow DNS-1035 format.",
													Optional: true,
												},
											},
										},
										"waf_skip_processing": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
					},
					"waf_exclusion_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
				},

			},
		},
	}
}

func (r *HTTPLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *HTTPLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *HTTPLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the http_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan HTTPLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *HTTPLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := HTTPLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *HTTPLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating http_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.HTTPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6Vip != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVip != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6Vip.IsNull() && !listItem.VirtualNetwork.SpecificV6Vip.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6Vip.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVip.IsNull() && !listItem.VirtualNetwork.SpecificVip.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVip.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVip != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVip.IP.IsNull() && !listItem.VirtualSiteWithVip.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVip.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVip.Network.IsNull() && !listItem.VirtualSiteWithVip.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVip.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		apiResource.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVip != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		apiResource.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.APIProtectionRules != nil {
		api_protection_rulesMap := make(map[string]interface{})
		if len(data.APIProtectionRules.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if len(data.APIProtectionRules.APIGroupsRules) > 0 {
			var api_groups_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIGroupsRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_groups_rulesList = append(api_groups_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_groups_rules"] = api_groups_rulesList
		}
		apiResource.Spec["api_protection_rules"] = api_protection_rulesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		apiResource.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["api_specification"] = api_specificationMap
	}
	if data.APITesting != nil {
		api_testingMap := make(map[string]interface{})
		if !data.APITesting.CustomHeaderValue.IsNull() && !data.APITesting.CustomHeaderValue.IsUnknown() {
			api_testingMap["custom_header_value"] = data.APITesting.CustomHeaderValue.ValueString()
		}
		if len(data.APITesting.Domains) > 0 {
			var domainsList []map[string]interface{}
			for _, listItem := range data.APITesting.Domains {
				listItemMap := make(map[string]interface{})
				if !listItem.AllowDestructiveMethods.IsNull() && !listItem.AllowDestructiveMethods.IsUnknown() {
					listItemMap["allow_destructive_methods"] = listItem.AllowDestructiveMethods.ValueBool()
				}
				if !listItem.Domain.IsNull() && !listItem.Domain.IsUnknown() {
					listItemMap["domain"] = listItem.Domain.ValueString()
				}
				domainsList = append(domainsList, listItemMap)
			}
			api_testingMap["domains"] = domainsList
		}
		if data.APITesting.EveryDay != nil {
			api_testingMap["every_day"] = map[string]interface{}{}
		}
		if data.APITesting.EveryMonth != nil {
			api_testingMap["every_month"] = map[string]interface{}{}
		}
		if data.APITesting.EveryWeek != nil {
			api_testingMap["every_week"] = map[string]interface{}{}
		}
		apiResource.Spec["api_testing"] = api_testingMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		apiResource.Spec["app_firewall"] = app_firewallMap
	}
	if len(data.BlockedClients) > 0 {
		var blocked_clientsList []map[string]interface{}
		for _, item := range data.BlockedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			blocked_clientsList = append(blocked_clientsList, itemMap)
		}
		apiResource.Spec["blocked_clients"] = blocked_clientsList
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCorsSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCorsSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		apiResource.Spec["bot_defense"] = bot_defenseMap
	}
	if data.BotDefenseAdvanced != nil {
		bot_defense_advancedMap := make(map[string]interface{})
		if data.BotDefenseAdvanced.DisableJsInsert != nil {
			bot_defense_advancedMap["disable_js_insert"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.DisableMobileSdk != nil {
			bot_defense_advancedMap["disable_mobile_sdk"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.JsInsertAllPages != nil {
			js_insert_all_pagesNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsUnknown() {
				js_insert_all_pagesNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages"] = js_insert_all_pagesNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertAllPagesExcept != nil {
			js_insert_all_pages_exceptNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsUnknown() {
				js_insert_all_pages_exceptNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages_except"] = js_insert_all_pages_exceptNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertionRules != nil {
			js_insertion_rulesNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["js_insertion_rules"] = js_insertion_rulesNestedMap
		}
		if data.BotDefenseAdvanced.Mobile != nil {
			mobileNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Mobile.Name.IsNull() && !data.BotDefenseAdvanced.Mobile.Name.IsUnknown() {
				mobileNestedMap["name"] = data.BotDefenseAdvanced.Mobile.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Namespace.IsNull() && !data.BotDefenseAdvanced.Mobile.Namespace.IsUnknown() {
				mobileNestedMap["namespace"] = data.BotDefenseAdvanced.Mobile.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Tenant.IsNull() && !data.BotDefenseAdvanced.Mobile.Tenant.IsUnknown() {
				mobileNestedMap["tenant"] = data.BotDefenseAdvanced.Mobile.Tenant.ValueString()
			}
			bot_defense_advancedMap["mobile"] = mobileNestedMap
		}
		if data.BotDefenseAdvanced.MobileSdkConfig != nil {
			mobile_sdk_configNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["mobile_sdk_config"] = mobile_sdk_configNestedMap
		}
		if data.BotDefenseAdvanced.Web != nil {
			webNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Web.Name.IsNull() && !data.BotDefenseAdvanced.Web.Name.IsUnknown() {
				webNestedMap["name"] = data.BotDefenseAdvanced.Web.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Namespace.IsNull() && !data.BotDefenseAdvanced.Web.Namespace.IsUnknown() {
				webNestedMap["namespace"] = data.BotDefenseAdvanced.Web.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Tenant.IsNull() && !data.BotDefenseAdvanced.Web.Tenant.IsUnknown() {
				webNestedMap["tenant"] = data.BotDefenseAdvanced.Web.Tenant.ValueString()
			}
			bot_defense_advancedMap["web"] = webNestedMap
		}
		apiResource.Spec["bot_defense_advanced"] = bot_defense_advancedMap
	}
	if data.CachingPolicy != nil {
		caching_policyMap := make(map[string]interface{})
		if data.CachingPolicy.CustomCacheRule != nil {
			custom_cache_ruleNestedMap := make(map[string]interface{})
			caching_policyMap["custom_cache_rule"] = custom_cache_ruleNestedMap
		}
		if data.CachingPolicy.DefaultCacheAction != nil {
			default_cache_actionNestedMap := make(map[string]interface{})
			if !data.CachingPolicy.DefaultCacheAction.CacheTtlDefault.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTtlDefault.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_default"] = data.CachingPolicy.DefaultCacheAction.CacheTtlDefault.ValueString()
			}
			if !data.CachingPolicy.DefaultCacheAction.CacheTtlOverride.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTtlOverride.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_override"] = data.CachingPolicy.DefaultCacheAction.CacheTtlOverride.ValueString()
			}
			caching_policyMap["default_cache_action"] = default_cache_actionNestedMap
		}
		apiResource.Spec["caching_policy"] = caching_policyMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		apiResource.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		apiResource.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CookieStickiness != nil {
		cookie_stickinessMap := make(map[string]interface{})
		if data.CookieStickiness.AddHttponly != nil {
			cookie_stickinessMap["add_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.AddSecure != nil {
			cookie_stickinessMap["add_secure"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreHttponly != nil {
			cookie_stickinessMap["ignore_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSamesite != nil {
			cookie_stickinessMap["ignore_samesite"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSecure != nil {
			cookie_stickinessMap["ignore_secure"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.Name.IsNull() && !data.CookieStickiness.Name.IsUnknown() {
			cookie_stickinessMap["name"] = data.CookieStickiness.Name.ValueString()
		}
		if !data.CookieStickiness.Path.IsNull() && !data.CookieStickiness.Path.IsUnknown() {
			cookie_stickinessMap["path"] = data.CookieStickiness.Path.ValueString()
		}
		if data.CookieStickiness.SamesiteLax != nil {
			cookie_stickinessMap["samesite_lax"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteNone != nil {
			cookie_stickinessMap["samesite_none"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteStrict != nil {
			cookie_stickinessMap["samesite_strict"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.Ttl.IsNull() && !data.CookieStickiness.Ttl.IsUnknown() {
			cookie_stickinessMap["ttl"] = data.CookieStickiness.Ttl.ValueInt64()
		}
		apiResource.Spec["cookie_stickiness"] = cookie_stickinessMap
	}
	if data.CorsPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CorsPolicy.AllowCredentials.IsNull() && !data.CorsPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CorsPolicy.AllowCredentials.ValueBool()
		}
		if !data.CorsPolicy.AllowHeaders.IsNull() && !data.CorsPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CorsPolicy.AllowHeaders.ValueString()
		}
		if !data.CorsPolicy.AllowMethods.IsNull() && !data.CorsPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CorsPolicy.AllowMethods.ValueString()
		}
		if !data.CorsPolicy.Disabled.IsNull() && !data.CorsPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CorsPolicy.Disabled.ValueBool()
		}
		if !data.CorsPolicy.ExposeHeaders.IsNull() && !data.CorsPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CorsPolicy.ExposeHeaders.ValueString()
		}
		if !data.CorsPolicy.MaximumAge.IsNull() && !data.CorsPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CorsPolicy.MaximumAge.ValueInt64()
		}
		apiResource.Spec["cors_policy"] = cors_policyMap
	}
	if data.CsrfPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CsrfPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CsrfPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CsrfPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["csrf_policy"] = csrf_policyMap
	}
	if len(data.DataGuardRules) > 0 {
		var data_guard_rulesList []map[string]interface{}
		for _, item := range data.DataGuardRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if item.ApplyDataGuard != nil {
				itemMap["apply_data_guard"] = map[string]interface{}{}
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.Path != nil {
				pathNestedMap := make(map[string]interface{})
				if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
					pathNestedMap["path"] = item.Path.Path.ValueString()
				}
				if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
					pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
				}
				if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
					pathNestedMap["regex"] = item.Path.Regex.ValueString()
				}
				itemMap["path"] = pathNestedMap
			}
			if item.SkipDataGuard != nil {
				itemMap["skip_data_guard"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			data_guard_rulesList = append(data_guard_rulesList, itemMap)
		}
		apiResource.Spec["data_guard_rules"] = data_guard_rulesList
	}
	if len(data.DdosMitigationRules) > 0 {
		var ddos_mitigation_rulesList []map[string]interface{}
		for _, item := range data.DdosMitigationRules {
			itemMap := make(map[string]interface{})
			if item.Block != nil {
				itemMap["block"] = map[string]interface{}{}
			}
			if item.DdosClientSource != nil {
				ddos_client_sourceNestedMap := make(map[string]interface{})
				if !item.DdosClientSource.CountryList.IsNull() && !item.DdosClientSource.CountryList.IsUnknown() {
					var CountryListItems []string
					diags := item.DdosClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
					if !diags.HasError() {
						ddos_client_sourceNestedMap["country_list"] = CountryListItems
					}
				}
				itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.IPPrefixList != nil {
				ip_prefix_listNestedMap := make(map[string]interface{})
				if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
					ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
				}
				if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
					var IPPrefixesItems []string
					diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
					if !diags.HasError() {
						ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
					}
				}
				itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
		}
		apiResource.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
	}
	if data.DefaultPool != nil {
		default_poolMap := make(map[string]interface{})
		if data.DefaultPool.AdvancedOptions != nil {
			advanced_optionsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsUnknown() {
				advanced_optionsNestedMap["connection_timeout"] = data.DefaultPool.AdvancedOptions.ConnectionTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsUnknown() {
				advanced_optionsNestedMap["http_idle_timeout"] = data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.PanicThreshold.IsNull() && !data.DefaultPool.AdvancedOptions.PanicThreshold.IsUnknown() {
				advanced_optionsNestedMap["panic_threshold"] = data.DefaultPool.AdvancedOptions.PanicThreshold.ValueInt64()
			}
			default_poolMap["advanced_options"] = advanced_optionsNestedMap
		}
		if data.DefaultPool.AutomaticPort != nil {
			default_poolMap["automatic_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.EndpointSelection.IsNull() && !data.DefaultPool.EndpointSelection.IsUnknown() {
			default_poolMap["endpoint_selection"] = data.DefaultPool.EndpointSelection.ValueString()
		}
		if !data.DefaultPool.HealthCheckPort.IsNull() && !data.DefaultPool.HealthCheckPort.IsUnknown() {
			default_poolMap["health_check_port"] = data.DefaultPool.HealthCheckPort.ValueInt64()
		}
		if len(data.DefaultPool.Healthcheck) > 0 {
			var healthcheckList []map[string]interface{}
			for _, listItem := range data.DefaultPool.Healthcheck {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				healthcheckList = append(healthcheckList, listItemMap)
			}
			default_poolMap["healthcheck"] = healthcheckList
		}
		if data.DefaultPool.LbPort != nil {
			default_poolMap["lb_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.LoadBalancerAlgorithm.IsNull() && !data.DefaultPool.LoadBalancerAlgorithm.IsUnknown() {
			default_poolMap["loadbalancer_algorithm"] = data.DefaultPool.LoadBalancerAlgorithm.ValueString()
		}
		if data.DefaultPool.NoTLS != nil {
			default_poolMap["no_tls"] = map[string]interface{}{}
		}
		if len(data.DefaultPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.DefaultPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if listItem.CbipService != nil {
					cbip_serviceDeepMap := make(map[string]interface{})
					if !listItem.CbipService.ServiceName.IsNull() && !listItem.CbipService.ServiceName.IsUnknown() {
						cbip_serviceDeepMap["service_name"] = listItem.CbipService.ServiceName.ValueString()
					}
					listItemMap["cbip_service"] = cbip_serviceDeepMap
				}
				if listItem.ConsulService != nil {
					consul_serviceDeepMap := make(map[string]interface{})
					if listItem.ConsulService.InsideNetwork != nil {
						consul_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.ConsulService.OutsideNetwork != nil {
						consul_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.ConsulService.ServiceName.IsNull() && !listItem.ConsulService.ServiceName.IsUnknown() {
						consul_serviceDeepMap["service_name"] = listItem.ConsulService.ServiceName.ValueString()
					}
					listItemMap["consul_service"] = consul_serviceDeepMap
				}
				if listItem.CustomEndpointObject != nil {
					custom_endpoint_objectDeepMap := make(map[string]interface{})
					listItemMap["custom_endpoint_object"] = custom_endpoint_objectDeepMap
				}
				if listItem.K8SService != nil {
					k8s_serviceDeepMap := make(map[string]interface{})
					if listItem.K8SService.InsideNetwork != nil {
						k8s_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.K8SService.OutsideNetwork != nil {
						k8s_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.K8SService.Protocol.IsNull() && !listItem.K8SService.Protocol.IsUnknown() {
						k8s_serviceDeepMap["protocol"] = listItem.K8SService.Protocol.ValueString()
					}
					if !listItem.K8SService.ServiceName.IsNull() && !listItem.K8SService.ServiceName.IsUnknown() {
						k8s_serviceDeepMap["service_name"] = listItem.K8SService.ServiceName.ValueString()
					}
					if listItem.K8SService.Vk8sNetworks != nil {
						k8s_serviceDeepMap["vk8s_networks"] = map[string]interface{}{}
					}
					listItemMap["k8s_service"] = k8s_serviceDeepMap
				}
				if listItem.Labels != nil {
					listItemMap["labels"] = map[string]interface{}{}
				}
				if listItem.PrivateIP != nil {
					private_ipDeepMap := make(map[string]interface{})
					if listItem.PrivateIP.InsideNetwork != nil {
						private_ipDeepMap["inside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateIP.IP.IsNull() && !listItem.PrivateIP.IP.IsUnknown() {
						private_ipDeepMap["ip"] = listItem.PrivateIP.IP.ValueString()
					}
					if listItem.PrivateIP.OutsideNetwork != nil {
						private_ipDeepMap["outside_network"] = map[string]interface{}{}
					}
					listItemMap["private_ip"] = private_ipDeepMap
				}
				if listItem.PrivateName != nil {
					private_nameDeepMap := make(map[string]interface{})
					if !listItem.PrivateName.DNSName.IsNull() && !listItem.PrivateName.DNSName.IsUnknown() {
						private_nameDeepMap["dns_name"] = listItem.PrivateName.DNSName.ValueString()
					}
					if listItem.PrivateName.InsideNetwork != nil {
						private_nameDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.PrivateName.OutsideNetwork != nil {
						private_nameDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateName.RefreshInterval.IsNull() && !listItem.PrivateName.RefreshInterval.IsUnknown() {
						private_nameDeepMap["refresh_interval"] = listItem.PrivateName.RefreshInterval.ValueInt64()
					}
					listItemMap["private_name"] = private_nameDeepMap
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				if listItem.VnPrivateIP != nil {
					vn_private_ipDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateIP.IP.IsNull() && !listItem.VnPrivateIP.IP.IsUnknown() {
						vn_private_ipDeepMap["ip"] = listItem.VnPrivateIP.IP.ValueString()
					}
					listItemMap["vn_private_ip"] = vn_private_ipDeepMap
				}
				if listItem.VnPrivateName != nil {
					vn_private_nameDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateName.DNSName.IsNull() && !listItem.VnPrivateName.DNSName.IsUnknown() {
						vn_private_nameDeepMap["dns_name"] = listItem.VnPrivateName.DNSName.ValueString()
					}
					listItemMap["vn_private_name"] = vn_private_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			default_poolMap["origin_servers"] = origin_serversList
		}
		if !data.DefaultPool.Port.IsNull() && !data.DefaultPool.Port.IsUnknown() {
			default_poolMap["port"] = data.DefaultPool.Port.ValueInt64()
		}
		if data.DefaultPool.SameAsEndpointPort != nil {
			default_poolMap["same_as_endpoint_port"] = map[string]interface{}{}
		}
		if data.DefaultPool.UpstreamConnPoolReuseType != nil {
			upstream_conn_pool_reuse_typeNestedMap := make(map[string]interface{})
			default_poolMap["upstream_conn_pool_reuse_type"] = upstream_conn_pool_reuse_typeNestedMap
		}
		if data.DefaultPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.UseTLS.MaxSessionKeys.IsNull() && !data.DefaultPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.DefaultPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.DefaultPool.UseTLS.Sni.IsNull() && !data.DefaultPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.DefaultPool.UseTLS.Sni.ValueString()
			}
			default_poolMap["use_tls"] = use_tlsNestedMap
		}
		if data.DefaultPool.ViewInternal != nil {
			view_internalNestedMap := make(map[string]interface{})
			if !data.DefaultPool.ViewInternal.Name.IsNull() && !data.DefaultPool.ViewInternal.Name.IsUnknown() {
				view_internalNestedMap["name"] = data.DefaultPool.ViewInternal.Name.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Namespace.IsNull() && !data.DefaultPool.ViewInternal.Namespace.IsUnknown() {
				view_internalNestedMap["namespace"] = data.DefaultPool.ViewInternal.Namespace.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Tenant.IsNull() && !data.DefaultPool.ViewInternal.Tenant.IsUnknown() {
				view_internalNestedMap["tenant"] = data.DefaultPool.ViewInternal.Tenant.ValueString()
			}
			default_poolMap["view_internal"] = view_internalNestedMap
		}
		apiResource.Spec["default_pool"] = default_poolMap
	}
	if data.DefaultPoolList != nil {
		default_pool_listMap := make(map[string]interface{})
		if len(data.DefaultPoolList.Pools) > 0 {
			var poolsList []map[string]interface{}
			for _, listItem := range data.DefaultPoolList.Pools {
				listItemMap := make(map[string]interface{})
				if listItem.Cluster != nil {
					clusterDeepMap := make(map[string]interface{})
					if !listItem.Cluster.Name.IsNull() && !listItem.Cluster.Name.IsUnknown() {
						clusterDeepMap["name"] = listItem.Cluster.Name.ValueString()
					}
					if !listItem.Cluster.Namespace.IsNull() && !listItem.Cluster.Namespace.IsUnknown() {
						clusterDeepMap["namespace"] = listItem.Cluster.Namespace.ValueString()
					}
					if !listItem.Cluster.Tenant.IsNull() && !listItem.Cluster.Tenant.IsUnknown() {
						clusterDeepMap["tenant"] = listItem.Cluster.Tenant.ValueString()
					}
					listItemMap["cluster"] = clusterDeepMap
				}
				if listItem.EndpointSubsets != nil {
					listItemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if listItem.Pool != nil {
					poolDeepMap := make(map[string]interface{})
					if !listItem.Pool.Name.IsNull() && !listItem.Pool.Name.IsUnknown() {
						poolDeepMap["name"] = listItem.Pool.Name.ValueString()
					}
					if !listItem.Pool.Namespace.IsNull() && !listItem.Pool.Namespace.IsUnknown() {
						poolDeepMap["namespace"] = listItem.Pool.Namespace.ValueString()
					}
					if !listItem.Pool.Tenant.IsNull() && !listItem.Pool.Tenant.IsUnknown() {
						poolDeepMap["tenant"] = listItem.Pool.Tenant.ValueString()
					}
					listItemMap["pool"] = poolDeepMap
				}
				if !listItem.Priority.IsNull() && !listItem.Priority.IsUnknown() {
					listItemMap["priority"] = listItem.Priority.ValueInt64()
				}
				if !listItem.Weight.IsNull() && !listItem.Weight.IsUnknown() {
					listItemMap["weight"] = listItem.Weight.ValueInt64()
				}
				poolsList = append(poolsList, listItemMap)
			}
			default_pool_listMap["pools"] = poolsList
		}
		apiResource.Spec["default_pool_list"] = default_pool_listMap
	}
	if len(data.DefaultRoutePools) > 0 {
		var default_route_poolsList []map[string]interface{}
		for _, item := range data.DefaultRoutePools {
			itemMap := make(map[string]interface{})
			if item.Cluster != nil {
				clusterNestedMap := make(map[string]interface{})
				if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
					clusterNestedMap["name"] = item.Cluster.Name.ValueString()
				}
				if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
					clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
				}
				if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
					clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
				}
				itemMap["cluster"] = clusterNestedMap
			}
			if item.EndpointSubsets != nil {
				itemMap["endpoint_subsets"] = map[string]interface{}{}
			}
			if item.Pool != nil {
				poolNestedMap := make(map[string]interface{})
				if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
					poolNestedMap["name"] = item.Pool.Name.ValueString()
				}
				if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
					poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
				}
				if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
					poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
				}
				itemMap["pool"] = poolNestedMap
			}
			if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
				itemMap["priority"] = item.Priority.ValueInt64()
			}
			if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
				itemMap["weight"] = item.Weight.ValueInt64()
			}
			default_route_poolsList = append(default_route_poolsList, itemMap)
		}
		apiResource.Spec["default_route_pools"] = default_route_poolsList
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		apiResource.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		apiResource.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		apiResource.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableAPITesting != nil {
		disable_api_testingMap := make(map[string]interface{})
		apiResource.Spec["disable_api_testing"] = disable_api_testingMap
	}
	if data.DisableBotDefense != nil {
		disable_bot_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_bot_defense"] = disable_bot_defenseMap
	}
	if data.DisableCaching != nil {
		disable_cachingMap := make(map[string]interface{})
		apiResource.Spec["disable_caching"] = disable_cachingMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableMalwareProtection != nil {
		disable_malware_protectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malware_protection"] = disable_malware_protectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		apiResource.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableTrustClientIPHeaders != nil {
		disable_trust_client_ip_headersMap := make(map[string]interface{})
		apiResource.Spec["disable_trust_client_ip_headers"] = disable_trust_client_ip_headersMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		apiResource.Spec["disable_waf"] = disable_wafMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		apiResource.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		apiResource.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if data.EnableTrustClientIPHeaders != nil {
		enable_trust_client_ip_headersMap := make(map[string]interface{})
		apiResource.Spec["enable_trust_client_ip_headers"] = enable_trust_client_ip_headersMap
	}
	if len(data.GraphqlRules) > 0 {
		var graphql_rulesList []map[string]interface{}
		for _, item := range data.GraphqlRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
				itemMap["exact_path"] = item.ExactPath.ValueString()
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.GraphqlSettings != nil {
				graphql_settingsNestedMap := make(map[string]interface{})
				if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
					graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
				}
				if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
					graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
				}
				if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
					graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
				}
				itemMap["graphql_settings"] = graphql_settingsNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.MethodGet != nil {
				itemMap["method_get"] = map[string]interface{}{}
			}
			if item.MethodPost != nil {
				itemMap["method_post"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			graphql_rulesList = append(graphql_rulesList, itemMap)
		}
		apiResource.Spec["graphql_rules"] = graphql_rulesList
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		apiResource.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.AppendServerName.IsNull() && !data.HTTPS.AppendServerName.IsUnknown() {
			httpsMap["append_server_name"] = data.HTTPS.AppendServerName.ValueString()
		}
		if data.HTTPS.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			httpsMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPS.ConnectionIdleTimeout.IsNull() && !data.HTTPS.ConnectionIdleTimeout.IsUnknown() {
			httpsMap["connection_idle_timeout"] = data.HTTPS.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPS.DefaultHeader != nil {
			httpsMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPS.DefaultLoadBalancer != nil {
			httpsMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.DisablePathNormalize != nil {
			httpsMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.EnablePathNormalize != nil {
			httpsMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			httpsMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.NonDefaultLoadBalancer != nil {
			httpsMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.PassThrough != nil {
			httpsMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPS.Port.IsNull() && !data.HTTPS.Port.IsUnknown() {
			httpsMap["port"] = data.HTTPS.Port.ValueInt64()
		}
		if !data.HTTPS.PortRanges.IsNull() && !data.HTTPS.PortRanges.IsUnknown() {
			httpsMap["port_ranges"] = data.HTTPS.PortRanges.ValueString()
		}
		if !data.HTTPS.ServerName.IsNull() && !data.HTTPS.ServerName.IsUnknown() {
			httpsMap["server_name"] = data.HTTPS.ServerName.ValueString()
		}
		if data.HTTPS.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.HTTPS.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			httpsMap["tls_parameters"] = tls_parametersNestedMap
		}
		apiResource.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.AppendServerName.IsNull() && !data.HTTPSAutoCert.AppendServerName.IsUnknown() {
			https_auto_certMap["append_server_name"] = data.HTTPSAutoCert.AppendServerName.ValueString()
		}
		if data.HTTPSAutoCert.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPSAutoCert.ConnectionIdleTimeout.IsNull() && !data.HTTPSAutoCert.ConnectionIdleTimeout.IsUnknown() {
			https_auto_certMap["connection_idle_timeout"] = data.HTTPSAutoCert.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPSAutoCert.DefaultHeader != nil {
			https_auto_certMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DefaultLoadBalancer != nil {
			https_auto_certMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DisablePathNormalize != nil {
			https_auto_certMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.EnablePathNormalize != nil {
			https_auto_certMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.NoMtls != nil {
			https_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.NonDefaultLoadBalancer != nil {
			https_auto_certMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.PassThrough != nil {
			https_auto_certMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPSAutoCert.Port.IsNull() && !data.HTTPSAutoCert.Port.IsUnknown() {
			https_auto_certMap["port"] = data.HTTPSAutoCert.Port.ValueInt64()
		}
		if !data.HTTPSAutoCert.PortRanges.IsNull() && !data.HTTPSAutoCert.PortRanges.IsUnknown() {
			https_auto_certMap["port_ranges"] = data.HTTPSAutoCert.PortRanges.ValueString()
		}
		if !data.HTTPSAutoCert.ServerName.IsNull() && !data.HTTPSAutoCert.ServerName.IsUnknown() {
			https_auto_certMap["server_name"] = data.HTTPSAutoCert.ServerName.ValueString()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.HTTPSAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.HTTPSAutoCert.UseMtls.TrustedCaURL.IsNull() && !data.HTTPSAutoCert.UseMtls.TrustedCaURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.HTTPSAutoCert.UseMtls.TrustedCaURL.ValueString()
			}
			https_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		apiResource.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["js_challenge"] = js_challengeMap
	}
	if data.JwtValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JwtValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JwtValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JwtValidation.JwksConfig.Cleartext.IsNull() && !data.JwtValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JwtValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JwtValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JwtValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JwtValidation.ReservedClaims.Issuer.IsNull() && !data.JwtValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JwtValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JwtValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JwtValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		apiResource.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DdosActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DdosActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DdosActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DdosActionJsChallenge.CookieExpiry.IsNull() && !data.L7DdosActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DdosActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DdosActionJsChallenge.CustomPage.IsNull() && !data.L7DdosActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DdosActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DdosActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DdosActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.L7DdosProtection != nil {
		l7_ddos_protectionMap := make(map[string]interface{})
		if data.L7DdosProtection.ClientsideActionCaptchaChallenge != nil {
			clientside_action_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.ClientsideActionCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CustomPage.IsNull() && !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CustomPage.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["custom_page"] = data.L7DdosProtection.ClientsideActionCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["clientside_action_captcha_challenge"] = clientside_action_captcha_challengeNestedMap
		}
		if data.L7DdosProtection.ClientsideActionJsChallenge != nil {
			clientside_action_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.ClientsideActionJsChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.ClientsideActionJsChallenge.CookieExpiry.IsUnknown() {
				clientside_action_js_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.ClientsideActionJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.ClientsideActionJsChallenge.CustomPage.IsNull() && !data.L7DdosProtection.ClientsideActionJsChallenge.CustomPage.IsUnknown() {
				clientside_action_js_challengeNestedMap["custom_page"] = data.L7DdosProtection.ClientsideActionJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DdosProtection.ClientsideActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosProtection.ClientsideActionJsChallenge.JsScriptDelay.IsUnknown() {
				clientside_action_js_challengeNestedMap["js_script_delay"] = data.L7DdosProtection.ClientsideActionJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["clientside_action_js_challenge"] = clientside_action_js_challengeNestedMap
		}
		if data.L7DdosProtection.ClientsideActionNone != nil {
			l7_ddos_protectionMap["clientside_action_none"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.DdosPolicyCustom != nil {
			ddos_policy_customNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.DdosPolicyCustom.Name.IsNull() && !data.L7DdosProtection.DdosPolicyCustom.Name.IsUnknown() {
				ddos_policy_customNestedMap["name"] = data.L7DdosProtection.DdosPolicyCustom.Name.ValueString()
			}
			if !data.L7DdosProtection.DdosPolicyCustom.Namespace.IsNull() && !data.L7DdosProtection.DdosPolicyCustom.Namespace.IsUnknown() {
				ddos_policy_customNestedMap["namespace"] = data.L7DdosProtection.DdosPolicyCustom.Namespace.ValueString()
			}
			if !data.L7DdosProtection.DdosPolicyCustom.Tenant.IsNull() && !data.L7DdosProtection.DdosPolicyCustom.Tenant.IsUnknown() {
				ddos_policy_customNestedMap["tenant"] = data.L7DdosProtection.DdosPolicyCustom.Tenant.ValueString()
			}
			l7_ddos_protectionMap["ddos_policy_custom"] = ddos_policy_customNestedMap
		}
		if data.L7DdosProtection.DdosPolicyNone != nil {
			l7_ddos_protectionMap["ddos_policy_none"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.DefaultRpsThreshold != nil {
			l7_ddos_protectionMap["default_rps_threshold"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.MitigationBlock != nil {
			l7_ddos_protectionMap["mitigation_block"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.MitigationCaptchaChallenge != nil {
			mitigation_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.MitigationCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.MitigationCaptchaChallenge.CookieExpiry.IsUnknown() {
				mitigation_captcha_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.MitigationCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.MitigationCaptchaChallenge.CustomPage.IsNull() && !data.L7DdosProtection.MitigationCaptchaChallenge.CustomPage.IsUnknown() {
				mitigation_captcha_challengeNestedMap["custom_page"] = data.L7DdosProtection.MitigationCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["mitigation_captcha_challenge"] = mitigation_captcha_challengeNestedMap
		}
		if data.L7DdosProtection.MitigationJsChallenge != nil {
			mitigation_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.MitigationJsChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.MitigationJsChallenge.CookieExpiry.IsUnknown() {
				mitigation_js_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.MitigationJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.MitigationJsChallenge.CustomPage.IsNull() && !data.L7DdosProtection.MitigationJsChallenge.CustomPage.IsUnknown() {
				mitigation_js_challengeNestedMap["custom_page"] = data.L7DdosProtection.MitigationJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DdosProtection.MitigationJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosProtection.MitigationJsChallenge.JsScriptDelay.IsUnknown() {
				mitigation_js_challengeNestedMap["js_script_delay"] = data.L7DdosProtection.MitigationJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["mitigation_js_challenge"] = mitigation_js_challengeNestedMap
		}
		if !data.L7DdosProtection.RpsThreshold.IsNull() && !data.L7DdosProtection.RpsThreshold.IsUnknown() {
			l7_ddos_protectionMap["rps_threshold"] = data.L7DdosProtection.RpsThreshold.ValueInt64()
		}
		apiResource.Spec["l7_ddos_protection"] = l7_ddos_protectionMap
	}
	if data.LeastActive != nil {
		least_activeMap := make(map[string]interface{})
		apiResource.Spec["least_active"] = least_activeMap
	}
	if data.MalwareProtectionSettings != nil {
		malware_protection_settingsMap := make(map[string]interface{})
		if len(data.MalwareProtectionSettings.MalwareProtectionRules) > 0 {
			var malware_protection_rulesList []map[string]interface{}
			for _, listItem := range data.MalwareProtectionSettings.MalwareProtectionRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Block != nil {
						actionDeepMap["block"] = map[string]interface{}{}
					}
					if listItem.Action.Report != nil {
						actionDeepMap["report"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.Domain != nil {
					domainDeepMap := make(map[string]interface{})
					if listItem.Domain.AnyDomain != nil {
						domainDeepMap["any_domain"] = map[string]interface{}{}
					}
					listItemMap["domain"] = domainDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.Path != nil {
					pathDeepMap := make(map[string]interface{})
					if !listItem.Path.Path.IsNull() && !listItem.Path.Path.IsUnknown() {
						pathDeepMap["path"] = listItem.Path.Path.ValueString()
					}
					if !listItem.Path.Prefix.IsNull() && !listItem.Path.Prefix.IsUnknown() {
						pathDeepMap["prefix"] = listItem.Path.Prefix.ValueString()
					}
					if !listItem.Path.Regex.IsNull() && !listItem.Path.Regex.IsUnknown() {
						pathDeepMap["regex"] = listItem.Path.Regex.ValueString()
					}
					listItemMap["path"] = pathDeepMap
				}
				malware_protection_rulesList = append(malware_protection_rulesList, listItemMap)
			}
			malware_protection_settingsMap["malware_protection_rules"] = malware_protection_rulesList
		}
		apiResource.Spec["malware_protection_settings"] = malware_protection_settingsMap
	}
	if data.MoreOption != nil {
		more_optionMap := make(map[string]interface{})
		if data.MoreOption.BufferPolicy != nil {
			buffer_policyNestedMap := make(map[string]interface{})
			if !data.MoreOption.BufferPolicy.Disabled.IsNull() && !data.MoreOption.BufferPolicy.Disabled.IsUnknown() {
				buffer_policyNestedMap["disabled"] = data.MoreOption.BufferPolicy.Disabled.ValueBool()
			}
			if !data.MoreOption.BufferPolicy.MaxRequestBytes.IsNull() && !data.MoreOption.BufferPolicy.MaxRequestBytes.IsUnknown() {
				buffer_policyNestedMap["max_request_bytes"] = data.MoreOption.BufferPolicy.MaxRequestBytes.ValueInt64()
			}
			more_optionMap["buffer_policy"] = buffer_policyNestedMap
		}
		if data.MoreOption.CompressionParams != nil {
			compression_paramsNestedMap := make(map[string]interface{})
			if !data.MoreOption.CompressionParams.ContentLength.IsNull() && !data.MoreOption.CompressionParams.ContentLength.IsUnknown() {
				compression_paramsNestedMap["content_length"] = data.MoreOption.CompressionParams.ContentLength.ValueInt64()
			}
			if !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsNull() && !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsUnknown() {
				compression_paramsNestedMap["disable_on_etag_header"] = data.MoreOption.CompressionParams.DisableOnEtagHeader.ValueBool()
			}
			if !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsNull() && !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsUnknown() {
				compression_paramsNestedMap["remove_accept_encoding_header"] = data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.ValueBool()
			}
			more_optionMap["compression_params"] = compression_paramsNestedMap
		}
		if data.MoreOption.CustomErrors != nil {
			more_optionMap["custom_errors"] = map[string]interface{}{}
		}
		if !data.MoreOption.DisableDefaultErrorPages.IsNull() && !data.MoreOption.DisableDefaultErrorPages.IsUnknown() {
			more_optionMap["disable_default_error_pages"] = data.MoreOption.DisableDefaultErrorPages.ValueBool()
		}
		if data.MoreOption.DisablePathNormalize != nil {
			more_optionMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.MoreOption.EnablePathNormalize != nil {
			more_optionMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if !data.MoreOption.IdleTimeout.IsNull() && !data.MoreOption.IdleTimeout.IsUnknown() {
			more_optionMap["idle_timeout"] = data.MoreOption.IdleTimeout.ValueInt64()
		}
		if !data.MoreOption.MaxRequestHeaderSize.IsNull() && !data.MoreOption.MaxRequestHeaderSize.IsUnknown() {
			more_optionMap["max_request_header_size"] = data.MoreOption.MaxRequestHeaderSize.ValueInt64()
		}
		if len(data.MoreOption.RequestCookiesToAdd) > 0 {
			var request_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_cookies_to_addList = append(request_cookies_to_addList, listItemMap)
			}
			more_optionMap["request_cookies_to_add"] = request_cookies_to_addList
		}
		if len(data.MoreOption.RequestHeadersToAdd) > 0 {
			var request_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_headers_to_addList = append(request_headers_to_addList, listItemMap)
			}
			more_optionMap["request_headers_to_add"] = request_headers_to_addList
		}
		if len(data.MoreOption.ResponseCookiesToAdd) > 0 {
			var response_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.AddDomain.IsNull() && !listItem.AddDomain.IsUnknown() {
					listItemMap["add_domain"] = listItem.AddDomain.ValueString()
				}
				if !listItem.AddExpiry.IsNull() && !listItem.AddExpiry.IsUnknown() {
					listItemMap["add_expiry"] = listItem.AddExpiry.ValueString()
				}
				if listItem.AddHttponly != nil {
					listItemMap["add_httponly"] = map[string]interface{}{}
				}
				if listItem.AddPartitioned != nil {
					listItemMap["add_partitioned"] = map[string]interface{}{}
				}
				if !listItem.AddPath.IsNull() && !listItem.AddPath.IsUnknown() {
					listItemMap["add_path"] = listItem.AddPath.ValueString()
				}
				if listItem.AddSecure != nil {
					listItemMap["add_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreDomain != nil {
					listItemMap["ignore_domain"] = map[string]interface{}{}
				}
				if listItem.IgnoreExpiry != nil {
					listItemMap["ignore_expiry"] = map[string]interface{}{}
				}
				if listItem.IgnoreHttponly != nil {
					listItemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if listItem.IgnoreMaxAge != nil {
					listItemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if listItem.IgnorePartitioned != nil {
					listItemMap["ignore_partitioned"] = map[string]interface{}{}
				}
				if listItem.IgnorePath != nil {
					listItemMap["ignore_path"] = map[string]interface{}{}
				}
				if listItem.IgnoreSamesite != nil {
					listItemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if listItem.IgnoreSecure != nil {
					listItemMap["ignore_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreValue != nil {
					listItemMap["ignore_value"] = map[string]interface{}{}
				}
				if !listItem.MaxAgeValue.IsNull() && !listItem.MaxAgeValue.IsUnknown() {
					listItemMap["max_age_value"] = listItem.MaxAgeValue.ValueInt64()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SamesiteLax != nil {
					listItemMap["samesite_lax"] = map[string]interface{}{}
				}
				if listItem.SamesiteNone != nil {
					listItemMap["samesite_none"] = map[string]interface{}{}
				}
				if listItem.SamesiteStrict != nil {
					listItemMap["samesite_strict"] = map[string]interface{}{}
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_cookies_to_addList = append(response_cookies_to_addList, listItemMap)
			}
			more_optionMap["response_cookies_to_add"] = response_cookies_to_addList
		}
		if len(data.MoreOption.ResponseHeadersToAdd) > 0 {
			var response_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_headers_to_addList = append(response_headers_to_addList, listItemMap)
			}
			more_optionMap["response_headers_to_add"] = response_headers_to_addList
		}
		apiResource.Spec["more_option"] = more_optionMap
	}
	if data.MultiLbApp != nil {
		multi_lb_appMap := make(map[string]interface{})
		apiResource.Spec["multi_lb_app"] = multi_lb_appMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		apiResource.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginServerSubsetRuleList != nil {
		origin_server_subset_rule_listMap := make(map[string]interface{})
		if len(data.OriginServerSubsetRuleList.OriginServerSubsetRules) > 0 {
			var origin_server_subset_rulesList []map[string]interface{}
			for _, listItem := range data.OriginServerSubsetRuleList.OriginServerSubsetRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyAsn != nil {
					listItemMap["any_asn"] = map[string]interface{}{}
				}
				if listItem.AnyIP != nil {
					listItemMap["any_ip"] = map[string]interface{}{}
				}
				if listItem.AsnList != nil {
					asn_listDeepMap := make(map[string]interface{})
					listItemMap["asn_list"] = asn_listDeepMap
				}
				if listItem.AsnMatcher != nil {
					asn_matcherDeepMap := make(map[string]interface{})
					listItemMap["asn_matcher"] = asn_matcherDeepMap
				}
				if listItem.ClientSelector != nil {
					client_selectorDeepMap := make(map[string]interface{})
					listItemMap["client_selector"] = client_selectorDeepMap
				}
				if listItem.IPMatcher != nil {
					ip_matcherDeepMap := make(map[string]interface{})
					if !listItem.IPMatcher.InvertMatcher.IsNull() && !listItem.IPMatcher.InvertMatcher.IsUnknown() {
						ip_matcherDeepMap["invert_matcher"] = listItem.IPMatcher.InvertMatcher.ValueBool()
					}
					listItemMap["ip_matcher"] = ip_matcherDeepMap
				}
				if listItem.IPPrefixList != nil {
					ip_prefix_listDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixList.InvertMatch.IsNull() && !listItem.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listDeepMap["invert_match"] = listItem.IPPrefixList.InvertMatch.ValueBool()
					}
					listItemMap["ip_prefix_list"] = ip_prefix_listDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.None != nil {
					listItemMap["none"] = map[string]interface{}{}
				}
				if listItem.OriginServerSubsetsAction != nil {
					listItemMap["origin_server_subsets_action"] = map[string]interface{}{}
				}
				origin_server_subset_rulesList = append(origin_server_subset_rulesList, listItemMap)
			}
			origin_server_subset_rule_listMap["origin_server_subset_rules"] = origin_server_subset_rulesList
		}
		apiResource.Spec["origin_server_subset_rule_list"] = origin_server_subset_rule_listMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		apiResource.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if len(data.ProtectedCookies) > 0 {
		var protected_cookiesList []map[string]interface{}
		for _, item := range data.ProtectedCookies {
			itemMap := make(map[string]interface{})
			if item.AddHttponly != nil {
				itemMap["add_httponly"] = map[string]interface{}{}
			}
			if item.AddSecure != nil {
				itemMap["add_secure"] = map[string]interface{}{}
			}
			if item.DisableTamperingProtection != nil {
				itemMap["disable_tampering_protection"] = map[string]interface{}{}
			}
			if item.EnableTamperingProtection != nil {
				itemMap["enable_tampering_protection"] = map[string]interface{}{}
			}
			if item.IgnoreHttponly != nil {
				itemMap["ignore_httponly"] = map[string]interface{}{}
			}
			if item.IgnoreMaxAge != nil {
				itemMap["ignore_max_age"] = map[string]interface{}{}
			}
			if item.IgnoreSamesite != nil {
				itemMap["ignore_samesite"] = map[string]interface{}{}
			}
			if item.IgnoreSecure != nil {
				itemMap["ignore_secure"] = map[string]interface{}{}
			}
			if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
				itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
			}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				itemMap["name"] = item.Name.ValueString()
			}
			if item.SamesiteLax != nil {
				itemMap["samesite_lax"] = map[string]interface{}{}
			}
			if item.SamesiteNone != nil {
				itemMap["samesite_none"] = map[string]interface{}{}
			}
			if item.SamesiteStrict != nil {
				itemMap["samesite_strict"] = map[string]interface{}{}
			}
			protected_cookiesList = append(protected_cookiesList, itemMap)
		}
		apiResource.Spec["protected_cookies"] = protected_cookiesList
	}
	if data.Random != nil {
		randomMap := make(map[string]interface{})
		apiResource.Spec["random"] = randomMap
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		apiResource.Spec["rate_limit"] = rate_limitMap
	}
	if data.RingHash != nil {
		ring_hashMap := make(map[string]interface{})
		if len(data.RingHash.HashPolicy) > 0 {
			var hash_policyList []map[string]interface{}
			for _, listItem := range data.RingHash.HashPolicy {
				listItemMap := make(map[string]interface{})
				if listItem.Cookie != nil {
					cookieDeepMap := make(map[string]interface{})
					if listItem.Cookie.AddHttponly != nil {
						cookieDeepMap["add_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.AddSecure != nil {
						cookieDeepMap["add_secure"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreHttponly != nil {
						cookieDeepMap["ignore_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSamesite != nil {
						cookieDeepMap["ignore_samesite"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSecure != nil {
						cookieDeepMap["ignore_secure"] = map[string]interface{}{}
					}
					if !listItem.Cookie.Name.IsNull() && !listItem.Cookie.Name.IsUnknown() {
						cookieDeepMap["name"] = listItem.Cookie.Name.ValueString()
					}
					if !listItem.Cookie.Path.IsNull() && !listItem.Cookie.Path.IsUnknown() {
						cookieDeepMap["path"] = listItem.Cookie.Path.ValueString()
					}
					if listItem.Cookie.SamesiteLax != nil {
						cookieDeepMap["samesite_lax"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteNone != nil {
						cookieDeepMap["samesite_none"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteStrict != nil {
						cookieDeepMap["samesite_strict"] = map[string]interface{}{}
					}
					if !listItem.Cookie.Ttl.IsNull() && !listItem.Cookie.Ttl.IsUnknown() {
						cookieDeepMap["ttl"] = listItem.Cookie.Ttl.ValueInt64()
					}
					listItemMap["cookie"] = cookieDeepMap
				}
				if !listItem.HeaderName.IsNull() && !listItem.HeaderName.IsUnknown() {
					listItemMap["header_name"] = listItem.HeaderName.ValueString()
				}
				if !listItem.SourceIP.IsNull() && !listItem.SourceIP.IsUnknown() {
					listItemMap["source_ip"] = listItem.SourceIP.ValueBool()
				}
				if !listItem.Terminal.IsNull() && !listItem.Terminal.IsUnknown() {
					listItemMap["terminal"] = listItem.Terminal.ValueBool()
				}
				hash_policyList = append(hash_policyList, listItemMap)
			}
			ring_hashMap["hash_policy"] = hash_policyList
		}
		apiResource.Spec["ring_hash"] = ring_hashMap
	}
	if data.RoundRobin != nil {
		round_robinMap := make(map[string]interface{})
		apiResource.Spec["round_robin"] = round_robinMap
	}
	if len(data.Routes) > 0 {
		var routesList []map[string]interface{}
		for _, item := range data.Routes {
			itemMap := make(map[string]interface{})
			if item.CustomRouteObject != nil {
				custom_route_objectNestedMap := make(map[string]interface{})
				itemMap["custom_route_object"] = custom_route_objectNestedMap
			}
			if item.DirectResponseRoute != nil {
				direct_response_routeNestedMap := make(map[string]interface{})
				if !item.DirectResponseRoute.HTTPMethod.IsNull() && !item.DirectResponseRoute.HTTPMethod.IsUnknown() {
					direct_response_routeNestedMap["http_method"] = item.DirectResponseRoute.HTTPMethod.ValueString()
				}
				itemMap["direct_response_route"] = direct_response_routeNestedMap
			}
			if item.RedirectRoute != nil {
				redirect_routeNestedMap := make(map[string]interface{})
				if !item.RedirectRoute.HTTPMethod.IsNull() && !item.RedirectRoute.HTTPMethod.IsUnknown() {
					redirect_routeNestedMap["http_method"] = item.RedirectRoute.HTTPMethod.ValueString()
				}
				itemMap["redirect_route"] = redirect_routeNestedMap
			}
			if item.SimpleRoute != nil {
				simple_routeNestedMap := make(map[string]interface{})
				if !item.SimpleRoute.HostRewrite.IsNull() && !item.SimpleRoute.HostRewrite.IsUnknown() {
					simple_routeNestedMap["host_rewrite"] = item.SimpleRoute.HostRewrite.ValueString()
				}
				if !item.SimpleRoute.HTTPMethod.IsNull() && !item.SimpleRoute.HTTPMethod.IsUnknown() {
					simple_routeNestedMap["http_method"] = item.SimpleRoute.HTTPMethod.ValueString()
				}
				itemMap["simple_route"] = simple_routeNestedMap
			}
			routesList = append(routesList, itemMap)
		}
		apiResource.Spec["routes"] = routesList
	}
	if data.SensitiveDataDisclosureRules != nil {
		sensitive_data_disclosure_rulesMap := make(map[string]interface{})
		if len(data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse) > 0 {
			var sensitive_data_types_in_responseList []map[string]interface{}
			for _, listItem := range data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse {
				listItemMap := make(map[string]interface{})
				if listItem.APIEndpoint != nil {
					api_endpointDeepMap := make(map[string]interface{})
					if !listItem.APIEndpoint.Path.IsNull() && !listItem.APIEndpoint.Path.IsUnknown() {
						api_endpointDeepMap["path"] = listItem.APIEndpoint.Path.ValueString()
					}
					listItemMap["api_endpoint"] = api_endpointDeepMap
				}
				if listItem.Body != nil {
					bodyDeepMap := make(map[string]interface{})
					listItemMap["body"] = bodyDeepMap
				}
				if listItem.Mask != nil {
					listItemMap["mask"] = map[string]interface{}{}
				}
				if listItem.Report != nil {
					listItemMap["report"] = map[string]interface{}{}
				}
				sensitive_data_types_in_responseList = append(sensitive_data_types_in_responseList, listItemMap)
			}
			sensitive_data_disclosure_rulesMap["sensitive_data_types_in_response"] = sensitive_data_types_in_responseList
		}
		apiResource.Spec["sensitive_data_disclosure_rules"] = sensitive_data_disclosure_rulesMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		apiResource.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SingleLbApp != nil {
		single_lb_appMap := make(map[string]interface{})
		if data.SingleLbApp.DisableDiscovery != nil {
			single_lb_appMap["disable_discovery"] = map[string]interface{}{}
		}
		if data.SingleLbApp.DisableMaliciousUserDetection != nil {
			single_lb_appMap["disable_malicious_user_detection"] = map[string]interface{}{}
		}
		if data.SingleLbApp.EnableDiscovery != nil {
			enable_discoveryNestedMap := make(map[string]interface{})
			single_lb_appMap["enable_discovery"] = enable_discoveryNestedMap
		}
		if data.SingleLbApp.EnableMaliciousUserDetection != nil {
			single_lb_appMap["enable_malicious_user_detection"] = map[string]interface{}{}
		}
		apiResource.Spec["single_lb_app"] = single_lb_appMap
	}
	if data.SlowDdosMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDdosMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDdosMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDdosMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDdosMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDdosMitigation.RequestTimeout.IsNull() && !data.SlowDdosMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDdosMitigation.RequestTimeout.ValueInt64()
		}
		apiResource.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SourceIPStickiness != nil {
		source_ip_stickinessMap := make(map[string]interface{})
		apiResource.Spec["source_ip_stickiness"] = source_ip_stickinessMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		apiResource.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if len(data.TrustedClients) > 0 {
		var trusted_clientsList []map[string]interface{}
		for _, item := range data.TrustedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			trusted_clientsList = append(trusted_clientsList, itemMap)
		}
		apiResource.Spec["trusted_clients"] = trusted_clientsList
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		apiResource.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		apiResource.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		apiResource.Spec["waf_exclusion"] = waf_exclusionMap
	}
	if !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		apiResource.Spec["add_location"] = data.AddLocation.ValueBool()
	}


	created, err := r.client.CreateHTTPLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create HTTPLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response
	if v, ok := created.Spec["add_location"].(bool); ok {
		data.AddLocation = types.BoolValue(v)
	} else if data.AddLocation.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AddLocation = types.BoolNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created HTTPLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HTTPLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetHTTPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "HTTPLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read HTTPLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The http_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &HTTPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []HTTPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &HTTPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{
										}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6Vip: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVip: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6Vip: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVip: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVip: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVipModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &HTTPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVip == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVip = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_protection_rules"].(map[string]interface{}); ok && (isImport || data.APIProtectionRules != nil) {
		data.APIProtectionRules = &HTTPLoadBalancerAPIProtectionRulesModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel{
										}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			APIGroupsRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel {
				if listData, ok := blockData["api_groups_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel{
										}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &HTTPLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLbUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{
										}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{
					}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel{
					}
				}
				return nil
			}(),
			IPAllowedList: func() *HTTPLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []HTTPLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLbUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{
										}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &HTTPLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_testing"].(map[string]interface{}); ok && (isImport || data.APITesting != nil) {
		data.APITesting = &HTTPLoadBalancerAPITestingModel{
			CustomHeaderValue: func() types.String {
				if v, ok := blockData["custom_header_value"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domains: func() []HTTPLoadBalancerAPITestingDomainsModel {
				if listData, ok := blockData["domains"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPITestingDomainsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPITestingDomainsModel{
								AllowDestructiveMethods: func() types.Bool {
									if v, ok := itemMap["allow_destructive_methods"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Domain: func() types.String {
									if v, ok := itemMap["domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			EveryDay: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryDay
				}
				// Import case: read from API
				if _, ok := blockData["every_day"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryMonth: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryMonth
				}
				// Import case: read from API
				if _, ok := blockData["every_month"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryWeek: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryWeek
				}
				// Import case: read from API
				if _, ok := blockData["every_week"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &HTTPLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []HTTPLoadBalancerBlockedClientsModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, HTTPLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["bot_skip_processing"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsHTTPHeaderModel{
							}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPV6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["skip_processing"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["waf_skip_processing"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		data.BlockedClients = blocked_clientsList
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &HTTPLoadBalancerBotDefenseModel{
			DisableCorsSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCorsSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCorsSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCorsSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *HTTPLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["bot_defense_advanced"].(map[string]interface{}); ok && isImport && data.BotDefenseAdvanced == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BotDefenseAdvanced = &HTTPLoadBalancerBotDefenseAdvancedModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["caching_policy"].(map[string]interface{}); ok && isImport && data.CachingPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CachingPolicy = &HTTPLoadBalancerCachingPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &HTTPLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &HTTPLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cookie_stickiness"].(map[string]interface{}); ok && (isImport || data.CookieStickiness != nil) {
		data.CookieStickiness = &HTTPLoadBalancerCookieStickinessModel{
			AddHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddHttponly
				}
				// Import case: read from API
				if _, ok := blockData["add_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			AddSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddSecure
				}
				// Import case: read from API
				if _, ok := blockData["add_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreHttponly
				}
				// Import case: read from API
				if _, ok := blockData["ignore_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSamesite
				}
				// Import case: read from API
				if _, ok := blockData["ignore_samesite"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSecure
				}
				// Import case: read from API
				if _, ok := blockData["ignore_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Path: func() types.String {
				if v, ok := blockData["path"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteLax
				}
				// Import case: read from API
				if _, ok := blockData["samesite_lax"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteNone
				}
				// Import case: read from API
				if _, ok := blockData["samesite_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteStrict
				}
				// Import case: read from API
				if _, ok := blockData["samesite_strict"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Ttl: func() types.Int64 {
				if v, ok := blockData["ttl"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CorsPolicy != nil) {
		data.CorsPolicy = &HTTPLoadBalancerCorsPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CorsPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.CorsPolicy.AllowCredentials
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CorsPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.CorsPolicy.Disabled
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CsrfPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CsrfPolicy = &HTTPLoadBalancerCsrfPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []HTTPLoadBalancerDataGuardRulesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, HTTPLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["apply_data_guard"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *HTTPLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["skip_data_guard"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.DataGuardRules = data_guard_rulesList
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []HTTPLoadBalancerDdosMitigationRulesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, HTTPLoadBalancerDdosMitigationRulesModel{
					Block: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["block"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DdosClientSource: func() *HTTPLoadBalancerDdosMitigationRulesDdosClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDdosMitigationRulesDdosClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *HTTPLoadBalancerDdosMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDdosMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerDdosMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDdosMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		data.DdosMitigationRules = ddos_mitigation_rulesList
	}
	if blockData, ok := apiResource.Spec["default_pool"].(map[string]interface{}); ok && (isImport || data.DefaultPool != nil) {
		data.DefaultPool = &HTTPLoadBalancerDefaultPoolModel{
			AdvancedOptions: func() *HTTPLoadBalancerDefaultPoolAdvancedOptionsModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.AdvancedOptions != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.AdvancedOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["advanced_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolAdvancedOptionsModel{
						ConnectionTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["connection_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						HTTPIdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["http_idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PanicThreshold: func() types.Int64 {
							if v, ok := nestedBlockData["panic_threshold"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			AutomaticPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.AutomaticPort
				}
				// Import case: read from API
				if _, ok := blockData["automatic_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EndpointSelection: func() types.String {
				if v, ok := blockData["endpoint_selection"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HealthCheckPort: func() types.Int64 {
				if v, ok := blockData["health_check_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Healthcheck: func() []HTTPLoadBalancerDefaultPoolHealthcheckModel {
				if listData, ok := blockData["healthcheck"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolHealthcheckModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolHealthcheckModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			LbPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.LbPort
				}
				// Import case: read from API
				if _, ok := blockData["lb_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			LoadBalancerAlgorithm: func() types.String {
				if v, ok := blockData["loadbalancer_algorithm"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoTLS: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginServers: func() []HTTPLoadBalancerDefaultPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolOriginServersModel{
								CbipService: func() *HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel {
									if deepMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel{
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ConsulService: func() *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel {
									if deepMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								CustomEndpointObject: func() *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel {
									if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel{
										}
									}
									return nil
								}(),
								K8SService: func() *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel {
									if deepMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Protocol: func() types.String {
												if v, ok := deepMap["protocol"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Vk8sNetworks: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["vk8s_networks"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Labels: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								PrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel {
									if deepMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								PrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel {
									if deepMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								PublicIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel {
									if deepMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel {
									if deepMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SameAsEndpointPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.SameAsEndpointPort
				}
				// Import case: read from API
				if _, ok := blockData["same_as_endpoint_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			UpstreamConnPoolReuseType: func() *HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UpstreamConnPoolReuseType != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UpstreamConnPoolReuseType
				}
				// Import case: read from API
				if _, ok := blockData["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel{
					}
				}
				return nil
			}(),
			UseTLS: func() *HTTPLoadBalancerDefaultPoolUseTLSModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ViewInternal: func() *HTTPLoadBalancerDefaultPoolViewInternalModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.ViewInternal != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.ViewInternal
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["view_internal"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolViewInternalModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["default_pool_list"].(map[string]interface{}); ok && (isImport || data.DefaultPoolList != nil) {
		data.DefaultPoolList = &HTTPLoadBalancerDefaultPoolListModel{
			Pools: func() []HTTPLoadBalancerDefaultPoolListPoolsModel {
				if listData, ok := blockData["pools"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolListPoolsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolListPoolsModel{
								Cluster: func() *HTTPLoadBalancerDefaultPoolListPoolsClusterModel {
									if deepMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsClusterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["endpoint_subsets"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Pool: func() *HTTPLoadBalancerDefaultPoolListPoolsPoolModel {
									if deepMap, ok := itemMap["pool"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsPoolModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Priority: func() types.Int64 {
									if v, ok := itemMap["priority"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Weight: func() types.Int64 {
									if v, ok := itemMap["weight"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["default_route_pools"].([]interface{}); ok && len(listData) > 0 {
		var default_route_poolsList []HTTPLoadBalancerDefaultRoutePoolsModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				default_route_poolsList = append(default_route_poolsList, HTTPLoadBalancerDefaultRoutePoolsModel{
					Cluster: func() *HTTPLoadBalancerDefaultRoutePoolsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["endpoint_subsets"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *HTTPLoadBalancerDefaultRoutePoolsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		data.DefaultRoutePools = default_route_poolsList
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_testing"].(map[string]interface{}); ok && isImport && data.DisableAPITesting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPITesting = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_bot_defense"].(map[string]interface{}); ok && isImport && data.DisableBotDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableBotDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_caching"].(map[string]interface{}); ok && isImport && data.DisableCaching == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableCaching = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malware_protection"].(map[string]interface{}); ok && isImport && data.DisableMalwareProtection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMalwareProtection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_trust_client_ip_headers"].(map[string]interface{}); ok && isImport && data.DisableTrustClientIPHeaders == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableTrustClientIPHeaders = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &HTTPLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &HTTPLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &HTTPLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_trust_client_ip_headers"].(map[string]interface{}); ok && (isImport || data.EnableTrustClientIPHeaders != nil) {
		data.EnableTrustClientIPHeaders = &HTTPLoadBalancerEnableTrustClientIPHeadersModel{
			ClientIPHeaders: func() types.List {
				if v, ok := blockData["client_ip_headers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []HTTPLoadBalancerGraphqlRulesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, HTTPLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel{
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["method_get"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["method_post"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		data.GraphqlRules = graphql_rulesList
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &HTTPLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTP.DNSVolterraManaged
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &HTTPLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPS.AddHsts
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSCoalescingOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSCoalescingOptionsModel{
					}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel{
					}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPS.HTTPRedirect
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSCertParams: func() *HTTPLoadBalancerHTTPSTLSCertParamsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertParams != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertParams
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSCertParamsModel{
					}
				}
				return nil
			}(),
			TLSParameters: func() *HTTPLoadBalancerHTTPSTLSParametersModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSParameters != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSParameters
				}
				// Import case: read from API
				if _, ok := blockData["tls_parameters"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSParametersModel{
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &HTTPLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPSAutoCert.AddHsts
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel{
					}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel{
					}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.HTTPSAutoCert.HTTPRedirect
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NoMtls: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *HTTPLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertTLSConfigModel{
					}
				}
				return nil
			}(),
			UseMtls: func() *HTTPLoadBalancerHTTPSAutoCertUseMtlsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.UseMtls
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertUseMtlsModel{
						ClientCertificateOptional: func() types.Bool {
							if v, ok := nestedBlockData["client_certificate_optional"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						TrustedCaURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &HTTPLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JwtValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JwtValidation = &HTTPLoadBalancerJwtValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DdosActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DdosActionBlock = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DdosActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DdosActionDefault = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DdosActionJsChallenge != nil) {
		data.L7DdosActionJsChallenge = &HTTPLoadBalancerL7DdosActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["l7_ddos_protection"].(map[string]interface{}); ok && (isImport || data.L7DdosProtection != nil) {
		data.L7DdosProtection = &HTTPLoadBalancerL7DdosProtectionModel{
			ClientsideActionCaptchaChallenge: func() *HTTPLoadBalancerL7DdosProtectionClientsideActionCaptchaChallengeModel {
				if !isImport && data.L7DdosProtection != nil && data.L7DdosProtection.ClientsideActionCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DdosProtection.ClientsideActionCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DdosProtectionClientsideActionCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionJsChallenge: func() *HTTPLoadBalancerL7DdosProtectionClientsideActionJsChallengeModel {
				if !isImport && data.L7DdosProtection != nil && data.L7DdosProtection.ClientsideActionJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DdosProtection.ClientsideActionJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DdosProtectionClientsideActionJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DdosProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DdosProtection.ClientsideActionNone
				}
				// Import case: read from API
				if _, ok := blockData["clientside_action_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DdosPolicyCustom: func() *HTTPLoadBalancerL7DdosProtectionDdosPolicyCustomModel {
				if !isImport && data.L7DdosProtection != nil && data.L7DdosProtection.DdosPolicyCustom != nil {
					// Normal Read: preserve existing state value
					return data.L7DdosProtection.DdosPolicyCustom
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ddos_policy_custom"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DdosProtectionDdosPolicyCustomModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DdosPolicyNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DdosProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DdosProtection.DdosPolicyNone
				}
				// Import case: read from API
				if _, ok := blockData["ddos_policy_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultRpsThreshold: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DdosProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DdosProtection.DefaultRpsThreshold
				}
				// Import case: read from API
				if _, ok := blockData["default_rps_threshold"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationBlock: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DdosProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DdosProtection.MitigationBlock
				}
				// Import case: read from API
				if _, ok := blockData["mitigation_block"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationCaptchaChallenge: func() *HTTPLoadBalancerL7DdosProtectionMitigationCaptchaChallengeModel {
				if !isImport && data.L7DdosProtection != nil && data.L7DdosProtection.MitigationCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DdosProtection.MitigationCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DdosProtectionMitigationCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MitigationJsChallenge: func() *HTTPLoadBalancerL7DdosProtectionMitigationJsChallengeModel {
				if !isImport && data.L7DdosProtection != nil && data.L7DdosProtection.MitigationJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DdosProtection.MitigationJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DdosProtectionMitigationJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			RpsThreshold: func() types.Int64 {
				if v, ok := blockData["rps_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["least_active"].(map[string]interface{}); ok && isImport && data.LeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LeastActive = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["malware_protection_settings"].(map[string]interface{}); ok && (isImport || data.MalwareProtectionSettings != nil) {
		data.MalwareProtectionSettings = &HTTPLoadBalancerMalwareProtectionSettingsModel{
			MalwareProtectionRules: func() []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel {
				if listData, ok := blockData["malware_protection_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel{
								Action: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel{
											Block: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["block"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Report: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["report"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Domain: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel {
									if deepMap, ok := itemMap["domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel{
											AnyDomain: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_domain"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Path: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel {
									if deepMap, ok := itemMap["path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Prefix: func() types.String {
												if v, ok := deepMap["prefix"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Regex: func() types.String {
												if v, ok := deepMap["regex"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["more_option"].(map[string]interface{}); ok && (isImport || data.MoreOption != nil) {
		data.MoreOption = &HTTPLoadBalancerMoreOptionModel{
			BufferPolicy: func() *HTTPLoadBalancerMoreOptionBufferPolicyModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.BufferPolicy != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.BufferPolicy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["buffer_policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionBufferPolicyModel{
						Disabled: func() types.Bool {
							if v, ok := nestedBlockData["disabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						MaxRequestBytes: func() types.Int64 {
							if v, ok := nestedBlockData["max_request_bytes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			CompressionParams: func() *HTTPLoadBalancerMoreOptionCompressionParamsModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.CompressionParams != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.CompressionParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["compression_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionCompressionParamsModel{
						ContentLength: func() types.Int64 {
							if v, ok := nestedBlockData["content_length"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ContentType: func() types.List {
							if v, ok := nestedBlockData["content_type"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						DisableOnEtagHeader: func() types.Bool {
							if v, ok := nestedBlockData["disable_on_etag_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						RemoveAcceptEncodingHeader: func() types.Bool {
							if v, ok := nestedBlockData["remove_accept_encoding_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			CustomErrors: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.CustomErrors
				}
				// Import case: read from API
				if _, ok := blockData["custom_errors"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisableDefaultErrorPages: func() types.Bool {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.MoreOption.DisableDefaultErrorPages
				}
				// Import case: read from API
				if v, ok := blockData["disable_default_error_pages"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IdleTimeout: func() types.Int64 {
				if v, ok := blockData["idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MaxRequestHeaderSize: func() types.Int64 {
				if v, ok := blockData["max_request_header_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestCookiesToAdd: func() []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel {
				if listData, ok := blockData["request_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestCookiesToAddModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel{
										}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestCookiesToRemove: func() types.List {
				if v, ok := blockData["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RequestHeadersToAdd: func() []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel {
				if listData, ok := blockData["request_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel{
										}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestHeadersToRemove: func() types.List {
				if v, ok := blockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseCookiesToAdd: func() []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel {
				if listData, ok := blockData["response_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseCookiesToAddModel{
								AddDomain: func() types.String {
									if v, ok := itemMap["add_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddExpiry: func() types.String {
									if v, ok := itemMap["add_expiry"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPath: func() types.String {
									if v, ok := itemMap["add_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreExpiry: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_expiry"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_max_age"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePath: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_samesite"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreValue: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxAgeValue: func() types.Int64 {
									if v, ok := itemMap["max_age_value"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_lax"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_strict"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel{
										}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseCookiesToRemove: func() types.List {
				if v, ok := blockData["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseHeadersToAdd: func() []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel {
				if listData, ok := blockData["response_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel{
										}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseHeadersToRemove: func() types.List {
				if v, ok := blockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["multi_lb_app"].(map[string]interface{}); ok && isImport && data.MultiLbApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.MultiLbApp = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_server_subset_rule_list"].(map[string]interface{}); ok && (isImport || data.OriginServerSubsetRuleList != nil) {
		data.OriginServerSubsetRuleList = &HTTPLoadBalancerOriginServerSubsetRuleListModel{
			OriginServerSubsetRules: func() []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel {
				if listData, ok := blockData["origin_server_subset_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel{
								AnyAsn: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_asn"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AsnList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel {
									if _, ok := itemMap["asn_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel{
										}
									}
									return nil
								}(),
								AsnMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel {
									if _, ok := itemMap["asn_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel{
										}
									}
									return nil
								}(),
								ClientSelector: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel {
									if _, ok := itemMap["client_selector"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel{
										}
									}
									return nil
								}(),
								IPMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel {
									if deepMap, ok := itemMap["ip_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								IPPrefixList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel {
									if deepMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel{
											InvertMatch: func() types.Bool {
												if v, ok := deepMap["invert_match"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								None: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								OriginServerSubsetsAction: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["origin_server_subsets_action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &HTTPLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []HTTPLoadBalancerProtectedCookiesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, HTTPLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["add_httponly"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["add_secure"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["disable_tampering_protection"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["enable_tampering_protection"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_httponly"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_max_age"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_samesite"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["ignore_secure"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["samesite_lax"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["samesite_none"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["samesite_strict"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		data.ProtectedCookies = protected_cookiesList
	}
	if _, ok := apiResource.Spec["random"].(map[string]interface{}); ok && isImport && data.Random == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Random = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &HTTPLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ring_hash"].(map[string]interface{}); ok && (isImport || data.RingHash != nil) {
		data.RingHash = &HTTPLoadBalancerRingHashModel{
			HashPolicy: func() []HTTPLoadBalancerRingHashHashPolicyModel {
				if listData, ok := blockData["hash_policy"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerRingHashHashPolicyModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerRingHashHashPolicyModel{
								Cookie: func() *HTTPLoadBalancerRingHashHashPolicyCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerRingHashHashPolicyCookieModel{
											AddHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AddSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_samesite"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_lax"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_none"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_strict"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Ttl: func() types.Int64 {
												if v, ok := deepMap["ttl"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HeaderName: func() types.String {
									if v, ok := itemMap["header_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SourceIP: func() types.Bool {
									if v, ok := itemMap["source_ip"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Terminal: func() types.Bool {
									if v, ok := itemMap["terminal"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["round_robin"].(map[string]interface{}); ok && isImport && data.RoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RoundRobin = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []HTTPLoadBalancerRoutesModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, HTTPLoadBalancerRoutesModel{
					CustomRouteObject: func() *HTTPLoadBalancerRoutesCustomRouteObjectModel {
						if _, ok := itemMap["custom_route_object"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesCustomRouteObjectModel{
							}
						}
						return nil
					}(),
					DirectResponseRoute: func() *HTTPLoadBalancerRoutesDirectResponseRouteModel {
						if nestedMap, ok := itemMap["direct_response_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesDirectResponseRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					RedirectRoute: func() *HTTPLoadBalancerRoutesRedirectRouteModel {
						if nestedMap, ok := itemMap["redirect_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesRedirectRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SimpleRoute: func() *HTTPLoadBalancerRoutesSimpleRouteModel {
						if nestedMap, ok := itemMap["simple_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesSimpleRouteModel{
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		data.Routes = routesList
	}
	if blockData, ok := apiResource.Spec["sensitive_data_disclosure_rules"].(map[string]interface{}); ok && (isImport || data.SensitiveDataDisclosureRules != nil) {
		data.SensitiveDataDisclosureRules = &HTTPLoadBalancerSensitiveDataDisclosureRulesModel{
			SensitiveDataTypesInResponse: func() []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel {
				if listData, ok := blockData["sensitive_data_types_in_response"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel{
								APIEndpoint: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel {
									if deepMap, ok := itemMap["api_endpoint"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Body: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel {
									if _, ok := itemMap["body"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel{
										}
									}
									return nil
								}(),
								Mask: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["mask"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Report: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["report"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &HTTPLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["single_lb_app"].(map[string]interface{}); ok && isImport && data.SingleLbApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SingleLbApp = &HTTPLoadBalancerSingleLbAppModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDdosMitigation != nil) {
		data.SlowDdosMitigation = &HTTPLoadBalancerSlowDdosMitigationModel{
			DisableRequestTimeout: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.SlowDdosMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDdosMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.SourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SourceIPStickiness = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []HTTPLoadBalancerTrustedClientsModel
		for _, item := range listData {
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, HTTPLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["bot_skip_processing"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsHTTPHeaderModel{
							}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPV6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["skip_processing"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if _, ok := itemMap["waf_skip_processing"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		data.TrustedClients = trusted_clientsList
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &HTTPLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &HTTPLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.AddLocation.IsNull() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case or null state: read from API
		if v, ok := apiResource.Spec["add_location"].(bool); ok {
			data.AddLocation = types.BoolValue(v)
		} else {
			data.AddLocation = types.BoolNull()
		}
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HTTPLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.HTTPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6Vip != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVip != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6Vip.IsNull() && !listItem.VirtualNetwork.SpecificV6Vip.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6Vip.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVip.IsNull() && !listItem.VirtualNetwork.SpecificVip.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVip.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVip != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVip.IP.IsNull() && !listItem.VirtualSiteWithVip.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVip.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVip.Network.IsNull() && !listItem.VirtualSiteWithVip.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVip.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		apiResource.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVip != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		apiResource.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.APIProtectionRules != nil {
		api_protection_rulesMap := make(map[string]interface{})
		if len(data.APIProtectionRules.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if len(data.APIProtectionRules.APIGroupsRules) > 0 {
			var api_groups_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIGroupsRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_groups_rulesList = append(api_groups_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_groups_rules"] = api_groups_rulesList
		}
		apiResource.Spec["api_protection_rules"] = api_protection_rulesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLbUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		apiResource.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["api_specification"] = api_specificationMap
	}
	if data.APITesting != nil {
		api_testingMap := make(map[string]interface{})
		if !data.APITesting.CustomHeaderValue.IsNull() && !data.APITesting.CustomHeaderValue.IsUnknown() {
			api_testingMap["custom_header_value"] = data.APITesting.CustomHeaderValue.ValueString()
		}
		if len(data.APITesting.Domains) > 0 {
			var domainsList []map[string]interface{}
			for _, listItem := range data.APITesting.Domains {
				listItemMap := make(map[string]interface{})
				if !listItem.AllowDestructiveMethods.IsNull() && !listItem.AllowDestructiveMethods.IsUnknown() {
					listItemMap["allow_destructive_methods"] = listItem.AllowDestructiveMethods.ValueBool()
				}
				if !listItem.Domain.IsNull() && !listItem.Domain.IsUnknown() {
					listItemMap["domain"] = listItem.Domain.ValueString()
				}
				domainsList = append(domainsList, listItemMap)
			}
			api_testingMap["domains"] = domainsList
		}
		if data.APITesting.EveryDay != nil {
			api_testingMap["every_day"] = map[string]interface{}{}
		}
		if data.APITesting.EveryMonth != nil {
			api_testingMap["every_month"] = map[string]interface{}{}
		}
		if data.APITesting.EveryWeek != nil {
			api_testingMap["every_week"] = map[string]interface{}{}
		}
		apiResource.Spec["api_testing"] = api_testingMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		apiResource.Spec["app_firewall"] = app_firewallMap
	}
	if len(data.BlockedClients) > 0 {
		var blocked_clientsList []map[string]interface{}
		for _, item := range data.BlockedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			blocked_clientsList = append(blocked_clientsList, itemMap)
		}
		apiResource.Spec["blocked_clients"] = blocked_clientsList
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCorsSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCorsSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		apiResource.Spec["bot_defense"] = bot_defenseMap
	}
	if data.BotDefenseAdvanced != nil {
		bot_defense_advancedMap := make(map[string]interface{})
		if data.BotDefenseAdvanced.DisableJsInsert != nil {
			bot_defense_advancedMap["disable_js_insert"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.DisableMobileSdk != nil {
			bot_defense_advancedMap["disable_mobile_sdk"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.JsInsertAllPages != nil {
			js_insert_all_pagesNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsUnknown() {
				js_insert_all_pagesNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages"] = js_insert_all_pagesNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertAllPagesExcept != nil {
			js_insert_all_pages_exceptNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsUnknown() {
				js_insert_all_pages_exceptNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages_except"] = js_insert_all_pages_exceptNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertionRules != nil {
			js_insertion_rulesNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["js_insertion_rules"] = js_insertion_rulesNestedMap
		}
		if data.BotDefenseAdvanced.Mobile != nil {
			mobileNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Mobile.Name.IsNull() && !data.BotDefenseAdvanced.Mobile.Name.IsUnknown() {
				mobileNestedMap["name"] = data.BotDefenseAdvanced.Mobile.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Namespace.IsNull() && !data.BotDefenseAdvanced.Mobile.Namespace.IsUnknown() {
				mobileNestedMap["namespace"] = data.BotDefenseAdvanced.Mobile.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Tenant.IsNull() && !data.BotDefenseAdvanced.Mobile.Tenant.IsUnknown() {
				mobileNestedMap["tenant"] = data.BotDefenseAdvanced.Mobile.Tenant.ValueString()
			}
			bot_defense_advancedMap["mobile"] = mobileNestedMap
		}
		if data.BotDefenseAdvanced.MobileSdkConfig != nil {
			mobile_sdk_configNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["mobile_sdk_config"] = mobile_sdk_configNestedMap
		}
		if data.BotDefenseAdvanced.Web != nil {
			webNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Web.Name.IsNull() && !data.BotDefenseAdvanced.Web.Name.IsUnknown() {
				webNestedMap["name"] = data.BotDefenseAdvanced.Web.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Namespace.IsNull() && !data.BotDefenseAdvanced.Web.Namespace.IsUnknown() {
				webNestedMap["namespace"] = data.BotDefenseAdvanced.Web.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Tenant.IsNull() && !data.BotDefenseAdvanced.Web.Tenant.IsUnknown() {
				webNestedMap["tenant"] = data.BotDefenseAdvanced.Web.Tenant.ValueString()
			}
			bot_defense_advancedMap["web"] = webNestedMap
		}
		apiResource.Spec["bot_defense_advanced"] = bot_defense_advancedMap
	}
	if data.CachingPolicy != nil {
		caching_policyMap := make(map[string]interface{})
		if data.CachingPolicy.CustomCacheRule != nil {
			custom_cache_ruleNestedMap := make(map[string]interface{})
			caching_policyMap["custom_cache_rule"] = custom_cache_ruleNestedMap
		}
		if data.CachingPolicy.DefaultCacheAction != nil {
			default_cache_actionNestedMap := make(map[string]interface{})
			if !data.CachingPolicy.DefaultCacheAction.CacheTtlDefault.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTtlDefault.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_default"] = data.CachingPolicy.DefaultCacheAction.CacheTtlDefault.ValueString()
			}
			if !data.CachingPolicy.DefaultCacheAction.CacheTtlOverride.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTtlOverride.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_override"] = data.CachingPolicy.DefaultCacheAction.CacheTtlOverride.ValueString()
			}
			caching_policyMap["default_cache_action"] = default_cache_actionNestedMap
		}
		apiResource.Spec["caching_policy"] = caching_policyMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		apiResource.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		apiResource.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CookieStickiness != nil {
		cookie_stickinessMap := make(map[string]interface{})
		if data.CookieStickiness.AddHttponly != nil {
			cookie_stickinessMap["add_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.AddSecure != nil {
			cookie_stickinessMap["add_secure"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreHttponly != nil {
			cookie_stickinessMap["ignore_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSamesite != nil {
			cookie_stickinessMap["ignore_samesite"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSecure != nil {
			cookie_stickinessMap["ignore_secure"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.Name.IsNull() && !data.CookieStickiness.Name.IsUnknown() {
			cookie_stickinessMap["name"] = data.CookieStickiness.Name.ValueString()
		}
		if !data.CookieStickiness.Path.IsNull() && !data.CookieStickiness.Path.IsUnknown() {
			cookie_stickinessMap["path"] = data.CookieStickiness.Path.ValueString()
		}
		if data.CookieStickiness.SamesiteLax != nil {
			cookie_stickinessMap["samesite_lax"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteNone != nil {
			cookie_stickinessMap["samesite_none"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteStrict != nil {
			cookie_stickinessMap["samesite_strict"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.Ttl.IsNull() && !data.CookieStickiness.Ttl.IsUnknown() {
			cookie_stickinessMap["ttl"] = data.CookieStickiness.Ttl.ValueInt64()
		}
		apiResource.Spec["cookie_stickiness"] = cookie_stickinessMap
	}
	if data.CorsPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CorsPolicy.AllowCredentials.IsNull() && !data.CorsPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CorsPolicy.AllowCredentials.ValueBool()
		}
		if !data.CorsPolicy.AllowHeaders.IsNull() && !data.CorsPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CorsPolicy.AllowHeaders.ValueString()
		}
		if !data.CorsPolicy.AllowMethods.IsNull() && !data.CorsPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CorsPolicy.AllowMethods.ValueString()
		}
		if !data.CorsPolicy.Disabled.IsNull() && !data.CorsPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CorsPolicy.Disabled.ValueBool()
		}
		if !data.CorsPolicy.ExposeHeaders.IsNull() && !data.CorsPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CorsPolicy.ExposeHeaders.ValueString()
		}
		if !data.CorsPolicy.MaximumAge.IsNull() && !data.CorsPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CorsPolicy.MaximumAge.ValueInt64()
		}
		apiResource.Spec["cors_policy"] = cors_policyMap
	}
	if data.CsrfPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CsrfPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CsrfPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CsrfPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["csrf_policy"] = csrf_policyMap
	}
	if len(data.DataGuardRules) > 0 {
		var data_guard_rulesList []map[string]interface{}
		for _, item := range data.DataGuardRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if item.ApplyDataGuard != nil {
				itemMap["apply_data_guard"] = map[string]interface{}{}
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.Path != nil {
				pathNestedMap := make(map[string]interface{})
				if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
					pathNestedMap["path"] = item.Path.Path.ValueString()
				}
				if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
					pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
				}
				if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
					pathNestedMap["regex"] = item.Path.Regex.ValueString()
				}
				itemMap["path"] = pathNestedMap
			}
			if item.SkipDataGuard != nil {
				itemMap["skip_data_guard"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			data_guard_rulesList = append(data_guard_rulesList, itemMap)
		}
		apiResource.Spec["data_guard_rules"] = data_guard_rulesList
	}
	if len(data.DdosMitigationRules) > 0 {
		var ddos_mitigation_rulesList []map[string]interface{}
		for _, item := range data.DdosMitigationRules {
			itemMap := make(map[string]interface{})
			if item.Block != nil {
				itemMap["block"] = map[string]interface{}{}
			}
			if item.DdosClientSource != nil {
				ddos_client_sourceNestedMap := make(map[string]interface{})
				if !item.DdosClientSource.CountryList.IsNull() && !item.DdosClientSource.CountryList.IsUnknown() {
					var CountryListItems []string
					diags := item.DdosClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
					if !diags.HasError() {
						ddos_client_sourceNestedMap["country_list"] = CountryListItems
					}
				}
				itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.IPPrefixList != nil {
				ip_prefix_listNestedMap := make(map[string]interface{})
				if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
					ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
				}
				if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
					var IPPrefixesItems []string
					diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
					if !diags.HasError() {
						ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
					}
				}
				itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
		}
		apiResource.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
	}
	if data.DefaultPool != nil {
		default_poolMap := make(map[string]interface{})
		if data.DefaultPool.AdvancedOptions != nil {
			advanced_optionsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsUnknown() {
				advanced_optionsNestedMap["connection_timeout"] = data.DefaultPool.AdvancedOptions.ConnectionTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsUnknown() {
				advanced_optionsNestedMap["http_idle_timeout"] = data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.PanicThreshold.IsNull() && !data.DefaultPool.AdvancedOptions.PanicThreshold.IsUnknown() {
				advanced_optionsNestedMap["panic_threshold"] = data.DefaultPool.AdvancedOptions.PanicThreshold.ValueInt64()
			}
			default_poolMap["advanced_options"] = advanced_optionsNestedMap
		}
		if data.DefaultPool.AutomaticPort != nil {
			default_poolMap["automatic_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.EndpointSelection.IsNull() && !data.DefaultPool.EndpointSelection.IsUnknown() {
			default_poolMap["endpoint_selection"] = data.DefaultPool.EndpointSelection.ValueString()
		}
		if !data.DefaultPool.HealthCheckPort.IsNull() && !data.DefaultPool.HealthCheckPort.IsUnknown() {
			default_poolMap["health_check_port"] = data.DefaultPool.HealthCheckPort.ValueInt64()
		}
		if len(data.DefaultPool.Healthcheck) > 0 {
			var healthcheckList []map[string]interface{}
			for _, listItem := range data.DefaultPool.Healthcheck {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				healthcheckList = append(healthcheckList, listItemMap)
			}
			default_poolMap["healthcheck"] = healthcheckList
		}
		if data.DefaultPool.LbPort != nil {
			default_poolMap["lb_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.LoadBalancerAlgorithm.IsNull() && !data.DefaultPool.LoadBalancerAlgorithm.IsUnknown() {
			default_poolMap["loadbalancer_algorithm"] = data.DefaultPool.LoadBalancerAlgorithm.ValueString()
		}
		if data.DefaultPool.NoTLS != nil {
			default_poolMap["no_tls"] = map[string]interface{}{}
		}
		if len(data.DefaultPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.DefaultPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if listItem.CbipService != nil {
					cbip_serviceDeepMap := make(map[string]interface{})
					if !listItem.CbipService.ServiceName.IsNull() && !listItem.CbipService.ServiceName.IsUnknown() {
						cbip_serviceDeepMap["service_name"] = listItem.CbipService.ServiceName.ValueString()
					}
					listItemMap["cbip_service"] = cbip_serviceDeepMap
				}
				if listItem.ConsulService != nil {
					consul_serviceDeepMap := make(map[string]interface{})
					if listItem.ConsulService.InsideNetwork != nil {
						consul_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.ConsulService.OutsideNetwork != nil {
						consul_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.ConsulService.ServiceName.IsNull() && !listItem.ConsulService.ServiceName.IsUnknown() {
						consul_serviceDeepMap["service_name"] = listItem.ConsulService.ServiceName.ValueString()
					}
					listItemMap["consul_service"] = consul_serviceDeepMap
				}
				if listItem.CustomEndpointObject != nil {
					custom_endpoint_objectDeepMap := make(map[string]interface{})
					listItemMap["custom_endpoint_object"] = custom_endpoint_objectDeepMap
				}
				if listItem.K8SService != nil {
					k8s_serviceDeepMap := make(map[string]interface{})
					if listItem.K8SService.InsideNetwork != nil {
						k8s_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.K8SService.OutsideNetwork != nil {
						k8s_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.K8SService.Protocol.IsNull() && !listItem.K8SService.Protocol.IsUnknown() {
						k8s_serviceDeepMap["protocol"] = listItem.K8SService.Protocol.ValueString()
					}
					if !listItem.K8SService.ServiceName.IsNull() && !listItem.K8SService.ServiceName.IsUnknown() {
						k8s_serviceDeepMap["service_name"] = listItem.K8SService.ServiceName.ValueString()
					}
					if listItem.K8SService.Vk8sNetworks != nil {
						k8s_serviceDeepMap["vk8s_networks"] = map[string]interface{}{}
					}
					listItemMap["k8s_service"] = k8s_serviceDeepMap
				}
				if listItem.Labels != nil {
					listItemMap["labels"] = map[string]interface{}{}
				}
				if listItem.PrivateIP != nil {
					private_ipDeepMap := make(map[string]interface{})
					if listItem.PrivateIP.InsideNetwork != nil {
						private_ipDeepMap["inside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateIP.IP.IsNull() && !listItem.PrivateIP.IP.IsUnknown() {
						private_ipDeepMap["ip"] = listItem.PrivateIP.IP.ValueString()
					}
					if listItem.PrivateIP.OutsideNetwork != nil {
						private_ipDeepMap["outside_network"] = map[string]interface{}{}
					}
					listItemMap["private_ip"] = private_ipDeepMap
				}
				if listItem.PrivateName != nil {
					private_nameDeepMap := make(map[string]interface{})
					if !listItem.PrivateName.DNSName.IsNull() && !listItem.PrivateName.DNSName.IsUnknown() {
						private_nameDeepMap["dns_name"] = listItem.PrivateName.DNSName.ValueString()
					}
					if listItem.PrivateName.InsideNetwork != nil {
						private_nameDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.PrivateName.OutsideNetwork != nil {
						private_nameDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateName.RefreshInterval.IsNull() && !listItem.PrivateName.RefreshInterval.IsUnknown() {
						private_nameDeepMap["refresh_interval"] = listItem.PrivateName.RefreshInterval.ValueInt64()
					}
					listItemMap["private_name"] = private_nameDeepMap
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				if listItem.VnPrivateIP != nil {
					vn_private_ipDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateIP.IP.IsNull() && !listItem.VnPrivateIP.IP.IsUnknown() {
						vn_private_ipDeepMap["ip"] = listItem.VnPrivateIP.IP.ValueString()
					}
					listItemMap["vn_private_ip"] = vn_private_ipDeepMap
				}
				if listItem.VnPrivateName != nil {
					vn_private_nameDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateName.DNSName.IsNull() && !listItem.VnPrivateName.DNSName.IsUnknown() {
						vn_private_nameDeepMap["dns_name"] = listItem.VnPrivateName.DNSName.ValueString()
					}
					listItemMap["vn_private_name"] = vn_private_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			default_poolMap["origin_servers"] = origin_serversList
		}
		if !data.DefaultPool.Port.IsNull() && !data.DefaultPool.Port.IsUnknown() {
			default_poolMap["port"] = data.DefaultPool.Port.ValueInt64()
		}
		if data.DefaultPool.SameAsEndpointPort != nil {
			default_poolMap["same_as_endpoint_port"] = map[string]interface{}{}
		}
		if data.DefaultPool.UpstreamConnPoolReuseType != nil {
			upstream_conn_pool_reuse_typeNestedMap := make(map[string]interface{})
			default_poolMap["upstream_conn_pool_reuse_type"] = upstream_conn_pool_reuse_typeNestedMap
		}
		if data.DefaultPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.UseTLS.MaxSessionKeys.IsNull() && !data.DefaultPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.DefaultPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.DefaultPool.UseTLS.Sni.IsNull() && !data.DefaultPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.DefaultPool.UseTLS.Sni.ValueString()
			}
			default_poolMap["use_tls"] = use_tlsNestedMap
		}
		if data.DefaultPool.ViewInternal != nil {
			view_internalNestedMap := make(map[string]interface{})
			if !data.DefaultPool.ViewInternal.Name.IsNull() && !data.DefaultPool.ViewInternal.Name.IsUnknown() {
				view_internalNestedMap["name"] = data.DefaultPool.ViewInternal.Name.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Namespace.IsNull() && !data.DefaultPool.ViewInternal.Namespace.IsUnknown() {
				view_internalNestedMap["namespace"] = data.DefaultPool.ViewInternal.Namespace.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Tenant.IsNull() && !data.DefaultPool.ViewInternal.Tenant.IsUnknown() {
				view_internalNestedMap["tenant"] = data.DefaultPool.ViewInternal.Tenant.ValueString()
			}
			default_poolMap["view_internal"] = view_internalNestedMap
		}
		apiResource.Spec["default_pool"] = default_poolMap
	}
	if data.DefaultPoolList != nil {
		default_pool_listMap := make(map[string]interface{})
		if len(data.DefaultPoolList.Pools) > 0 {
			var poolsList []map[string]interface{}
			for _, listItem := range data.DefaultPoolList.Pools {
				listItemMap := make(map[string]interface{})
				if listItem.Cluster != nil {
					clusterDeepMap := make(map[string]interface{})
					if !listItem.Cluster.Name.IsNull() && !listItem.Cluster.Name.IsUnknown() {
						clusterDeepMap["name"] = listItem.Cluster.Name.ValueString()
					}
					if !listItem.Cluster.Namespace.IsNull() && !listItem.Cluster.Namespace.IsUnknown() {
						clusterDeepMap["namespace"] = listItem.Cluster.Namespace.ValueString()
					}
					if !listItem.Cluster.Tenant.IsNull() && !listItem.Cluster.Tenant.IsUnknown() {
						clusterDeepMap["tenant"] = listItem.Cluster.Tenant.ValueString()
					}
					listItemMap["cluster"] = clusterDeepMap
				}
				if listItem.EndpointSubsets != nil {
					listItemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if listItem.Pool != nil {
					poolDeepMap := make(map[string]interface{})
					if !listItem.Pool.Name.IsNull() && !listItem.Pool.Name.IsUnknown() {
						poolDeepMap["name"] = listItem.Pool.Name.ValueString()
					}
					if !listItem.Pool.Namespace.IsNull() && !listItem.Pool.Namespace.IsUnknown() {
						poolDeepMap["namespace"] = listItem.Pool.Namespace.ValueString()
					}
					if !listItem.Pool.Tenant.IsNull() && !listItem.Pool.Tenant.IsUnknown() {
						poolDeepMap["tenant"] = listItem.Pool.Tenant.ValueString()
					}
					listItemMap["pool"] = poolDeepMap
				}
				if !listItem.Priority.IsNull() && !listItem.Priority.IsUnknown() {
					listItemMap["priority"] = listItem.Priority.ValueInt64()
				}
				if !listItem.Weight.IsNull() && !listItem.Weight.IsUnknown() {
					listItemMap["weight"] = listItem.Weight.ValueInt64()
				}
				poolsList = append(poolsList, listItemMap)
			}
			default_pool_listMap["pools"] = poolsList
		}
		apiResource.Spec["default_pool_list"] = default_pool_listMap
	}
	if len(data.DefaultRoutePools) > 0 {
		var default_route_poolsList []map[string]interface{}
		for _, item := range data.DefaultRoutePools {
			itemMap := make(map[string]interface{})
			if item.Cluster != nil {
				clusterNestedMap := make(map[string]interface{})
				if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
					clusterNestedMap["name"] = item.Cluster.Name.ValueString()
				}
				if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
					clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
				}
				if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
					clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
				}
				itemMap["cluster"] = clusterNestedMap
			}
			if item.EndpointSubsets != nil {
				itemMap["endpoint_subsets"] = map[string]interface{}{}
			}
			if item.Pool != nil {
				poolNestedMap := make(map[string]interface{})
				if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
					poolNestedMap["name"] = item.Pool.Name.ValueString()
				}
				if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
					poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
				}
				if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
					poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
				}
				itemMap["pool"] = poolNestedMap
			}
			if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
				itemMap["priority"] = item.Priority.ValueInt64()
			}
			if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
				itemMap["weight"] = item.Weight.ValueInt64()
			}
			default_route_poolsList = append(default_route_poolsList, itemMap)
		}
		apiResource.Spec["default_route_pools"] = default_route_poolsList
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		apiResource.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		apiResource.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		apiResource.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableAPITesting != nil {
		disable_api_testingMap := make(map[string]interface{})
		apiResource.Spec["disable_api_testing"] = disable_api_testingMap
	}
	if data.DisableBotDefense != nil {
		disable_bot_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_bot_defense"] = disable_bot_defenseMap
	}
	if data.DisableCaching != nil {
		disable_cachingMap := make(map[string]interface{})
		apiResource.Spec["disable_caching"] = disable_cachingMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableMalwareProtection != nil {
		disable_malware_protectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malware_protection"] = disable_malware_protectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		apiResource.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableTrustClientIPHeaders != nil {
		disable_trust_client_ip_headersMap := make(map[string]interface{})
		apiResource.Spec["disable_trust_client_ip_headers"] = disable_trust_client_ip_headersMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		apiResource.Spec["disable_waf"] = disable_wafMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		apiResource.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		apiResource.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if data.EnableTrustClientIPHeaders != nil {
		enable_trust_client_ip_headersMap := make(map[string]interface{})
		apiResource.Spec["enable_trust_client_ip_headers"] = enable_trust_client_ip_headersMap
	}
	if len(data.GraphqlRules) > 0 {
		var graphql_rulesList []map[string]interface{}
		for _, item := range data.GraphqlRules {
			itemMap := make(map[string]interface{})
			if item.AnyDomain != nil {
				itemMap["any_domain"] = map[string]interface{}{}
			}
			if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
				itemMap["exact_path"] = item.ExactPath.ValueString()
			}
			if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
				itemMap["exact_value"] = item.ExactValue.ValueString()
			}
			if item.GraphqlSettings != nil {
				graphql_settingsNestedMap := make(map[string]interface{})
				if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
					graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
				}
				if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
					graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
				}
				if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
					graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
				}
				itemMap["graphql_settings"] = graphql_settingsNestedMap
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.MethodGet != nil {
				itemMap["method_get"] = map[string]interface{}{}
			}
			if item.MethodPost != nil {
				itemMap["method_post"] = map[string]interface{}{}
			}
			if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
				itemMap["suffix_value"] = item.SuffixValue.ValueString()
			}
			graphql_rulesList = append(graphql_rulesList, itemMap)
		}
		apiResource.Spec["graphql_rules"] = graphql_rulesList
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		apiResource.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.AppendServerName.IsNull() && !data.HTTPS.AppendServerName.IsUnknown() {
			httpsMap["append_server_name"] = data.HTTPS.AppendServerName.ValueString()
		}
		if data.HTTPS.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			httpsMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPS.ConnectionIdleTimeout.IsNull() && !data.HTTPS.ConnectionIdleTimeout.IsUnknown() {
			httpsMap["connection_idle_timeout"] = data.HTTPS.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPS.DefaultHeader != nil {
			httpsMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPS.DefaultLoadBalancer != nil {
			httpsMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.DisablePathNormalize != nil {
			httpsMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.EnablePathNormalize != nil {
			httpsMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			httpsMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.NonDefaultLoadBalancer != nil {
			httpsMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.PassThrough != nil {
			httpsMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPS.Port.IsNull() && !data.HTTPS.Port.IsUnknown() {
			httpsMap["port"] = data.HTTPS.Port.ValueInt64()
		}
		if !data.HTTPS.PortRanges.IsNull() && !data.HTTPS.PortRanges.IsUnknown() {
			httpsMap["port_ranges"] = data.HTTPS.PortRanges.ValueString()
		}
		if !data.HTTPS.ServerName.IsNull() && !data.HTTPS.ServerName.IsUnknown() {
			httpsMap["server_name"] = data.HTTPS.ServerName.ValueString()
		}
		if data.HTTPS.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.HTTPS.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			httpsMap["tls_parameters"] = tls_parametersNestedMap
		}
		apiResource.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.AppendServerName.IsNull() && !data.HTTPSAutoCert.AppendServerName.IsUnknown() {
			https_auto_certMap["append_server_name"] = data.HTTPSAutoCert.AppendServerName.ValueString()
		}
		if data.HTTPSAutoCert.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPSAutoCert.ConnectionIdleTimeout.IsNull() && !data.HTTPSAutoCert.ConnectionIdleTimeout.IsUnknown() {
			https_auto_certMap["connection_idle_timeout"] = data.HTTPSAutoCert.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPSAutoCert.DefaultHeader != nil {
			https_auto_certMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DefaultLoadBalancer != nil {
			https_auto_certMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DisablePathNormalize != nil {
			https_auto_certMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.EnablePathNormalize != nil {
			https_auto_certMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.NoMtls != nil {
			https_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.NonDefaultLoadBalancer != nil {
			https_auto_certMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.PassThrough != nil {
			https_auto_certMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPSAutoCert.Port.IsNull() && !data.HTTPSAutoCert.Port.IsUnknown() {
			https_auto_certMap["port"] = data.HTTPSAutoCert.Port.ValueInt64()
		}
		if !data.HTTPSAutoCert.PortRanges.IsNull() && !data.HTTPSAutoCert.PortRanges.IsUnknown() {
			https_auto_certMap["port_ranges"] = data.HTTPSAutoCert.PortRanges.ValueString()
		}
		if !data.HTTPSAutoCert.ServerName.IsNull() && !data.HTTPSAutoCert.ServerName.IsUnknown() {
			https_auto_certMap["server_name"] = data.HTTPSAutoCert.ServerName.ValueString()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.HTTPSAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.HTTPSAutoCert.UseMtls.TrustedCaURL.IsNull() && !data.HTTPSAutoCert.UseMtls.TrustedCaURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.HTTPSAutoCert.UseMtls.TrustedCaURL.ValueString()
			}
			https_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		apiResource.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["js_challenge"] = js_challengeMap
	}
	if data.JwtValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JwtValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JwtValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JwtValidation.JwksConfig.Cleartext.IsNull() && !data.JwtValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JwtValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JwtValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JwtValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JwtValidation.ReservedClaims.Issuer.IsNull() && !data.JwtValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JwtValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JwtValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JwtValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		apiResource.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DdosActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DdosActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DdosActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DdosActionJsChallenge.CookieExpiry.IsNull() && !data.L7DdosActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DdosActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DdosActionJsChallenge.CustomPage.IsNull() && !data.L7DdosActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DdosActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DdosActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DdosActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.L7DdosProtection != nil {
		l7_ddos_protectionMap := make(map[string]interface{})
		if data.L7DdosProtection.ClientsideActionCaptchaChallenge != nil {
			clientside_action_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.ClientsideActionCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CustomPage.IsNull() && !data.L7DdosProtection.ClientsideActionCaptchaChallenge.CustomPage.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["custom_page"] = data.L7DdosProtection.ClientsideActionCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["clientside_action_captcha_challenge"] = clientside_action_captcha_challengeNestedMap
		}
		if data.L7DdosProtection.ClientsideActionJsChallenge != nil {
			clientside_action_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.ClientsideActionJsChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.ClientsideActionJsChallenge.CookieExpiry.IsUnknown() {
				clientside_action_js_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.ClientsideActionJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.ClientsideActionJsChallenge.CustomPage.IsNull() && !data.L7DdosProtection.ClientsideActionJsChallenge.CustomPage.IsUnknown() {
				clientside_action_js_challengeNestedMap["custom_page"] = data.L7DdosProtection.ClientsideActionJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DdosProtection.ClientsideActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosProtection.ClientsideActionJsChallenge.JsScriptDelay.IsUnknown() {
				clientside_action_js_challengeNestedMap["js_script_delay"] = data.L7DdosProtection.ClientsideActionJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["clientside_action_js_challenge"] = clientside_action_js_challengeNestedMap
		}
		if data.L7DdosProtection.ClientsideActionNone != nil {
			l7_ddos_protectionMap["clientside_action_none"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.DdosPolicyCustom != nil {
			ddos_policy_customNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.DdosPolicyCustom.Name.IsNull() && !data.L7DdosProtection.DdosPolicyCustom.Name.IsUnknown() {
				ddos_policy_customNestedMap["name"] = data.L7DdosProtection.DdosPolicyCustom.Name.ValueString()
			}
			if !data.L7DdosProtection.DdosPolicyCustom.Namespace.IsNull() && !data.L7DdosProtection.DdosPolicyCustom.Namespace.IsUnknown() {
				ddos_policy_customNestedMap["namespace"] = data.L7DdosProtection.DdosPolicyCustom.Namespace.ValueString()
			}
			if !data.L7DdosProtection.DdosPolicyCustom.Tenant.IsNull() && !data.L7DdosProtection.DdosPolicyCustom.Tenant.IsUnknown() {
				ddos_policy_customNestedMap["tenant"] = data.L7DdosProtection.DdosPolicyCustom.Tenant.ValueString()
			}
			l7_ddos_protectionMap["ddos_policy_custom"] = ddos_policy_customNestedMap
		}
		if data.L7DdosProtection.DdosPolicyNone != nil {
			l7_ddos_protectionMap["ddos_policy_none"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.DefaultRpsThreshold != nil {
			l7_ddos_protectionMap["default_rps_threshold"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.MitigationBlock != nil {
			l7_ddos_protectionMap["mitigation_block"] = map[string]interface{}{}
		}
		if data.L7DdosProtection.MitigationCaptchaChallenge != nil {
			mitigation_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.MitigationCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.MitigationCaptchaChallenge.CookieExpiry.IsUnknown() {
				mitigation_captcha_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.MitigationCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.MitigationCaptchaChallenge.CustomPage.IsNull() && !data.L7DdosProtection.MitigationCaptchaChallenge.CustomPage.IsUnknown() {
				mitigation_captcha_challengeNestedMap["custom_page"] = data.L7DdosProtection.MitigationCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["mitigation_captcha_challenge"] = mitigation_captcha_challengeNestedMap
		}
		if data.L7DdosProtection.MitigationJsChallenge != nil {
			mitigation_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DdosProtection.MitigationJsChallenge.CookieExpiry.IsNull() && !data.L7DdosProtection.MitigationJsChallenge.CookieExpiry.IsUnknown() {
				mitigation_js_challengeNestedMap["cookie_expiry"] = data.L7DdosProtection.MitigationJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DdosProtection.MitigationJsChallenge.CustomPage.IsNull() && !data.L7DdosProtection.MitigationJsChallenge.CustomPage.IsUnknown() {
				mitigation_js_challengeNestedMap["custom_page"] = data.L7DdosProtection.MitigationJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DdosProtection.MitigationJsChallenge.JsScriptDelay.IsNull() && !data.L7DdosProtection.MitigationJsChallenge.JsScriptDelay.IsUnknown() {
				mitigation_js_challengeNestedMap["js_script_delay"] = data.L7DdosProtection.MitigationJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["mitigation_js_challenge"] = mitigation_js_challengeNestedMap
		}
		if !data.L7DdosProtection.RpsThreshold.IsNull() && !data.L7DdosProtection.RpsThreshold.IsUnknown() {
			l7_ddos_protectionMap["rps_threshold"] = data.L7DdosProtection.RpsThreshold.ValueInt64()
		}
		apiResource.Spec["l7_ddos_protection"] = l7_ddos_protectionMap
	}
	if data.LeastActive != nil {
		least_activeMap := make(map[string]interface{})
		apiResource.Spec["least_active"] = least_activeMap
	}
	if data.MalwareProtectionSettings != nil {
		malware_protection_settingsMap := make(map[string]interface{})
		if len(data.MalwareProtectionSettings.MalwareProtectionRules) > 0 {
			var malware_protection_rulesList []map[string]interface{}
			for _, listItem := range data.MalwareProtectionSettings.MalwareProtectionRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Block != nil {
						actionDeepMap["block"] = map[string]interface{}{}
					}
					if listItem.Action.Report != nil {
						actionDeepMap["report"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.Domain != nil {
					domainDeepMap := make(map[string]interface{})
					if listItem.Domain.AnyDomain != nil {
						domainDeepMap["any_domain"] = map[string]interface{}{}
					}
					listItemMap["domain"] = domainDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.Path != nil {
					pathDeepMap := make(map[string]interface{})
					if !listItem.Path.Path.IsNull() && !listItem.Path.Path.IsUnknown() {
						pathDeepMap["path"] = listItem.Path.Path.ValueString()
					}
					if !listItem.Path.Prefix.IsNull() && !listItem.Path.Prefix.IsUnknown() {
						pathDeepMap["prefix"] = listItem.Path.Prefix.ValueString()
					}
					if !listItem.Path.Regex.IsNull() && !listItem.Path.Regex.IsUnknown() {
						pathDeepMap["regex"] = listItem.Path.Regex.ValueString()
					}
					listItemMap["path"] = pathDeepMap
				}
				malware_protection_rulesList = append(malware_protection_rulesList, listItemMap)
			}
			malware_protection_settingsMap["malware_protection_rules"] = malware_protection_rulesList
		}
		apiResource.Spec["malware_protection_settings"] = malware_protection_settingsMap
	}
	if data.MoreOption != nil {
		more_optionMap := make(map[string]interface{})
		if data.MoreOption.BufferPolicy != nil {
			buffer_policyNestedMap := make(map[string]interface{})
			if !data.MoreOption.BufferPolicy.Disabled.IsNull() && !data.MoreOption.BufferPolicy.Disabled.IsUnknown() {
				buffer_policyNestedMap["disabled"] = data.MoreOption.BufferPolicy.Disabled.ValueBool()
			}
			if !data.MoreOption.BufferPolicy.MaxRequestBytes.IsNull() && !data.MoreOption.BufferPolicy.MaxRequestBytes.IsUnknown() {
				buffer_policyNestedMap["max_request_bytes"] = data.MoreOption.BufferPolicy.MaxRequestBytes.ValueInt64()
			}
			more_optionMap["buffer_policy"] = buffer_policyNestedMap
		}
		if data.MoreOption.CompressionParams != nil {
			compression_paramsNestedMap := make(map[string]interface{})
			if !data.MoreOption.CompressionParams.ContentLength.IsNull() && !data.MoreOption.CompressionParams.ContentLength.IsUnknown() {
				compression_paramsNestedMap["content_length"] = data.MoreOption.CompressionParams.ContentLength.ValueInt64()
			}
			if !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsNull() && !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsUnknown() {
				compression_paramsNestedMap["disable_on_etag_header"] = data.MoreOption.CompressionParams.DisableOnEtagHeader.ValueBool()
			}
			if !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsNull() && !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsUnknown() {
				compression_paramsNestedMap["remove_accept_encoding_header"] = data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.ValueBool()
			}
			more_optionMap["compression_params"] = compression_paramsNestedMap
		}
		if data.MoreOption.CustomErrors != nil {
			more_optionMap["custom_errors"] = map[string]interface{}{}
		}
		if !data.MoreOption.DisableDefaultErrorPages.IsNull() && !data.MoreOption.DisableDefaultErrorPages.IsUnknown() {
			more_optionMap["disable_default_error_pages"] = data.MoreOption.DisableDefaultErrorPages.ValueBool()
		}
		if data.MoreOption.DisablePathNormalize != nil {
			more_optionMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.MoreOption.EnablePathNormalize != nil {
			more_optionMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if !data.MoreOption.IdleTimeout.IsNull() && !data.MoreOption.IdleTimeout.IsUnknown() {
			more_optionMap["idle_timeout"] = data.MoreOption.IdleTimeout.ValueInt64()
		}
		if !data.MoreOption.MaxRequestHeaderSize.IsNull() && !data.MoreOption.MaxRequestHeaderSize.IsUnknown() {
			more_optionMap["max_request_header_size"] = data.MoreOption.MaxRequestHeaderSize.ValueInt64()
		}
		if len(data.MoreOption.RequestCookiesToAdd) > 0 {
			var request_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_cookies_to_addList = append(request_cookies_to_addList, listItemMap)
			}
			more_optionMap["request_cookies_to_add"] = request_cookies_to_addList
		}
		if len(data.MoreOption.RequestHeadersToAdd) > 0 {
			var request_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_headers_to_addList = append(request_headers_to_addList, listItemMap)
			}
			more_optionMap["request_headers_to_add"] = request_headers_to_addList
		}
		if len(data.MoreOption.ResponseCookiesToAdd) > 0 {
			var response_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.AddDomain.IsNull() && !listItem.AddDomain.IsUnknown() {
					listItemMap["add_domain"] = listItem.AddDomain.ValueString()
				}
				if !listItem.AddExpiry.IsNull() && !listItem.AddExpiry.IsUnknown() {
					listItemMap["add_expiry"] = listItem.AddExpiry.ValueString()
				}
				if listItem.AddHttponly != nil {
					listItemMap["add_httponly"] = map[string]interface{}{}
				}
				if listItem.AddPartitioned != nil {
					listItemMap["add_partitioned"] = map[string]interface{}{}
				}
				if !listItem.AddPath.IsNull() && !listItem.AddPath.IsUnknown() {
					listItemMap["add_path"] = listItem.AddPath.ValueString()
				}
				if listItem.AddSecure != nil {
					listItemMap["add_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreDomain != nil {
					listItemMap["ignore_domain"] = map[string]interface{}{}
				}
				if listItem.IgnoreExpiry != nil {
					listItemMap["ignore_expiry"] = map[string]interface{}{}
				}
				if listItem.IgnoreHttponly != nil {
					listItemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if listItem.IgnoreMaxAge != nil {
					listItemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if listItem.IgnorePartitioned != nil {
					listItemMap["ignore_partitioned"] = map[string]interface{}{}
				}
				if listItem.IgnorePath != nil {
					listItemMap["ignore_path"] = map[string]interface{}{}
				}
				if listItem.IgnoreSamesite != nil {
					listItemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if listItem.IgnoreSecure != nil {
					listItemMap["ignore_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreValue != nil {
					listItemMap["ignore_value"] = map[string]interface{}{}
				}
				if !listItem.MaxAgeValue.IsNull() && !listItem.MaxAgeValue.IsUnknown() {
					listItemMap["max_age_value"] = listItem.MaxAgeValue.ValueInt64()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SamesiteLax != nil {
					listItemMap["samesite_lax"] = map[string]interface{}{}
				}
				if listItem.SamesiteNone != nil {
					listItemMap["samesite_none"] = map[string]interface{}{}
				}
				if listItem.SamesiteStrict != nil {
					listItemMap["samesite_strict"] = map[string]interface{}{}
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_cookies_to_addList = append(response_cookies_to_addList, listItemMap)
			}
			more_optionMap["response_cookies_to_add"] = response_cookies_to_addList
		}
		if len(data.MoreOption.ResponseHeadersToAdd) > 0 {
			var response_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_headers_to_addList = append(response_headers_to_addList, listItemMap)
			}
			more_optionMap["response_headers_to_add"] = response_headers_to_addList
		}
		apiResource.Spec["more_option"] = more_optionMap
	}
	if data.MultiLbApp != nil {
		multi_lb_appMap := make(map[string]interface{})
		apiResource.Spec["multi_lb_app"] = multi_lb_appMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		apiResource.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginServerSubsetRuleList != nil {
		origin_server_subset_rule_listMap := make(map[string]interface{})
		if len(data.OriginServerSubsetRuleList.OriginServerSubsetRules) > 0 {
			var origin_server_subset_rulesList []map[string]interface{}
			for _, listItem := range data.OriginServerSubsetRuleList.OriginServerSubsetRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyAsn != nil {
					listItemMap["any_asn"] = map[string]interface{}{}
				}
				if listItem.AnyIP != nil {
					listItemMap["any_ip"] = map[string]interface{}{}
				}
				if listItem.AsnList != nil {
					asn_listDeepMap := make(map[string]interface{})
					listItemMap["asn_list"] = asn_listDeepMap
				}
				if listItem.AsnMatcher != nil {
					asn_matcherDeepMap := make(map[string]interface{})
					listItemMap["asn_matcher"] = asn_matcherDeepMap
				}
				if listItem.ClientSelector != nil {
					client_selectorDeepMap := make(map[string]interface{})
					listItemMap["client_selector"] = client_selectorDeepMap
				}
				if listItem.IPMatcher != nil {
					ip_matcherDeepMap := make(map[string]interface{})
					if !listItem.IPMatcher.InvertMatcher.IsNull() && !listItem.IPMatcher.InvertMatcher.IsUnknown() {
						ip_matcherDeepMap["invert_matcher"] = listItem.IPMatcher.InvertMatcher.ValueBool()
					}
					listItemMap["ip_matcher"] = ip_matcherDeepMap
				}
				if listItem.IPPrefixList != nil {
					ip_prefix_listDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixList.InvertMatch.IsNull() && !listItem.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listDeepMap["invert_match"] = listItem.IPPrefixList.InvertMatch.ValueBool()
					}
					listItemMap["ip_prefix_list"] = ip_prefix_listDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.None != nil {
					listItemMap["none"] = map[string]interface{}{}
				}
				if listItem.OriginServerSubsetsAction != nil {
					listItemMap["origin_server_subsets_action"] = map[string]interface{}{}
				}
				origin_server_subset_rulesList = append(origin_server_subset_rulesList, listItemMap)
			}
			origin_server_subset_rule_listMap["origin_server_subset_rules"] = origin_server_subset_rulesList
		}
		apiResource.Spec["origin_server_subset_rule_list"] = origin_server_subset_rule_listMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		apiResource.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if len(data.ProtectedCookies) > 0 {
		var protected_cookiesList []map[string]interface{}
		for _, item := range data.ProtectedCookies {
			itemMap := make(map[string]interface{})
			if item.AddHttponly != nil {
				itemMap["add_httponly"] = map[string]interface{}{}
			}
			if item.AddSecure != nil {
				itemMap["add_secure"] = map[string]interface{}{}
			}
			if item.DisableTamperingProtection != nil {
				itemMap["disable_tampering_protection"] = map[string]interface{}{}
			}
			if item.EnableTamperingProtection != nil {
				itemMap["enable_tampering_protection"] = map[string]interface{}{}
			}
			if item.IgnoreHttponly != nil {
				itemMap["ignore_httponly"] = map[string]interface{}{}
			}
			if item.IgnoreMaxAge != nil {
				itemMap["ignore_max_age"] = map[string]interface{}{}
			}
			if item.IgnoreSamesite != nil {
				itemMap["ignore_samesite"] = map[string]interface{}{}
			}
			if item.IgnoreSecure != nil {
				itemMap["ignore_secure"] = map[string]interface{}{}
			}
			if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
				itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
			}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				itemMap["name"] = item.Name.ValueString()
			}
			if item.SamesiteLax != nil {
				itemMap["samesite_lax"] = map[string]interface{}{}
			}
			if item.SamesiteNone != nil {
				itemMap["samesite_none"] = map[string]interface{}{}
			}
			if item.SamesiteStrict != nil {
				itemMap["samesite_strict"] = map[string]interface{}{}
			}
			protected_cookiesList = append(protected_cookiesList, itemMap)
		}
		apiResource.Spec["protected_cookies"] = protected_cookiesList
	}
	if data.Random != nil {
		randomMap := make(map[string]interface{})
		apiResource.Spec["random"] = randomMap
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		apiResource.Spec["rate_limit"] = rate_limitMap
	}
	if data.RingHash != nil {
		ring_hashMap := make(map[string]interface{})
		if len(data.RingHash.HashPolicy) > 0 {
			var hash_policyList []map[string]interface{}
			for _, listItem := range data.RingHash.HashPolicy {
				listItemMap := make(map[string]interface{})
				if listItem.Cookie != nil {
					cookieDeepMap := make(map[string]interface{})
					if listItem.Cookie.AddHttponly != nil {
						cookieDeepMap["add_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.AddSecure != nil {
						cookieDeepMap["add_secure"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreHttponly != nil {
						cookieDeepMap["ignore_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSamesite != nil {
						cookieDeepMap["ignore_samesite"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSecure != nil {
						cookieDeepMap["ignore_secure"] = map[string]interface{}{}
					}
					if !listItem.Cookie.Name.IsNull() && !listItem.Cookie.Name.IsUnknown() {
						cookieDeepMap["name"] = listItem.Cookie.Name.ValueString()
					}
					if !listItem.Cookie.Path.IsNull() && !listItem.Cookie.Path.IsUnknown() {
						cookieDeepMap["path"] = listItem.Cookie.Path.ValueString()
					}
					if listItem.Cookie.SamesiteLax != nil {
						cookieDeepMap["samesite_lax"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteNone != nil {
						cookieDeepMap["samesite_none"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteStrict != nil {
						cookieDeepMap["samesite_strict"] = map[string]interface{}{}
					}
					if !listItem.Cookie.Ttl.IsNull() && !listItem.Cookie.Ttl.IsUnknown() {
						cookieDeepMap["ttl"] = listItem.Cookie.Ttl.ValueInt64()
					}
					listItemMap["cookie"] = cookieDeepMap
				}
				if !listItem.HeaderName.IsNull() && !listItem.HeaderName.IsUnknown() {
					listItemMap["header_name"] = listItem.HeaderName.ValueString()
				}
				if !listItem.SourceIP.IsNull() && !listItem.SourceIP.IsUnknown() {
					listItemMap["source_ip"] = listItem.SourceIP.ValueBool()
				}
				if !listItem.Terminal.IsNull() && !listItem.Terminal.IsUnknown() {
					listItemMap["terminal"] = listItem.Terminal.ValueBool()
				}
				hash_policyList = append(hash_policyList, listItemMap)
			}
			ring_hashMap["hash_policy"] = hash_policyList
		}
		apiResource.Spec["ring_hash"] = ring_hashMap
	}
	if data.RoundRobin != nil {
		round_robinMap := make(map[string]interface{})
		apiResource.Spec["round_robin"] = round_robinMap
	}
	if len(data.Routes) > 0 {
		var routesList []map[string]interface{}
		for _, item := range data.Routes {
			itemMap := make(map[string]interface{})
			if item.CustomRouteObject != nil {
				custom_route_objectNestedMap := make(map[string]interface{})
				itemMap["custom_route_object"] = custom_route_objectNestedMap
			}
			if item.DirectResponseRoute != nil {
				direct_response_routeNestedMap := make(map[string]interface{})
				if !item.DirectResponseRoute.HTTPMethod.IsNull() && !item.DirectResponseRoute.HTTPMethod.IsUnknown() {
					direct_response_routeNestedMap["http_method"] = item.DirectResponseRoute.HTTPMethod.ValueString()
				}
				itemMap["direct_response_route"] = direct_response_routeNestedMap
			}
			if item.RedirectRoute != nil {
				redirect_routeNestedMap := make(map[string]interface{})
				if !item.RedirectRoute.HTTPMethod.IsNull() && !item.RedirectRoute.HTTPMethod.IsUnknown() {
					redirect_routeNestedMap["http_method"] = item.RedirectRoute.HTTPMethod.ValueString()
				}
				itemMap["redirect_route"] = redirect_routeNestedMap
			}
			if item.SimpleRoute != nil {
				simple_routeNestedMap := make(map[string]interface{})
				if !item.SimpleRoute.HostRewrite.IsNull() && !item.SimpleRoute.HostRewrite.IsUnknown() {
					simple_routeNestedMap["host_rewrite"] = item.SimpleRoute.HostRewrite.ValueString()
				}
				if !item.SimpleRoute.HTTPMethod.IsNull() && !item.SimpleRoute.HTTPMethod.IsUnknown() {
					simple_routeNestedMap["http_method"] = item.SimpleRoute.HTTPMethod.ValueString()
				}
				itemMap["simple_route"] = simple_routeNestedMap
			}
			routesList = append(routesList, itemMap)
		}
		apiResource.Spec["routes"] = routesList
	}
	if data.SensitiveDataDisclosureRules != nil {
		sensitive_data_disclosure_rulesMap := make(map[string]interface{})
		if len(data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse) > 0 {
			var sensitive_data_types_in_responseList []map[string]interface{}
			for _, listItem := range data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse {
				listItemMap := make(map[string]interface{})
				if listItem.APIEndpoint != nil {
					api_endpointDeepMap := make(map[string]interface{})
					if !listItem.APIEndpoint.Path.IsNull() && !listItem.APIEndpoint.Path.IsUnknown() {
						api_endpointDeepMap["path"] = listItem.APIEndpoint.Path.ValueString()
					}
					listItemMap["api_endpoint"] = api_endpointDeepMap
				}
				if listItem.Body != nil {
					bodyDeepMap := make(map[string]interface{})
					listItemMap["body"] = bodyDeepMap
				}
				if listItem.Mask != nil {
					listItemMap["mask"] = map[string]interface{}{}
				}
				if listItem.Report != nil {
					listItemMap["report"] = map[string]interface{}{}
				}
				sensitive_data_types_in_responseList = append(sensitive_data_types_in_responseList, listItemMap)
			}
			sensitive_data_disclosure_rulesMap["sensitive_data_types_in_response"] = sensitive_data_types_in_responseList
		}
		apiResource.Spec["sensitive_data_disclosure_rules"] = sensitive_data_disclosure_rulesMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		apiResource.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SingleLbApp != nil {
		single_lb_appMap := make(map[string]interface{})
		if data.SingleLbApp.DisableDiscovery != nil {
			single_lb_appMap["disable_discovery"] = map[string]interface{}{}
		}
		if data.SingleLbApp.DisableMaliciousUserDetection != nil {
			single_lb_appMap["disable_malicious_user_detection"] = map[string]interface{}{}
		}
		if data.SingleLbApp.EnableDiscovery != nil {
			enable_discoveryNestedMap := make(map[string]interface{})
			single_lb_appMap["enable_discovery"] = enable_discoveryNestedMap
		}
		if data.SingleLbApp.EnableMaliciousUserDetection != nil {
			single_lb_appMap["enable_malicious_user_detection"] = map[string]interface{}{}
		}
		apiResource.Spec["single_lb_app"] = single_lb_appMap
	}
	if data.SlowDdosMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDdosMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDdosMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDdosMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDdosMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDdosMitigation.RequestTimeout.IsNull() && !data.SlowDdosMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDdosMitigation.RequestTimeout.ValueInt64()
		}
		apiResource.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SourceIPStickiness != nil {
		source_ip_stickinessMap := make(map[string]interface{})
		apiResource.Spec["source_ip_stickiness"] = source_ip_stickinessMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		apiResource.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if len(data.TrustedClients) > 0 {
		var trusted_clientsList []map[string]interface{}
		for _, item := range data.TrustedClients {
			itemMap := make(map[string]interface{})
			if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
				itemMap["as_number"] = item.AsNumber.ValueInt64()
			}
			if item.BotSkipProcessing != nil {
				itemMap["bot_skip_processing"] = map[string]interface{}{}
			}
			if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
				itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
			}
			if item.HTTPHeader != nil {
				http_headerNestedMap := make(map[string]interface{})
				itemMap["http_header"] = http_headerNestedMap
			}
			if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
				itemMap["ip_prefix"] = item.IPPrefix.ValueString()
			}
			if !item.IPV6Prefix.IsNull() && !item.IPV6Prefix.IsUnknown() {
				itemMap["ipv6_prefix"] = item.IPV6Prefix.ValueString()
			}
			if item.Metadata != nil {
				metadataNestedMap := make(map[string]interface{})
				if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
					metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
				}
				if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
					metadataNestedMap["name"] = item.Metadata.Name.ValueString()
				}
				itemMap["metadata"] = metadataNestedMap
			}
			if item.SkipProcessing != nil {
				itemMap["skip_processing"] = map[string]interface{}{}
			}
			if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
				itemMap["user_identifier"] = item.UserIdentifier.ValueString()
			}
			if item.WAFSkipProcessing != nil {
				itemMap["waf_skip_processing"] = map[string]interface{}{}
			}
			trusted_clientsList = append(trusted_clientsList, itemMap)
		}
		apiResource.Spec["trusted_clients"] = trusted_clientsList
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		apiResource.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		apiResource.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		apiResource.Spec["waf_exclusion"] = waf_exclusionMap
	}
	if !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		apiResource.Spec["add_location"] = data.AddLocation.ValueBool()
	}


	updated, err := r.client.UpdateHTTPLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update HTTPLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response
	if v, ok := updated.Spec["add_location"].(bool); ok {
		data.AddLocation = types.BoolValue(v)
	} else if data.AddLocation.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AddLocation = types.BoolNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetHTTPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HTTPLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteHTTPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "HTTPLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "HTTPLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete HTTPLoadBalancer: %s", err))
		return
	}
}

func (r *HTTPLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
