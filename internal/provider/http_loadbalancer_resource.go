// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &HTTPLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &HTTPLoadBalancerResource{}
)

// http_loadbalancerSchemaVersion is the schema version for state upgrades
const http_loadbalancerSchemaVersion int64 = 1

func NewHTTPLoadBalancerResource() resource.Resource {
	return &HTTPLoadBalancerResource{}
}

type HTTPLoadBalancerResource struct {
	client *client.Client
}

// HTTPLoadBalancerEmptyModel represents empty nested blocks
type HTTPLoadBalancerEmptyModel struct {
}

// HTTPLoadBalancerActiveServicePoliciesModel represents active_service_policies block
type HTTPLoadBalancerActiveServicePoliciesModel struct {
	Policies []HTTPLoadBalancerActiveServicePoliciesPoliciesModel `tfsdk:"policies"`
}

// HTTPLoadBalancerActiveServicePoliciesModelAttrTypes defines the attribute types for HTTPLoadBalancerActiveServicePoliciesModel
var HTTPLoadBalancerActiveServicePoliciesModelAttrTypes = map[string]attr.Type{
	"policies": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes}},
}

// HTTPLoadBalancerActiveServicePoliciesPoliciesModel represents policies block
type HTTPLoadBalancerActiveServicePoliciesPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes defines the attribute types for HTTPLoadBalancerActiveServicePoliciesPoliciesModel
var HTTPLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomModel represents advertise_custom block
type HTTPLoadBalancerAdvertiseCustomModel struct {
	AdvertiseWhere []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
}

// HTTPLoadBalancerAdvertiseCustomModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomModel
var HTTPLoadBalancerAdvertiseCustomModelAttrTypes = map[string]attr.Type{
	"advertise_where": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes}},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel struct {
	Port               types.Int64                                                           `tfsdk:"port"`
	PortRanges         types.String                                                          `tfsdk:"port_ranges"`
	AdvertiseOnPublic  *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel  `tfsdk:"advertise_on_public"`
	Site               *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel               `tfsdk:"site"`
	UseDefaultPort     *HTTPLoadBalancerEmptyModel                                           `tfsdk:"use_default_port"`
	VirtualNetwork     *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel     `tfsdk:"virtual_network"`
	VirtualSite        *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel        `tfsdk:"virtual_site"`
	VirtualSiteWithVIP *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel `tfsdk:"virtual_site_with_vip"`
	Vk8sService        *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel        `tfsdk:"vk8s_service"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes = map[string]attr.Type{
	"port":                  types.Int64Type,
	"port_ranges":           types.StringType,
	"advertise_on_public":   types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes},
	"site":                  types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes},
	"use_default_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_network":       types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes},
	"virtual_site":          types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes},
	"virtual_site_with_vip": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes},
	"vk8s_service":          types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel represents advertise_on_public block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel struct {
	PublicIP *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel represents public_ip block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel represents site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP      types.String                                                `tfsdk:"ip"`
	Network types.String                                                `tfsdk:"network"`
	Site    *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes = map[string]attr.Type{
	"ip":      types.StringType,
	"network": types.StringType,
	"site":    types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel represents virtual_network block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel struct {
	SpecificV6VIP  types.String                                                                    `tfsdk:"specific_v6_vip"`
	SpecificVIP    types.String                                                                    `tfsdk:"specific_vip"`
	DefaultV6VIP   *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"default_v6_vip"`
	DefaultVIP     *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"default_vip"`
	VirtualNetwork *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel `tfsdk:"virtual_network"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"specific_v6_vip": types.StringType,
	"specific_vip":    types.StringType,
	"default_v6_vip":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_vip":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_network": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel represents virtual_network block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                              `tfsdk:"network"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes = map[string]attr.Type{
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel represents virtual_site_with_vip block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel struct {
	IP          types.String                                                                     `tfsdk:"ip"`
	Network     types.String                                                                     `tfsdk:"network"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes = map[string]attr.Type{
	"ip":           types.StringType,
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site        *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel        `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel
var HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAdvertiseOnPublicModel represents advertise_on_public block
type HTTPLoadBalancerAdvertiseOnPublicModel struct {
	PublicIP *HTTPLoadBalancerAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// HTTPLoadBalancerAdvertiseOnPublicModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseOnPublicModel
var HTTPLoadBalancerAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: HTTPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes},
}

// HTTPLoadBalancerAdvertiseOnPublicPublicIPModel represents public_ip block
type HTTPLoadBalancerAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes defines the attribute types for HTTPLoadBalancerAdvertiseOnPublicPublicIPModel
var HTTPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesModel represents api_protection_rules block
type HTTPLoadBalancerAPIProtectionRulesModel struct {
	APIEndpointRules []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel `tfsdk:"api_endpoint_rules"`
	APIGroupsRules   []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel   `tfsdk:"api_groups_rules"`
}

// HTTPLoadBalancerAPIProtectionRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesModel
var HTTPLoadBalancerAPIProtectionRulesModelAttrTypes = map[string]attr.Type{
	"api_endpoint_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModelAttrTypes}},
	"api_groups_rules":   types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel represents api_endpoint_rules block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel struct {
	APIEndpointPath   types.String                                                              `tfsdk:"api_endpoint_path"`
	SpecificDomain    types.String                                                              `tfsdk:"specific_domain"`
	Action            *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel            `tfsdk:"action"`
	AnyDomain         *HTTPLoadBalancerEmptyModel                                               `tfsdk:"any_domain"`
	APIEndpointMethod *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel `tfsdk:"api_endpoint_method"`
	ClientMatcher     *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel     `tfsdk:"client_matcher"`
	Metadata          *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel          `tfsdk:"metadata"`
	RequestMatcher    *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel    `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModelAttrTypes = map[string]attr.Type{
	"api_endpoint_path":   types.StringType,
	"specific_domain":     types.StringType,
	"action":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModelAttrTypes},
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint_method": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModelAttrTypes},
	"client_matcher":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModelAttrTypes},
	"metadata":            types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModelAttrTypes},
	"request_matcher":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel represents action block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel struct {
	Allow *HTTPLoadBalancerEmptyModel `tfsdk:"allow"`
	Deny  *HTTPLoadBalancerEmptyModel `tfsdk:"deny"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModelAttrTypes = map[string]attr.Type{
	"allow": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"deny":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel represents api_endpoint_method block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods       types.List `tfsdk:"methods"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"methods":        types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel struct {
	AnyClient             *HTTPLoadBalancerEmptyModel                                                                `tfsdk:"any_client"`
	AnyIP                 *HTTPLoadBalancerEmptyModel                                                                `tfsdk:"any_ip"`
	AsnList               *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                                `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                               `tfsdk:"invert_matcher"`
	Name            types.String                                                                             `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                              `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                              `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                        `tfsdk:"invert_matcher"`
	Name            types.String                                                                      `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                          `tfsdk:"invert_matcher"`
	Name            types.String                                                                        `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                            `tfsdk:"invert_matcher"`
	Key             types.String                                                                          `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel represents api_groups_rules block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel struct {
	APIGroup       types.String                                                         `tfsdk:"api_group"`
	BasePath       types.String                                                         `tfsdk:"base_path"`
	SpecificDomain types.String                                                         `tfsdk:"specific_domain"`
	Action         *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel         `tfsdk:"action"`
	AnyDomain      *HTTPLoadBalancerEmptyModel                                          `tfsdk:"any_domain"`
	ClientMatcher  *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel  `tfsdk:"client_matcher"`
	Metadata       *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel       `tfsdk:"metadata"`
	RequestMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModelAttrTypes = map[string]attr.Type{
	"api_group":       types.StringType,
	"base_path":       types.StringType,
	"specific_domain": types.StringType,
	"action":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModelAttrTypes},
	"any_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"client_matcher":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModelAttrTypes},
	"metadata":        types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModelAttrTypes},
	"request_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel represents action block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel struct {
	Allow *HTTPLoadBalancerEmptyModel `tfsdk:"allow"`
	Deny  *HTTPLoadBalancerEmptyModel `tfsdk:"deny"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModelAttrTypes = map[string]attr.Type{
	"allow": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"deny":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel struct {
	AnyClient             *HTTPLoadBalancerEmptyModel                                                              `tfsdk:"any_client"`
	AnyIP                 *HTTPLoadBalancerEmptyModel                                                              `tfsdk:"any_ip"`
	AsnList               *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                              `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                             `tfsdk:"invert_matcher"`
	Name            types.String                                                                           `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                            `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                            `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                      `tfsdk:"invert_matcher"`
	Name            types.String                                                                    `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                        `tfsdk:"invert_matcher"`
	Name            types.String                                                                      `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                          `tfsdk:"invert_matcher"`
	Key             types.String                                                                        `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModel
var HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitModel represents api_rate_limit block
type HTTPLoadBalancerAPIRateLimitModel struct {
	APIEndpointRules        []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel       `tfsdk:"api_endpoint_rules"`
	BypassRateLimitingRules *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
	CustomIPAllowedList     *HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel     `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList           *HTTPLoadBalancerAPIRateLimitIPAllowedListModel           `tfsdk:"ip_allowed_list"`
	NoIPAllowedList         *HTTPLoadBalancerEmptyModel                               `tfsdk:"no_ip_allowed_list"`
	ServerURLRules          []HTTPLoadBalancerAPIRateLimitServerURLRulesModel         `tfsdk:"server_url_rules"`
}

// HTTPLoadBalancerAPIRateLimitModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitModel
var HTTPLoadBalancerAPIRateLimitModelAttrTypes = map[string]attr.Type{
	"api_endpoint_rules":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModelAttrTypes}},
	"bypass_rate_limiting_rules": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModelAttrTypes},
	"custom_ip_allowed_list":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModelAttrTypes},
	"ip_allowed_list":            types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitIPAllowedListModelAttrTypes},
	"no_ip_allowed_list":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"server_url_rules":           types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel represents api_endpoint_rules block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel struct {
	APIEndpointPath   types.String                                                        `tfsdk:"api_endpoint_path"`
	SpecificDomain    types.String                                                        `tfsdk:"specific_domain"`
	AnyDomain         *HTTPLoadBalancerEmptyModel                                         `tfsdk:"any_domain"`
	APIEndpointMethod *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel `tfsdk:"api_endpoint_method"`
	ClientMatcher     *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel     `tfsdk:"client_matcher"`
	InlineRateLimiter *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter    *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel    `tfsdk:"ref_rate_limiter"`
	RequestMatcher    *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel    `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModelAttrTypes = map[string]attr.Type{
	"api_endpoint_path":   types.StringType,
	"specific_domain":     types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint_method": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModelAttrTypes},
	"client_matcher":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModelAttrTypes},
	"inline_rate_limiter": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModelAttrTypes},
	"ref_rate_limiter":    types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModelAttrTypes},
	"request_matcher":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel represents api_endpoint_method block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods       types.List `tfsdk:"methods"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"methods":        types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel struct {
	AnyClient             *HTTPLoadBalancerEmptyModel                                                          `tfsdk:"any_client"`
	AnyIP                 *HTTPLoadBalancerEmptyModel                                                          `tfsdk:"any_ip"`
	AsnList               *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                          `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel represents inline_rate_limiter block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel struct {
	Threshold       types.Int64                                                                  `tfsdk:"threshold"`
	Unit            types.String                                                                 `tfsdk:"unit"`
	RefUserID       *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLBUserID *HTTPLoadBalancerEmptyModel                                                  `tfsdk:"use_http_lb_user_id"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModelAttrTypes = map[string]attr.Type{
	"threshold":           types.Int64Type,
	"unit":                types.StringType,
	"ref_user_id":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModelAttrTypes},
	"use_http_lb_user_id": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterRefUserIDModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel represents ref_rate_limiter block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                         `tfsdk:"invert_matcher"`
	Name            types.String                                                                       `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                        `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                        `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                  `tfsdk:"invert_matcher"`
	Name            types.String                                                                `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                    `tfsdk:"invert_matcher"`
	Name            types.String                                                                  `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                      `tfsdk:"invert_matcher"`
	Key             types.String                                                                    `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModel
var HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel struct {
	BypassRateLimitingRules []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel `tfsdk:"bypass_rate_limiting_rules"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModelAttrTypes = map[string]attr.Type{
	"bypass_rate_limiting_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel represents bypass_rate_limiting_rules block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel struct {
	BasePath       types.String                                                                                   `tfsdk:"base_path"`
	SpecificDomain types.String                                                                                   `tfsdk:"specific_domain"`
	AnyDomain      *HTTPLoadBalancerEmptyModel                                                                    `tfsdk:"any_domain"`
	AnyURL         *HTTPLoadBalancerEmptyModel                                                                    `tfsdk:"any_url"`
	APIEndpoint    *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel    `tfsdk:"api_endpoint"`
	APIGroups      *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel      `tfsdk:"api_groups"`
	ClientMatcher  *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel  `tfsdk:"client_matcher"`
	RequestMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesModelAttrTypes = map[string]attr.Type{
	"base_path":       types.StringType,
	"specific_domain": types.StringType,
	"any_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_url":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":    types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModelAttrTypes},
	"api_groups":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModelAttrTypes},
	"client_matcher":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModelAttrTypes},
	"request_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel represents api_groups block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesAPIGroupsModelAttrTypes = map[string]attr.Type{
	"api_groups": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel struct {
	AnyClient             *HTTPLoadBalancerEmptyModel                                                                                        `tfsdk:"any_client"`
	AnyIP                 *HTTPLoadBalancerEmptyModel                                                                                        `tfsdk:"any_ip"`
	AsnList               *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                                                        `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                                                       `tfsdk:"invert_matcher"`
	Name            types.String                                                                                                     `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                                                      `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                                                      `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                                                `tfsdk:"invert_matcher"`
	Name            types.String                                                                                              `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                                               `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                                               `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                                                  `tfsdk:"invert_matcher"`
	Name            types.String                                                                                                `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                                                 `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                                                 `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                                                    `tfsdk:"invert_matcher"`
	Key             types.String                                                                                                  `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                                                   `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                                                   `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModel
var HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesBypassRateLimitingRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel
var HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModelAttrTypes = map[string]attr.Type{
	"rate_limiter_allowed_prefixes": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel
var HTTPLoadBalancerAPIRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPIRateLimitIPAllowedListModel represents ip_allowed_list block
type HTTPLoadBalancerAPIRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerAPIRateLimitIPAllowedListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitIPAllowedListModel
var HTTPLoadBalancerAPIRateLimitIPAllowedListModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesModel represents server_url_rules block
type HTTPLoadBalancerAPIRateLimitServerURLRulesModel struct {
	APIGroup          types.String                                                      `tfsdk:"api_group"`
	BasePath          types.String                                                      `tfsdk:"base_path"`
	SpecificDomain    types.String                                                      `tfsdk:"specific_domain"`
	AnyDomain         *HTTPLoadBalancerEmptyModel                                       `tfsdk:"any_domain"`
	ClientMatcher     *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel     `tfsdk:"client_matcher"`
	InlineRateLimiter *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel `tfsdk:"inline_rate_limiter"`
	RefRateLimiter    *HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel    `tfsdk:"ref_rate_limiter"`
	RequestMatcher    *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel    `tfsdk:"request_matcher"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesModelAttrTypes = map[string]attr.Type{
	"api_group":           types.StringType,
	"base_path":           types.StringType,
	"specific_domain":     types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"client_matcher":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModelAttrTypes},
	"inline_rate_limiter": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModelAttrTypes},
	"ref_rate_limiter":    types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModelAttrTypes},
	"request_matcher":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel represents client_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel struct {
	AnyClient             *HTTPLoadBalancerEmptyModel                                                        `tfsdk:"any_client"`
	AnyIP                 *HTTPLoadBalancerEmptyModel                                                        `tfsdk:"any_ip"`
	AsnList               *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher            *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel            `tfsdk:"asn_matcher"`
	ClientSelector        *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel        `tfsdk:"client_selector"`
	IPMatcher             *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList          *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	IPThreatCategoryList  *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel  `tfsdk:"ip_threat_category_list"`
	TLSFingerprintMatcher *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModelAttrTypes = map[string]attr.Type{
	"any_client":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModelAttrTypes},
	"asn_matcher":             types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModelAttrTypes},
	"client_selector":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModelAttrTypes},
	"ip_matcher":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModelAttrTypes},
	"ip_prefix_list":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModelAttrTypes},
	"ip_threat_category_list": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModelAttrTypes},
	"tls_fingerprint_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel represents asn_list block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel represents client_selector block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel struct {
	InvertMatcher types.Bool                                                                        `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel represents ip_threat_category_list block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherIPThreatCategoryListModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel represents inline_rate_limiter block
type HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel struct {
	Threshold       types.Int64                                                                `tfsdk:"threshold"`
	Unit            types.String                                                               `tfsdk:"unit"`
	RefUserID       *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel `tfsdk:"ref_user_id"`
	UseHTTPLBUserID *HTTPLoadBalancerEmptyModel                                                `tfsdk:"use_http_lb_user_id"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModelAttrTypes = map[string]attr.Type{
	"threshold":           types.Int64Type,
	"unit":                types.StringType,
	"ref_user_id":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModelAttrTypes},
	"use_http_lb_user_id": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel represents ref_user_id block
type HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterRefUserIDModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel represents ref_rate_limiter block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel represents request_matcher block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel struct {
	CookieMatchers []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel `tfsdk:"cookie_matchers"`
	Headers        []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel        `tfsdk:"headers"`
	JWTClaims      []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel      `tfsdk:"jwt_claims"`
	QueryParams    []HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel    `tfsdk:"query_params"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModelAttrTypes = map[string]attr.Type{
	"cookie_matchers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModelAttrTypes}},
	"headers":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModelAttrTypes}},
	"jwt_claims":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModelAttrTypes}},
	"query_params":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModelAttrTypes}},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                       `tfsdk:"invert_matcher"`
	Name            types.String                                                                     `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel represents headers block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel struct {
	InvertMatcher   types.Bool                                                                `tfsdk:"invert_matcher"`
	Name            types.String                                                              `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                               `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                               `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel represents jwt_claims block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel struct {
	InvertMatcher   types.Bool                                                                  `tfsdk:"invert_matcher"`
	Name            types.String                                                                `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherJWTClaimsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel represents query_params block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                    `tfsdk:"invert_matcher"`
	Key             types.String                                                                  `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel represents item block
type HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModel
var HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerAPISpecificationModel represents api_specification block
type HTTPLoadBalancerAPISpecificationModel struct {
	APIDefinition              *HTTPLoadBalancerAPISpecificationAPIDefinitionModel              `tfsdk:"api_definition"`
	ValidationAllSpecEndpoints *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel `tfsdk:"validation_all_spec_endpoints"`
	ValidationCustomList       *HTTPLoadBalancerAPISpecificationValidationCustomListModel       `tfsdk:"validation_custom_list"`
	ValidationDisabled         *HTTPLoadBalancerEmptyModel                                      `tfsdk:"validation_disabled"`
}

// HTTPLoadBalancerAPISpecificationModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationModel
var HTTPLoadBalancerAPISpecificationModelAttrTypes = map[string]attr.Type{
	"api_definition":                types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationAPIDefinitionModelAttrTypes},
	"validation_all_spec_endpoints": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModelAttrTypes},
	"validation_custom_list":        types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListModelAttrTypes},
	"validation_disabled":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationAPIDefinitionModel represents api_definition block
type HTTPLoadBalancerAPISpecificationAPIDefinitionModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAPISpecificationAPIDefinitionModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationAPIDefinitionModel
var HTTPLoadBalancerAPISpecificationAPIDefinitionModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel represents validation_all_spec_endpoints block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel struct {
	FallThroughMode *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel `tfsdk:"fall_through_mode"`
	Settings        *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel        `tfsdk:"settings"`
	ValidationMode  *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel  `tfsdk:"validation_mode"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsModelAttrTypes = map[string]attr.Type{
	"fall_through_mode": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModelAttrTypes},
	"settings":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModelAttrTypes},
	"validation_mode":   types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel represents fall_through_mode block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel struct {
	FallThroughModeAllow  *HTTPLoadBalancerEmptyModel                                                                          `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeModelAttrTypes = map[string]attr.Type{
	"fall_through_mode_allow":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"fall_through_mode_custom": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomModelAttrTypes = map[string]attr.Type{
	"open_api_validation_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes}},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup     types.String                                                                                                                          `tfsdk:"api_group"`
	BasePath     types.String                                                                                                                          `tfsdk:"base_path"`
	ActionBlock  *HTTPLoadBalancerEmptyModel                                                                                                           `tfsdk:"action_block"`
	ActionReport *HTTPLoadBalancerEmptyModel                                                                                                           `tfsdk:"action_report"`
	ActionSkip   *HTTPLoadBalancerEmptyModel                                                                                                           `tfsdk:"action_skip"`
	APIEndpoint  *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata     *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel    `tfsdk:"metadata"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes = map[string]attr.Type{
	"api_group":     types.StringType,
	"base_path":     types.StringType,
	"action_block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_skip":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes},
	"metadata":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel represents settings block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel struct {
	OversizedBodyFailValidation       *HTTPLoadBalancerEmptyModel                                                                              `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation       *HTTPLoadBalancerEmptyModel                                                                              `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom  *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *HTTPLoadBalancerEmptyModel                                                                              `tfsdk:"property_validation_settings_default"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsModelAttrTypes = map[string]attr.Type{
	"oversized_body_fail_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"oversized_body_skip_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"property_validation_settings_custom":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModelAttrTypes},
	"property_validation_settings_default": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomModelAttrTypes = map[string]attr.Type{
	"query_parameters": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters    *HTTPLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *HTTPLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes = map[string]attr.Type{
	"allow_additional_parameters":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disallow_additional_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel represents validation_mode block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel struct {
	ResponseValidationModeActive *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation       *HTTPLoadBalancerEmptyModel                                                                                `tfsdk:"skip_response_validation"`
	SkipValidation               *HTTPLoadBalancerEmptyModel                                                                                `tfsdk:"skip_validation"`
	ValidationModeActive         *HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel         `tfsdk:"validation_mode_active"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeModelAttrTypes = map[string]attr.Type{
	"response_validation_mode_active": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModelAttrTypes},
	"skip_response_validation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_validation":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validation_mode_active":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List                  `tfsdk:"response_validation_properties"`
	EnforcementBlock             *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport            *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeResponseValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"response_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel represents validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List                  `tfsdk:"request_validation_properties"`
	EnforcementBlock            *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport           *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModel
var HTTPLoadBalancerAPISpecificationValidationAllSpecEndpointsValidationModeValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"request_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListModel represents validation_custom_list block
type HTTPLoadBalancerAPISpecificationValidationCustomListModel struct {
	FallThroughMode        *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel         `tfsdk:"fall_through_mode"`
	OpenAPIValidationRules []HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
	Settings               *HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel                `tfsdk:"settings"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListModel
var HTTPLoadBalancerAPISpecificationValidationCustomListModelAttrTypes = map[string]attr.Type{
	"fall_through_mode":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModelAttrTypes},
	"open_api_validation_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModelAttrTypes}},
	"settings":                  types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel represents fall_through_mode block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel struct {
	FallThroughModeAllow  *HTTPLoadBalancerEmptyModel                                                                    `tfsdk:"fall_through_mode_allow"`
	FallThroughModeCustom *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel `tfsdk:"fall_through_mode_custom"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModel
var HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeModelAttrTypes = map[string]attr.Type{
	"fall_through_mode_allow":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"fall_through_mode_custom": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel represents fall_through_mode_custom block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel struct {
	OpenAPIValidationRules []HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel `tfsdk:"open_api_validation_rules"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModel
var HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomModelAttrTypes = map[string]attr.Type{
	"open_api_validation_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes}},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel represents open_api_validation_rules block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel struct {
	APIGroup     types.String                                                                                                                    `tfsdk:"api_group"`
	BasePath     types.String                                                                                                                    `tfsdk:"base_path"`
	ActionBlock  *HTTPLoadBalancerEmptyModel                                                                                                     `tfsdk:"action_block"`
	ActionReport *HTTPLoadBalancerEmptyModel                                                                                                     `tfsdk:"action_report"`
	ActionSkip   *HTTPLoadBalancerEmptyModel                                                                                                     `tfsdk:"action_skip"`
	APIEndpoint  *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel `tfsdk:"api_endpoint"`
	Metadata     *HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel    `tfsdk:"metadata"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModel
var HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesModelAttrTypes = map[string]attr.Type{
	"api_group":     types.StringType,
	"base_path":     types.StringType,
	"action_block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"action_skip":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes},
	"metadata":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModel
var HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModel
var HTTPLoadBalancerAPISpecificationValidationCustomListFallThroughModeFallThroughModeCustomOpenAPIValidationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel represents open_api_validation_rules block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel struct {
	APIGroup       types.String                                                                                   `tfsdk:"api_group"`
	BasePath       types.String                                                                                   `tfsdk:"base_path"`
	SpecificDomain types.String                                                                                   `tfsdk:"specific_domain"`
	AnyDomain      *HTTPLoadBalancerEmptyModel                                                                    `tfsdk:"any_domain"`
	APIEndpoint    *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel    `tfsdk:"api_endpoint"`
	Metadata       *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel       `tfsdk:"metadata"`
	ValidationMode *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel `tfsdk:"validation_mode"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModel
var HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesModelAttrTypes = map[string]attr.Type{
	"api_group":       types.StringType,
	"base_path":       types.StringType,
	"specific_domain": types.StringType,
	"any_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_endpoint":    types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModelAttrTypes},
	"metadata":        types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModelAttrTypes},
	"validation_mode": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModel
var HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel represents metadata block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModel
var HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel represents validation_mode block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel struct {
	ResponseValidationModeActive *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel `tfsdk:"response_validation_mode_active"`
	SkipResponseValidation       *HTTPLoadBalancerEmptyModel                                                                                                `tfsdk:"skip_response_validation"`
	SkipValidation               *HTTPLoadBalancerEmptyModel                                                                                                `tfsdk:"skip_validation"`
	ValidationModeActive         *HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel         `tfsdk:"validation_mode_active"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModel
var HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeModelAttrTypes = map[string]attr.Type{
	"response_validation_mode_active": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModelAttrTypes},
	"skip_response_validation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_validation":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validation_mode_active":          types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel represents response_validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel struct {
	ResponseValidationProperties types.List                  `tfsdk:"response_validation_properties"`
	EnforcementBlock             *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport            *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModel
var HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeResponseValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"response_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel represents validation_mode_active block
type HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel struct {
	RequestValidationProperties types.List                  `tfsdk:"request_validation_properties"`
	EnforcementBlock            *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_block"`
	EnforcementReport           *HTTPLoadBalancerEmptyModel `tfsdk:"enforcement_report"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModel
var HTTPLoadBalancerAPISpecificationValidationCustomListOpenAPIValidationRulesValidationModeValidationModeActiveModelAttrTypes = map[string]attr.Type{
	"request_validation_properties": types.ListType{ElemType: types.StringType},
	"enforcement_block":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enforcement_report":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel represents settings block
type HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel struct {
	OversizedBodyFailValidation       *HTTPLoadBalancerEmptyModel                                                                        `tfsdk:"oversized_body_fail_validation"`
	OversizedBodySkipValidation       *HTTPLoadBalancerEmptyModel                                                                        `tfsdk:"oversized_body_skip_validation"`
	PropertyValidationSettingsCustom  *HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel `tfsdk:"property_validation_settings_custom"`
	PropertyValidationSettingsDefault *HTTPLoadBalancerEmptyModel                                                                        `tfsdk:"property_validation_settings_default"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModel
var HTTPLoadBalancerAPISpecificationValidationCustomListSettingsModelAttrTypes = map[string]attr.Type{
	"oversized_body_fail_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"oversized_body_skip_validation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"property_validation_settings_custom":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModelAttrTypes},
	"property_validation_settings_default": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel represents property_validation_settings_custom block
type HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel struct {
	Queryparameters *HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel `tfsdk:"query_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModel
var HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomModelAttrTypes = map[string]attr.Type{
	"query_parameters": types.ObjectType{AttrTypes: HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes},
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel represents query_parameters block
type HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel struct {
	AllowAdditionalParameters    *HTTPLoadBalancerEmptyModel `tfsdk:"allow_additional_parameters"`
	DisallowAdditionalParameters *HTTPLoadBalancerEmptyModel `tfsdk:"disallow_additional_parameters"`
}

// HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModel
var HTTPLoadBalancerAPISpecificationValidationCustomListSettingsPropertyValidationSettingsCustomQueryParametersModelAttrTypes = map[string]attr.Type{
	"allow_additional_parameters":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disallow_additional_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPITestingModel represents api_testing block
type HTTPLoadBalancerAPITestingModel struct {
	CustomHeaderValue types.String                             `tfsdk:"custom_header_value"`
	Domains           []HTTPLoadBalancerAPITestingDomainsModel `tfsdk:"domains"`
	EveryDay          *HTTPLoadBalancerEmptyModel              `tfsdk:"every_day"`
	EveryMonth        *HTTPLoadBalancerEmptyModel              `tfsdk:"every_month"`
	EveryWeek         *HTTPLoadBalancerEmptyModel              `tfsdk:"every_week"`
}

// HTTPLoadBalancerAPITestingModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingModel
var HTTPLoadBalancerAPITestingModelAttrTypes = map[string]attr.Type{
	"custom_header_value": types.StringType,
	"domains":             types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsModelAttrTypes}},
	"every_day":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"every_month":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"every_week":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPITestingDomainsModel represents domains block
type HTTPLoadBalancerAPITestingDomainsModel struct {
	AllowDestructiveMethods types.Bool                                          `tfsdk:"allow_destructive_methods"`
	Domain                  types.String                                        `tfsdk:"domain"`
	Credentials             []HTTPLoadBalancerAPITestingDomainsCredentialsModel `tfsdk:"credentials"`
}

// HTTPLoadBalancerAPITestingDomainsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsModel
var HTTPLoadBalancerAPITestingDomainsModelAttrTypes = map[string]attr.Type{
	"allow_destructive_methods": types.BoolType,
	"domain":                    types.StringType,
	"credentials":               types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsModelAttrTypes}},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsModel represents credentials block
type HTTPLoadBalancerAPITestingDomainsCredentialsModel struct {
	CredentialName types.String                                                    `tfsdk:"credential_name"`
	Admin          *HTTPLoadBalancerEmptyModel                                     `tfsdk:"admin"`
	APIKey         *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel        `tfsdk:"api_key"`
	BasicAuth      *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel     `tfsdk:"basic_auth"`
	BearerToken    *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel   `tfsdk:"bearer_token"`
	LoginEndpoint  *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel `tfsdk:"login_endpoint"`
	Standard       *HTTPLoadBalancerEmptyModel                                     `tfsdk:"standard"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsModel
var HTTPLoadBalancerAPITestingDomainsCredentialsModelAttrTypes = map[string]attr.Type{
	"credential_name": types.StringType,
	"admin":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_key":         types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModelAttrTypes},
	"basic_auth":      types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModelAttrTypes},
	"bearer_token":    types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModelAttrTypes},
	"login_endpoint":  types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModelAttrTypes},
	"standard":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel represents api_key block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel struct {
	Key   types.String                                                  `tfsdk:"key"`
	Value *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel `tfsdk:"value"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModel
var HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyModelAttrTypes = map[string]attr.Type{
	"key":   types.StringType,
	"value": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel represents value block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModel
var HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsAPIKeyValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel represents basic_auth block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel struct {
	User     types.String                                                        `tfsdk:"user"`
	Password *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel `tfsdk:"password"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthModelAttrTypes = map[string]attr.Type{
	"user":     types.StringType,
	"password": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel represents password block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBasicAuthPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel represents bearer_token block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel struct {
	Token *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel `tfsdk:"token"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenModelAttrTypes = map[string]attr.Type{
	"token": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel represents token block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsBearerTokenTokenClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel represents login_endpoint block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel struct {
	Method           types.String                                                               `tfsdk:"method"`
	Path             types.String                                                               `tfsdk:"path"`
	TokenResponseKey types.String                                                               `tfsdk:"token_response_key"`
	JSONPayload      *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModel `tfsdk:"json_payload"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModel
var HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointModelAttrTypes = map[string]attr.Type{
	"method":             types.StringType,
	"path":               types.StringType,
	"token_response_key": types.StringType,
	"json_payload":       types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModel represents json_payload block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModel
var HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModel
var HTTPLoadBalancerAPITestingDomainsCredentialsLoginEndpointJSONPayloadClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerAppFirewallModel represents app_firewall block
type HTTPLoadBalancerAppFirewallModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerAppFirewallModelAttrTypes defines the attribute types for HTTPLoadBalancerAppFirewallModel
var HTTPLoadBalancerAppFirewallModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerBlockedClientsModel represents blocked_clients block
type HTTPLoadBalancerBlockedClientsModel struct {
	Actions             types.List                                     `tfsdk:"actions"`
	AsNumber            types.Int64                                    `tfsdk:"as_number"`
	ExpirationTimestamp types.String                                   `tfsdk:"expiration_timestamp"`
	IPPrefix            types.String                                   `tfsdk:"ip_prefix"`
	Ipv6Prefix          types.String                                   `tfsdk:"ipv6_prefix"`
	UserIdentifier      types.String                                   `tfsdk:"user_identifier"`
	BotSkipProcessing   *HTTPLoadBalancerEmptyModel                    `tfsdk:"bot_skip_processing"`
	HTTPHeader          *HTTPLoadBalancerBlockedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata            *HTTPLoadBalancerBlockedClientsMetadataModel   `tfsdk:"metadata"`
	SkipProcessing      *HTTPLoadBalancerEmptyModel                    `tfsdk:"skip_processing"`
	WAFSkipProcessing   *HTTPLoadBalancerEmptyModel                    `tfsdk:"waf_skip_processing"`
}

// HTTPLoadBalancerBlockedClientsModelAttrTypes defines the attribute types for HTTPLoadBalancerBlockedClientsModel
var HTTPLoadBalancerBlockedClientsModelAttrTypes = map[string]attr.Type{
	"actions":              types.ListType{ElemType: types.StringType},
	"as_number":            types.Int64Type,
	"expiration_timestamp": types.StringType,
	"ip_prefix":            types.StringType,
	"ipv6_prefix":          types.StringType,
	"user_identifier":      types.StringType,
	"bot_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_header":          types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsHTTPHeaderModelAttrTypes},
	"metadata":             types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsMetadataModelAttrTypes},
	"skip_processing":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"waf_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBlockedClientsHTTPHeaderModel represents http_header block
type HTTPLoadBalancerBlockedClientsHTTPHeaderModel struct {
	Headers []HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerBlockedClientsHTTPHeaderModelAttrTypes defines the attribute types for HTTPLoadBalancerBlockedClientsHTTPHeaderModel
var HTTPLoadBalancerBlockedClientsHTTPHeaderModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModelAttrTypes}},
}

// HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel represents headers block
type HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModel
var HTTPLoadBalancerBlockedClientsHTTPHeaderHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// HTTPLoadBalancerBlockedClientsMetadataModel represents metadata block
type HTTPLoadBalancerBlockedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBlockedClientsMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBlockedClientsMetadataModel
var HTTPLoadBalancerBlockedClientsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefenseModel represents bot_defense block
type HTTPLoadBalancerBotDefenseModel struct {
	RegionalEndpoint   types.String                           `tfsdk:"regional_endpoint"`
	Timeout            types.Int64                            `tfsdk:"timeout"`
	DisableCORSSupport *HTTPLoadBalancerEmptyModel            `tfsdk:"disable_cors_support"`
	EnableCORSSupport  *HTTPLoadBalancerEmptyModel            `tfsdk:"enable_cors_support"`
	Policy             *HTTPLoadBalancerBotDefensePolicyModel `tfsdk:"policy"`
}

// HTTPLoadBalancerBotDefenseModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseModel
var HTTPLoadBalancerBotDefenseModelAttrTypes = map[string]attr.Type{
	"regional_endpoint":    types.StringType,
	"timeout":              types.Int64Type,
	"disable_cors_support": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_cors_support":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"policy":               types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyModel represents policy block
type HTTPLoadBalancerBotDefensePolicyModel struct {
	JavascriptMode         types.String                                                 `tfsdk:"javascript_mode"`
	JsDownloadPath         types.String                                                 `tfsdk:"js_download_path"`
	DisableJsInsert        *HTTPLoadBalancerEmptyModel                                  `tfsdk:"disable_js_insert"`
	DisableMobileSdk       *HTTPLoadBalancerEmptyModel                                  `tfsdk:"disable_mobile_sdk"`
	JsInsertAllPages       *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel       `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules       *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel       `tfsdk:"js_insertion_rules"`
	MobileSdkConfig        *HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel        `tfsdk:"mobile_sdk_config"`
	ProtectedAppEndpoints  []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel `tfsdk:"protected_app_endpoints"`
}

// HTTPLoadBalancerBotDefensePolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyModel
var HTTPLoadBalancerBotDefensePolicyModelAttrTypes = map[string]attr.Type{
	"javascript_mode":            types.StringType,
	"js_download_path":           types.StringType,
	"disable_js_insert":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_mobile_sdk":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages":        types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModelAttrTypes},
	"js_insert_all_pages_except": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModelAttrTypes},
	"js_insertion_rules":         types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModelAttrTypes},
	"mobile_sdk_config":          types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModelAttrTypes},
	"protected_app_endpoints":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModelAttrTypes}},
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel represents js_insert_all_pages block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModel
var HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel struct {
	JavascriptLocation types.String                                                             `tfsdk:"javascript_location"`
	ExcludeList        []HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModel
var HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"exclude_list":        types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes}},
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                     `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModel
var HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel
var HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel
var HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModel
var HTTPLoadBalancerBotDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules       []HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel       `tfsdk:"rules"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModelAttrTypes}},
	"rules":        types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModelAttrTypes}},
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                               `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel represents rules block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel struct {
	JavascriptLocation types.String                                                        `tfsdk:"javascript_location"`
	AnyDomain          *HTTPLoadBalancerEmptyModel                                         `tfsdk:"any_domain"`
	Domain             *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel   `tfsdk:"domain"`
	Metadata           *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path               *HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes},
	"metadata":            types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes},
	"path":                types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModel
var HTTPLoadBalancerBotDefensePolicyJsInsertionRulesRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel represents mobile_sdk_config block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel struct {
	MobileIdentifier *HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel `tfsdk:"mobile_identifier"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModel
var HTTPLoadBalancerBotDefensePolicyMobileSdkConfigModelAttrTypes = map[string]attr.Type{
	"mobile_identifier": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel represents mobile_identifier block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel struct {
	Headers []HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModel
var HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModelAttrTypes}},
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel represents headers block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel struct {
	Name            types.String                                                                     `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModel
var HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel represents item block
type HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModel
var HTTPLoadBalancerBotDefensePolicyMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel represents protected_app_endpoints block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel struct {
	HTTPMethods        types.List                                                              `tfsdk:"http_methods"`
	Protocol           types.String                                                            `tfsdk:"protocol"`
	AllowGoodBots      *HTTPLoadBalancerEmptyModel                                             `tfsdk:"allow_good_bots"`
	AnyDomain          *HTTPLoadBalancerEmptyModel                                             `tfsdk:"any_domain"`
	Domain             *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel       `tfsdk:"domain"`
	FlowLabel          *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel    `tfsdk:"flow_label"`
	Headers            []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel     `tfsdk:"headers"`
	Metadata           *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel     `tfsdk:"metadata"`
	MitigateGoodBots   *HTTPLoadBalancerEmptyModel                                             `tfsdk:"mitigate_good_bots"`
	Mitigation         *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel   `tfsdk:"mitigation"`
	Mobile             *HTTPLoadBalancerEmptyModel                                             `tfsdk:"mobile"`
	Path               *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel         `tfsdk:"path"`
	QueryParams        []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel `tfsdk:"query_params"`
	UndefinedFlowLabel *HTTPLoadBalancerEmptyModel                                             `tfsdk:"undefined_flow_label"`
	Web                *HTTPLoadBalancerEmptyModel                                             `tfsdk:"web"`
	WebMobile          *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel    `tfsdk:"web_mobile"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsModelAttrTypes = map[string]attr.Type{
	"http_methods":         types.ListType{ElemType: types.StringType},
	"protocol":             types.StringType,
	"allow_good_bots":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_domain":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":               types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModelAttrTypes},
	"flow_label":           types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModelAttrTypes},
	"headers":              types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModelAttrTypes}},
	"metadata":             types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModelAttrTypes},
	"mitigate_good_bots":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mitigation":           types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModelAttrTypes},
	"mobile":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModelAttrTypes},
	"query_params":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModelAttrTypes}},
	"undefined_flow_label": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web_mobile":           types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel represents domain block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel represents flow_label block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel struct {
	AccountManagement *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel `tfsdk:"account_management"`
	Authentication    *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel    `tfsdk:"authentication"`
	FinancialServices *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel `tfsdk:"financial_services"`
	Flight            *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel            `tfsdk:"flight"`
	ProfileManagement *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel `tfsdk:"profile_management"`
	Search            *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel            `tfsdk:"search"`
	ShoppingGiftCards *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel `tfsdk:"shopping_gift_cards"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelModelAttrTypes = map[string]attr.Type{
	"account_management":  types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModelAttrTypes},
	"authentication":      types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModelAttrTypes},
	"financial_services":  types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModelAttrTypes},
	"flight":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModelAttrTypes},
	"profile_management":  types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModelAttrTypes},
	"search":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModelAttrTypes},
	"shopping_gift_cards": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel represents account_management block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel struct {
	Create        *HTTPLoadBalancerEmptyModel `tfsdk:"create"`
	PasswordReset *HTTPLoadBalancerEmptyModel `tfsdk:"password_reset"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAccountManagementModelAttrTypes = map[string]attr.Type{
	"create":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"password_reset": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel represents authentication block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel struct {
	Login        *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel `tfsdk:"login"`
	LoginMFA     *HTTPLoadBalancerEmptyModel                                                             `tfsdk:"login_mfa"`
	LoginPartner *HTTPLoadBalancerEmptyModel                                                             `tfsdk:"login_partner"`
	Logout       *HTTPLoadBalancerEmptyModel                                                             `tfsdk:"logout"`
	TokenRefresh *HTTPLoadBalancerEmptyModel                                                             `tfsdk:"token_refresh"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationModelAttrTypes = map[string]attr.Type{
	"login":         types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModelAttrTypes},
	"login_mfa":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"login_partner": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"logout":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"token_refresh": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel represents login block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel struct {
	DisableTransactionResult *HTTPLoadBalancerEmptyModel                                                                              `tfsdk:"disable_transaction_result"`
	TransactionResult        *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel `tfsdk:"transaction_result"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginModelAttrTypes = map[string]attr.Type{
	"disable_transaction_result": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"transaction_result":         types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel represents transaction_result block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel struct {
	FailureConditions []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel `tfsdk:"failure_conditions"`
	SuccessConditions []HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel `tfsdk:"success_conditions"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultModelAttrTypes = map[string]attr.Type{
	"failure_conditions": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModelAttrTypes}},
	"success_conditions": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModelAttrTypes}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel represents failure_conditions block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel struct {
	Name        types.String `tfsdk:"name"`
	RegexValues types.List   `tfsdk:"regex_values"`
	Status      types.String `tfsdk:"status"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultFailureConditionsModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"regex_values": types.ListType{ElemType: types.StringType},
	"status":       types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel represents success_conditions block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel struct {
	Name        types.String `tfsdk:"name"`
	RegexValues types.List   `tfsdk:"regex_values"`
	Status      types.String `tfsdk:"status"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelAuthenticationLoginTransactionResultSuccessConditionsModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"regex_values": types.ListType{ElemType: types.StringType},
	"status":       types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel represents financial_services block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel struct {
	Apply         *HTTPLoadBalancerEmptyModel `tfsdk:"apply"`
	MoneyTransfer *HTTPLoadBalancerEmptyModel `tfsdk:"money_transfer"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFinancialServicesModelAttrTypes = map[string]attr.Type{
	"apply":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"money_transfer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel represents flight block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel struct {
	Checkin *HTTPLoadBalancerEmptyModel `tfsdk:"checkin"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelFlightModelAttrTypes = map[string]attr.Type{
	"checkin": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel represents profile_management block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel struct {
	Create *HTTPLoadBalancerEmptyModel `tfsdk:"create"`
	Update *HTTPLoadBalancerEmptyModel `tfsdk:"update"`
	View   *HTTPLoadBalancerEmptyModel `tfsdk:"view"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelProfileManagementModelAttrTypes = map[string]attr.Type{
	"create": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"update": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"view":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel represents search block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel struct {
	FlightSearch      *HTTPLoadBalancerEmptyModel `tfsdk:"flight_search"`
	ProductSearch     *HTTPLoadBalancerEmptyModel `tfsdk:"product_search"`
	ReservationSearch *HTTPLoadBalancerEmptyModel `tfsdk:"reservation_search"`
	RoomSearch        *HTTPLoadBalancerEmptyModel `tfsdk:"room_search"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelSearchModelAttrTypes = map[string]attr.Type{
	"flight_search":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"product_search":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"reservation_search": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"room_search":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel represents shopping_gift_cards block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel struct {
	GiftCardMakePurchaseWithGiftCard *HTTPLoadBalancerEmptyModel `tfsdk:"gift_card_make_purchase_with_gift_card"`
	GiftCardValidation               *HTTPLoadBalancerEmptyModel `tfsdk:"gift_card_validation"`
	ShopAddToCart                    *HTTPLoadBalancerEmptyModel `tfsdk:"shop_add_to_cart"`
	ShopCheckout                     *HTTPLoadBalancerEmptyModel `tfsdk:"shop_checkout"`
	ShopChooseSeat                   *HTTPLoadBalancerEmptyModel `tfsdk:"shop_choose_seat"`
	ShopEnterDrawingSubmission       *HTTPLoadBalancerEmptyModel `tfsdk:"shop_enter_drawing_submission"`
	ShopMakePayment                  *HTTPLoadBalancerEmptyModel `tfsdk:"shop_make_payment"`
	ShopOrder                        *HTTPLoadBalancerEmptyModel `tfsdk:"shop_order"`
	ShopPriceInquiry                 *HTTPLoadBalancerEmptyModel `tfsdk:"shop_price_inquiry"`
	ShopPromoCodeValidation          *HTTPLoadBalancerEmptyModel `tfsdk:"shop_promo_code_validation"`
	ShopPurchaseGiftCard             *HTTPLoadBalancerEmptyModel `tfsdk:"shop_purchase_gift_card"`
	ShopUpdateQuantity               *HTTPLoadBalancerEmptyModel `tfsdk:"shop_update_quantity"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsFlowLabelShoppingGiftCardsModelAttrTypes = map[string]attr.Type{
	"gift_card_make_purchase_with_gift_card": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"gift_card_validation":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_add_to_cart":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_checkout":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_choose_seat":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_enter_drawing_submission":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_make_payment":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_order":                             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_price_inquiry":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_promo_code_validation":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_purchase_gift_card":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"shop_update_quantity":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel represents headers block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel struct {
	InvertMatcher   types.Bool                                                             `tfsdk:"invert_matcher"`
	Name            types.String                                                           `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                            `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                            `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel represents item block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel represents metadata block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel represents mitigation block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel struct {
	Block    *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel    `tfsdk:"block"`
	Flag     *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel     `tfsdk:"flag"`
	Redirect *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel `tfsdk:"redirect"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationModelAttrTypes = map[string]attr.Type{
	"block":    types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModelAttrTypes},
	"flag":     types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModelAttrTypes},
	"redirect": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel represents block block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel struct {
	Body   types.String `tfsdk:"body"`
	Status types.String `tfsdk:"status"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationBlockModelAttrTypes = map[string]attr.Type{
	"body":   types.StringType,
	"status": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel represents flag block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel struct {
	AppendHeaders *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel `tfsdk:"append_headers"`
	NoHeaders     *HTTPLoadBalancerEmptyModel                                                            `tfsdk:"no_headers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagModelAttrTypes = map[string]attr.Type{
	"append_headers": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModelAttrTypes},
	"no_headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel represents append_headers block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel struct {
	AutoTypeHeaderName  types.String `tfsdk:"auto_type_header_name"`
	InferenceHeaderName types.String `tfsdk:"inference_header_name"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationFlagAppendHeadersModelAttrTypes = map[string]attr.Type{
	"auto_type_header_name": types.StringType,
	"inference_header_name": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel represents redirect block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel struct {
	URI types.String `tfsdk:"uri"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsMitigationRedirectModelAttrTypes = map[string]attr.Type{
	"uri": types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel represents path block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel represents query_params block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                 `tfsdk:"invert_matcher"`
	Key             types.String                                                               `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel represents item block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel represents web_mobile block
type HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel struct {
	MobileIdentifier types.String `tfsdk:"mobile_identifier"`
}

// HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModel
var HTTPLoadBalancerBotDefensePolicyProtectedAppEndpointsWebMobileModelAttrTypes = map[string]attr.Type{
	"mobile_identifier": types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedModel represents bot_defense_advanced block
type HTTPLoadBalancerBotDefenseAdvancedModel struct {
	DisableJsInsert        *HTTPLoadBalancerEmptyModel                                    `tfsdk:"disable_js_insert"`
	DisableMobileSdk       *HTTPLoadBalancerEmptyModel                                    `tfsdk:"disable_mobile_sdk"`
	JsInsertAllPages       *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel       `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules       *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel       `tfsdk:"js_insertion_rules"`
	Mobile                 *HTTPLoadBalancerBotDefenseAdvancedMobileModel                 `tfsdk:"mobile"`
	MobileSdkConfig        *HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel        `tfsdk:"mobile_sdk_config"`
	Web                    *HTTPLoadBalancerBotDefenseAdvancedWebModel                    `tfsdk:"web"`
}

// HTTPLoadBalancerBotDefenseAdvancedModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedModel
var HTTPLoadBalancerBotDefenseAdvancedModelAttrTypes = map[string]attr.Type{
	"disable_js_insert":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_mobile_sdk":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages":        types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModelAttrTypes},
	"js_insert_all_pages_except": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModelAttrTypes},
	"js_insertion_rules":         types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModelAttrTypes},
	"mobile":                     types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedMobileModelAttrTypes},
	"mobile_sdk_config":          types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModelAttrTypes},
	"web":                        types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedWebModelAttrTypes},
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel represents js_insert_all_pages block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel struct {
	JavascriptLocation types.String `tfsdk:"javascript_location"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel struct {
	JavascriptLocation types.String                                                               `tfsdk:"javascript_location"`
	ExcludeList        []HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"exclude_list":        types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModelAttrTypes}},
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModelAttrTypes},
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertAllPagesExceptExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel represents js_insertion_rules block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel struct {
	ExcludeList []HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules       []HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel       `tfsdk:"rules"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModelAttrTypes}},
	"rules":        types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModelAttrTypes}},
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel represents exclude_list block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModelAttrTypes},
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel represents domain block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel represents path block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel represents rules block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel struct {
	JavascriptLocation types.String                                                          `tfsdk:"javascript_location"`
	AnyDomain          *HTTPLoadBalancerEmptyModel                                           `tfsdk:"any_domain"`
	Domain             *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel   `tfsdk:"domain"`
	Metadata           *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path               *HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"any_domain":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModelAttrTypes},
	"metadata":            types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModelAttrTypes},
	"path":                types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModelAttrTypes},
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel represents domain block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel represents path block
type HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModel
var HTTPLoadBalancerBotDefenseAdvancedJsInsertionRulesRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedMobileModel represents mobile block
type HTTPLoadBalancerBotDefenseAdvancedMobileModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedMobileModel
var HTTPLoadBalancerBotDefenseAdvancedMobileModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel represents mobile_sdk_config block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel struct {
	MobileIdentifier *HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel `tfsdk:"mobile_identifier"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModel
var HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigModelAttrTypes = map[string]attr.Type{
	"mobile_identifier": types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModelAttrTypes},
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel represents mobile_identifier block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel struct {
	Headers []HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModel
var HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModelAttrTypes}},
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel represents headers block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel struct {
	Name            types.String                                                                       `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                        `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                        `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModel
var HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel represents item block
type HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModel
var HTTPLoadBalancerBotDefenseAdvancedMobileSdkConfigMobileIdentifierHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerBotDefenseAdvancedWebModel represents web block
type HTTPLoadBalancerBotDefenseAdvancedWebModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerBotDefenseAdvancedWebModelAttrTypes defines the attribute types for HTTPLoadBalancerBotDefenseAdvancedWebModel
var HTTPLoadBalancerBotDefenseAdvancedWebModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerCachingPolicyModel represents caching_policy block
type HTTPLoadBalancerCachingPolicyModel struct {
	CustomCacheRule    *HTTPLoadBalancerCachingPolicyCustomCacheRuleModel    `tfsdk:"custom_cache_rule"`
	DefaultCacheAction *HTTPLoadBalancerCachingPolicyDefaultCacheActionModel `tfsdk:"default_cache_action"`
}

// HTTPLoadBalancerCachingPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerCachingPolicyModel
var HTTPLoadBalancerCachingPolicyModelAttrTypes = map[string]attr.Type{
	"custom_cache_rule":    types.ObjectType{AttrTypes: HTTPLoadBalancerCachingPolicyCustomCacheRuleModelAttrTypes},
	"default_cache_action": types.ObjectType{AttrTypes: HTTPLoadBalancerCachingPolicyDefaultCacheActionModelAttrTypes},
}

// HTTPLoadBalancerCachingPolicyCustomCacheRuleModel represents custom_cache_rule block
type HTTPLoadBalancerCachingPolicyCustomCacheRuleModel struct {
	CDNCacheRules []HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel `tfsdk:"cdn_cache_rules"`
}

// HTTPLoadBalancerCachingPolicyCustomCacheRuleModelAttrTypes defines the attribute types for HTTPLoadBalancerCachingPolicyCustomCacheRuleModel
var HTTPLoadBalancerCachingPolicyCustomCacheRuleModelAttrTypes = map[string]attr.Type{
	"cdn_cache_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModelAttrTypes}},
}

// HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel represents cdn_cache_rules block
type HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModel
var HTTPLoadBalancerCachingPolicyCustomCacheRuleCDNCacheRulesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerCachingPolicyDefaultCacheActionModel represents default_cache_action block
type HTTPLoadBalancerCachingPolicyDefaultCacheActionModel struct {
	CacheTTLDefault  types.String                `tfsdk:"cache_ttl_default"`
	CacheTTLOverride types.String                `tfsdk:"cache_ttl_override"`
	CacheDisabled    *HTTPLoadBalancerEmptyModel `tfsdk:"cache_disabled"`
}

// HTTPLoadBalancerCachingPolicyDefaultCacheActionModelAttrTypes defines the attribute types for HTTPLoadBalancerCachingPolicyDefaultCacheActionModel
var HTTPLoadBalancerCachingPolicyDefaultCacheActionModelAttrTypes = map[string]attr.Type{
	"cache_ttl_default":  types.StringType,
	"cache_ttl_override": types.StringType,
	"cache_disabled":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerCaptchaChallengeModel represents captcha_challenge block
type HTTPLoadBalancerCaptchaChallengeModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerCaptchaChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerCaptchaChallengeModel
var HTTPLoadBalancerCaptchaChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// HTTPLoadBalancerClientSideDefenseModel represents client_side_defense block
type HTTPLoadBalancerClientSideDefenseModel struct {
	Policy *HTTPLoadBalancerClientSideDefensePolicyModel `tfsdk:"policy"`
}

// HTTPLoadBalancerClientSideDefenseModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefenseModel
var HTTPLoadBalancerClientSideDefenseModelAttrTypes = map[string]attr.Type{
	"policy": types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyModelAttrTypes},
}

// HTTPLoadBalancerClientSideDefensePolicyModel represents policy block
type HTTPLoadBalancerClientSideDefensePolicyModel struct {
	DisableJsInsert        *HTTPLoadBalancerEmptyModel                                         `tfsdk:"disable_js_insert"`
	JsInsertAllPages       *HTTPLoadBalancerEmptyModel                                         `tfsdk:"js_insert_all_pages"`
	JsInsertAllPagesExcept *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel `tfsdk:"js_insert_all_pages_except"`
	JsInsertionRules       *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel       `tfsdk:"js_insertion_rules"`
}

// HTTPLoadBalancerClientSideDefensePolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyModel
var HTTPLoadBalancerClientSideDefensePolicyModelAttrTypes = map[string]attr.Type{
	"disable_js_insert":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_insert_all_pages_except": types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModelAttrTypes},
	"js_insertion_rules":         types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModelAttrTypes},
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel represents js_insert_all_pages_except block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel struct {
	ExcludeList []HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel `tfsdk:"exclude_list"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes}},
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel represents exclude_list block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                            `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes},
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel represents domain block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel represents path block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertAllPagesExceptExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel represents js_insertion_rules block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel struct {
	ExcludeList []HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel `tfsdk:"exclude_list"`
	Rules       []HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel       `tfsdk:"rules"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesModelAttrTypes = map[string]attr.Type{
	"exclude_list": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModelAttrTypes}},
	"rules":        types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModelAttrTypes}},
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel represents exclude_list block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes},
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel represents domain block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel represents metadata block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel represents path block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesExcludeListPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel represents rules block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel   `tfsdk:"domain"`
	Metadata  *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel `tfsdk:"metadata"`
	Path      *HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes},
	"metadata":   types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes},
	"path":       types.ObjectType{AttrTypes: HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModelAttrTypes},
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel represents domain block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel represents path block
type HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModelAttrTypes defines the attribute types for HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModel
var HTTPLoadBalancerClientSideDefensePolicyJsInsertionRulesRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerCookieStickinessModel represents cookie_stickiness block
type HTTPLoadBalancerCookieStickinessModel struct {
	Name           types.String                `tfsdk:"name"`
	Path           types.String                `tfsdk:"path"`
	TTL            types.Int64                 `tfsdk:"ttl"`
	AddHttponly    *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure      *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure   *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax    *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone   *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerCookieStickinessModelAttrTypes defines the attribute types for HTTPLoadBalancerCookieStickinessModel
var HTTPLoadBalancerCookieStickinessModelAttrTypes = map[string]attr.Type{
	"name":            types.StringType,
	"path":            types.StringType,
	"ttl":             types.Int64Type,
	"add_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerCORSPolicyModel represents cors_policy block
type HTTPLoadBalancerCORSPolicyModel struct {
	AllowCredentials types.Bool   `tfsdk:"allow_credentials"`
	AllowHeaders     types.String `tfsdk:"allow_headers"`
	AllowMethods     types.String `tfsdk:"allow_methods"`
	AllowOrigin      types.List   `tfsdk:"allow_origin"`
	AllowOriginRegex types.List   `tfsdk:"allow_origin_regex"`
	Disabled         types.Bool   `tfsdk:"disabled"`
	ExposeHeaders    types.String `tfsdk:"expose_headers"`
	MaximumAge       types.Int64  `tfsdk:"maximum_age"`
}

// HTTPLoadBalancerCORSPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerCORSPolicyModel
var HTTPLoadBalancerCORSPolicyModelAttrTypes = map[string]attr.Type{
	"allow_credentials":  types.BoolType,
	"allow_headers":      types.StringType,
	"allow_methods":      types.StringType,
	"allow_origin":       types.ListType{ElemType: types.StringType},
	"allow_origin_regex": types.ListType{ElemType: types.StringType},
	"disabled":           types.BoolType,
	"expose_headers":     types.StringType,
	"maximum_age":        types.Int64Type,
}

// HTTPLoadBalancerCSRFPolicyModel represents csrf_policy block
type HTTPLoadBalancerCSRFPolicyModel struct {
	AllLoadBalancerDomains *HTTPLoadBalancerEmptyModel                      `tfsdk:"all_load_balancer_domains"`
	CustomDomainList       *HTTPLoadBalancerCSRFPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled               *HTTPLoadBalancerEmptyModel                      `tfsdk:"disabled"`
}

// HTTPLoadBalancerCSRFPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerCSRFPolicyModel
var HTTPLoadBalancerCSRFPolicyModelAttrTypes = map[string]attr.Type{
	"all_load_balancer_domains": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"custom_domain_list":        types.ObjectType{AttrTypes: HTTPLoadBalancerCSRFPolicyCustomDomainListModelAttrTypes},
	"disabled":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerCSRFPolicyCustomDomainListModel represents custom_domain_list block
type HTTPLoadBalancerCSRFPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// HTTPLoadBalancerCSRFPolicyCustomDomainListModelAttrTypes defines the attribute types for HTTPLoadBalancerCSRFPolicyCustomDomainListModel
var HTTPLoadBalancerCSRFPolicyCustomDomainListModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDataGuardRulesModel represents data_guard_rules block
type HTTPLoadBalancerDataGuardRulesModel struct {
	ExactValue     types.String                                 `tfsdk:"exact_value"`
	SuffixValue    types.String                                 `tfsdk:"suffix_value"`
	AnyDomain      *HTTPLoadBalancerEmptyModel                  `tfsdk:"any_domain"`
	ApplyDataGuard *HTTPLoadBalancerEmptyModel                  `tfsdk:"apply_data_guard"`
	Metadata       *HTTPLoadBalancerDataGuardRulesMetadataModel `tfsdk:"metadata"`
	Path           *HTTPLoadBalancerDataGuardRulesPathModel     `tfsdk:"path"`
	SkipDataGuard  *HTTPLoadBalancerEmptyModel                  `tfsdk:"skip_data_guard"`
}

// HTTPLoadBalancerDataGuardRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerDataGuardRulesModel
var HTTPLoadBalancerDataGuardRulesModelAttrTypes = map[string]attr.Type{
	"exact_value":      types.StringType,
	"suffix_value":     types.StringType,
	"any_domain":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"apply_data_guard": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"metadata":         types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesMetadataModelAttrTypes},
	"path":             types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesPathModelAttrTypes},
	"skip_data_guard":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDataGuardRulesMetadataModel represents metadata block
type HTTPLoadBalancerDataGuardRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerDataGuardRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerDataGuardRulesMetadataModel
var HTTPLoadBalancerDataGuardRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerDataGuardRulesPathModel represents path block
type HTTPLoadBalancerDataGuardRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerDataGuardRulesPathModelAttrTypes defines the attribute types for HTTPLoadBalancerDataGuardRulesPathModel
var HTTPLoadBalancerDataGuardRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerDDOSMitigationRulesModel represents ddos_mitigation_rules block
type HTTPLoadBalancerDDOSMitigationRulesModel struct {
	ExpirationTimestamp types.String                                              `tfsdk:"expiration_timestamp"`
	Block               *HTTPLoadBalancerEmptyModel                               `tfsdk:"block"`
	DDOSClientSource    *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel `tfsdk:"ddos_client_source"`
	IPPrefixList        *HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel     `tfsdk:"ip_prefix_list"`
	Metadata            *HTTPLoadBalancerDDOSMitigationRulesMetadataModel         `tfsdk:"metadata"`
}

// HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesModel
var HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes = map[string]attr.Type{
	"expiration_timestamp": types.StringType,
	"block":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ddos_client_source":   types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModelAttrTypes},
	"ip_prefix_list":       types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModelAttrTypes},
	"metadata":             types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesMetadataModelAttrTypes},
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel represents ddos_client_source block
type HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel struct {
	CountryList              types.List                                                                        `tfsdk:"country_list"`
	AsnList                  *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel                  `tfsdk:"asn_list"`
	Ja4TLSFingerprintMatcher *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel `tfsdk:"ja4_tls_fingerprint_matcher"`
	TLSFingerprintMatcher    *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel    `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel
var HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModelAttrTypes = map[string]attr.Type{
	"country_list":                types.ListType{ElemType: types.StringType},
	"asn_list":                    types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModelAttrTypes},
	"ja4_tls_fingerprint_matcher": types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModelAttrTypes},
	"tls_fingerprint_matcher":     types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel represents asn_list block
type HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModel
var HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel represents ja4_tls_fingerprint_matcher block
type HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModel
var HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceJa4TLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModel
var HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel
var HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDDOSMitigationRulesMetadataModel represents metadata block
type HTTPLoadBalancerDDOSMitigationRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerDDOSMitigationRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerDDOSMitigationRulesMetadataModel
var HTTPLoadBalancerDDOSMitigationRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerDefaultPoolModel represents default_pool block
type HTTPLoadBalancerDefaultPoolModel struct {
	EndpointSelection         types.String                                               `tfsdk:"endpoint_selection"`
	HealthCheckPort           types.Int64                                                `tfsdk:"health_check_port"`
	LoadBalancerAlgorithm     types.String                                               `tfsdk:"loadbalancer_algorithm"`
	Port                      types.Int64                                                `tfsdk:"port"`
	AdvancedOptions           *HTTPLoadBalancerDefaultPoolAdvancedOptionsModel           `tfsdk:"advanced_options"`
	AutomaticPort             *HTTPLoadBalancerEmptyModel                                `tfsdk:"automatic_port"`
	Healthcheck               []HTTPLoadBalancerDefaultPoolHealthcheckModel              `tfsdk:"healthcheck"`
	LBPort                    *HTTPLoadBalancerEmptyModel                                `tfsdk:"lb_port"`
	NoTLS                     *HTTPLoadBalancerEmptyModel                                `tfsdk:"no_tls"`
	OriginServers             []HTTPLoadBalancerDefaultPoolOriginServersModel            `tfsdk:"origin_servers"`
	SameAsEndpointPort        *HTTPLoadBalancerEmptyModel                                `tfsdk:"same_as_endpoint_port"`
	UpstreamConnPoolReuseType *HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel `tfsdk:"upstream_conn_pool_reuse_type"`
	UseTLS                    *HTTPLoadBalancerDefaultPoolUseTLSModel                    `tfsdk:"use_tls"`
	ViewInternal              *HTTPLoadBalancerDefaultPoolViewInternalModel              `tfsdk:"view_internal"`
}

// HTTPLoadBalancerDefaultPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolModel
var HTTPLoadBalancerDefaultPoolModelAttrTypes = map[string]attr.Type{
	"endpoint_selection":            types.StringType,
	"health_check_port":             types.Int64Type,
	"loadbalancer_algorithm":        types.StringType,
	"port":                          types.Int64Type,
	"advanced_options":              types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsModelAttrTypes},
	"automatic_port":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"healthcheck":                   types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolHealthcheckModelAttrTypes}},
	"lb_port":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_tls":                        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"origin_servers":                types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersModelAttrTypes}},
	"same_as_endpoint_port":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"upstream_conn_pool_reuse_type": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModelAttrTypes},
	"use_tls":                       types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSModelAttrTypes},
	"view_internal":                 types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolViewInternalModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsModel represents advanced_options block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsModel struct {
	ConnectionTimeout            types.Int64                                                      `tfsdk:"connection_timeout"`
	HTTPIdleTimeout              types.Int64                                                      `tfsdk:"http_idle_timeout"`
	PanicThreshold               types.Int64                                                      `tfsdk:"panic_threshold"`
	AutoHTTPConfig               *HTTPLoadBalancerEmptyModel                                      `tfsdk:"auto_http_config"`
	CircuitBreaker               *HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel   `tfsdk:"circuit_breaker"`
	DefaultCircuitBreaker        *HTTPLoadBalancerEmptyModel                                      `tfsdk:"default_circuit_breaker"`
	DisableCircuitBreaker        *HTTPLoadBalancerEmptyModel                                      `tfsdk:"disable_circuit_breaker"`
	DisableLBSourceIPPersistance *HTTPLoadBalancerEmptyModel                                      `tfsdk:"disable_lb_source_ip_persistance"`
	DisableOutlierDetection      *HTTPLoadBalancerEmptyModel                                      `tfsdk:"disable_outlier_detection"`
	DisableProxyProtocol         *HTTPLoadBalancerEmptyModel                                      `tfsdk:"disable_proxy_protocol"`
	DisableSubsets               *HTTPLoadBalancerEmptyModel                                      `tfsdk:"disable_subsets"`
	EnableLBSourceIPPersistance  *HTTPLoadBalancerEmptyModel                                      `tfsdk:"enable_lb_source_ip_persistance"`
	EnableSubsets                *HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel    `tfsdk:"enable_subsets"`
	Http1Config                  *HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel      `tfsdk:"http1_config"`
	Http2Options                 *HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel     `tfsdk:"http2_options"`
	NoPanicThreshold             *HTTPLoadBalancerEmptyModel                                      `tfsdk:"no_panic_threshold"`
	OutlierDetection             *HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel `tfsdk:"outlier_detection"`
	ProxyProtocolV1              *HTTPLoadBalancerEmptyModel                                      `tfsdk:"proxy_protocol_v1"`
	ProxyProtocolV2              *HTTPLoadBalancerEmptyModel                                      `tfsdk:"proxy_protocol_v2"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsModelAttrTypes = map[string]attr.Type{
	"connection_timeout":               types.Int64Type,
	"http_idle_timeout":                types.Int64Type,
	"panic_threshold":                  types.Int64Type,
	"auto_http_config":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"circuit_breaker":                  types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModelAttrTypes},
	"default_circuit_breaker":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_circuit_breaker":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_lb_source_ip_persistance": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_outlier_detection":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_proxy_protocol":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_subsets":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_lb_source_ip_persistance":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_subsets":                   types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModelAttrTypes},
	"http1_config":                     types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModelAttrTypes},
	"http2_options":                    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModelAttrTypes},
	"no_panic_threshold":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outlier_detection":                types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModelAttrTypes},
	"proxy_protocol_v1":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proxy_protocol_v2":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel represents circuit_breaker block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel struct {
	ConnectionLimit types.Int64  `tfsdk:"connection_limit"`
	MaxRequests     types.Int64  `tfsdk:"max_requests"`
	PendingRequests types.Int64  `tfsdk:"pending_requests"`
	Priority        types.String `tfsdk:"priority"`
	Retries         types.Int64  `tfsdk:"retries"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsCircuitBreakerModelAttrTypes = map[string]attr.Type{
	"connection_limit": types.Int64Type,
	"max_requests":     types.Int64Type,
	"pending_requests": types.Int64Type,
	"priority":         types.StringType,
	"retries":          types.Int64Type,
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel represents enable_subsets block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel struct {
	AnyEndpoint     *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"any_endpoint"`
	DefaultSubset   *HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel    `tfsdk:"default_subset"`
	EndpointSubsets []HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel `tfsdk:"endpoint_subsets"`
	FailRequest     *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"fail_request"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsModelAttrTypes = map[string]attr.Type{
	"any_endpoint":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_subset":   types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModelAttrTypes},
	"endpoint_subsets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModelAttrTypes}},
	"fail_request":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel represents default_subset block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel struct {
	DefaultSubset *HTTPLoadBalancerEmptyModel `tfsdk:"default_subset"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsDefaultSubsetModelAttrTypes = map[string]attr.Type{
	"default_subset": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel represents endpoint_subsets block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel struct {
	Keys types.List `tfsdk:"keys"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModelAttrTypes = map[string]attr.Type{
	"keys": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel represents http1_config block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel struct {
	HeaderTransformation *HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel `tfsdk:"header_transformation"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel represents header_transformation block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel struct {
	DefaultHeaderTransformation      *HTTPLoadBalancerEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *HTTPLoadBalancerEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *HTTPLoadBalancerEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp1ConfigHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel represents http2_options block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel struct {
	Enabled types.Bool `tfsdk:"enabled"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsHttp2OptionsModelAttrTypes = map[string]attr.Type{
	"enabled": types.BoolType,
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel represents outlier_detection block
type HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel struct {
	BaseEjectionTime          types.Int64 `tfsdk:"base_ejection_time"`
	Consecutive5xx            types.Int64 `tfsdk:"consecutive_5xx"`
	ConsecutiveGatewayFailure types.Int64 `tfsdk:"consecutive_gateway_failure"`
	Interval                  types.Int64 `tfsdk:"interval"`
	MaxEjectionPercent        types.Int64 `tfsdk:"max_ejection_percent"`
}

// HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModel
var HTTPLoadBalancerDefaultPoolAdvancedOptionsOutlierDetectionModelAttrTypes = map[string]attr.Type{
	"base_ejection_time":          types.Int64Type,
	"consecutive_5xx":             types.Int64Type,
	"consecutive_gateway_failure": types.Int64Type,
	"interval":                    types.Int64Type,
	"max_ejection_percent":        types.Int64Type,
}

// HTTPLoadBalancerDefaultPoolHealthcheckModel represents healthcheck block
type HTTPLoadBalancerDefaultPoolHealthcheckModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolHealthcheckModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolHealthcheckModel
var HTTPLoadBalancerDefaultPoolHealthcheckModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersModel represents origin_servers block
type HTTPLoadBalancerDefaultPoolOriginServersModel struct {
	CbipService          *HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel          `tfsdk:"cbip_service"`
	ConsulService        *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel        `tfsdk:"consul_service"`
	CustomEndpointObject *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel `tfsdk:"custom_endpoint_object"`
	K8SService           *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel           `tfsdk:"k8s_service"`
	Labels               *HTTPLoadBalancerEmptyModel                                        `tfsdk:"labels"`
	PrivateIP            *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel            `tfsdk:"private_ip"`
	PrivateName          *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel          `tfsdk:"private_name"`
	PublicIP             *HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel             `tfsdk:"public_ip"`
	PublicName           *HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel           `tfsdk:"public_name"`
	VnPrivateIP          *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel          `tfsdk:"vn_private_ip"`
	VnPrivateName        *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel        `tfsdk:"vn_private_name"`
}

// HTTPLoadBalancerDefaultPoolOriginServersModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersModel
var HTTPLoadBalancerDefaultPoolOriginServersModelAttrTypes = map[string]attr.Type{
	"cbip_service":           types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModelAttrTypes},
	"consul_service":         types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModelAttrTypes},
	"custom_endpoint_object": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModelAttrTypes},
	"k8s_service":            types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModelAttrTypes},
	"labels":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_ip":             types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModelAttrTypes},
	"private_name":           types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModelAttrTypes},
	"public_ip":              types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPublicIPModelAttrTypes},
	"public_name":            types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPublicNameModelAttrTypes},
	"vn_private_ip":          types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModelAttrTypes},
	"vn_private_name":        types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel represents cbip_service block
type HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel struct {
	ServiceName types.String `tfsdk:"service_name"`
}

// HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel
var HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModelAttrTypes = map[string]attr.Type{
	"service_name": types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel represents consul_service block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel struct {
	ServiceName    types.String                                                           `tfsdk:"service_name"`
	InsideNetwork  *HTTPLoadBalancerEmptyModel                                            `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel                                            `tfsdk:"outside_network"`
	SiteLocator    *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool       *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel    `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel
var HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModelAttrTypes = map[string]attr.Type{
	"service_name":    types.StringType,
	"inside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_locator":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModelAttrTypes},
	"snat_pool":       types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel struct {
	Site        *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModel
var HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"no_snat_pool"`
	SnatPool   *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersConsulServiceSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel represents custom_endpoint_object block
type HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel struct {
	Endpoint *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel `tfsdk:"endpoint"`
}

// HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel
var HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModelAttrTypes = map[string]attr.Type{
	"endpoint": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel represents endpoint block
type HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModel
var HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectEndpointModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel represents k8s_service block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel struct {
	Protocol       types.String                                                        `tfsdk:"protocol"`
	ServiceName    types.String                                                        `tfsdk:"service_name"`
	InsideNetwork  *HTTPLoadBalancerEmptyModel                                         `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel                                         `tfsdk:"outside_network"`
	SiteLocator    *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool       *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel    `tfsdk:"snat_pool"`
	Vk8sNetworks   *HTTPLoadBalancerEmptyModel                                         `tfsdk:"vk8s_networks"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel
var HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModelAttrTypes = map[string]attr.Type{
	"protocol":        types.StringType,
	"service_name":    types.StringType,
	"inside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_locator":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModelAttrTypes},
	"snat_pool":       types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModelAttrTypes},
	"vk8s_networks":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel struct {
	Site        *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModel
var HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel                                              `tfsdk:"no_snat_pool"`
	SnatPool   *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersK8SServiceSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel represents private_ip block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel struct {
	IP             types.String                                                       `tfsdk:"ip"`
	InsideNetwork  *HTTPLoadBalancerEmptyModel                                        `tfsdk:"inside_network"`
	OutsideNetwork *HTTPLoadBalancerEmptyModel                                        `tfsdk:"outside_network"`
	Segment        *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel     `tfsdk:"segment"`
	SiteLocator    *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool       *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel    `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModelAttrTypes = map[string]attr.Type{
	"ip":              types.StringType,
	"inside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"segment":         types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModelAttrTypes},
	"site_locator":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModelAttrTypes},
	"snat_pool":       types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel represents segment block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSegmentModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel struct {
	Site        *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel                                             `tfsdk:"no_snat_pool"`
	SnatPool   *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateIPSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel represents private_name block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel struct {
	DNSName         types.String                                                         `tfsdk:"dns_name"`
	RefreshInterval types.Int64                                                          `tfsdk:"refresh_interval"`
	InsideNetwork   *HTTPLoadBalancerEmptyModel                                          `tfsdk:"inside_network"`
	OutsideNetwork  *HTTPLoadBalancerEmptyModel                                          `tfsdk:"outside_network"`
	Segment         *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel     `tfsdk:"segment"`
	SiteLocator     *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool        *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel    `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModelAttrTypes = map[string]attr.Type{
	"dns_name":         types.StringType,
	"refresh_interval": types.Int64Type,
	"inside_network":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"segment":          types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModelAttrTypes},
	"site_locator":     types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModelAttrTypes},
	"snat_pool":        types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel represents segment block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSegmentModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel represents site_locator block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel struct {
	Site        *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel represents site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel represents virtual_site block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel struct {
	NoSnatPool *HTTPLoadBalancerEmptyModel                                               `tfsdk:"no_snat_pool"`
	SnatPool   *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel represents snat_pool block
type HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModel
var HTTPLoadBalancerDefaultPoolOriginServersPrivateNameSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel represents public_ip block
type HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel struct {
	IP types.String `tfsdk:"ip"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPublicIPModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel
var HTTPLoadBalancerDefaultPoolOriginServersPublicIPModelAttrTypes = map[string]attr.Type{
	"ip": types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel represents public_name block
type HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel struct {
	DNSName         types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64  `tfsdk:"refresh_interval"`
}

// HTTPLoadBalancerDefaultPoolOriginServersPublicNameModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel
var HTTPLoadBalancerDefaultPoolOriginServersPublicNameModelAttrTypes = map[string]attr.Type{
	"dns_name":         types.StringType,
	"refresh_interval": types.Int64Type,
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel represents vn_private_ip block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel struct {
	IP             types.String                                                            `tfsdk:"ip"`
	VirtualNetwork *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel `tfsdk:"virtual_network"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel
var HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModelAttrTypes = map[string]attr.Type{
	"ip":              types.StringType,
	"virtual_network": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel represents virtual_network block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModel
var HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel represents vn_private_name block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel struct {
	DNSName        types.String                                                              `tfsdk:"dns_name"`
	PrivateNetwork *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel `tfsdk:"private_network"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel
var HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModelAttrTypes = map[string]attr.Type{
	"dns_name":        types.StringType,
	"private_network": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel represents private_network block
type HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModel
var HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNamePrivateNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel represents upstream_conn_pool_reuse_type block
type HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel struct {
	DisableConnPoolReuse *HTTPLoadBalancerEmptyModel `tfsdk:"disable_conn_pool_reuse"`
	EnableConnPoolReuse  *HTTPLoadBalancerEmptyModel `tfsdk:"enable_conn_pool_reuse"`
}

// HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel
var HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModelAttrTypes = map[string]attr.Type{
	"disable_conn_pool_reuse": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_conn_pool_reuse":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolUseTLSModel represents use_tls block
type HTTPLoadBalancerDefaultPoolUseTLSModel struct {
	MaxSessionKeys           types.Int64                                                  `tfsdk:"max_session_keys"`
	Sni                      types.String                                                 `tfsdk:"sni"`
	DefaultSessionKeyCaching *HTTPLoadBalancerEmptyModel                                  `tfsdk:"default_session_key_caching"`
	DisableSessionKeyCaching *HTTPLoadBalancerEmptyModel                                  `tfsdk:"disable_session_key_caching"`
	DisableSni               *HTTPLoadBalancerEmptyModel                                  `tfsdk:"disable_sni"`
	NoMtls                   *HTTPLoadBalancerEmptyModel                                  `tfsdk:"no_mtls"`
	SkipServerVerification   *HTTPLoadBalancerEmptyModel                                  `tfsdk:"skip_server_verification"`
	TLSConfig                *HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel             `tfsdk:"tls_config"`
	UseHostHeaderAsSni       *HTTPLoadBalancerEmptyModel                                  `tfsdk:"use_host_header_as_sni"`
	UseMtls                  *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel               `tfsdk:"use_mtls"`
	UseMtlsObj               *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel            `tfsdk:"use_mtls_obj"`
	UseServerVerification    *HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel `tfsdk:"use_server_verification"`
	VolterraTrustedCA        *HTTPLoadBalancerEmptyModel                                  `tfsdk:"volterra_trusted_ca"`
}

// HTTPLoadBalancerDefaultPoolUseTLSModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSModel
var HTTPLoadBalancerDefaultPoolUseTLSModelAttrTypes = map[string]attr.Type{
	"max_session_keys":            types.Int64Type,
	"sni":                         types.StringType,
	"default_session_key_caching": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_session_key_caching": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_sni":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_mtls":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_server_verification":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":                  types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModelAttrTypes},
	"use_host_header_as_sni":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":                    types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModelAttrTypes},
	"use_mtls_obj":                types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModelAttrTypes},
	"use_server_verification":     types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModelAttrTypes},
	"volterra_trusted_ca":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel represents tls_config block
type HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel struct {
	CustomSecurity  *HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel                                    `tfsdk:"default_security"`
	LowSecurity     *HTTPLoadBalancerEmptyModel                                    `tfsdk:"low_security"`
	MediumSecurity  *HTTPLoadBalancerEmptyModel                                    `tfsdk:"medium_security"`
}

// HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModel
var HTTPLoadBalancerDefaultPoolUseTLSTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModel
var HTTPLoadBalancerDefaultPoolUseTLSTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel represents use_mtls block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel struct {
	TLSCertificates []HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel `tfsdk:"tls_certificates"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsModelAttrTypes = map[string]attr.Type{
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes}},
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel represents tls_certificates block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel struct {
	CertificateURL       types.String                                                                      `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                      `tfsdk:"description_spec"`
	CustomHashAlgorithms *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"use_system_defaults"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel represents private_key block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel represents use_mtls_obj block
type HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModel
var HTTPLoadBalancerDefaultPoolUseTLSUseMtlsObjModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel represents use_server_verification block
type HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel struct {
	TrustedCAURL types.String                                                          `tfsdk:"trusted_ca_url"`
	TrustedCA    *HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModel `tfsdk:"trusted_ca"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModel
var HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationModelAttrTypes = map[string]attr.Type{
	"trusted_ca_url": types.StringType,
	"trusted_ca":     types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModel represents trusted_ca block
type HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModel
var HTTPLoadBalancerDefaultPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolViewInternalModel represents view_internal block
type HTTPLoadBalancerDefaultPoolViewInternalModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolViewInternalModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolViewInternalModel
var HTTPLoadBalancerDefaultPoolViewInternalModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolListModel represents default_pool_list block
type HTTPLoadBalancerDefaultPoolListModel struct {
	Pools []HTTPLoadBalancerDefaultPoolListPoolsModel `tfsdk:"pools"`
}

// HTTPLoadBalancerDefaultPoolListModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolListModel
var HTTPLoadBalancerDefaultPoolListModelAttrTypes = map[string]attr.Type{
	"pools": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolListPoolsModelAttrTypes}},
}

// HTTPLoadBalancerDefaultPoolListPoolsModel represents pools block
type HTTPLoadBalancerDefaultPoolListPoolsModel struct {
	Priority        types.Int64                                       `tfsdk:"priority"`
	Weight          types.Int64                                       `tfsdk:"weight"`
	Cluster         *HTTPLoadBalancerDefaultPoolListPoolsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel                       `tfsdk:"endpoint_subsets"`
	Pool            *HTTPLoadBalancerDefaultPoolListPoolsPoolModel    `tfsdk:"pool"`
}

// HTTPLoadBalancerDefaultPoolListPoolsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolListPoolsModel
var HTTPLoadBalancerDefaultPoolListPoolsModelAttrTypes = map[string]attr.Type{
	"priority":         types.Int64Type,
	"weight":           types.Int64Type,
	"cluster":          types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolListPoolsClusterModelAttrTypes},
	"endpoint_subsets": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pool":             types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultPoolListPoolsPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultPoolListPoolsClusterModel represents cluster block
type HTTPLoadBalancerDefaultPoolListPoolsClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolListPoolsClusterModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolListPoolsClusterModel
var HTTPLoadBalancerDefaultPoolListPoolsClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultPoolListPoolsPoolModel represents pool block
type HTTPLoadBalancerDefaultPoolListPoolsPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultPoolListPoolsPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultPoolListPoolsPoolModel
var HTTPLoadBalancerDefaultPoolListPoolsPoolModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultRoutePoolsModel represents default_route_pools block
type HTTPLoadBalancerDefaultRoutePoolsModel struct {
	Priority        types.Int64                                    `tfsdk:"priority"`
	Weight          types.Int64                                    `tfsdk:"weight"`
	Cluster         *HTTPLoadBalancerDefaultRoutePoolsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel                    `tfsdk:"endpoint_subsets"`
	Pool            *HTTPLoadBalancerDefaultRoutePoolsPoolModel    `tfsdk:"pool"`
}

// HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultRoutePoolsModel
var HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes = map[string]attr.Type{
	"priority":         types.Int64Type,
	"weight":           types.Int64Type,
	"cluster":          types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsClusterModelAttrTypes},
	"endpoint_subsets": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pool":             types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsPoolModelAttrTypes},
}

// HTTPLoadBalancerDefaultRoutePoolsClusterModel represents cluster block
type HTTPLoadBalancerDefaultRoutePoolsClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultRoutePoolsClusterModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultRoutePoolsClusterModel
var HTTPLoadBalancerDefaultRoutePoolsClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerDefaultRoutePoolsPoolModel represents pool block
type HTTPLoadBalancerDefaultRoutePoolsPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerDefaultRoutePoolsPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerDefaultRoutePoolsPoolModel
var HTTPLoadBalancerDefaultRoutePoolsPoolModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerEnableAPIDiscoveryModel represents enable_api_discovery block
type HTTPLoadBalancerEnableAPIDiscoveryModel struct {
	APICrawler                      *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel               `tfsdk:"api_crawler"`
	APIDiscoveryFromCodeScan        *HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel `tfsdk:"api_discovery_from_code_scan"`
	CustomAPIAuthDiscovery          *HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel   `tfsdk:"custom_api_auth_discovery"`
	DefaultAPIAuthDiscovery         *HTTPLoadBalancerEmptyModel                                      `tfsdk:"default_api_auth_discovery"`
	DisableLearnFromRedirectTraffic *HTTPLoadBalancerEmptyModel                                      `tfsdk:"disable_learn_from_redirect_traffic"`
	DiscoveredAPISettings           *HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel    `tfsdk:"discovered_api_settings"`
	EnableLearnFromRedirectTraffic  *HTTPLoadBalancerEmptyModel                                      `tfsdk:"enable_learn_from_redirect_traffic"`
}

// HTTPLoadBalancerEnableAPIDiscoveryModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryModel
var HTTPLoadBalancerEnableAPIDiscoveryModelAttrTypes = map[string]attr.Type{
	"api_crawler":                         types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModelAttrTypes},
	"api_discovery_from_code_scan":        types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes},
	"custom_api_auth_discovery":           types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModelAttrTypes},
	"default_api_auth_discovery":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_learn_from_redirect_traffic": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"discovered_api_settings":             types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModelAttrTypes},
	"enable_learn_from_redirect_traffic":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel represents api_crawler block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel struct {
	APICrawlerConfig  *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel `tfsdk:"api_crawler_config"`
	DisableAPICrawler *HTTPLoadBalancerEmptyModel                                        `tfsdk:"disable_api_crawler"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerModelAttrTypes = map[string]attr.Type{
	"api_crawler_config":  types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes},
	"disable_api_crawler": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel represents api_crawler_config block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel struct {
	Domains []HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel `tfsdk:"domains"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes}},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel represents domains block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel struct {
	Domain      types.String                                                                         `tfsdk:"domain"`
	SimpleLogin *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel `tfsdk:"simple_login"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes = map[string]attr.Type{
	"domain":       types.StringType,
	"simple_login": types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel represents simple_login block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel struct {
	User     types.String                                                                                 `tfsdk:"user"`
	Password *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel `tfsdk:"password"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes = map[string]attr.Type{
	"user":     types.StringType,
	"password": types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel represents password block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel
var HTTPLoadBalancerEnableAPIDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel represents api_discovery_from_code_scan block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel struct {
	CodeBaseIntegrations []HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel `tfsdk:"code_base_integrations"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModel
var HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes = map[string]attr.Type{
	"code_base_integrations": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes}},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel represents code_base_integrations block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel struct {
	AllRepos            *HTTPLoadBalancerEmptyModel                                                                             `tfsdk:"all_repos"`
	CodeBaseIntegration *HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel `tfsdk:"code_base_integration"`
	SelectedRepos       *HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel       `tfsdk:"selected_repos"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel
var HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes = map[string]attr.Type{
	"all_repos":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"code_base_integration": types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes},
	"selected_repos":        types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes},
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel represents code_base_integration block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel
var HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel represents selected_repos block
type HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel struct {
	APICodeRepo types.List `tfsdk:"api_code_repo"`
}

// HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel
var HTTPLoadBalancerEnableAPIDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes = map[string]attr.Type{
	"api_code_repo": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel represents custom_api_auth_discovery block
type HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel struct {
	APIDiscoveryRef *HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel `tfsdk:"api_discovery_ref"`
}

// HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModel
var HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryModelAttrTypes = map[string]attr.Type{
	"api_discovery_ref": types.ObjectType{AttrTypes: HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes},
}

// HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel represents api_discovery_ref block
type HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel
var HTTPLoadBalancerEnableAPIDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel represents discovered_api_settings block
type HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel struct {
	PurgeDurationForInactiveDiscoveredApis types.Int64 `tfsdk:"purge_duration_for_inactive_discovered_apis"`
}

// HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModel
var HTTPLoadBalancerEnableAPIDiscoveryDiscoveredAPISettingsModelAttrTypes = map[string]attr.Type{
	"purge_duration_for_inactive_discovered_apis": types.Int64Type,
}

// HTTPLoadBalancerEnableChallengeModel represents enable_challenge block
type HTTPLoadBalancerEnableChallengeModel struct {
	CaptchaChallengeParameters        *HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters *HTTPLoadBalancerEmptyModel                                     `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters      *HTTPLoadBalancerEmptyModel                                     `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings         *HTTPLoadBalancerEmptyModel                                     `tfsdk:"default_mitigation_settings"`
	JsChallengeParameters             *HTTPLoadBalancerEnableChallengeJsChallengeParametersModel      `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation           *HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel    `tfsdk:"malicious_user_mitigation"`
}

// HTTPLoadBalancerEnableChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableChallengeModel
var HTTPLoadBalancerEnableChallengeModelAttrTypes = map[string]attr.Type{
	"captcha_challenge_parameters":         types.ObjectType{AttrTypes: HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModelAttrTypes},
	"default_captcha_challenge_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_js_challenge_parameters":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_mitigation_settings":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_challenge_parameters":              types.ObjectType{AttrTypes: HTTPLoadBalancerEnableChallengeJsChallengeParametersModelAttrTypes},
	"malicious_user_mitigation":            types.ObjectType{AttrTypes: HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModelAttrTypes},
}

// HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModel
var HTTPLoadBalancerEnableChallengeCaptchaChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// HTTPLoadBalancerEnableChallengeJsChallengeParametersModel represents js_challenge_parameters block
type HTTPLoadBalancerEnableChallengeJsChallengeParametersModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerEnableChallengeJsChallengeParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableChallengeJsChallengeParametersModel
var HTTPLoadBalancerEnableChallengeJsChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModel
var HTTPLoadBalancerEnableChallengeMaliciousUserMitigationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerEnableIPReputationModel represents enable_ip_reputation block
type HTTPLoadBalancerEnableIPReputationModel struct {
	IPThreatCategories types.List `tfsdk:"ip_threat_categories"`
}

// HTTPLoadBalancerEnableIPReputationModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableIPReputationModel
var HTTPLoadBalancerEnableIPReputationModelAttrTypes = map[string]attr.Type{
	"ip_threat_categories": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerEnableTrustClientIPHeadersModel represents enable_trust_client_ip_headers block
type HTTPLoadBalancerEnableTrustClientIPHeadersModel struct {
	ClientIPHeaders types.List `tfsdk:"client_ip_headers"`
}

// HTTPLoadBalancerEnableTrustClientIPHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerEnableTrustClientIPHeadersModel
var HTTPLoadBalancerEnableTrustClientIPHeadersModelAttrTypes = map[string]attr.Type{
	"client_ip_headers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerGraphqlRulesModel represents graphql_rules block
type HTTPLoadBalancerGraphqlRulesModel struct {
	ExactPath       types.String                                      `tfsdk:"exact_path"`
	ExactValue      types.String                                      `tfsdk:"exact_value"`
	SuffixValue     types.String                                      `tfsdk:"suffix_value"`
	AnyDomain       *HTTPLoadBalancerEmptyModel                       `tfsdk:"any_domain"`
	GraphqlSettings *HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel `tfsdk:"graphql_settings"`
	Metadata        *HTTPLoadBalancerGraphqlRulesMetadataModel        `tfsdk:"metadata"`
	MethodGet       *HTTPLoadBalancerEmptyModel                       `tfsdk:"method_get"`
	MethodPost      *HTTPLoadBalancerEmptyModel                       `tfsdk:"method_post"`
}

// HTTPLoadBalancerGraphqlRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerGraphqlRulesModel
var HTTPLoadBalancerGraphqlRulesModelAttrTypes = map[string]attr.Type{
	"exact_path":       types.StringType,
	"exact_value":      types.StringType,
	"suffix_value":     types.StringType,
	"any_domain":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"graphql_settings": types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesGraphqlSettingsModelAttrTypes},
	"metadata":         types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesMetadataModelAttrTypes},
	"method_get":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"method_post":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel represents graphql_settings block
type HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel struct {
	MaxBatchedQueries    types.Int64                 `tfsdk:"max_batched_queries"`
	MaxDepth             types.Int64                 `tfsdk:"max_depth"`
	MaxTotalLength       types.Int64                 `tfsdk:"max_total_length"`
	DisableIntrospection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_introspection"`
	EnableIntrospection  *HTTPLoadBalancerEmptyModel `tfsdk:"enable_introspection"`
}

// HTTPLoadBalancerGraphqlRulesGraphqlSettingsModelAttrTypes defines the attribute types for HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel
var HTTPLoadBalancerGraphqlRulesGraphqlSettingsModelAttrTypes = map[string]attr.Type{
	"max_batched_queries":   types.Int64Type,
	"max_depth":             types.Int64Type,
	"max_total_length":      types.Int64Type,
	"disable_introspection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_introspection":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerGraphqlRulesMetadataModel represents metadata block
type HTTPLoadBalancerGraphqlRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerGraphqlRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerGraphqlRulesMetadataModel
var HTTPLoadBalancerGraphqlRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerHTTPModel represents http block
type HTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// HTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPModel
var HTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// HTTPLoadBalancerHTTPSModel represents https block
type HTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                     `tfsdk:"add_hsts"`
	AppendServerName       types.String                                   `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                    `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                     `tfsdk:"http_redirect"`
	Port                   types.Int64                                    `tfsdk:"port"`
	PortRanges             types.String                                   `tfsdk:"port_ranges"`
	ServerName             types.String                                   `tfsdk:"server_name"`
	CoalescingOptions      *HTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *HTTPLoadBalancerEmptyModel                    `tfsdk:"default_header"`
	DefaultLoadBalancer    *HTTPLoadBalancerEmptyModel                    `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *HTTPLoadBalancerEmptyModel                    `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *HTTPLoadBalancerEmptyModel                    `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *HTTPLoadBalancerEmptyModel                    `tfsdk:"non_default_loadbalancer"`
	PassThrough            *HTTPLoadBalancerEmptyModel                    `tfsdk:"pass_through"`
	TLSCertParams          *HTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *HTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// HTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSModel
var HTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// HTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type HTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *HTTPLoadBalancerEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *HTTPLoadBalancerEmptyModel `tfsdk:"strict_coalescing"`
}

// HTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSCoalescingOptionsModel
var HTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *HTTPLoadBalancerEmptyModel                                            `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *HTTPLoadBalancerEmptyModel                                            `tfsdk:"http_protocol_enable_v2_only"`
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var HTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *HTTPLoadBalancerEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *HTTPLoadBalancerEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *HTTPLoadBalancerEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var HTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type HTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *HTTPLoadBalancerEmptyModel                           `tfsdk:"no_mtls"`
	TLSConfig    *HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsModel
var HTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var HTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel                                     `tfsdk:"default_security"`
	LowSecurity     *HTTPLoadBalancerEmptyModel                                     `tfsdk:"low_security"`
	MediumSecurity  *HTTPLoadBalancerEmptyModel                                     `tfsdk:"medium_security"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var HTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                               `tfsdk:"trusted_ca_url"`
	CRL                       *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *HTTPLoadBalancerEmptyModel                                `tfsdk:"no_crl"`
	TrustedCA                 *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *HTTPLoadBalancerEmptyModel                                `tfsdk:"xfcc_disabled"`
	XfccOptions               *HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var HTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type HTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *HTTPLoadBalancerEmptyModel                              `tfsdk:"no_mtls"`
	TLSCertificates []HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// HTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersModel
var HTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                `tfsdk:"description_spec"`
	CustomHashAlgorithms *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *HTTPLoadBalancerEmptyModel                                                 `tfsdk:"use_system_defaults"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var HTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel                                     `tfsdk:"default_security"`
	LowSecurity     *HTTPLoadBalancerEmptyModel                                     `tfsdk:"low_security"`
	MediumSecurity  *HTTPLoadBalancerEmptyModel                                     `tfsdk:"medium_security"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var HTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var HTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                               `tfsdk:"trusted_ca_url"`
	CRL                       *HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *HTTPLoadBalancerEmptyModel                                `tfsdk:"no_crl"`
	TrustedCA                 *HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *HTTPLoadBalancerEmptyModel                                `tfsdk:"xfcc_disabled"`
	XfccOptions               *HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var HTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var HTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var HTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var HTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type HTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                             `tfsdk:"add_hsts"`
	AppendServerName       types.String                                           `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                            `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                             `tfsdk:"http_redirect"`
	Port                   types.Int64                                            `tfsdk:"port"`
	PortRanges             types.String                                           `tfsdk:"port_ranges"`
	ServerName             types.String                                           `tfsdk:"server_name"`
	CoalescingOptions      *HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *HTTPLoadBalancerEmptyModel                            `tfsdk:"default_header"`
	DefaultLoadBalancer    *HTTPLoadBalancerEmptyModel                            `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *HTTPLoadBalancerEmptyModel                            `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *HTTPLoadBalancerEmptyModel                            `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *HTTPLoadBalancerEmptyModel                            `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *HTTPLoadBalancerEmptyModel                            `tfsdk:"non_default_loadbalancer"`
	PassThrough            *HTTPLoadBalancerEmptyModel                            `tfsdk:"pass_through"`
	TLSConfig              *HTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *HTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// HTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertModel
var HTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *HTTPLoadBalancerEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *HTTPLoadBalancerEmptyModel `tfsdk:"strict_coalescing"`
}

// HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *HTTPLoadBalancerEmptyModel                                                    `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *HTTPLoadBalancerEmptyModel                                                    `tfsdk:"http_protocol_enable_v2_only"`
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *HTTPLoadBalancerEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *HTTPLoadBalancerEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *HTTPLoadBalancerEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *HTTPLoadBalancerEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type HTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *HTTPLoadBalancerEmptyModel                                `tfsdk:"default_security"`
	LowSecurity     *HTTPLoadBalancerEmptyModel                                `tfsdk:"low_security"`
	MediumSecurity  *HTTPLoadBalancerEmptyModel                                `tfsdk:"medium_security"`
}

// HTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var HTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var HTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                            `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                          `tfsdk:"trusted_ca_url"`
	CRL                       *HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *HTTPLoadBalancerEmptyModel                           `tfsdk:"no_crl"`
	TrustedCA                 *HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *HTTPLoadBalancerEmptyModel                           `tfsdk:"xfcc_disabled"`
	XfccOptions               *HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var HTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var HTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var HTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var HTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerJsChallengeModel represents js_challenge block
type HTTPLoadBalancerJsChallengeModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerJsChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerJsChallengeModel
var HTTPLoadBalancerJsChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// HTTPLoadBalancerJWTValidationModel represents jwt_validation block
type HTTPLoadBalancerJWTValidationModel struct {
	Action          *HTTPLoadBalancerJWTValidationActionModel          `tfsdk:"action"`
	JwksConfig      *HTTPLoadBalancerJWTValidationJwksConfigModel      `tfsdk:"jwks_config"`
	MandatoryClaims *HTTPLoadBalancerJWTValidationMandatoryClaimsModel `tfsdk:"mandatory_claims"`
	ReservedClaims  *HTTPLoadBalancerJWTValidationReservedClaimsModel  `tfsdk:"reserved_claims"`
	Target          *HTTPLoadBalancerJWTValidationTargetModel          `tfsdk:"target"`
	TokenLocation   *HTTPLoadBalancerJWTValidationTokenLocationModel   `tfsdk:"token_location"`
}

// HTTPLoadBalancerJWTValidationModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationModel
var HTTPLoadBalancerJWTValidationModelAttrTypes = map[string]attr.Type{
	"action":           types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationActionModelAttrTypes},
	"jwks_config":      types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationJwksConfigModelAttrTypes},
	"mandatory_claims": types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationMandatoryClaimsModelAttrTypes},
	"reserved_claims":  types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationReservedClaimsModelAttrTypes},
	"target":           types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationTargetModelAttrTypes},
	"token_location":   types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationTokenLocationModelAttrTypes},
}

// HTTPLoadBalancerJWTValidationActionModel represents action block
type HTTPLoadBalancerJWTValidationActionModel struct {
	Block  *HTTPLoadBalancerEmptyModel `tfsdk:"block"`
	Report *HTTPLoadBalancerEmptyModel `tfsdk:"report"`
}

// HTTPLoadBalancerJWTValidationActionModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationActionModel
var HTTPLoadBalancerJWTValidationActionModelAttrTypes = map[string]attr.Type{
	"block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerJWTValidationJwksConfigModel represents jwks_config block
type HTTPLoadBalancerJWTValidationJwksConfigModel struct {
	Cleartext types.String `tfsdk:"cleartext"`
}

// HTTPLoadBalancerJWTValidationJwksConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationJwksConfigModel
var HTTPLoadBalancerJWTValidationJwksConfigModelAttrTypes = map[string]attr.Type{
	"cleartext": types.StringType,
}

// HTTPLoadBalancerJWTValidationMandatoryClaimsModel represents mandatory_claims block
type HTTPLoadBalancerJWTValidationMandatoryClaimsModel struct {
	ClaimNames types.List `tfsdk:"claim_names"`
}

// HTTPLoadBalancerJWTValidationMandatoryClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationMandatoryClaimsModel
var HTTPLoadBalancerJWTValidationMandatoryClaimsModelAttrTypes = map[string]attr.Type{
	"claim_names": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerJWTValidationReservedClaimsModel represents reserved_claims block
type HTTPLoadBalancerJWTValidationReservedClaimsModel struct {
	Issuer                types.String                                              `tfsdk:"issuer"`
	Audience              *HTTPLoadBalancerJWTValidationReservedClaimsAudienceModel `tfsdk:"audience"`
	AudienceDisable       *HTTPLoadBalancerEmptyModel                               `tfsdk:"audience_disable"`
	IssuerDisable         *HTTPLoadBalancerEmptyModel                               `tfsdk:"issuer_disable"`
	ValidatePeriodDisable *HTTPLoadBalancerEmptyModel                               `tfsdk:"validate_period_disable"`
	ValidatePeriodEnable  *HTTPLoadBalancerEmptyModel                               `tfsdk:"validate_period_enable"`
}

// HTTPLoadBalancerJWTValidationReservedClaimsModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationReservedClaimsModel
var HTTPLoadBalancerJWTValidationReservedClaimsModelAttrTypes = map[string]attr.Type{
	"issuer":                  types.StringType,
	"audience":                types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationReservedClaimsAudienceModelAttrTypes},
	"audience_disable":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"issuer_disable":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validate_period_disable": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"validate_period_enable":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerJWTValidationReservedClaimsAudienceModel represents audience block
type HTTPLoadBalancerJWTValidationReservedClaimsAudienceModel struct {
	Audiences types.List `tfsdk:"audiences"`
}

// HTTPLoadBalancerJWTValidationReservedClaimsAudienceModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationReservedClaimsAudienceModel
var HTTPLoadBalancerJWTValidationReservedClaimsAudienceModelAttrTypes = map[string]attr.Type{
	"audiences": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerJWTValidationTargetModel represents target block
type HTTPLoadBalancerJWTValidationTargetModel struct {
	AllEndpoint *HTTPLoadBalancerEmptyModel                        `tfsdk:"all_endpoint"`
	APIGroups   *HTTPLoadBalancerJWTValidationTargetAPIGroupsModel `tfsdk:"api_groups"`
	BasePaths   *HTTPLoadBalancerJWTValidationTargetBasePathsModel `tfsdk:"base_paths"`
}

// HTTPLoadBalancerJWTValidationTargetModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationTargetModel
var HTTPLoadBalancerJWTValidationTargetModelAttrTypes = map[string]attr.Type{
	"all_endpoint": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"api_groups":   types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationTargetAPIGroupsModelAttrTypes},
	"base_paths":   types.ObjectType{AttrTypes: HTTPLoadBalancerJWTValidationTargetBasePathsModelAttrTypes},
}

// HTTPLoadBalancerJWTValidationTargetAPIGroupsModel represents api_groups block
type HTTPLoadBalancerJWTValidationTargetAPIGroupsModel struct {
	APIGroups types.List `tfsdk:"api_groups"`
}

// HTTPLoadBalancerJWTValidationTargetAPIGroupsModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationTargetAPIGroupsModel
var HTTPLoadBalancerJWTValidationTargetAPIGroupsModelAttrTypes = map[string]attr.Type{
	"api_groups": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerJWTValidationTargetBasePathsModel represents base_paths block
type HTTPLoadBalancerJWTValidationTargetBasePathsModel struct {
	BasePaths types.List `tfsdk:"base_paths"`
}

// HTTPLoadBalancerJWTValidationTargetBasePathsModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationTargetBasePathsModel
var HTTPLoadBalancerJWTValidationTargetBasePathsModelAttrTypes = map[string]attr.Type{
	"base_paths": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerJWTValidationTokenLocationModel represents token_location block
type HTTPLoadBalancerJWTValidationTokenLocationModel struct {
	BearerToken *HTTPLoadBalancerEmptyModel `tfsdk:"bearer_token"`
}

// HTTPLoadBalancerJWTValidationTokenLocationModelAttrTypes defines the attribute types for HTTPLoadBalancerJWTValidationTokenLocationModel
var HTTPLoadBalancerJWTValidationTokenLocationModelAttrTypes = map[string]attr.Type{
	"bearer_token": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerL7DDOSActionJsChallengeModel represents l7_ddos_action_js_challenge block
type HTTPLoadBalancerL7DDOSActionJsChallengeModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerL7DDOSActionJsChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSActionJsChallengeModel
var HTTPLoadBalancerL7DDOSActionJsChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// HTTPLoadBalancerL7DDOSProtectionModel represents l7_ddos_protection block
type HTTPLoadBalancerL7DDOSProtectionModel struct {
	RpsThreshold                     types.Int64                                                            `tfsdk:"rps_threshold"`
	ClientsideActionCaptchaChallenge *HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel `tfsdk:"clientside_action_captcha_challenge"`
	ClientsideActionJsChallenge      *HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel      `tfsdk:"clientside_action_js_challenge"`
	ClientsideActionNone             *HTTPLoadBalancerEmptyModel                                            `tfsdk:"clientside_action_none"`
	DDOSPolicyCustom                 *HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel                 `tfsdk:"ddos_policy_custom"`
	DDOSPolicyNone                   *HTTPLoadBalancerEmptyModel                                            `tfsdk:"ddos_policy_none"`
	DefaultRpsThreshold              *HTTPLoadBalancerEmptyModel                                            `tfsdk:"default_rps_threshold"`
	MitigationBlock                  *HTTPLoadBalancerEmptyModel                                            `tfsdk:"mitigation_block"`
	MitigationCaptchaChallenge       *HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel       `tfsdk:"mitigation_captcha_challenge"`
	MitigationJsChallenge            *HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel            `tfsdk:"mitigation_js_challenge"`
}

// HTTPLoadBalancerL7DDOSProtectionModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSProtectionModel
var HTTPLoadBalancerL7DDOSProtectionModelAttrTypes = map[string]attr.Type{
	"rps_threshold":                       types.Int64Type,
	"clientside_action_captcha_challenge": types.ObjectType{AttrTypes: HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModelAttrTypes},
	"clientside_action_js_challenge":      types.ObjectType{AttrTypes: HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModelAttrTypes},
	"clientside_action_none":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ddos_policy_custom":                  types.ObjectType{AttrTypes: HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModelAttrTypes},
	"ddos_policy_none":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_rps_threshold":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mitigation_block":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mitigation_captcha_challenge":        types.ObjectType{AttrTypes: HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModelAttrTypes},
	"mitigation_js_challenge":             types.ObjectType{AttrTypes: HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModelAttrTypes},
}

// HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel represents clientside_action_captcha_challenge block
type HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel
var HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel represents clientside_action_js_challenge block
type HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel
var HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel represents ddos_policy_custom block
type HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel
var HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel represents mitigation_captcha_challenge block
type HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel
var HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel represents mitigation_js_challenge block
type HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel
var HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// HTTPLoadBalancerMalwareProtectionSettingsModel represents malware_protection_settings block
type HTTPLoadBalancerMalwareProtectionSettingsModel struct {
	MalwareProtectionRules []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel `tfsdk:"malware_protection_rules"`
}

// HTTPLoadBalancerMalwareProtectionSettingsModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsModel
var HTTPLoadBalancerMalwareProtectionSettingsModelAttrTypes = map[string]attr.Type{
	"malware_protection_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModelAttrTypes}},
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel represents malware_protection_rules block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel struct {
	HTTPMethods types.List                                                                    `tfsdk:"http_methods"`
	Action      *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel   `tfsdk:"action"`
	Domain      *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel   `tfsdk:"domain"`
	Metadata    *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel `tfsdk:"metadata"`
	Path        *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel     `tfsdk:"path"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel
var HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModelAttrTypes = map[string]attr.Type{
	"http_methods": types.ListType{ElemType: types.StringType},
	"action":       types.ObjectType{AttrTypes: HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModelAttrTypes},
	"domain":       types.ObjectType{AttrTypes: HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModelAttrTypes},
	"metadata":     types.ObjectType{AttrTypes: HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModelAttrTypes},
	"path":         types.ObjectType{AttrTypes: HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModelAttrTypes},
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel represents action block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel struct {
	Block  *HTTPLoadBalancerEmptyModel `tfsdk:"block"`
	Report *HTTPLoadBalancerEmptyModel `tfsdk:"report"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel
var HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModelAttrTypes = map[string]attr.Type{
	"block":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"report": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel represents domain block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel struct {
	AnyDomain *HTTPLoadBalancerEmptyModel                                                       `tfsdk:"any_domain"`
	Domain    *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel `tfsdk:"domain"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel
var HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModelAttrTypes = map[string]attr.Type{
	"any_domain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain":     types.ObjectType{AttrTypes: HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModelAttrTypes},
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel represents domain block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModel
var HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainDomainModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel represents metadata block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel
var HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel represents path block
type HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModelAttrTypes defines the attribute types for HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel
var HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerMoreOptionModel represents more_option block
type HTTPLoadBalancerMoreOptionModel struct {
	DisableDefaultErrorPages types.Bool                                            `tfsdk:"disable_default_error_pages"`
	IdleTimeout              types.Int64                                           `tfsdk:"idle_timeout"`
	MaxRequestHeaderSize     types.Int64                                           `tfsdk:"max_request_header_size"`
	RequestCookiesToRemove   types.List                                            `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove   types.List                                            `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove  types.List                                            `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove  types.List                                            `tfsdk:"response_headers_to_remove"`
	BufferPolicy             *HTTPLoadBalancerMoreOptionBufferPolicyModel          `tfsdk:"buffer_policy"`
	CompressionParams        *HTTPLoadBalancerMoreOptionCompressionParamsModel     `tfsdk:"compression_params"`
	CustomErrors             *HTTPLoadBalancerEmptyModel                           `tfsdk:"custom_errors"`
	DisablePathNormalize     *HTTPLoadBalancerEmptyModel                           `tfsdk:"disable_path_normalize"`
	EnablePathNormalize      *HTTPLoadBalancerEmptyModel                           `tfsdk:"enable_path_normalize"`
	RequestCookiesToAdd      []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel  `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd      []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel  `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd     []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd     []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// HTTPLoadBalancerMoreOptionModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionModel
var HTTPLoadBalancerMoreOptionModelAttrTypes = map[string]attr.Type{
	"disable_default_error_pages": types.BoolType,
	"idle_timeout":                types.Int64Type,
	"max_request_header_size":     types.Int64Type,
	"request_cookies_to_remove":   types.ListType{ElemType: types.StringType},
	"request_headers_to_remove":   types.ListType{ElemType: types.StringType},
	"response_cookies_to_remove":  types.ListType{ElemType: types.StringType},
	"response_headers_to_remove":  types.ListType{ElemType: types.StringType},
	"buffer_policy":               types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionBufferPolicyModelAttrTypes},
	"compression_params":          types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionCompressionParamsModelAttrTypes},
	"custom_errors":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"request_cookies_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestCookiesToAddModelAttrTypes}},
	"request_headers_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestHeadersToAddModelAttrTypes}},
	"response_cookies_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseCookiesToAddModelAttrTypes}},
	"response_headers_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseHeadersToAddModelAttrTypes}},
}

// HTTPLoadBalancerMoreOptionBufferPolicyModel represents buffer_policy block
type HTTPLoadBalancerMoreOptionBufferPolicyModel struct {
	Disabled        types.Bool  `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// HTTPLoadBalancerMoreOptionBufferPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionBufferPolicyModel
var HTTPLoadBalancerMoreOptionBufferPolicyModelAttrTypes = map[string]attr.Type{
	"disabled":          types.BoolType,
	"max_request_bytes": types.Int64Type,
}

// HTTPLoadBalancerMoreOptionCompressionParamsModel represents compression_params block
type HTTPLoadBalancerMoreOptionCompressionParamsModel struct {
	ContentLength              types.Int64 `tfsdk:"content_length"`
	ContentType                types.List  `tfsdk:"content_type"`
	DisableOnEtagHeader        types.Bool  `tfsdk:"disable_on_etag_header"`
	RemoveAcceptEncodingHeader types.Bool  `tfsdk:"remove_accept_encoding_header"`
}

// HTTPLoadBalancerMoreOptionCompressionParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionCompressionParamsModel
var HTTPLoadBalancerMoreOptionCompressionParamsModelAttrTypes = map[string]attr.Type{
	"content_length":                types.Int64Type,
	"content_type":                  types.ListType{ElemType: types.StringType},
	"disable_on_etag_header":        types.BoolType,
	"remove_accept_encoding_header": types.BoolType,
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddModel represents request_cookies_to_add block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddModel struct {
	Name        types.String                                                   `tfsdk:"name"`
	Overwrite   types.Bool                                                     `tfsdk:"overwrite"`
	Value       types.String                                                   `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestCookiesToAddModel
var HTTPLoadBalancerMoreOptionRequestCookiesToAddModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"overwrite":    types.BoolType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel
var HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddModel represents request_headers_to_add block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddModel struct {
	Append      types.Bool                                                     `tfsdk:"append"`
	Name        types.String                                                   `tfsdk:"name"`
	Value       types.String                                                   `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestHeadersToAddModel
var HTTPLoadBalancerMoreOptionRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel
var HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddModel represents response_cookies_to_add block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddModel struct {
	AddDomain         types.String                                                    `tfsdk:"add_domain"`
	AddExpiry         types.String                                                    `tfsdk:"add_expiry"`
	AddPath           types.String                                                    `tfsdk:"add_path"`
	MaxAgeValue       types.Int64                                                     `tfsdk:"max_age_value"`
	Name              types.String                                                    `tfsdk:"name"`
	Overwrite         types.Bool                                                      `tfsdk:"overwrite"`
	Value             types.String                                                    `tfsdk:"value"`
	AddHttponly       *HTTPLoadBalancerEmptyModel                                     `tfsdk:"add_httponly"`
	AddPartitioned    *HTTPLoadBalancerEmptyModel                                     `tfsdk:"add_partitioned"`
	AddSecure         *HTTPLoadBalancerEmptyModel                                     `tfsdk:"add_secure"`
	IgnoreDomain      *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_domain"`
	IgnoreExpiry      *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_expiry"`
	IgnoreHttponly    *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_httponly"`
	IgnoreMaxAge      *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_max_age"`
	IgnorePartitioned *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_partitioned"`
	IgnorePath        *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_path"`
	IgnoreSamesite    *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_samesite"`
	IgnoreSecure      *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_secure"`
	IgnoreValue       *HTTPLoadBalancerEmptyModel                                     `tfsdk:"ignore_value"`
	SamesiteLax       *HTTPLoadBalancerEmptyModel                                     `tfsdk:"samesite_lax"`
	SamesiteNone      *HTTPLoadBalancerEmptyModel                                     `tfsdk:"samesite_none"`
	SamesiteStrict    *HTTPLoadBalancerEmptyModel                                     `tfsdk:"samesite_strict"`
	SecretValue       *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseCookiesToAddModel
var HTTPLoadBalancerMoreOptionResponseCookiesToAddModelAttrTypes = map[string]attr.Type{
	"add_domain":         types.StringType,
	"add_expiry":         types.StringType,
	"add_path":           types.StringType,
	"max_age_value":      types.Int64Type,
	"name":               types.StringType,
	"overwrite":          types.BoolType,
	"value":              types.StringType,
	"add_httponly":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_partitioned":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_expiry":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_partitioned": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_path":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_value":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"secret_value":       types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel
var HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddModel represents response_headers_to_add block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddModel struct {
	Append      types.Bool                                                      `tfsdk:"append"`
	Name        types.String                                                    `tfsdk:"name"`
	Value       types.String                                                    `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseHeadersToAddModel
var HTTPLoadBalancerMoreOptionResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel
var HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerOriginServerSubsetRuleListModel represents origin_server_subset_rule_list block
type HTTPLoadBalancerOriginServerSubsetRuleListModel struct {
	OriginServerSubsetRules []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel `tfsdk:"origin_server_subset_rules"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListModel
var HTTPLoadBalancerOriginServerSubsetRuleListModelAttrTypes = map[string]attr.Type{
	"origin_server_subset_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModelAttrTypes}},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel represents origin_server_subset_rules block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel struct {
	CountryCodes              types.List                                                                            `tfsdk:"country_codes"`
	RENameList                types.List                                                                            `tfsdk:"re_name_list"`
	AnyAsn                    *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"any_asn"`
	AnyIP                     *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"any_ip"`
	AsnList                   *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel        `tfsdk:"asn_list"`
	AsnMatcher                *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel     `tfsdk:"asn_matcher"`
	ClientSelector            *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel `tfsdk:"client_selector"`
	IPMatcher                 *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel      `tfsdk:"ip_matcher"`
	IPPrefixList              *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel   `tfsdk:"ip_prefix_list"`
	Metadata                  *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel       `tfsdk:"metadata"`
	None                      *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"none"`
	OriginServerSubsetsAction *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"origin_server_subsets_action"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModelAttrTypes = map[string]attr.Type{
	"country_codes":                types.ListType{ElemType: types.StringType},
	"re_name_list":                 types.ListType{ElemType: types.StringType},
	"any_asn":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":                     types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModelAttrTypes},
	"asn_matcher":                  types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModelAttrTypes},
	"client_selector":              types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModelAttrTypes},
	"ip_matcher":                   types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModelAttrTypes},
	"ip_prefix_list":               types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModelAttrTypes},
	"metadata":                     types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModelAttrTypes},
	"none":                         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"origin_server_subsets_action": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel represents asn_list block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel represents client_selector block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel struct {
	InvertMatcher types.Bool                                                                                  `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel represents metadata block
type HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel
var HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerPolicyBasedChallengeModel represents policy_based_challenge block
type HTTPLoadBalancerPolicyBasedChallengeModel struct {
	AlwaysEnableCaptchaChallenge       *HTTPLoadBalancerEmptyModel                                          `tfsdk:"always_enable_captcha_challenge"`
	AlwaysEnableJsChallenge            *HTTPLoadBalancerEmptyModel                                          `tfsdk:"always_enable_js_challenge"`
	CaptchaChallengeParameters         *HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel `tfsdk:"captcha_challenge_parameters"`
	DefaultCaptchaChallengeParameters  *HTTPLoadBalancerEmptyModel                                          `tfsdk:"default_captcha_challenge_parameters"`
	DefaultJsChallengeParameters       *HTTPLoadBalancerEmptyModel                                          `tfsdk:"default_js_challenge_parameters"`
	DefaultMitigationSettings          *HTTPLoadBalancerEmptyModel                                          `tfsdk:"default_mitigation_settings"`
	DefaultTemporaryBlockingParameters *HTTPLoadBalancerEmptyModel                                          `tfsdk:"default_temporary_blocking_parameters"`
	JsChallengeParameters              *HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel      `tfsdk:"js_challenge_parameters"`
	MaliciousUserMitigation            *HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel    `tfsdk:"malicious_user_mitigation"`
	NoChallenge                        *HTTPLoadBalancerEmptyModel                                          `tfsdk:"no_challenge"`
	RuleList                           *HTTPLoadBalancerPolicyBasedChallengeRuleListModel                   `tfsdk:"rule_list"`
	TemporaryUserBlocking              *HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel      `tfsdk:"temporary_user_blocking"`
}

// HTTPLoadBalancerPolicyBasedChallengeModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeModel
var HTTPLoadBalancerPolicyBasedChallengeModelAttrTypes = map[string]attr.Type{
	"always_enable_captcha_challenge":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"always_enable_js_challenge":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"captcha_challenge_parameters":          types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModelAttrTypes},
	"default_captcha_challenge_parameters":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_js_challenge_parameters":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_mitigation_settings":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_temporary_blocking_parameters": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"js_challenge_parameters":               types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModelAttrTypes},
	"malicious_user_mitigation":             types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModelAttrTypes},
	"no_challenge":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"rule_list":                             types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListModelAttrTypes},
	"temporary_user_blocking":               types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel represents captcha_challenge_parameters block
type HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel struct {
	CookieExpiry types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage   types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModel
var HTTPLoadBalancerPolicyBasedChallengeCaptchaChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry": types.Int64Type,
	"custom_page":   types.StringType,
}

// HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel represents js_challenge_parameters block
type HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel struct {
	CookieExpiry  types.Int64  `tfsdk:"cookie_expiry"`
	CustomPage    types.String `tfsdk:"custom_page"`
	JsScriptDelay types.Int64  `tfsdk:"js_script_delay"`
}

// HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModel
var HTTPLoadBalancerPolicyBasedChallengeJsChallengeParametersModelAttrTypes = map[string]attr.Type{
	"cookie_expiry":   types.Int64Type,
	"custom_page":     types.StringType,
	"js_script_delay": types.Int64Type,
}

// HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel represents malicious_user_mitigation block
type HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModel
var HTTPLoadBalancerPolicyBasedChallengeMaliciousUserMitigationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListModel represents rule_list block
type HTTPLoadBalancerPolicyBasedChallengeRuleListModel struct {
	Rules []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListModelAttrTypes = map[string]attr.Type{
	"rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModelAttrTypes}},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel represents rules block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel struct {
	Metadata *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel `tfsdk:"metadata"`
	Spec     *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel     `tfsdk:"spec"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesModelAttrTypes = map[string]attr.Type{
	"metadata": types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModelAttrTypes},
	"spec":     types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel represents metadata block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel represents spec block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel struct {
	ExpirationTimestamp       types.String                                                                     `tfsdk:"expiration_timestamp"`
	AnyAsn                    *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"any_asn"`
	AnyClient                 *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"any_client"`
	AnyIP                     *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"any_ip"`
	ArgMatchers               []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel          `tfsdk:"arg_matchers"`
	AsnList                   *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel               `tfsdk:"asn_list"`
	AsnMatcher                *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel            `tfsdk:"asn_matcher"`
	BodyMatcher               *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel           `tfsdk:"body_matcher"`
	ClientSelector            *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel        `tfsdk:"client_selector"`
	CookieMatchers            []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel       `tfsdk:"cookie_matchers"`
	DisableChallenge          *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"disable_challenge"`
	DomainMatcher             *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel         `tfsdk:"domain_matcher"`
	EnableCaptchaChallenge    *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"enable_captcha_challenge"`
	EnableJavascriptChallenge *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"enable_javascript_challenge"`
	Headers                   []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel              `tfsdk:"headers"`
	HTTPMethod                *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel            `tfsdk:"http_method"`
	IPMatcher                 *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel             `tfsdk:"ip_matcher"`
	IPPrefixList              *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel          `tfsdk:"ip_prefix_list"`
	Path                      *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel                  `tfsdk:"path"`
	QueryParams               []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel          `tfsdk:"query_params"`
	TLSFingerprintMatcher     *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel `tfsdk:"tls_fingerprint_matcher"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecModelAttrTypes = map[string]attr.Type{
	"expiration_timestamp":        types.StringType,
	"any_asn":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_client":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"arg_matchers":                types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModelAttrTypes}},
	"asn_list":                    types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModelAttrTypes},
	"asn_matcher":                 types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModelAttrTypes},
	"body_matcher":                types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModelAttrTypes},
	"client_selector":             types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModelAttrTypes},
	"cookie_matchers":             types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModelAttrTypes}},
	"disable_challenge":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain_matcher":              types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModelAttrTypes},
	"enable_captcha_challenge":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_javascript_challenge": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"headers":                     types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModelAttrTypes}},
	"http_method":                 types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModelAttrTypes},
	"ip_matcher":                  types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModelAttrTypes},
	"ip_prefix_list":              types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModelAttrTypes},
	"path":                        types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModelAttrTypes},
	"query_params":                types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModelAttrTypes}},
	"tls_fingerprint_matcher":     types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel represents arg_matchers block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel struct {
	InvertMatcher   types.Bool                                                                 `tfsdk:"invert_matcher"`
	Name            types.String                                                               `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecArgMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel represents asn_list block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel represents asn_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel struct {
	AsnSets []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModelAttrTypes}},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel represents asn_sets block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel represents body_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecBodyMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel represents client_selector block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecClientSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel represents cookie_matchers block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel struct {
	InvertMatcher   types.Bool                                                                    `tfsdk:"invert_matcher"`
	Name            types.String                                                                  `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                   `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecCookieMatchersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel represents domain_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecDomainMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel represents headers block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel struct {
	InvertMatcher   types.Bool                                                             `tfsdk:"invert_matcher"`
	Name            types.String                                                           `tfsdk:"name"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                            `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                            `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel represents http_method block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods       types.List `tfsdk:"methods"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecHTTPMethodModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"methods":        types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel represents ip_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel struct {
	InvertMatcher types.Bool                                                                      `tfsdk:"invert_matcher"`
	PrefixSets    []HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModelAttrTypes}},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel represents prefix_sets block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel represents ip_prefix_list block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel represents path block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel struct {
	ExactValues   types.List `tfsdk:"exact_values"`
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixValues  types.List `tfsdk:"prefix_values"`
	RegexValues   types.List `tfsdk:"regex_values"`
	SuffixValues  types.List `tfsdk:"suffix_values"`
	Transformers  types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecPathModelAttrTypes = map[string]attr.Type{
	"exact_values":   types.ListType{ElemType: types.StringType},
	"invert_matcher": types.BoolType,
	"prefix_values":  types.ListType{ElemType: types.StringType},
	"regex_values":   types.ListType{ElemType: types.StringType},
	"suffix_values":  types.ListType{ElemType: types.StringType},
	"transformers":   types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel represents query_params block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel struct {
	InvertMatcher   types.Bool                                                                 `tfsdk:"invert_matcher"`
	Key             types.String                                                               `tfsdk:"key"`
	CheckNotPresent *HTTPLoadBalancerEmptyModel                                                `tfsdk:"check_not_present"`
	CheckPresent    *HTTPLoadBalancerEmptyModel                                                `tfsdk:"check_present"`
	Item            *HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel `tfsdk:"item"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"key":               types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModelAttrTypes},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel represents item block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecQueryParamsItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel represents tls_fingerprint_matcher block
type HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel struct {
	Classes        types.List `tfsdk:"classes"`
	ExactValues    types.List `tfsdk:"exact_values"`
	ExcludedValues types.List `tfsdk:"excluded_values"`
}

// HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModel
var HTTPLoadBalancerPolicyBasedChallengeRuleListRulesSpecTLSFingerprintMatcherModelAttrTypes = map[string]attr.Type{
	"classes":         types.ListType{ElemType: types.StringType},
	"exact_values":    types.ListType{ElemType: types.StringType},
	"excluded_values": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel represents temporary_user_blocking block
type HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel struct {
	CustomPage types.String `tfsdk:"custom_page"`
}

// HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModelAttrTypes defines the attribute types for HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModel
var HTTPLoadBalancerPolicyBasedChallengeTemporaryUserBlockingModelAttrTypes = map[string]attr.Type{
	"custom_page": types.StringType,
}

// HTTPLoadBalancerProtectedCookiesModel represents protected_cookies block
type HTTPLoadBalancerProtectedCookiesModel struct {
	MaxAgeValue                types.Int64                 `tfsdk:"max_age_value"`
	Name                       types.String                `tfsdk:"name"`
	AddHttponly                *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure                  *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	DisableTamperingProtection *HTTPLoadBalancerEmptyModel `tfsdk:"disable_tampering_protection"`
	EnableTamperingProtection  *HTTPLoadBalancerEmptyModel `tfsdk:"enable_tampering_protection"`
	IgnoreHttponly             *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreMaxAge               *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_max_age"`
	IgnoreSamesite             *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure               *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax                *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone               *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict             *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerProtectedCookiesModelAttrTypes defines the attribute types for HTTPLoadBalancerProtectedCookiesModel
var HTTPLoadBalancerProtectedCookiesModelAttrTypes = map[string]attr.Type{
	"max_age_value":                types.Int64Type,
	"name":                         types.StringType,
	"add_httponly":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_tampering_protection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_tampering_protection":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRateLimitModel represents rate_limit block
type HTTPLoadBalancerRateLimitModel struct {
	CustomIPAllowedList *HTTPLoadBalancerRateLimitCustomIPAllowedListModel `tfsdk:"custom_ip_allowed_list"`
	IPAllowedList       *HTTPLoadBalancerRateLimitIPAllowedListModel       `tfsdk:"ip_allowed_list"`
	NoIPAllowedList     *HTTPLoadBalancerEmptyModel                        `tfsdk:"no_ip_allowed_list"`
	NoPolicies          *HTTPLoadBalancerEmptyModel                        `tfsdk:"no_policies"`
	Policies            *HTTPLoadBalancerRateLimitPoliciesModel            `tfsdk:"policies"`
	RateLimiter         *HTTPLoadBalancerRateLimitRateLimiterModel         `tfsdk:"rate_limiter"`
}

// HTTPLoadBalancerRateLimitModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitModel
var HTTPLoadBalancerRateLimitModelAttrTypes = map[string]attr.Type{
	"custom_ip_allowed_list": types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitCustomIPAllowedListModelAttrTypes},
	"ip_allowed_list":        types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitIPAllowedListModelAttrTypes},
	"no_ip_allowed_list":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_policies":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"policies":               types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitPoliciesModelAttrTypes},
	"rate_limiter":           types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitRateLimiterModelAttrTypes},
}

// HTTPLoadBalancerRateLimitCustomIPAllowedListModel represents custom_ip_allowed_list block
type HTTPLoadBalancerRateLimitCustomIPAllowedListModel struct {
	RateLimiterAllowedPrefixes []HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel `tfsdk:"rate_limiter_allowed_prefixes"`
}

// HTTPLoadBalancerRateLimitCustomIPAllowedListModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitCustomIPAllowedListModel
var HTTPLoadBalancerRateLimitCustomIPAllowedListModelAttrTypes = map[string]attr.Type{
	"rate_limiter_allowed_prefixes": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes}},
}

// HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel represents rate_limiter_allowed_prefixes block
type HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModel
var HTTPLoadBalancerRateLimitCustomIPAllowedListRateLimiterAllowedPrefixesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRateLimitIPAllowedListModel represents ip_allowed_list block
type HTTPLoadBalancerRateLimitIPAllowedListModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// HTTPLoadBalancerRateLimitIPAllowedListModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitIPAllowedListModel
var HTTPLoadBalancerRateLimitIPAllowedListModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerRateLimitPoliciesModel represents policies block
type HTTPLoadBalancerRateLimitPoliciesModel struct {
	Policies []HTTPLoadBalancerRateLimitPoliciesPoliciesModel `tfsdk:"policies"`
}

// HTTPLoadBalancerRateLimitPoliciesModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitPoliciesModel
var HTTPLoadBalancerRateLimitPoliciesModelAttrTypes = map[string]attr.Type{
	"policies": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitPoliciesPoliciesModelAttrTypes}},
}

// HTTPLoadBalancerRateLimitPoliciesPoliciesModel represents policies block
type HTTPLoadBalancerRateLimitPoliciesPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRateLimitPoliciesPoliciesModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitPoliciesPoliciesModel
var HTTPLoadBalancerRateLimitPoliciesPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRateLimitRateLimiterModel represents rate_limiter block
type HTTPLoadBalancerRateLimitRateLimiterModel struct {
	BurstMultiplier  types.Int64                                           `tfsdk:"burst_multiplier"`
	PeriodMultiplier types.Int64                                           `tfsdk:"period_multiplier"`
	TotalNumber      types.Int64                                           `tfsdk:"total_number"`
	Unit             types.String                                          `tfsdk:"unit"`
	ActionBlock      *HTTPLoadBalancerRateLimitRateLimiterActionBlockModel `tfsdk:"action_block"`
	Disabled         *HTTPLoadBalancerEmptyModel                           `tfsdk:"disabled"`
	LeakyBucket      *HTTPLoadBalancerEmptyModel                           `tfsdk:"leaky_bucket"`
	TokenBucket      *HTTPLoadBalancerEmptyModel                           `tfsdk:"token_bucket"`
}

// HTTPLoadBalancerRateLimitRateLimiterModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitRateLimiterModel
var HTTPLoadBalancerRateLimitRateLimiterModelAttrTypes = map[string]attr.Type{
	"burst_multiplier":  types.Int64Type,
	"period_multiplier": types.Int64Type,
	"total_number":      types.Int64Type,
	"unit":              types.StringType,
	"action_block":      types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitRateLimiterActionBlockModelAttrTypes},
	"disabled":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"leaky_bucket":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"token_bucket":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockModel represents action_block block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockModel struct {
	Hours   *HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel   `tfsdk:"hours"`
	Minutes *HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel `tfsdk:"minutes"`
	Seconds *HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel `tfsdk:"seconds"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitRateLimiterActionBlockModel
var HTTPLoadBalancerRateLimitRateLimiterActionBlockModelAttrTypes = map[string]attr.Type{
	"hours":   types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModelAttrTypes},
	"minutes": types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModelAttrTypes},
	"seconds": types.ObjectType{AttrTypes: HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModelAttrTypes},
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel represents hours block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModel
var HTTPLoadBalancerRateLimitRateLimiterActionBlockHoursModelAttrTypes = map[string]attr.Type{
	"duration": types.Int64Type,
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel represents minutes block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModel
var HTTPLoadBalancerRateLimitRateLimiterActionBlockMinutesModelAttrTypes = map[string]attr.Type{
	"duration": types.Int64Type,
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel represents seconds block
type HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel struct {
	Duration types.Int64 `tfsdk:"duration"`
}

// HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModelAttrTypes defines the attribute types for HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModel
var HTTPLoadBalancerRateLimitRateLimiterActionBlockSecondsModelAttrTypes = map[string]attr.Type{
	"duration": types.Int64Type,
}

// HTTPLoadBalancerRingHashModel represents ring_hash block
type HTTPLoadBalancerRingHashModel struct {
	HashPolicy []HTTPLoadBalancerRingHashHashPolicyModel `tfsdk:"hash_policy"`
}

// HTTPLoadBalancerRingHashModelAttrTypes defines the attribute types for HTTPLoadBalancerRingHashModel
var HTTPLoadBalancerRingHashModelAttrTypes = map[string]attr.Type{
	"hash_policy": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRingHashHashPolicyModelAttrTypes}},
}

// HTTPLoadBalancerRingHashHashPolicyModel represents hash_policy block
type HTTPLoadBalancerRingHashHashPolicyModel struct {
	HeaderName types.String                                   `tfsdk:"header_name"`
	SourceIP   types.Bool                                     `tfsdk:"source_ip"`
	Terminal   types.Bool                                     `tfsdk:"terminal"`
	Cookie     *HTTPLoadBalancerRingHashHashPolicyCookieModel `tfsdk:"cookie"`
}

// HTTPLoadBalancerRingHashHashPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRingHashHashPolicyModel
var HTTPLoadBalancerRingHashHashPolicyModelAttrTypes = map[string]attr.Type{
	"header_name": types.StringType,
	"source_ip":   types.BoolType,
	"terminal":    types.BoolType,
	"cookie":      types.ObjectType{AttrTypes: HTTPLoadBalancerRingHashHashPolicyCookieModelAttrTypes},
}

// HTTPLoadBalancerRingHashHashPolicyCookieModel represents cookie block
type HTTPLoadBalancerRingHashHashPolicyCookieModel struct {
	Name           types.String                `tfsdk:"name"`
	Path           types.String                `tfsdk:"path"`
	TTL            types.Int64                 `tfsdk:"ttl"`
	AddHttponly    *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure      *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure   *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax    *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone   *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerRingHashHashPolicyCookieModelAttrTypes defines the attribute types for HTTPLoadBalancerRingHashHashPolicyCookieModel
var HTTPLoadBalancerRingHashHashPolicyCookieModelAttrTypes = map[string]attr.Type{
	"name":            types.StringType,
	"path":            types.StringType,
	"ttl":             types.Int64Type,
	"add_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesModel represents routes block
type HTTPLoadBalancerRoutesModel struct {
	CustomRouteObject   *HTTPLoadBalancerRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *HTTPLoadBalancerRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *HTTPLoadBalancerRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *HTTPLoadBalancerRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// HTTPLoadBalancerRoutesModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesModel
var HTTPLoadBalancerRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteModelAttrTypes},
}

// HTTPLoadBalancerRoutesCustomRouteObjectModel represents custom_route_object block
type HTTPLoadBalancerRoutesCustomRouteObjectModel struct {
	RouteRef *HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// HTTPLoadBalancerRoutesCustomRouteObjectModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesCustomRouteObjectModel
var HTTPLoadBalancerRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel represents route_ref block
type HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModel
var HTTPLoadBalancerRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRoutesDirectResponseRouteModel represents direct_response_route block
type HTTPLoadBalancerRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                       `tfsdk:"http_method"`
	Headers             []HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *HTTPLoadBalancerRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesDirectResponseRouteModel
var HTTPLoadBalancerRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel represents headers block
type HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesDirectResponseRouteHeadersModel
var HTTPLoadBalancerRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64                 `tfsdk:"port"`
	PortRanges  types.String                `tfsdk:"port_ranges"`
	NoPortMatch *HTTPLoadBalancerEmptyModel `tfsdk:"no_port_match"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModel
var HTTPLoadBalancerRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesDirectResponseRoutePathModel represents path block
type HTTPLoadBalancerRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesDirectResponseRoutePathModel
var HTTPLoadBalancerRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModel
var HTTPLoadBalancerRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// HTTPLoadBalancerRoutesRedirectRouteModel represents redirect_route block
type HTTPLoadBalancerRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                           `tfsdk:"http_method"`
	Headers       []HTTPLoadBalancerRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *HTTPLoadBalancerRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// HTTPLoadBalancerRoutesRedirectRouteModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesRedirectRouteModel
var HTTPLoadBalancerRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// HTTPLoadBalancerRoutesRedirectRouteHeadersModel represents headers block
type HTTPLoadBalancerRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesRedirectRouteHeadersModel
var HTTPLoadBalancerRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel represents incoming_port block
type HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64                 `tfsdk:"port"`
	PortRanges  types.String                `tfsdk:"port_ranges"`
	NoPortMatch *HTTPLoadBalancerEmptyModel `tfsdk:"no_port_match"`
}

// HTTPLoadBalancerRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesRedirectRouteIncomingPortModel
var HTTPLoadBalancerRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesRedirectRoutePathModel represents path block
type HTTPLoadBalancerRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesRedirectRoutePathModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesRedirectRoutePathModel
var HTTPLoadBalancerRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String                `tfsdk:"host_redirect"`
	PathRedirect    types.String                `tfsdk:"path_redirect"`
	PrefixRewrite   types.String                `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String                `tfsdk:"proto_redirect"`
	ReplaceParams   types.String                `tfsdk:"replace_params"`
	ResponseCode    types.Int64                 `tfsdk:"response_code"`
	RemoveAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"retain_all_params"`
}

// HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModel
var HTTPLoadBalancerRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesSimpleRouteModel represents simple_route block
type HTTPLoadBalancerRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                           `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                           `tfsdk:"http_method"`
	AdvancedOptions    *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel `tfsdk:"advanced_options"`
	AutoHostRewrite    *HTTPLoadBalancerEmptyModel                            `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *HTTPLoadBalancerEmptyModel                            `tfsdk:"disable_host_rewrite"`
	Headers            []HTTPLoadBalancerRoutesSimpleRouteHeadersModel        `tfsdk:"headers"`
	IncomingPort       *HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel    `tfsdk:"incoming_port"`
	OriginPools        []HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel    `tfsdk:"origin_pools"`
	Path               *HTTPLoadBalancerRoutesSimpleRoutePathModel            `tfsdk:"path"`
	QueryParams        *HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel     `tfsdk:"query_params"`
}

// HTTPLoadBalancerRoutesSimpleRouteModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteModel
var HTTPLoadBalancerRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"advanced_options":     types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModelAttrTypes},
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"headers":              types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteHeadersModelAttrTypes}},
	"incoming_port":        types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteIncomingPortModelAttrTypes},
	"origin_pools":         types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModelAttrTypes}},
	"path":                 types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRoutePathModelAttrTypes},
	"query_params":         types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteQueryParamsModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel represents advanced_options block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel struct {
	DisableLocationAdd                     types.Bool                                                                          `tfsdk:"disable_location_add"`
	PrefixRewrite                          types.String                                                                        `tfsdk:"prefix_rewrite"`
	Priority                               types.String                                                                        `tfsdk:"priority"`
	RequestCookiesToRemove                 types.List                                                                          `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove                 types.List                                                                          `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove                types.List                                                                          `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove                types.List                                                                          `tfsdk:"response_headers_to_remove"`
	Timeout                                types.Int64                                                                         `tfsdk:"timeout"`
	AppFirewall                            *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel                   `tfsdk:"app_firewall"`
	BotDefenseJavascriptInjection          *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel `tfsdk:"bot_defense_javascript_injection"`
	BufferPolicy                           *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel                  `tfsdk:"buffer_policy"`
	CommonBuffering                        *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"common_buffering"`
	CommonHashPolicy                       *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"common_hash_policy"`
	CORSPolicy                             *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModel                    `tfsdk:"cors_policy"`
	CSRFPolicy                             *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModel                    `tfsdk:"csrf_policy"`
	DefaultRetryPolicy                     *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"default_retry_policy"`
	DisableMirroring                       *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"disable_mirroring"`
	DisablePrefixRewrite                   *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"disable_prefix_rewrite"`
	DisableSpdy                            *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"disable_spdy"`
	DisableWAF                             *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"disable_waf"`
	DisableWebSocketConfig                 *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"disable_web_socket_config"`
	DoNotRetractCluster                    *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"do_not_retract_cluster"`
	EnableSpdy                             *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"enable_spdy"`
	EndpointSubsets                        *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"endpoint_subsets"`
	InheritedBotDefenseJavascriptInjection *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"inherited_bot_defense_javascript_injection"`
	InheritedWAF                           *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"inherited_waf"`
	InheritedWAFExclusion                  *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"inherited_waf_exclusion"`
	MirrorPolicy                           *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel                  `tfsdk:"mirror_policy"`
	NoRetryPolicy                          *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"no_retry_policy"`
	RegexRewrite                           *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel                  `tfsdk:"regex_rewrite"`
	RequestCookiesToAdd                    []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel          `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd                    []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel          `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd                   []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel         `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd                   []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel         `tfsdk:"response_headers_to_add"`
	RetractCluster                         *HTTPLoadBalancerEmptyModel                                                         `tfsdk:"retract_cluster"`
	RetryPolicy                            *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel                   `tfsdk:"retry_policy"`
	SpecificHashPolicy                     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel            `tfsdk:"specific_hash_policy"`
	WAFExclusionPolicy                     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel            `tfsdk:"waf_exclusion_policy"`
	WebSocketConfig                        *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel               `tfsdk:"web_socket_config"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsModelAttrTypes = map[string]attr.Type{
	"disable_location_add":                       types.BoolType,
	"prefix_rewrite":                             types.StringType,
	"priority":                                   types.StringType,
	"request_cookies_to_remove":                  types.ListType{ElemType: types.StringType},
	"request_headers_to_remove":                  types.ListType{ElemType: types.StringType},
	"response_cookies_to_remove":                 types.ListType{ElemType: types.StringType},
	"response_headers_to_remove":                 types.ListType{ElemType: types.StringType},
	"timeout":                                    types.Int64Type,
	"app_firewall":                               types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModelAttrTypes},
	"bot_defense_javascript_injection":           types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModelAttrTypes},
	"buffer_policy":                              types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModelAttrTypes},
	"common_buffering":                           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"common_hash_policy":                         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"cors_policy":                                types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModelAttrTypes},
	"csrf_policy":                                types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModelAttrTypes},
	"default_retry_policy":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_mirroring":                          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_prefix_rewrite":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_spdy":                               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_waf":                                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_web_socket_config":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"do_not_retract_cluster":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_spdy":                                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"endpoint_subsets":                           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"inherited_bot_defense_javascript_injection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"inherited_waf":                              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"inherited_waf_exclusion":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mirror_policy":                              types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModelAttrTypes},
	"no_retry_policy":                            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"regex_rewrite":                              types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModelAttrTypes},
	"request_cookies_to_add":                     types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModelAttrTypes}},
	"request_headers_to_add":                     types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModelAttrTypes}},
	"response_cookies_to_add":                    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModelAttrTypes}},
	"response_headers_to_add":                    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModelAttrTypes}},
	"retract_cluster":                            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retry_policy":                               types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModelAttrTypes},
	"specific_hash_policy":                       types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModelAttrTypes},
	"waf_exclusion_policy":                       types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModelAttrTypes},
	"web_socket_config":                          types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel represents app_firewall block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsAppFirewallModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel represents bot_defense_javascript_injection block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel struct {
	JavascriptLocation types.String                                                                                       `tfsdk:"javascript_location"`
	JavascriptTags     []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel `tfsdk:"javascript_tags"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"javascript_tags":     types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModelAttrTypes}},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel represents javascript_tags block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel struct {
	JavascriptURL types.String                                                                                                    `tfsdk:"javascript_url"`
	TagAttributes []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel `tfsdk:"tag_attributes"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsModelAttrTypes = map[string]attr.Type{
	"javascript_url": types.StringType,
	"tag_attributes": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModelAttrTypes}},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel represents tag_attributes block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel struct {
	JavascriptTag types.String `tfsdk:"javascript_tag"`
	TagValue      types.String `tfsdk:"tag_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModelAttrTypes = map[string]attr.Type{
	"javascript_tag": types.StringType,
	"tag_value":      types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel represents buffer_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel struct {
	Disabled        types.Bool  `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsBufferPolicyModelAttrTypes = map[string]attr.Type{
	"disabled":          types.BoolType,
	"max_request_bytes": types.Int64Type,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModel represents cors_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModel struct {
	AllowCredentials types.Bool   `tfsdk:"allow_credentials"`
	AllowHeaders     types.String `tfsdk:"allow_headers"`
	AllowMethods     types.String `tfsdk:"allow_methods"`
	AllowOrigin      types.List   `tfsdk:"allow_origin"`
	AllowOriginRegex types.List   `tfsdk:"allow_origin_regex"`
	Disabled         types.Bool   `tfsdk:"disabled"`
	ExposeHeaders    types.String `tfsdk:"expose_headers"`
	MaximumAge       types.Int64  `tfsdk:"maximum_age"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCORSPolicyModelAttrTypes = map[string]attr.Type{
	"allow_credentials":  types.BoolType,
	"allow_headers":      types.StringType,
	"allow_methods":      types.StringType,
	"allow_origin":       types.ListType{ElemType: types.StringType},
	"allow_origin_regex": types.ListType{ElemType: types.StringType},
	"disabled":           types.BoolType,
	"expose_headers":     types.StringType,
	"maximum_age":        types.Int64Type,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModel represents csrf_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModel struct {
	AllLoadBalancerDomains *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"all_load_balancer_domains"`
	CustomDomainList       *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled               *HTTPLoadBalancerEmptyModel                                                      `tfsdk:"disabled"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyModelAttrTypes = map[string]attr.Type{
	"all_load_balancer_domains": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"custom_domain_list":        types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModelAttrTypes},
	"disabled":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModel represents custom_domain_list block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsCSRFPolicyCustomDomainListModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel represents mirror_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel struct {
	OriginPool *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel `tfsdk:"origin_pool"`
	Percent    *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel    `tfsdk:"percent"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyModelAttrTypes = map[string]attr.Type{
	"origin_pool": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModelAttrTypes},
	"percent":     types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel represents origin_pool block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyOriginPoolModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel represents percent block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel struct {
	Denominator types.String `tfsdk:"denominator"`
	Numerator   types.Int64  `tfsdk:"numerator"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsMirrorPolicyPercentModelAttrTypes = map[string]attr.Type{
	"denominator": types.StringType,
	"numerator":   types.Int64Type,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel represents regex_rewrite block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel struct {
	Pattern      types.String `tfsdk:"pattern"`
	Substitution types.String `tfsdk:"substitution"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRegexRewriteModelAttrTypes = map[string]attr.Type{
	"pattern":      types.StringType,
	"substitution": types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel represents request_cookies_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel struct {
	Name        types.String                                                                         `tfsdk:"name"`
	Overwrite   types.Bool                                                                           `tfsdk:"overwrite"`
	Value       types.String                                                                         `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"overwrite":    types.BoolType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel represents request_headers_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel struct {
	Append      types.Bool                                                                           `tfsdk:"append"`
	Name        types.String                                                                         `tfsdk:"name"`
	Value       types.String                                                                         `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel represents response_cookies_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel struct {
	AddDomain         types.String                                                                          `tfsdk:"add_domain"`
	AddExpiry         types.String                                                                          `tfsdk:"add_expiry"`
	AddPath           types.String                                                                          `tfsdk:"add_path"`
	MaxAgeValue       types.Int64                                                                           `tfsdk:"max_age_value"`
	Name              types.String                                                                          `tfsdk:"name"`
	Overwrite         types.Bool                                                                            `tfsdk:"overwrite"`
	Value             types.String                                                                          `tfsdk:"value"`
	AddHttponly       *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"add_httponly"`
	AddPartitioned    *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"add_partitioned"`
	AddSecure         *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"add_secure"`
	IgnoreDomain      *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_domain"`
	IgnoreExpiry      *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_expiry"`
	IgnoreHttponly    *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_httponly"`
	IgnoreMaxAge      *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_max_age"`
	IgnorePartitioned *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_partitioned"`
	IgnorePath        *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_path"`
	IgnoreSamesite    *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_samesite"`
	IgnoreSecure      *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_secure"`
	IgnoreValue       *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"ignore_value"`
	SamesiteLax       *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"samesite_lax"`
	SamesiteNone      *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"samesite_none"`
	SamesiteStrict    *HTTPLoadBalancerEmptyModel                                                           `tfsdk:"samesite_strict"`
	SecretValue       *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddModelAttrTypes = map[string]attr.Type{
	"add_domain":         types.StringType,
	"add_expiry":         types.StringType,
	"add_path":           types.StringType,
	"max_age_value":      types.Int64Type,
	"name":               types.StringType,
	"overwrite":          types.BoolType,
	"value":              types.StringType,
	"add_httponly":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_partitioned":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_expiry":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_partitioned": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_path":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_value":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"secret_value":       types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel represents response_headers_to_add block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel struct {
	Append      types.Bool                                                                            `tfsdk:"append"`
	Name        types.String                                                                          `tfsdk:"name"`
	Value       types.String                                                                          `tfsdk:"value"`
	SecretValue *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel represents secret_value block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel represents retry_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel struct {
	NumRetries           types.Int64                                                              `tfsdk:"num_retries"`
	PerTryTimeout        types.Int64                                                              `tfsdk:"per_try_timeout"`
	RetriableStatusCodes types.List                                                               `tfsdk:"retriable_status_codes"`
	RetryCondition       types.List                                                               `tfsdk:"retry_condition"`
	BackOff              *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel `tfsdk:"back_off"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyModelAttrTypes = map[string]attr.Type{
	"num_retries":            types.Int64Type,
	"per_try_timeout":        types.Int64Type,
	"retriable_status_codes": types.ListType{ElemType: types.Int64Type},
	"retry_condition":        types.ListType{ElemType: types.StringType},
	"back_off":               types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel represents back_off block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel struct {
	BaseInterval types.Int64 `tfsdk:"base_interval"`
	MaxInterval  types.Int64 `tfsdk:"max_interval"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsRetryPolicyBackOffModelAttrTypes = map[string]attr.Type{
	"base_interval": types.Int64Type,
	"max_interval":  types.Int64Type,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel represents specific_hash_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel struct {
	HashPolicy []HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel `tfsdk:"hash_policy"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyModelAttrTypes = map[string]attr.Type{
	"hash_policy": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModelAttrTypes}},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel represents hash_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel struct {
	HeaderName types.String                                                                             `tfsdk:"header_name"`
	SourceIP   types.Bool                                                                               `tfsdk:"source_ip"`
	Terminal   types.Bool                                                                               `tfsdk:"terminal"`
	Cookie     *HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel `tfsdk:"cookie"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyModelAttrTypes = map[string]attr.Type{
	"header_name": types.StringType,
	"source_ip":   types.BoolType,
	"terminal":    types.BoolType,
	"cookie":      types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel represents cookie block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel struct {
	Name           types.String                `tfsdk:"name"`
	Path           types.String                `tfsdk:"path"`
	TTL            types.Int64                 `tfsdk:"ttl"`
	AddHttponly    *HTTPLoadBalancerEmptyModel `tfsdk:"add_httponly"`
	AddSecure      *HTTPLoadBalancerEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure   *HTTPLoadBalancerEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax    *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone   *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *HTTPLoadBalancerEmptyModel `tfsdk:"samesite_strict"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsSpecificHashPolicyHashPolicyCookieModelAttrTypes = map[string]attr.Type{
	"name":            types.StringType,
	"path":            types.StringType,
	"ttl":             types.Int64Type,
	"add_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel represents waf_exclusion_policy block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWAFExclusionPolicyModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel represents web_socket_config block
type HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel struct {
	UseWebSocket types.Bool `tfsdk:"use_websocket"`
}

// HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModel
var HTTPLoadBalancerRoutesSimpleRouteAdvancedOptionsWebSocketConfigModelAttrTypes = map[string]attr.Type{
	"use_websocket": types.BoolType,
}

// HTTPLoadBalancerRoutesSimpleRouteHeadersModel represents headers block
type HTTPLoadBalancerRoutesSimpleRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesSimpleRouteHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteHeadersModel
var HTTPLoadBalancerRoutesSimpleRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel represents incoming_port block
type HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel struct {
	Port        types.Int64                 `tfsdk:"port"`
	PortRanges  types.String                `tfsdk:"port_ranges"`
	NoPortMatch *HTTPLoadBalancerEmptyModel `tfsdk:"no_port_match"`
}

// HTTPLoadBalancerRoutesSimpleRouteIncomingPortModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteIncomingPortModel
var HTTPLoadBalancerRoutesSimpleRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel represents origin_pools block
type HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel struct {
	Priority        types.Int64                                               `tfsdk:"priority"`
	Weight          types.Int64                                               `tfsdk:"weight"`
	Cluster         *HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *HTTPLoadBalancerEmptyModel                               `tfsdk:"endpoint_subsets"`
	Pool            *HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel    `tfsdk:"pool"`
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModel
var HTTPLoadBalancerRoutesSimpleRouteOriginPoolsModelAttrTypes = map[string]attr.Type{
	"priority":         types.Int64Type,
	"weight":           types.Int64Type,
	"cluster":          types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModelAttrTypes},
	"endpoint_subsets": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pool":             types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModelAttrTypes},
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel represents cluster block
type HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModel
var HTTPLoadBalancerRoutesSimpleRouteOriginPoolsClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel represents pool block
type HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModel
var HTTPLoadBalancerRoutesSimpleRouteOriginPoolsPoolModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRoutePathModel represents path block
type HTTPLoadBalancerRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerRoutesSimpleRoutePathModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRoutePathModel
var HTTPLoadBalancerRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel represents query_params block
type HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel struct {
	ReplaceParams   types.String                `tfsdk:"replace_params"`
	RemoveAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *HTTPLoadBalancerEmptyModel `tfsdk:"retain_all_params"`
}

// HTTPLoadBalancerRoutesSimpleRouteQueryParamsModelAttrTypes defines the attribute types for HTTPLoadBalancerRoutesSimpleRouteQueryParamsModel
var HTTPLoadBalancerRoutesSimpleRouteQueryParamsModelAttrTypes = map[string]attr.Type{
	"replace_params":    types.StringType,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesModel represents sensitive_data_disclosure_rules block
type HTTPLoadBalancerSensitiveDataDisclosureRulesModel struct {
	SensitiveDataTypesInResponse []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel `tfsdk:"sensitive_data_types_in_response"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerSensitiveDataDisclosureRulesModel
var HTTPLoadBalancerSensitiveDataDisclosureRulesModelAttrTypes = map[string]attr.Type{
	"sensitive_data_types_in_response": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModelAttrTypes}},
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel represents sensitive_data_types_in_response block
type HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel struct {
	APIEndpoint *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel `tfsdk:"api_endpoint"`
	Body        *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel        `tfsdk:"body"`
	Mask        *HTTPLoadBalancerEmptyModel                                                               `tfsdk:"mask"`
	Report      *HTTPLoadBalancerEmptyModel                                                               `tfsdk:"report"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModelAttrTypes defines the attribute types for HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel
var HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModelAttrTypes = map[string]attr.Type{
	"api_endpoint": types.ObjectType{AttrTypes: HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModelAttrTypes},
	"body":         types.ObjectType{AttrTypes: HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModelAttrTypes},
	"mask":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"report":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel represents api_endpoint block
type HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel struct {
	Methods types.List   `tfsdk:"methods"`
	Path    types.String `tfsdk:"path"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModelAttrTypes defines the attribute types for HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel
var HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModelAttrTypes = map[string]attr.Type{
	"methods": types.ListType{ElemType: types.StringType},
	"path":    types.StringType,
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel represents body block
type HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel struct {
	Fields types.List `tfsdk:"fields"`
}

// HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModelAttrTypes defines the attribute types for HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel
var HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModelAttrTypes = map[string]attr.Type{
	"fields": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerSensitiveDataPolicyModel represents sensitive_data_policy block
type HTTPLoadBalancerSensitiveDataPolicyModel struct {
	SensitiveDataPolicyRef *HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel `tfsdk:"sensitive_data_policy_ref"`
}

// HTTPLoadBalancerSensitiveDataPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerSensitiveDataPolicyModel
var HTTPLoadBalancerSensitiveDataPolicyModelAttrTypes = map[string]attr.Type{
	"sensitive_data_policy_ref": types.ObjectType{AttrTypes: HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModelAttrTypes},
}

// HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel represents sensitive_data_policy_ref block
type HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModelAttrTypes defines the attribute types for HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModel
var HTTPLoadBalancerSensitiveDataPolicySensitiveDataPolicyRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerSingleLBAppModel represents single_lb_app block
type HTTPLoadBalancerSingleLBAppModel struct {
	DisableDiscovery              *HTTPLoadBalancerEmptyModel                      `tfsdk:"disable_discovery"`
	DisableMaliciousUserDetection *HTTPLoadBalancerEmptyModel                      `tfsdk:"disable_malicious_user_detection"`
	EnableDiscovery               *HTTPLoadBalancerSingleLBAppEnableDiscoveryModel `tfsdk:"enable_discovery"`
	EnableMaliciousUserDetection  *HTTPLoadBalancerEmptyModel                      `tfsdk:"enable_malicious_user_detection"`
}

// HTTPLoadBalancerSingleLBAppModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppModel
var HTTPLoadBalancerSingleLBAppModelAttrTypes = map[string]attr.Type{
	"disable_discovery":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_malicious_user_detection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_discovery":                 types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryModelAttrTypes},
	"enable_malicious_user_detection":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryModel represents enable_discovery block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryModel struct {
	APICrawler                      *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModel               `tfsdk:"api_crawler"`
	APIDiscoveryFromCodeScan        *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModel `tfsdk:"api_discovery_from_code_scan"`
	CustomAPIAuthDiscovery          *HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModel   `tfsdk:"custom_api_auth_discovery"`
	DefaultAPIAuthDiscovery         *HTTPLoadBalancerEmptyModel                                              `tfsdk:"default_api_auth_discovery"`
	DisableLearnFromRedirectTraffic *HTTPLoadBalancerEmptyModel                                              `tfsdk:"disable_learn_from_redirect_traffic"`
	DiscoveredAPISettings           *HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModel    `tfsdk:"discovered_api_settings"`
	EnableLearnFromRedirectTraffic  *HTTPLoadBalancerEmptyModel                                              `tfsdk:"enable_learn_from_redirect_traffic"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryModelAttrTypes = map[string]attr.Type{
	"api_crawler":                         types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModelAttrTypes},
	"api_discovery_from_code_scan":        types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes},
	"custom_api_auth_discovery":           types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModelAttrTypes},
	"default_api_auth_discovery":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_learn_from_redirect_traffic": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"discovered_api_settings":             types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModelAttrTypes},
	"enable_learn_from_redirect_traffic":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModel represents api_crawler block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModel struct {
	APICrawlerConfig  *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel `tfsdk:"api_crawler_config"`
	DisableAPICrawler *HTTPLoadBalancerEmptyModel                                                `tfsdk:"disable_api_crawler"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerModelAttrTypes = map[string]attr.Type{
	"api_crawler_config":  types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes},
	"disable_api_crawler": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel represents api_crawler_config block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel struct {
	Domains []HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel `tfsdk:"domains"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes}},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel represents domains block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel struct {
	Domain      types.String                                                                                 `tfsdk:"domain"`
	SimpleLogin *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel `tfsdk:"simple_login"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsModelAttrTypes = map[string]attr.Type{
	"domain":       types.StringType,
	"simple_login": types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel represents simple_login block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel struct {
	User     types.String                                                                                         `tfsdk:"user"`
	Password *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel `tfsdk:"password"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginModelAttrTypes = map[string]attr.Type{
	"user":     types.StringType,
	"password": types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel represents password block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel struct {
	BlindfoldSecretInfo *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel represents clear_secret_info block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPICrawlerAPICrawlerConfigDomainsSimpleLoginPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModel represents api_discovery_from_code_scan block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModel struct {
	CodeBaseIntegrations []HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel `tfsdk:"code_base_integrations"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanModelAttrTypes = map[string]attr.Type{
	"code_base_integrations": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes}},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel represents code_base_integrations block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel struct {
	AllRepos            *HTTPLoadBalancerEmptyModel                                                                                     `tfsdk:"all_repos"`
	CodeBaseIntegration *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel `tfsdk:"code_base_integration"`
	SelectedRepos       *HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel       `tfsdk:"selected_repos"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsModelAttrTypes = map[string]attr.Type{
	"all_repos":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"code_base_integration": types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes},
	"selected_repos":        types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel represents code_base_integration block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsCodeBaseIntegrationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel represents selected_repos block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel struct {
	APICodeRepo types.List `tfsdk:"api_code_repo"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryAPIDiscoveryFromCodeScanCodeBaseIntegrationsSelectedReposModelAttrTypes = map[string]attr.Type{
	"api_code_repo": types.ListType{ElemType: types.StringType},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModel represents custom_api_auth_discovery block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModel struct {
	APIDiscoveryRef *HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel `tfsdk:"api_discovery_ref"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryModelAttrTypes = map[string]attr.Type{
	"api_discovery_ref": types.ObjectType{AttrTypes: HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes},
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel represents api_discovery_ref block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryCustomAPIAuthDiscoveryAPIDiscoveryRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModel represents discovered_api_settings block
type HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModel struct {
	PurgeDurationForInactiveDiscoveredApis types.Int64 `tfsdk:"purge_duration_for_inactive_discovered_apis"`
}

// HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModelAttrTypes defines the attribute types for HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModel
var HTTPLoadBalancerSingleLBAppEnableDiscoveryDiscoveredAPISettingsModelAttrTypes = map[string]attr.Type{
	"purge_duration_for_inactive_discovered_apis": types.Int64Type,
}

// HTTPLoadBalancerSlowDDOSMitigationModel represents slow_ddos_mitigation block
type HTTPLoadBalancerSlowDDOSMitigationModel struct {
	RequestHeadersTimeout types.Int64                 `tfsdk:"request_headers_timeout"`
	RequestTimeout        types.Int64                 `tfsdk:"request_timeout"`
	DisableRequestTimeout *HTTPLoadBalancerEmptyModel `tfsdk:"disable_request_timeout"`
}

// HTTPLoadBalancerSlowDDOSMitigationModelAttrTypes defines the attribute types for HTTPLoadBalancerSlowDDOSMitigationModel
var HTTPLoadBalancerSlowDDOSMitigationModelAttrTypes = map[string]attr.Type{
	"request_headers_timeout": types.Int64Type,
	"request_timeout":         types.Int64Type,
	"disable_request_timeout": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerTrustedClientsModel represents trusted_clients block
type HTTPLoadBalancerTrustedClientsModel struct {
	Actions             types.List                                     `tfsdk:"actions"`
	AsNumber            types.Int64                                    `tfsdk:"as_number"`
	ExpirationTimestamp types.String                                   `tfsdk:"expiration_timestamp"`
	IPPrefix            types.String                                   `tfsdk:"ip_prefix"`
	Ipv6Prefix          types.String                                   `tfsdk:"ipv6_prefix"`
	UserIdentifier      types.String                                   `tfsdk:"user_identifier"`
	BotSkipProcessing   *HTTPLoadBalancerEmptyModel                    `tfsdk:"bot_skip_processing"`
	HTTPHeader          *HTTPLoadBalancerTrustedClientsHTTPHeaderModel `tfsdk:"http_header"`
	Metadata            *HTTPLoadBalancerTrustedClientsMetadataModel   `tfsdk:"metadata"`
	SkipProcessing      *HTTPLoadBalancerEmptyModel                    `tfsdk:"skip_processing"`
	WAFSkipProcessing   *HTTPLoadBalancerEmptyModel                    `tfsdk:"waf_skip_processing"`
}

// HTTPLoadBalancerTrustedClientsModelAttrTypes defines the attribute types for HTTPLoadBalancerTrustedClientsModel
var HTTPLoadBalancerTrustedClientsModelAttrTypes = map[string]attr.Type{
	"actions":              types.ListType{ElemType: types.StringType},
	"as_number":            types.Int64Type,
	"expiration_timestamp": types.StringType,
	"ip_prefix":            types.StringType,
	"ipv6_prefix":          types.StringType,
	"user_identifier":      types.StringType,
	"bot_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_header":          types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsHTTPHeaderModelAttrTypes},
	"metadata":             types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsMetadataModelAttrTypes},
	"skip_processing":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"waf_skip_processing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerTrustedClientsHTTPHeaderModel represents http_header block
type HTTPLoadBalancerTrustedClientsHTTPHeaderModel struct {
	Headers []HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel `tfsdk:"headers"`
}

// HTTPLoadBalancerTrustedClientsHTTPHeaderModelAttrTypes defines the attribute types for HTTPLoadBalancerTrustedClientsHTTPHeaderModel
var HTTPLoadBalancerTrustedClientsHTTPHeaderModelAttrTypes = map[string]attr.Type{
	"headers": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModelAttrTypes}},
}

// HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel represents headers block
type HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModelAttrTypes defines the attribute types for HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModel
var HTTPLoadBalancerTrustedClientsHTTPHeaderHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// HTTPLoadBalancerTrustedClientsMetadataModel represents metadata block
type HTTPLoadBalancerTrustedClientsMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerTrustedClientsMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerTrustedClientsMetadataModel
var HTTPLoadBalancerTrustedClientsMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerUserIdentificationModel represents user_identification block
type HTTPLoadBalancerUserIdentificationModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerUserIdentificationModelAttrTypes defines the attribute types for HTTPLoadBalancerUserIdentificationModel
var HTTPLoadBalancerUserIdentificationModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// HTTPLoadBalancerWAFExclusionModel represents waf_exclusion block
type HTTPLoadBalancerWAFExclusionModel struct {
	WAFExclusionInlineRules *HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel `tfsdk:"waf_exclusion_inline_rules"`
	WAFExclusionPolicy      *HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel      `tfsdk:"waf_exclusion_policy"`
}

// HTTPLoadBalancerWAFExclusionModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionModel
var HTTPLoadBalancerWAFExclusionModelAttrTypes = map[string]attr.Type{
	"waf_exclusion_inline_rules": types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModelAttrTypes},
	"waf_exclusion_policy":       types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModelAttrTypes},
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel represents waf_exclusion_inline_rules block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel struct {
	Rules []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel `tfsdk:"rules"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesModelAttrTypes = map[string]attr.Type{
	"rules": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModelAttrTypes}},
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel represents rules block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel struct {
	ExactValue                  types.String                                                                              `tfsdk:"exact_value"`
	ExpirationTimestamp         types.String                                                                              `tfsdk:"expiration_timestamp"`
	Methods                     types.List                                                                                `tfsdk:"methods"`
	PathPrefix                  types.String                                                                              `tfsdk:"path_prefix"`
	PathRegex                   types.String                                                                              `tfsdk:"path_regex"`
	SuffixValue                 types.String                                                                              `tfsdk:"suffix_value"`
	AnyDomain                   *HTTPLoadBalancerEmptyModel                                                               `tfsdk:"any_domain"`
	AnyPath                     *HTTPLoadBalancerEmptyModel                                                               `tfsdk:"any_path"`
	AppFirewallDetectionControl *HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel `tfsdk:"app_firewall_detection_control"`
	Metadata                    *HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel                    `tfsdk:"metadata"`
	WAFSkipProcessing           *HTTPLoadBalancerEmptyModel                                                               `tfsdk:"waf_skip_processing"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesModelAttrTypes = map[string]attr.Type{
	"exact_value":                    types.StringType,
	"expiration_timestamp":           types.StringType,
	"methods":                        types.ListType{ElemType: types.StringType},
	"path_prefix":                    types.StringType,
	"path_regex":                     types.StringType,
	"suffix_value":                   types.StringType,
	"any_domain":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_path":                       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"app_firewall_detection_control": types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModelAttrTypes},
	"metadata":                       types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModelAttrTypes},
	"waf_skip_processing":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel represents app_firewall_detection_control block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel struct {
	ExcludeAttackTypeContexts []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel `tfsdk:"exclude_attack_type_contexts"`
	ExcludeBotNameContexts    []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel    `tfsdk:"exclude_bot_name_contexts"`
	ExcludeSignatureContexts  []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel  `tfsdk:"exclude_signature_contexts"`
	ExcludeViolationContexts  []HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel  `tfsdk:"exclude_violation_contexts"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlModelAttrTypes = map[string]attr.Type{
	"exclude_attack_type_contexts": types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModelAttrTypes}},
	"exclude_bot_name_contexts":    types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModelAttrTypes}},
	"exclude_signature_contexts":   types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModelAttrTypes}},
	"exclude_violation_contexts":   types.ListType{ElemType: types.ObjectType{AttrTypes: HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModelAttrTypes}},
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel represents exclude_attack_type_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel struct {
	Context           types.String `tfsdk:"context"`
	ContextName       types.String `tfsdk:"context_name"`
	ExcludeAttackType types.String `tfsdk:"exclude_attack_type"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeAttackTypeContextsModelAttrTypes = map[string]attr.Type{
	"context":             types.StringType,
	"context_name":        types.StringType,
	"exclude_attack_type": types.StringType,
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel represents exclude_bot_name_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel struct {
	BotName types.String `tfsdk:"bot_name"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeBotNameContextsModelAttrTypes = map[string]attr.Type{
	"bot_name": types.StringType,
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel represents exclude_signature_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel struct {
	Context     types.String `tfsdk:"context"`
	ContextName types.String `tfsdk:"context_name"`
	SignatureID types.Int64  `tfsdk:"signature_id"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeSignatureContextsModelAttrTypes = map[string]attr.Type{
	"context":      types.StringType,
	"context_name": types.StringType,
	"signature_id": types.Int64Type,
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel represents exclude_violation_contexts block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel struct {
	Context          types.String `tfsdk:"context"`
	ContextName      types.String `tfsdk:"context_name"`
	ExcludeViolation types.String `tfsdk:"exclude_violation"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesAppFirewallDetectionControlExcludeViolationContextsModelAttrTypes = map[string]attr.Type{
	"context":           types.StringType,
	"context_name":      types.StringType,
	"exclude_violation": types.StringType,
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel represents metadata block
type HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModel
var HTTPLoadBalancerWAFExclusionWAFExclusionInlineRulesRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel represents waf_exclusion_policy block
type HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModelAttrTypes defines the attribute types for HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModel
var HTTPLoadBalancerWAFExclusionWAFExclusionPolicyModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

type HTTPLoadBalancerResourceModel struct {
	Name                          types.String                                       `tfsdk:"name"`
	Namespace                     types.String                                       `tfsdk:"namespace"`
	Annotations                   types.Map                                          `tfsdk:"annotations"`
	Description                   types.String                                       `tfsdk:"description"`
	Disable                       types.Bool                                         `tfsdk:"disable"`
	Domains                       types.List                                         `tfsdk:"domains"`
	Labels                        types.Map                                          `tfsdk:"labels"`
	ID                            types.String                                       `tfsdk:"id"`
	AddLocation                   types.Bool                                         `tfsdk:"add_location"`
	Timeouts                      timeouts.Value                                     `tfsdk:"timeouts"`
	ActiveServicePolicies         *HTTPLoadBalancerActiveServicePoliciesModel        `tfsdk:"active_service_policies"`
	AdvertiseCustom               *HTTPLoadBalancerAdvertiseCustomModel              `tfsdk:"advertise_custom"`
	AdvertiseOnPublic             *HTTPLoadBalancerAdvertiseOnPublicModel            `tfsdk:"advertise_on_public"`
	AdvertiseOnPublicDefaultVIP   *HTTPLoadBalancerEmptyModel                        `tfsdk:"advertise_on_public_default_vip"`
	APIProtectionRules            *HTTPLoadBalancerAPIProtectionRulesModel           `tfsdk:"api_protection_rules"`
	APIRateLimit                  *HTTPLoadBalancerAPIRateLimitModel                 `tfsdk:"api_rate_limit"`
	APISpecification              *HTTPLoadBalancerAPISpecificationModel             `tfsdk:"api_specification"`
	APITesting                    *HTTPLoadBalancerAPITestingModel                   `tfsdk:"api_testing"`
	AppFirewall                   *HTTPLoadBalancerAppFirewallModel                  `tfsdk:"app_firewall"`
	BlockedClients                types.List                                         `tfsdk:"blocked_clients"`
	BotDefense                    *HTTPLoadBalancerBotDefenseModel                   `tfsdk:"bot_defense"`
	BotDefenseAdvanced            *HTTPLoadBalancerBotDefenseAdvancedModel           `tfsdk:"bot_defense_advanced"`
	CachingPolicy                 *HTTPLoadBalancerCachingPolicyModel                `tfsdk:"caching_policy"`
	CaptchaChallenge              *HTTPLoadBalancerCaptchaChallengeModel             `tfsdk:"captcha_challenge"`
	ClientSideDefense             *HTTPLoadBalancerClientSideDefenseModel            `tfsdk:"client_side_defense"`
	CookieStickiness              *HTTPLoadBalancerCookieStickinessModel             `tfsdk:"cookie_stickiness"`
	CORSPolicy                    *HTTPLoadBalancerCORSPolicyModel                   `tfsdk:"cors_policy"`
	CSRFPolicy                    *HTTPLoadBalancerCSRFPolicyModel                   `tfsdk:"csrf_policy"`
	DataGuardRules                types.List                                         `tfsdk:"data_guard_rules"`
	DDOSMitigationRules           types.List                                         `tfsdk:"ddos_mitigation_rules"`
	DefaultPool                   *HTTPLoadBalancerDefaultPoolModel                  `tfsdk:"default_pool"`
	DefaultPoolList               *HTTPLoadBalancerDefaultPoolListModel              `tfsdk:"default_pool_list"`
	DefaultRoutePools             types.List                                         `tfsdk:"default_route_pools"`
	DefaultSensitiveDataPolicy    *HTTPLoadBalancerEmptyModel                        `tfsdk:"default_sensitive_data_policy"`
	DisableAPIDefinition          *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_api_definition"`
	DisableAPIDiscovery           *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_api_discovery"`
	DisableAPITesting             *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_api_testing"`
	DisableBotDefense             *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_bot_defense"`
	DisableCaching                *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_caching"`
	DisableClientSideDefense      *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_client_side_defense"`
	DisableIPReputation           *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_ip_reputation"`
	DisableMaliciousUserDetection *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_malicious_user_detection"`
	DisableMalwareProtection      *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_malware_protection"`
	DisableRateLimit              *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_rate_limit"`
	DisableThreatMesh             *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_threat_mesh"`
	DisableTrustClientIPHeaders   *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_trust_client_ip_headers"`
	DisableWAF                    *HTTPLoadBalancerEmptyModel                        `tfsdk:"disable_waf"`
	DoNotAdvertise                *HTTPLoadBalancerEmptyModel                        `tfsdk:"do_not_advertise"`
	EnableAPIDiscovery            *HTTPLoadBalancerEnableAPIDiscoveryModel           `tfsdk:"enable_api_discovery"`
	EnableChallenge               *HTTPLoadBalancerEnableChallengeModel              `tfsdk:"enable_challenge"`
	EnableIPReputation            *HTTPLoadBalancerEnableIPReputationModel           `tfsdk:"enable_ip_reputation"`
	EnableMaliciousUserDetection  *HTTPLoadBalancerEmptyModel                        `tfsdk:"enable_malicious_user_detection"`
	EnableThreatMesh              *HTTPLoadBalancerEmptyModel                        `tfsdk:"enable_threat_mesh"`
	EnableTrustClientIPHeaders    *HTTPLoadBalancerEnableTrustClientIPHeadersModel   `tfsdk:"enable_trust_client_ip_headers"`
	GraphqlRules                  types.List                                         `tfsdk:"graphql_rules"`
	HTTP                          *HTTPLoadBalancerHTTPModel                         `tfsdk:"http"`
	HTTPS                         *HTTPLoadBalancerHTTPSModel                        `tfsdk:"https"`
	HTTPSAutoCert                 *HTTPLoadBalancerHTTPSAutoCertModel                `tfsdk:"https_auto_cert"`
	JsChallenge                   *HTTPLoadBalancerJsChallengeModel                  `tfsdk:"js_challenge"`
	JWTValidation                 *HTTPLoadBalancerJWTValidationModel                `tfsdk:"jwt_validation"`
	L7DDOSActionBlock             *HTTPLoadBalancerEmptyModel                        `tfsdk:"l7_ddos_action_block"`
	L7DDOSActionDefault           *HTTPLoadBalancerEmptyModel                        `tfsdk:"l7_ddos_action_default"`
	L7DDOSActionJsChallenge       *HTTPLoadBalancerL7DDOSActionJsChallengeModel      `tfsdk:"l7_ddos_action_js_challenge"`
	L7DDOSProtection              *HTTPLoadBalancerL7DDOSProtectionModel             `tfsdk:"l7_ddos_protection"`
	LeastActive                   *HTTPLoadBalancerEmptyModel                        `tfsdk:"least_active"`
	MalwareProtectionSettings     *HTTPLoadBalancerMalwareProtectionSettingsModel    `tfsdk:"malware_protection_settings"`
	MoreOption                    *HTTPLoadBalancerMoreOptionModel                   `tfsdk:"more_option"`
	MultiLBApp                    *HTTPLoadBalancerEmptyModel                        `tfsdk:"multi_lb_app"`
	NoChallenge                   *HTTPLoadBalancerEmptyModel                        `tfsdk:"no_challenge"`
	NoServicePolicies             *HTTPLoadBalancerEmptyModel                        `tfsdk:"no_service_policies"`
	OriginServerSubsetRuleList    *HTTPLoadBalancerOriginServerSubsetRuleListModel   `tfsdk:"origin_server_subset_rule_list"`
	PolicyBasedChallenge          *HTTPLoadBalancerPolicyBasedChallengeModel         `tfsdk:"policy_based_challenge"`
	ProtectedCookies              types.List                                         `tfsdk:"protected_cookies"`
	Random                        *HTTPLoadBalancerEmptyModel                        `tfsdk:"random"`
	RateLimit                     *HTTPLoadBalancerRateLimitModel                    `tfsdk:"rate_limit"`
	RingHash                      *HTTPLoadBalancerRingHashModel                     `tfsdk:"ring_hash"`
	RoundRobin                    *HTTPLoadBalancerEmptyModel                        `tfsdk:"round_robin"`
	Routes                        types.List                                         `tfsdk:"routes"`
	SensitiveDataDisclosureRules  *HTTPLoadBalancerSensitiveDataDisclosureRulesModel `tfsdk:"sensitive_data_disclosure_rules"`
	SensitiveDataPolicy           *HTTPLoadBalancerSensitiveDataPolicyModel          `tfsdk:"sensitive_data_policy"`
	ServicePoliciesFromNamespace  *HTTPLoadBalancerEmptyModel                        `tfsdk:"service_policies_from_namespace"`
	SingleLBApp                   *HTTPLoadBalancerSingleLBAppModel                  `tfsdk:"single_lb_app"`
	SlowDDOSMitigation            *HTTPLoadBalancerSlowDDOSMitigationModel           `tfsdk:"slow_ddos_mitigation"`
	SourceIPStickiness            *HTTPLoadBalancerEmptyModel                        `tfsdk:"source_ip_stickiness"`
	SystemDefaultTimeouts         *HTTPLoadBalancerEmptyModel                        `tfsdk:"system_default_timeouts"`
	TrustedClients                types.List                                         `tfsdk:"trusted_clients"`
	UserIDClientIP                *HTTPLoadBalancerEmptyModel                        `tfsdk:"user_id_client_ip"`
	UserIdentification            *HTTPLoadBalancerUserIdentificationModel           `tfsdk:"user_identification"`
	WAFExclusion                  *HTTPLoadBalancerWAFExclusionModel                 `tfsdk:"waf_exclusion"`
}

func (r *HTTPLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_http_loadbalancer"
}

func (r *HTTPLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             http_loadbalancerSchemaVersion,
		MarkdownDescription: "Manages a HTTP Load Balancer resource in F5 Distributed Cloud for load balancing HTTP/HTTPS traffic with advanced routing and security.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the HTTP Load Balancer. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the HTTP Load Balancer will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "List of Domains (host/authority header) that will be matched to load balancer. Supported Domains and search order: 1. Exact Domain names: www.example.com. 2.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"add_location": schema.BoolAttribute{
				MarkdownDescription: "Add Location. X-example: true Appends header x-F5 Distributed Cloud-location = <RE-site-name> in responses. This configuration is ignored on CE sites.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_service_policies, no_service_policies, service_policies_from_namespace; Default: no_service_policies] Service Policy List. List of service policies.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"policies": schema.ListNestedBlock{
						MarkdownDescription: "Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the correct order (policies evaluated from top to bottom in the list) for service policies, to GET the intended result. For each request, its..",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"advertise_custom": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: advertise_custom, advertise_on_public, advertise_on_public_default_vip, do_not_advertise; Default: advertise_on_public_default_vip] Defines a way to advertise a VIP on specific sites.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"advertise_where": schema.ListNestedBlock{
						MarkdownDescription: "Where should this load balancer be available .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Port to Listen.",
									Optional:            true,
								},
								"port_ranges": schema.StringAttribute{
									MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"advertise_on_public": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"public_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a CE site along with network type and an optional IP address where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"use_default_port": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"virtual_network": schema.SingleNestedBlock{
									MarkdownDescription: "Parameters to advertise on a given virtual network.",
									Attributes: map[string]schema.Attribute{
										"specific_v6_vip": schema.StringAttribute{
											MarkdownDescription: "Use given IPv6 address as VIP on virtual Network.",
											Optional:            true,
										},
										"specific_vip": schema.StringAttribute{
											MarkdownDescription: "Use given IPv4 address as VIP on virtual Network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"default_v6_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"default_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"virtual_site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"virtual_site_with_vip": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type and IP where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_SPECIFIED_VIP_OUTSIDE|SITE_NETWORK_SPECIFIED_VIP_INSIDE] Defines network types to be used on virtual-site with specified VIP All outside networks. All inside networks. Possible values are `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`, `SITE_NETWORK_SPECIFIED_VIP_INSIDE`. Defaults to `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"vk8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"advertise_on_public": schema.SingleNestedBlock{
				MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"advertise_on_public_default_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"api_protection_rules": schema.SingleNestedBlock{
				MarkdownDescription: "API Protection Rules. API Protection Rules.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_endpoint_rules": schema.ListNestedBlock{
						MarkdownDescription: "Category defines specific rules per API endpoints. If request matches any of these rules, skipping second category rules.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_endpoint_path": schema.StringAttribute{
									MarkdownDescription: "The endpoint (path) of the request.",
									Optional:            true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "The rule will apply for a specific domain. For",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"action": schema.SingleNestedBlock{
									MarkdownDescription: "The action to take if the input request matches the rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"allow": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"deny": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"api_endpoint_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional:            true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional:            true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
											Optional:            true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive cookie name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"api_groups_rules": schema.ListNestedBlock{
						MarkdownDescription: "Category includes rules per API group or Server URL. For API groups, refer to API Definition which includes API groups derived from uploaded swaggers.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_group": schema.StringAttribute{
									MarkdownDescription: "API groups derived from API Definition swaggers. For example oas-all-operations including all paths and methods from the swaggers, oas-base-URLs covering all requests under base-paths from the swaggers. Custom groups can be created if user tags paths or operations with 'x-F5 Distributed..",
									Optional:            true,
								},
								"base_path": schema.StringAttribute{
									MarkdownDescription: "Base Path. Prefix of the request path. For example: /v1 .",
									Optional:            true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "The rule will apply for a specific domain. For",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"action": schema.SingleNestedBlock{
									MarkdownDescription: "The action to take if the input request matches the rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"allow": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"deny": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional:            true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
											Optional:            true,
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive cookie name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"api_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_rate_limit, disable_rate_limit, rate_limit; Default: disable_rate_limit] APIRateLimit.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_endpoint_rules": schema.ListNestedBlock{
						MarkdownDescription: "Sets of rules for a specific endpoints. Order is matter as it uses first match policy. For creating rule that contain a whole domain or group of endpoints, please use the server URL rules above.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_endpoint_path": schema.StringAttribute{
									MarkdownDescription: "The endpoint (path) of the request.",
									Optional:            true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "The rule will apply for a specific domain.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"api_endpoint_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional:            true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional:            true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional:            true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "[Enum: SECOND|MINUTE|HOUR] Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive cookie name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"bypass_rate_limiting_rules": schema.SingleNestedBlock{
						MarkdownDescription: "Category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"bypass_rate_limiting_rules": schema.ListNestedBlock{
								MarkdownDescription: "Category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"base_path": schema.StringAttribute{
											MarkdownDescription: "The base path which this validation applies to.",
											Optional:            true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "The rule will apply for a specific domain. For",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_url": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines API endpoint.",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched .",
													Optional:            true,
												},
											},
										},
										"api_groups": schema.SingleNestedBlock{
											MarkdownDescription: "API Groups.",
											Attributes: map[string]schema.Attribute{
												"api_groups": schema.ListAttribute{
													MarkdownDescription: "API Groups. .",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"client_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional:            true,
															ElementType:         types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional:            true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"ip_threat_category_list": schema.SingleNestedBlock{
													MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
													Attributes: map[string]schema.Attribute{
														"ip_threat_categories": schema.ListAttribute{
															MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
										"request_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive cookie name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-insensitive HTTP header name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"jwt_claims": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert the match result.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "JWT Claim Name. JWT claim name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional:            true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive HTTP query parameter name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IP Allowed list using existing ip_prefix_set objects.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"server_url_rules": schema.ListNestedBlock{
						MarkdownDescription: "Set of rules for entire domain or base path that contain multiple endpoints. Order is matter as it uses first match policy. For matching also specific endpoints you can use the API endpoint rules set bellow.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"api_group": schema.StringAttribute{
									MarkdownDescription: "API groups derived from API Definition swaggers. For example oas-all-operations including all paths and methods from the swaggers, oas-base-URLs covering all requests under base-paths from the swaggers. Custom groups can be created if user tags paths or operations with 'x-F5 Distributed..",
									Optional:            true,
								},
								"base_path": schema.StringAttribute{
									MarkdownDescription: "Prefix of the request path.",
									Optional:            true,
								},
								"specific_domain": schema.StringAttribute{
									MarkdownDescription: "The rule will apply for a specific domain.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"any_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"client_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Client Matcher. Client conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_client": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"asn_list": schema.SingleNestedBlock{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Attributes: map[string]schema.Attribute{
												"as_numbers": schema.ListAttribute{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
											},
										},
										"asn_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"asn_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to bgp_asn_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"client_selector": schema.SingleNestedBlock{
											MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
											Attributes: map[string]schema.Attribute{
												"expressions": schema.ListAttribute{
													MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
											Attributes: map[string]schema.Attribute{
												"invert_matcher": schema.BoolAttribute{
													MarkdownDescription: "Invert IP Matcher. Invert the match result.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"prefix_sets": schema.ListNestedBlock{
													MarkdownDescription: "List of references to ip_prefix_set objects.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"kind": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																Optional:            true,
															},
															"namespace": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"tenant": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
															"uid": schema.StringAttribute{
																MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																Optional:            true,
																Computed:            true,
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.UseStateForUnknown(),
																},
															},
														},
													},
												},
											},
										},
										"ip_prefix_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of IP Prefix strings to match against.",
											Attributes: map[string]schema.Attribute{
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert Match Result. Invert the match result.",
													Optional:            true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"ip_threat_category_list": schema.SingleNestedBlock{
											MarkdownDescription: "IP Threat Category List Type. List of IP threat categories.",
											Attributes: map[string]schema.Attribute{
												"ip_threat_categories": schema.ListAttribute{
													MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions . Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"tls_fingerprint_matcher": schema.SingleNestedBlock{
											MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
											Attributes: map[string]schema.Attribute{
												"classes": schema.ListAttribute{
													MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"exact_values": schema.ListAttribute{
													MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"excluded_values": schema.ListAttribute{
													MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"inline_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "InlineRateLimiter.",
									Attributes: map[string]schema.Attribute{
										"threshold": schema.Int64Attribute{
											MarkdownDescription: "The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.",
											Optional:            true,
										},
										"unit": schema.StringAttribute{
											MarkdownDescription: "[Enum: SECOND|MINUTE|HOUR] Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"ref_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"use_http_lb_user_id": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"ref_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"request_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Request Matcher. Request conditions for matching a rule.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cookie_matchers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive cookie name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"jwt_claims": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "JWT Claim Name. JWT claim name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"api_specification": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_specification, disable_api_definition; Default: disable_api_definition] Settings for API specification (API definition, OpenAPI validation, etc.).",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_definition": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"validation_all_spec_endpoints": schema.SingleNestedBlock{
						MarkdownDescription: "API Inventory. Settings for API Inventory validation.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. Swagger) or doesn't have a specific rule in custom rules).",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List. .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "The API group which this validation applies to.",
															Optional:            true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "The base path which this validation applies to.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines API endpoint.",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched .",
																	Optional:            true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional:            true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Custom settings for query parameters validation.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"validation_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. Swagger).",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"response_validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response.",
										Attributes: map[string]schema.Attribute{
											"response_validation_properties": schema.ListAttribute{
												MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the response to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"skip_response_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"validation_mode_active": schema.SingleNestedBlock{
										MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request.",
										Attributes: map[string]schema.Attribute{
											"request_validation_properties": schema.ListAttribute{
												MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the request to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
										Blocks: map[string]schema.Block{
											"enforcement_block": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"enforcement_report": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
								},
							},
						},
					},
					"validation_custom_list": schema.SingleNestedBlock{
						MarkdownDescription: "Define API groups, base paths, or API endpoints and their OpenAPI validation modes. Any other API-endpoint not listed will act according to 'Fall Through Mode'.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"fall_through_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. Swagger) or doesn't have a specific rule in custom rules).",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"fall_through_mode_allow": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"fall_through_mode_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Fall Through Mode. Define the fall through settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"open_api_validation_rules": schema.ListNestedBlock{
												MarkdownDescription: "Custom Fall Through Rule List. .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"api_group": schema.StringAttribute{
															MarkdownDescription: "The API group which this validation applies to.",
															Optional:            true,
														},
														"base_path": schema.StringAttribute{
															MarkdownDescription: "The base path which this validation applies to.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"action_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"action_skip": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"api_endpoint": schema.SingleNestedBlock{
															MarkdownDescription: "API Endpoint. This defines API endpoint.",
															Attributes: map[string]schema.Attribute{
																"methods": schema.ListAttribute{
																	MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"path": schema.StringAttribute{
																	MarkdownDescription: "Path. Path to be matched .",
																	Optional:            true,
																},
															},
														},
														"metadata": schema.SingleNestedBlock{
															MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
															Attributes: map[string]schema.Attribute{
																"description_spec": schema.StringAttribute{
																	MarkdownDescription: "Description. Human readable description.",
																	Optional:            true,
																},
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"open_api_validation_rules": schema.ListNestedBlock{
								MarkdownDescription: "Validation List. .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"api_group": schema.StringAttribute{
											MarkdownDescription: "The API group which this validation applies to.",
											Optional:            true,
										},
										"base_path": schema.StringAttribute{
											MarkdownDescription: "The base path which this validation applies to.",
											Optional:            true,
										},
										"specific_domain": schema.StringAttribute{
											MarkdownDescription: "The rule will apply for a specific domain.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"api_endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "API Endpoint. This defines API endpoint.",
											Attributes: map[string]schema.Attribute{
												"methods": schema.ListAttribute{
													MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to be matched .",
													Optional:            true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"validation_mode": schema.SingleNestedBlock{
											MarkdownDescription: "Validation mode of OpenAPI specification. When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. Swagger).",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"response_validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of response.",
													Attributes: map[string]schema.Attribute{
														"response_validation_properties": schema.ListAttribute{
															MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the response to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"skip_response_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"skip_validation": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"validation_mode_active": schema.SingleNestedBlock{
													MarkdownDescription: "Open API Validation Mode Active. Validation mode properties of request.",
													Attributes: map[string]schema.Attribute{
														"request_validation_properties": schema.ListAttribute{
															MarkdownDescription: "[Enum: PROPERTY_QUERY_PARAMETERS|PROPERTY_PATH_PARAMETERS|PROPERTY_CONTENT_TYPE|PROPERTY_COOKIE_PARAMETERS|PROPERTY_HTTP_HEADERS|PROPERTY_HTTP_BODY|PROPERTY_SECURITY_SCHEMA|PROPERTY_RESPONSE_CODE] List of properties of the request to validate according to the OpenAPI specification file (a.k.a. Swagger) . Possible values are `PROPERTY_QUERY_PARAMETERS`, `PROPERTY_PATH_PARAMETERS`, `PROPERTY_CONTENT_TYPE`, `PROPERTY_COOKIE_PARAMETERS`, `PROPERTY_HTTP_HEADERS`, `PROPERTY_HTTP_BODY`, `PROPERTY_SECURITY_SCHEMA`, `PROPERTY_RESPONSE_CODE`. Defaults to `PROPERTY_QUERY_PARAMETERS`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"enforcement_block": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"enforcement_report": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
											},
										},
									},
								},
							},
							"settings": schema.SingleNestedBlock{
								MarkdownDescription: "OpenAPI specification validation settings relevant for 'API Inventory' enforcement and for 'Custom list' enforcement.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"oversized_body_fail_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"oversized_body_skip_validation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"property_validation_settings_custom": schema.SingleNestedBlock{
										MarkdownDescription: "Validation Property Settings. Custom property validation settings.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"query_parameters": schema.SingleNestedBlock{
												MarkdownDescription: "Custom settings for query parameters validation.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"allow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"disallow_additional_parameters": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
										},
									},
									"property_validation_settings_default": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
						},
					},
					"validation_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"api_testing": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: api_testing, disable_api_testing; Default: disable_api_testing] API Testing.",
				Attributes: map[string]schema.Attribute{
					"custom_header_value": schema.StringAttribute{
						MarkdownDescription: "Add x-F5-API-testing-identifier header value to prevent security flags on API testing traffic.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"domains": schema.ListNestedBlock{
						MarkdownDescription: "Add and configure testing domains and credentials .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"allow_destructive_methods": schema.BoolAttribute{
									MarkdownDescription: "Enable to allow API test to execute destructive methods. Be cautious as these can alter or DELETE data.",
									Optional:            true,
								},
								"domain": schema.StringAttribute{
									MarkdownDescription: "Add your testing environment domain. Be aware that running tests on a production domain can impact live applications, as API testing cannot distinguish between production and testing environments.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"credentials": schema.ListNestedBlock{
									MarkdownDescription: "Add credentials for API testing to use in the selected environment.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"credential_name": schema.StringAttribute{
												MarkdownDescription: "Enter a unique name for the credentials used in API testing .",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"admin": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"api_key": schema.SingleNestedBlock{
												MarkdownDescription: "API Key",
												Attributes: map[string]schema.Attribute{
													"key": schema.StringAttribute{
														MarkdownDescription: "Key.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"value": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
											"basic_auth": schema.SingleNestedBlock{
												MarkdownDescription: "Basic Authentication.",
												Attributes: map[string]schema.Attribute{
													"user": schema.StringAttribute{
														MarkdownDescription: "User.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"password": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
											"bearer_token": schema.SingleNestedBlock{
												MarkdownDescription: "Bearer",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"token": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
											"login_endpoint": schema.SingleNestedBlock{
												MarkdownDescription: "Login Endpoint.",
												Attributes: map[string]schema.Attribute{
													"method": schema.StringAttribute{
														MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
														Optional:            true,
													},
													"path": schema.StringAttribute{
														MarkdownDescription: "Path.",
														Optional:            true,
													},
													"token_response_key": schema.StringAttribute{
														MarkdownDescription: "Specifies how to handle the API response, extracting authentication tokens.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"json_payload": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
											"standard": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
								},
							},
						},
					},
					"every_day": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"every_month": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"every_week": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"app_firewall": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: app_firewall, disable_waf; Default: disable_waf] Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"blocked_clients": schema.ListNestedBlock{
				MarkdownDescription: "Define rules to block IP Prefixes or AS numbers.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "[Enum: SKIP_PROCESSING_WAF|SKIP_PROCESSING_BOT|SKIP_PROCESSING_MUM|SKIP_PROCESSING_IP_REPUTATION|SKIP_PROCESSING_API_PROTECTION|SKIP_PROCESSING_OAS_VALIDATION|SKIP_PROCESSING_DDOS_PROTECTION|SKIP_PROCESSING_THREAT_MESH|SKIP_PROCESSING_MALWARE_PROTECTION] Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "RFC 6793 defined 4-byte AS number.",
							Optional:            true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional:            true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 prefix string.",
							Optional:            true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 prefix string.",
							Optional:            true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "List of HTTP header name and value pairs .",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"bot_defense": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: bot_defense, bot_defense_advanced, disable_bot_defense; Default: disable_bot_defense] Defines various configuration OPTIONS for Bot Defense Policy.",
				Attributes: map[string]schema.Attribute{
					"regional_endpoint": schema.StringAttribute{
						MarkdownDescription: "[Enum: AUTO|US|EU|ASIA] Defines a selection for Bot Defense region - AUTO: AUTO Automatic selection based on client IP address - US: US US region - EU: EU European Union region - ASIA: ASIA Asia region. Possible values are `AUTO`, `US`, `EU`, `ASIA`. Defaults to `AUTO`.",
						Optional:            true,
					},
					"timeout": schema.Int64Attribute{
						MarkdownDescription: "The timeout for the inference check, in milliseconds.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_cors_support": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various configuration OPTIONS for Bot Defense policy.",
						Attributes: map[string]schema.Attribute{
							"javascript_mode": schema.StringAttribute{
								MarkdownDescription: "[Enum: ASYNC_JS_NO_CACHING|ASYNC_JS_CACHING|SYNC_JS_NO_CACHING|SYNC_JS_CACHING] Web Client JavaScript Mode. Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable Bot Defense JavaScript for telemetry collection is requested.. Possible values are `ASYNC_JS_NO_CACHING`, `ASYNC_JS_CACHING`, `SYNC_JS_NO_CACHING`, `SYNC_JS_CACHING`. Defaults to `ASYNC_JS_NO_CACHING`.",
								Optional:            true,
							},
							"js_download_path": schema.StringAttribute{
								MarkdownDescription: "Customize Bot Defense Client JavaScript path. If not specified, default",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_mobile_sdk": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Bot Defense JavaScript in all pages.",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional:            true,
									},
								},
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Bot Defense JavaScript in all pages with the exceptions.",
								Attributes: map[string]schema.Attribute{
									"javascript_location": schema.StringAttribute{
										MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "Defines custom JavaScript insertion rules for Bot Defense Policy.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "Required list of pages to insert Bot Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"javascript_location": schema.StringAttribute{
													MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"mobile_sdk_config": schema.SingleNestedBlock{
								MarkdownDescription: "Mobile SDK Configuration. Mobile SDK configuration.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"mobile_identifier": schema.SingleNestedBlock{
										MarkdownDescription: "Mobile Traffic Identifier. Mobile traffic identifier type.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"headers": schema.ListNestedBlock{
												MarkdownDescription: "Headers that can be used to identify mobile traffic.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Case-insensitive HTTP header name.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"check_not_present": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"check_present": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"item": schema.SingleNestedBlock{
															MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
															Attributes: map[string]schema.Attribute{
																"exact_values": schema.ListAttribute{
																	MarkdownDescription: "List of exact values to match the input against.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"regex_values": schema.ListAttribute{
																	MarkdownDescription: "List of regular expressions to match the input against.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"transformers": schema.ListAttribute{
																	MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"protected_app_endpoints": schema.ListNestedBlock{
								MarkdownDescription: "List of protected endpoints. Limit: Approx '128 endpoints per Load Balancer (LB)' upto 4 LBs, '32 endpoints per LB' after 4 LBs.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"http_methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: METHOD_ANY|METHOD_GET|METHOD_POST|METHOD_PUT|METHOD_PATCH|METHOD_DELETE|METHOD_GET_DOCUMENT] HTTP Methods. List of HTTP methods. Possible values are `METHOD_ANY`, `METHOD_GET`, `METHOD_POST`, `METHOD_PUT`, `METHOD_PATCH`, `METHOD_DELETE`, `METHOD_GET_DOCUMENT`. Defaults to `METHOD_ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"protocol": schema.StringAttribute{
											MarkdownDescription: "[Enum: BOTH|HTTP|HTTPS] SchemeType is used to indicate URL scheme. - BOTH: BOTH URL scheme for HTTPS:// or HTTP://. - HTTP: HTTP URL scheme HTTP:// only. - HTTPS: HTTPS URL scheme HTTPS:// only. Possible values are `BOTH`, `HTTP`, `HTTPS`. Defaults to `BOTH`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"allow_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
										"flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Defense Flow Label Category allows to associate traffic with selected category.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"account_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Account Management Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"password_reset": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"authentication": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Authentication Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"login": schema.SingleNestedBlock{
															MarkdownDescription: "Bot Defense Transaction Result. Bot Defense Transaction Result.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"disable_transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Enable this option",
																},
																"transaction_result": schema.SingleNestedBlock{
																	MarkdownDescription: "Bot Defense Transaction Result Type. Bot Defense Transaction ResultType.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"failure_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Failure Conditions. Failure Conditions.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional:            true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "List of regular expressions to match the input against.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status.. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional:            true,
																					},
																				},
																			},
																		},
																		"success_conditions": schema.ListNestedBlock{
																			MarkdownDescription: "Success Conditions. Success Conditions.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Header Name. A case-insensitive HTTP header name.",
																						Optional:            true,
																					},
																					"regex_values": schema.ListAttribute{
																						MarkdownDescription: "List of regular expressions to match the input against.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"status": schema.StringAttribute{
																						MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status.. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
																						Optional:            true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"login_mfa": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"login_partner": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"logout": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"token_refresh": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"financial_services": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Financial Services Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"apply": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"money_transfer": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"flight": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Flight Category. Bot Defense Flow Label Flight Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"checkin": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"profile_management": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Profile Management Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"create": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"update": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"view": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"search": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Search Category. Bot Defense Flow Label Search Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"flight_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"product_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"reservation_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"room_search": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"shopping_gift_cards": schema.SingleNestedBlock{
													MarkdownDescription: "Bot Defense Flow Label Shopping & Gift Cards Category.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"gift_card_make_purchase_with_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"gift_card_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_add_to_cart": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_checkout": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_choose_seat": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_enter_drawing_submission": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_make_payment": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_order": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_price_inquiry": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_promo_code_validation": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_purchase_gift_card": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
														"shop_update_quantity": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
											},
										},
										"headers": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Header Matcher. Invert the match result.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Case-insensitive HTTP header name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"mitigate_good_bots": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"mitigation": schema.SingleNestedBlock{
											MarkdownDescription: "Modify Bot Defense behavior for a matching request.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"block": schema.SingleNestedBlock{
													MarkdownDescription: "Block request and respond with custom content.",
													Attributes: map[string]schema.Attribute{
														"body": schema.StringAttribute{
															MarkdownDescription: "Custom body message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
															Optional:            true,
														},
														"status": schema.StringAttribute{
															MarkdownDescription: "[Enum: EmptyStatusCode|Continue|OK|Created|Accepted|NonAuthoritativeInformation|NoContent|ResetContent|PartialContent|MultiStatus|AlreadyReported|IMUsed|MultipleChoices|MovedPermanently|Found|SeeOther|NotModified|UseProxy|TemporaryRedirect|PermanentRedirect|BadRequest|Unauthorized|PaymentRequired|Forbidden|NotFound|MethodNotAllowed|NotAcceptable|ProxyAuthenticationRequired|RequestTimeout|Conflict|Gone|LengthRequired|PreconditionFailed|PayloadTooLarge|URITooLong|UnsupportedMediaType|RangeNotSatisfiable|ExpectationFailed|MisdirectedRequest|UnprocessableEntity|Locked|FailedDependency|UpgradeRequired|PreconditionRequired|TooManyRequests|RequestHeaderFieldsTooLarge|InternalServerError|NotImplemented|BadGateway|ServiceUnavailable|GatewayTimeout|HTTPVersionNotSupported|VariantAlsoNegotiates|InsufficientStorage|LoopDetected|NotExtended|NetworkAuthenticationRequired] HTTP response status codes EmptyStatusCode response codes means it is not specified Continue status code OK status code Created status code Accepted status code Non Authoritative Information status code No Content status code Reset Content status code Partial Content status code Multi Status.. Possible values are `EmptyStatusCode`, `Continue`, `OK`, `Created`, `Accepted`, `NonAuthoritativeInformation`, `NoContent`, `ResetContent`, `PartialContent`, `MultiStatus`, `AlreadyReported`, `IMUsed`, `MultipleChoices`, `MovedPermanently`, `Found`, `SeeOther`, `NotModified`, `UseProxy`, `TemporaryRedirect`, `PermanentRedirect`, `BadRequest`, `Unauthorized`, `PaymentRequired`, `Forbidden`, `NotFound`, `MethodNotAllowed`, `NotAcceptable`, `ProxyAuthenticationRequired`, `RequestTimeout`, `Conflict`, `Gone`, `LengthRequired`, `PreconditionFailed`, `PayloadTooLarge`, `URITooLong`, `UnsupportedMediaType`, `RangeNotSatisfiable`, `ExpectationFailed`, `MisdirectedRequest`, `UnprocessableEntity`, `Locked`, `FailedDependency`, `UpgradeRequired`, `PreconditionRequired`, `TooManyRequests`, `RequestHeaderFieldsTooLarge`, `InternalServerError`, `NotImplemented`, `BadGateway`, `ServiceUnavailable`, `GatewayTimeout`, `HTTPVersionNotSupported`, `VariantAlsoNegotiates`, `InsufficientStorage`, `LoopDetected`, `NotExtended`, `NetworkAuthenticationRequired`. Defaults to `EmptyStatusCode`.",
															Optional:            true,
														},
													},
												},
												"flag": schema.SingleNestedBlock{
													MarkdownDescription: "Select Flag Bot Mitigation Action. Flag mitigation action.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"append_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Append flag mitigation headers to forwarded request.",
															Attributes: map[string]schema.Attribute{
																"auto_type_header_name": schema.StringAttribute{
																	MarkdownDescription: "Case-insensitive HTTP header name.",
																	Optional:            true,
																},
																"inference_header_name": schema.StringAttribute{
																	MarkdownDescription: "Case-insensitive HTTP header name.",
																	Optional:            true,
																},
															},
														},
														"no_headers": schema.SingleNestedBlock{
															MarkdownDescription: "Enable this option",
														},
													},
												},
												"redirect": schema.SingleNestedBlock{
													MarkdownDescription: "Redirect bot mitigation. Redirect request to a custom URI.",
													Attributes: map[string]schema.Attribute{
														"uri": schema.StringAttribute{
															MarkdownDescription: "URI location for redirect may be relative or absolute.",
															Optional:            true,
														},
													},
												},
											},
										},
										"mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact path value to match.",
													Optional:            true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
													Optional:            true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
													Optional:            true,
												},
											},
										},
										"query_params": schema.ListNestedBlock{
											MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"invert_matcher": schema.BoolAttribute{
														MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
														Optional:            true,
													},
													"key": schema.StringAttribute{
														MarkdownDescription: "Case-sensitive HTTP query parameter name.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"check_not_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"check_present": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"item": schema.SingleNestedBlock{
														MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
														Attributes: map[string]schema.Attribute{
															"exact_values": schema.ListAttribute{
																MarkdownDescription: "List of exact values to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"regex_values": schema.ListAttribute{
																MarkdownDescription: "List of regular expressions to match the input against.",
																Optional:            true,
																ElementType:         types.StringType,
															},
															"transformers": schema.ListAttribute{
																MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																Optional:            true,
																ElementType:         types.StringType,
															},
														},
													},
												},
											},
										},
										"undefined_flow_label": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"web": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"web_mobile": schema.SingleNestedBlock{
											MarkdownDescription: "Web and Mobile traffic type. Web and Mobile traffic type.",
											Attributes: map[string]schema.Attribute{
												"mobile_identifier": schema.StringAttribute{
													MarkdownDescription: "[Enum: HEADERS] Mobile identifier type - HEADERS: Headers Headers. The only possible value is `HEADERS`. Defaults to `HEADERS`.",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"bot_defense_advanced": schema.SingleNestedBlock{
				MarkdownDescription: "Bot Defense Advanced. Bot Defense Advanced.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_js_insert": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_mobile_sdk": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"js_insert_all_pages": schema.SingleNestedBlock{
						MarkdownDescription: "Insert Bot Defense JavaScript in all pages.",
						Attributes: map[string]schema.Attribute{
							"javascript_location": schema.StringAttribute{
								MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
								Optional:            true,
							},
						},
					},
					"js_insert_all_pages_except": schema.SingleNestedBlock{
						MarkdownDescription: "Insert Bot Defense JavaScript in all pages with the exceptions.",
						Attributes: map[string]schema.Attribute{
							"javascript_location": schema.StringAttribute{
								MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"exclude_list": schema.ListNestedBlock{
								MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact path value to match.",
													Optional:            true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
													Optional:            true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"js_insertion_rules": schema.SingleNestedBlock{
						MarkdownDescription: "Defines custom JavaScript insertion rules for Bot Defense Policy.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"exclude_list": schema.ListNestedBlock{
								MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact path value to match.",
													Optional:            true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
													Optional:            true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
													Optional:            true,
												},
											},
										},
									},
								},
							},
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Required list of pages to insert Bot Defense client JavaScript.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"javascript_location": schema.StringAttribute{
											MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"path": schema.SingleNestedBlock{
											MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
											Attributes: map[string]schema.Attribute{
												"path": schema.StringAttribute{
													MarkdownDescription: "Exact path value to match.",
													Optional:            true,
												},
												"prefix": schema.StringAttribute{
													MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
													Optional:            true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"mobile": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"mobile_sdk_config": schema.SingleNestedBlock{
						MarkdownDescription: "Mobile Request Identifier Headers. Mobile Request Identifier Headers.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"mobile_identifier": schema.SingleNestedBlock{
								MarkdownDescription: "Mobile Traffic Identifier. Mobile traffic identifier type.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"headers": schema.ListNestedBlock{
										MarkdownDescription: "Headers that can be used to identify mobile traffic.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Case-insensitive HTTP header name.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"check_not_present": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"check_present": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"item": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact values to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"web": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"caching_policy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: caching_policy, disable_caching; Default: disable_caching] Caching Policies. Caching Policies for the CDN.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"custom_cache_rule": schema.SingleNestedBlock{
						MarkdownDescription: "Custom Cache Rules. Caching policies for CDN.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"cdn_cache_rules": schema.ListNestedBlock{
								MarkdownDescription: "Reference to CDN Cache Rule configuration object.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"default_cache_action": schema.SingleNestedBlock{
						MarkdownDescription: "Default Cache Behaviour. This defines a Default Cache Action.",
						Attributes: map[string]schema.Attribute{
							"cache_ttl_default": schema.StringAttribute{
								MarkdownDescription: "Use Cache TTL Provided by Origin, and set a contigency TTL value in case one is not provided.",
								Optional:            true,
							},
							"cache_ttl_override": schema.StringAttribute{
								MarkdownDescription: "Always override the Cahce TTL provided by Origin.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"cache_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"captcha_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: captcha_challenge, enable_challenge, js_challenge, no_challenge, policy_based_challenge; Default: no_challenge] Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional:            true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
						Optional:            true,
					},
				},
			},
			"client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: client_side_defense, disable_client_side_defense; Default: disable_client_side_defense] Defines various configuration OPTIONS for Client-Side Defense Policy.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various configuration OPTIONS for Client-Side Defense policy.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable_js_insert": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"js_insert_all_pages": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"js_insert_all_pages_except": schema.SingleNestedBlock{
								MarkdownDescription: "Insert Client-Side Defense JavaScript in all pages with the exceptions.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"js_insertion_rules": schema.SingleNestedBlock{
								MarkdownDescription: "Defines custom JavaScript insertion rules for Client-Side Defense Policy.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"exclude_list": schema.ListNestedBlock{
										MarkdownDescription: "Optional JavaScript insertions exclude list of domain and path matchers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
									"rules": schema.ListNestedBlock{
										MarkdownDescription: "Required list of pages to insert Client-Side Defense client JavaScript.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"any_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain": schema.SingleNestedBlock{
													MarkdownDescription: "Domains. Domains names.",
													Attributes: map[string]schema.Attribute{
														"exact_value": schema.StringAttribute{
															MarkdownDescription: "Exact domain name.",
															Optional:            true,
														},
														"regex_value": schema.StringAttribute{
															MarkdownDescription: "Regular Expression value for the domain name.",
															Optional:            true,
														},
														"suffix_value": schema.StringAttribute{
															MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
															Optional:            true,
														},
													},
												},
												"metadata": schema.SingleNestedBlock{
													MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
													Attributes: map[string]schema.Attribute{
														"description_spec": schema.StringAttribute{
															MarkdownDescription: "Description. Human readable description.",
															Optional:            true,
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
															Optional:            true,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
													Attributes: map[string]schema.Attribute{
														"path": schema.StringAttribute{
															MarkdownDescription: "Exact path value to match.",
															Optional:            true,
														},
														"prefix": schema.StringAttribute{
															MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
															Optional:            true,
														},
														"regex": schema.StringAttribute{
															MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"cookie_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: cookie_stickiness, least_active, random, ring_hash, round_robin, source_ip_stickiness; Default: round_robin] Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets..",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced .",
						Optional:            true,
					},
					"path": schema.StringAttribute{
						MarkdownDescription: "The name of the path for the cookie. If no path is specified here, no path will be set for the cookie.",
						Optional:            true,
					},
					"ttl": schema.Int64Attribute{
						MarkdownDescription: "If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"add_httponly": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"add_secure": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"ignore_httponly": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"ignore_samesite": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"ignore_secure": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"samesite_lax": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"samesite_none": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"samesite_strict": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"cors_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel MAC OS X 10.5..",
				Attributes: map[string]schema.Attribute{
					"allow_credentials": schema.BoolAttribute{
						MarkdownDescription: "Specifies whether the resource allows credentials.",
						Optional:            true,
					},
					"allow_headers": schema.StringAttribute{
						MarkdownDescription: "Specifies the content for the access-control-allow-headers header.",
						Optional:            true,
					},
					"allow_methods": schema.StringAttribute{
						MarkdownDescription: "Specifies the content for the access-control-allow-methods header.",
						Optional:            true,
					},
					"allow_origin": schema.ListAttribute{
						MarkdownDescription: "Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"allow_origin_regex": schema.ListAttribute{
						MarkdownDescription: "Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"disabled": schema.BoolAttribute{
						MarkdownDescription: "Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
						Optional:            true,
					},
					"expose_headers": schema.StringAttribute{
						MarkdownDescription: "Specifies the content for the access-control-expose-headers header.",
						Optional:            true,
					},
					"maximum_age": schema.Int64Attribute{
						MarkdownDescription: "Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours).",
						Optional:            true,
					},
				},
			},
			"csrf_policy": schema.SingleNestedBlock{
				MarkdownDescription: "To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.the policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to..",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"all_load_balancer_domains": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"custom_domain_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of domain names used for Host header matching.",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "List of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"data_guard_rules": schema.ListNestedBlock{
				MarkdownDescription: "Data Guard prevents responses from exposing sensitive information by masking the data. The system masks credit card numbers and social security numbers leaked from the application from within the HTTP response with a string of asterisks (*).",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact domain name.",
							Optional:            true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"apply_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"path": schema.SingleNestedBlock{
							MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
							Attributes: map[string]schema.Attribute{
								"path": schema.StringAttribute{
									MarkdownDescription: "Exact path value to match.",
									Optional:            true,
								},
								"prefix": schema.StringAttribute{
									MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
									Optional:            true,
								},
								"regex": schema.StringAttribute{
									MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
									Optional:            true,
								},
							},
						},
						"skip_data_guard": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"ddos_mitigation_rules": schema.ListNestedBlock{
				MarkdownDescription: "Define manual mitigation rules to block L7 DDoS attacks.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"block": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ddos_client_source": schema.SingleNestedBlock{
							MarkdownDescription: "DDoS Client Source Choice. DDoS Mitigation sources to be blocked.",
							Attributes: map[string]schema.Attribute{
								"country_list": schema.ListAttribute{
									MarkdownDescription: "[Enum: COUNTRY_NONE|COUNTRY_AD|COUNTRY_AE|COUNTRY_AF|COUNTRY_AG|COUNTRY_AI|COUNTRY_AL|COUNTRY_AM|COUNTRY_AN|COUNTRY_AO|COUNTRY_AQ|COUNTRY_AR|COUNTRY_AS|COUNTRY_AT|COUNTRY_AU|COUNTRY_AW|COUNTRY_AX|COUNTRY_AZ|COUNTRY_BA|COUNTRY_BB|COUNTRY_BD|COUNTRY_BE|COUNTRY_BF|COUNTRY_BG|COUNTRY_BH|COUNTRY_BI|COUNTRY_BJ|COUNTRY_BL|COUNTRY_BM|COUNTRY_BN|COUNTRY_BO|COUNTRY_BQ|COUNTRY_BR|COUNTRY_BS|COUNTRY_BT|COUNTRY_BV|COUNTRY_BW|COUNTRY_BY|COUNTRY_BZ|COUNTRY_CA|COUNTRY_CC|COUNTRY_CD|COUNTRY_CF|COUNTRY_CG|COUNTRY_CH|COUNTRY_CI|COUNTRY_CK|COUNTRY_CL|COUNTRY_CM|COUNTRY_CN|COUNTRY_CO|COUNTRY_CR|COUNTRY_CS|COUNTRY_CU|COUNTRY_CV|COUNTRY_CW|COUNTRY_CX|COUNTRY_CY|COUNTRY_CZ|COUNTRY_DE|COUNTRY_DJ|COUNTRY_DK|COUNTRY_DM|COUNTRY_DO|COUNTRY_DZ|COUNTRY_EC|COUNTRY_EE|COUNTRY_EG|COUNTRY_EH|COUNTRY_ER|COUNTRY_ES|COUNTRY_ET|COUNTRY_FI|COUNTRY_FJ|COUNTRY_FK|COUNTRY_FM|COUNTRY_FO|COUNTRY_FR|COUNTRY_GA|COUNTRY_GB|COUNTRY_GD|COUNTRY_GE|COUNTRY_GF|COUNTRY_GG|COUNTRY_GH|COUNTRY_GI|COUNTRY_GL|COUNTRY_GM|COUNTRY_GN|COUNTRY_GP|COUNTRY_GQ|COUNTRY_GR|COUNTRY_GS|COUNTRY_GT|COUNTRY_GU|COUNTRY_GW|COUNTRY_GY|COUNTRY_HK|COUNTRY_HM|COUNTRY_HN|COUNTRY_HR|COUNTRY_HT|COUNTRY_HU|COUNTRY_ID|COUNTRY_IE|COUNTRY_IL|COUNTRY_IM|COUNTRY_IN|COUNTRY_IO|COUNTRY_IQ|COUNTRY_IR|COUNTRY_IS|COUNTRY_IT|COUNTRY_JE|COUNTRY_JM|COUNTRY_JO|COUNTRY_JP|COUNTRY_KE|COUNTRY_KG|COUNTRY_KH|COUNTRY_KI|COUNTRY_KM|COUNTRY_KN|COUNTRY_KP|COUNTRY_KR|COUNTRY_KW|COUNTRY_KY|COUNTRY_KZ|COUNTRY_LA|COUNTRY_LB|COUNTRY_LC|COUNTRY_LI|COUNTRY_LK|COUNTRY_LR|COUNTRY_LS|COUNTRY_LT|COUNTRY_LU|COUNTRY_LV|COUNTRY_LY|COUNTRY_MA|COUNTRY_MC|COUNTRY_MD|COUNTRY_ME|COUNTRY_MF|COUNTRY_MG|COUNTRY_MH|COUNTRY_MK|COUNTRY_ML|COUNTRY_MM|COUNTRY_MN|COUNTRY_MO|COUNTRY_MP|COUNTRY_MQ|COUNTRY_MR|COUNTRY_MS|COUNTRY_MT|COUNTRY_MU|COUNTRY_MV|COUNTRY_MW|COUNTRY_MX|COUNTRY_MY|COUNTRY_MZ|COUNTRY_NA|COUNTRY_NC|COUNTRY_NE|COUNTRY_NF|COUNTRY_NG|COUNTRY_NI|COUNTRY_NL|COUNTRY_NO|COUNTRY_NP|COUNTRY_NR|COUNTRY_NU|COUNTRY_NZ|COUNTRY_OM|COUNTRY_PA|COUNTRY_PE|COUNTRY_PF|COUNTRY_PG|COUNTRY_PH|COUNTRY_PK|COUNTRY_PL|COUNTRY_PM|COUNTRY_PN|COUNTRY_PR|COUNTRY_PS|COUNTRY_PT|COUNTRY_PW|COUNTRY_PY|COUNTRY_QA|COUNTRY_RE|COUNTRY_RO|COUNTRY_RS|COUNTRY_RU|COUNTRY_RW|COUNTRY_SA|COUNTRY_SB|COUNTRY_SC|COUNTRY_SD|COUNTRY_SE|COUNTRY_SG|COUNTRY_SH|COUNTRY_SI|COUNTRY_SJ|COUNTRY_SK|COUNTRY_SL|COUNTRY_SM|COUNTRY_SN|COUNTRY_SO|COUNTRY_SR|COUNTRY_SS|COUNTRY_ST|COUNTRY_SV|COUNTRY_SX|COUNTRY_SY|COUNTRY_SZ|COUNTRY_TC|COUNTRY_TD|COUNTRY_TF|COUNTRY_TG|COUNTRY_TH|COUNTRY_TJ|COUNTRY_TK|COUNTRY_TL|COUNTRY_TM|COUNTRY_TN|COUNTRY_TO|COUNTRY_TR|COUNTRY_TT|COUNTRY_TV|COUNTRY_TW|COUNTRY_TZ|COUNTRY_UA|COUNTRY_UG|COUNTRY_UM|COUNTRY_US|COUNTRY_UY|COUNTRY_UZ|COUNTRY_VA|COUNTRY_VC|COUNTRY_VE|COUNTRY_VG|COUNTRY_VI|COUNTRY_VN|COUNTRY_VU|COUNTRY_WF|COUNTRY_WS|COUNTRY_XK|COUNTRY_XT|COUNTRY_YE|COUNTRY_YT|COUNTRY_ZA|COUNTRY_ZM|COUNTRY_ZW] Sources that are located in one of the countries in the given list. Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
									Optional:            true,
									ElementType:         types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional:            true,
											ElementType:         types.Int64Type,
										},
									},
								},
								"ja4_tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Extended version of JA3 that includes additional fields for more comprehensive fingerprinting of SSL/TLS clients and potentially has a different structure and length.",
									Attributes: map[string]schema.Attribute{
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "List of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"tls_fingerprint_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
									Attributes: map[string]schema.Attribute{
										"classes": schema.ListAttribute{
											MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"excluded_values": schema.ListAttribute{
											MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
							},
						},
						"ip_prefix_list": schema.SingleNestedBlock{
							MarkdownDescription: "List of IP Prefix strings to match against.",
							Attributes: map[string]schema.Attribute{
								"invert_match": schema.BoolAttribute{
									MarkdownDescription: "Invert Match Result. Invert the match result.",
									Optional:            true,
								},
								"ip_prefixes": schema.ListAttribute{
									MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
									Optional:            true,
									ElementType:         types.StringType,
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
					},
				},
			},
			"default_pool": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_pool, default_pool_list; Default: default_pool] Global Specification. Shape of the origin pool specification.",
				Attributes: map[string]schema.Attribute{
					"endpoint_selection": schema.StringAttribute{
						MarkdownDescription: "[Enum: DISTRIBUTED|LOCAL_ONLY|LOCAL_PREFERRED] Policy for selection of endpoints from local site/remote site/both Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing Enable this policy to load balance ONLY among locally discovered endpoints Prefer the local endpoints for.. Possible values are `DISTRIBUTED`, `LOCAL_ONLY`, `LOCAL_PREFERRED`. Defaults to `DISTRIBUTED`.",
						Optional:            true,
					},
					"health_check_port": schema.Int64Attribute{
						MarkdownDescription: "Port used for performing health check.",
						Optional:            true,
					},
					"loadbalancer_algorithm": schema.StringAttribute{
						MarkdownDescription: "[Enum: ROUND_ROBIN|LEAST_REQUEST|RING_HASH|RANDOM|LB_OVERRIDE] Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load balancer uses loadbalancer_algorithm to determine which host is selected. - ROUND_ROBIN: ROUND_ROBIN Policy in which each healthy/available upstream endpoint is selected in.. Possible values are `ROUND_ROBIN`, `LEAST_REQUEST`, `RING_HASH`, `RANDOM`, `LB_OVERRIDE`. Defaults to `ROUND_ROBIN`.",
						Optional:            true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "Endpoint service is available on this port.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advanced_options": schema.SingleNestedBlock{
						MarkdownDescription: "Configure Advanced OPTIONS for origin pool.",
						Attributes: map[string]schema.Attribute{
							"connection_timeout": schema.Int64Attribute{
								MarkdownDescription: "The timeout for new network connections to endpoints in the cluster. This is specified in milliseconds. The  seconds. Defaults to `2`.",
								Optional:            true,
							},
							"http_idle_timeout": schema.Int64Attribute{
								MarkdownDescription: "The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
								Optional:            true,
							},
							"panic_threshold": schema.Int64Attribute{
								MarkdownDescription: "Configure a threshold (percentage of unhealthy endpoints) below which all endpoints will be considered for load balancing ignoring its health status.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"auto_http_config": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"circuit_breaker": schema.SingleNestedBlock{
								MarkdownDescription: "CircuitBreaker provides a mechanism for watching failures in upstream connections or requests and if the failures reach a certain threshold, automatically fail subsequent requests which allows to apply back pressure on downstream quickly.",
								Attributes: map[string]schema.Attribute{
									"connection_limit": schema.Int64Attribute{
										MarkdownDescription: "The maximum number of connections that loadbalancer will establish to all hosts in an upstream cluster. In practice this is only applicable to TCP and HTTP/1.1 clusters since HTTP/2 uses a single connection to each host. Remove endpoint out of load balancing decision, if number of connections..",
										Optional:            true,
									},
									"max_requests": schema.Int64Attribute{
										MarkdownDescription: "The maximum number of requests that can be outstanding to all hosts in a cluster at any given time. In practice this is applicable to HTTP/2 clusters since HTTP/1.1 clusters are governed by the maximum connections (connection_limit). Remove endpoint out of load balancing decision, if requests..",
										Optional:            true,
									},
									"pending_requests": schema.Int64Attribute{
										MarkdownDescription: "The maximum number of requests that will be queued while waiting for a ready connection pool connection. Since HTTP/2 requests are sent over a single connection, this circuit breaker only comes into play as the initial connection is created, as requests will be multiplexed immediately..",
										Optional:            true,
									},
									"priority": schema.StringAttribute{
										MarkdownDescription: "[Enum: DEFAULT|HIGH] Priority routing for each request. Different connection pools are used based on the priority selected for the request. Also, circuit-breaker configuration at destination cluster is chosen based on selected priority. Possible values are `DEFAULT`, `HIGH`. Defaults to `DEFAULT`.",
										Optional:            true,
									},
									"retries": schema.Int64Attribute{
										MarkdownDescription: "The maximum number of retries that can be outstanding to all hosts in a cluster at any given time. Remove endpoint out of load balancing decision, if retries for request exceed this count.",
										Optional:            true,
									},
								},
							},
							"default_circuit_breaker": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_circuit_breaker": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_lb_source_ip_persistance": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_outlier_detection": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_proxy_protocol": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_subsets": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_lb_source_ip_persistance": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_subsets": schema.SingleNestedBlock{
								MarkdownDescription: "Configure subset OPTIONS for origin pool.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"any_endpoint": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"default_subset": schema.SingleNestedBlock{
										MarkdownDescription: "Origin Pool Default Subset. Default Subset definition.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"default_subset": schema.SingleNestedBlock{
												MarkdownDescription: "List of key-value pairs that define default subset. Which gets used when route specifies no metadata or no subset matching the metadata exists.",
											},
										},
									},
									"endpoint_subsets": schema.ListNestedBlock{
										MarkdownDescription: "List of subset class. Subsets class is defined using list of keys. Every unique combination of values of these keys form a subset withing the class.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"keys": schema.ListAttribute{
													MarkdownDescription: "List of keys that define a cluster subset class.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
									"fail_request": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"http1_config": schema.SingleNestedBlock{
								MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for upstream connections.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"default_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"legacy_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"preserve_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"proper_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
								},
							},
							"http2_options": schema.SingleNestedBlock{
								MarkdownDescription: "Http2 Protocol OPTIONS for upstream connections.",
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										MarkdownDescription: "Enable/disable HTTP2 Protocol for upstream connections.",
										Optional:            true,
									},
								},
							},
							"no_panic_threshold": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"outlier_detection": schema.SingleNestedBlock{
								MarkdownDescription: "Outlier detection and ejection is the process of dynamically determining whether some number of hosts in an upstream cluster are performing unlike the others and removing them from the healthy load balancing set. Outlier detection is a form of passive health checking. Algorithm 1.",
								Attributes: map[string]schema.Attribute{
									"base_ejection_time": schema.Int64Attribute{
										MarkdownDescription: "The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the host has been ejected. This causes hosts to GET ejected for longer periods if they continue to fail.",
										Optional:            true,
									},
									"consecutive_5xx": schema.Int64Attribute{
										MarkdownDescription: "If an upstream endpoint returns some number of consecutive 5xx, it will be ejected. Note that in this case a 5xx means an actual 5xx respond code, or an event that would cause the HTTP router to return one on the upstreams behalf(reset, connection failure, etc.) consecutive_5xx indicates the..",
										Optional:            true,
									},
									"consecutive_gateway_failure": schema.Int64Attribute{
										MarkdownDescription: "If an upstream endpoint returns some number of consecutive gateway errors (502, 503 or 504 status code), it will be ejected. Note that this includes events that would cause the HTTP router to return one of these status codes on the upstreams behalf (reset, connection failure, etc.)..",
										Optional:            true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "The time interval between ejection analysis sweeps. This can result in both new ejections as well as endpoints being returned to service. Defaults to `10000ms`.",
										Optional:            true,
									},
									"max_ejection_percent": schema.Int64Attribute{
										MarkdownDescription: "The maximum % of an upstream cluster that can be ejected due to outlier detection.  but will eject at least one host regardless of the value. Defaults to `10%`.",
										Optional:            true,
									},
								},
							},
							"proxy_protocol_v1": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"proxy_protocol_v2": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"automatic_port": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"healthcheck": schema.ListNestedBlock{
						MarkdownDescription: "Reference to healthcheck configuration objects.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
					"lb_port": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_tls": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"origin_servers": schema.ListNestedBlock{
						MarkdownDescription: "List of origin servers in this pool .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"cbip_service": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with Classic BIG-IP Service (Virtual Server).",
									Attributes: map[string]schema.Attribute{
										"service_name": schema.StringAttribute{
											MarkdownDescription: "Name of the discovered Classic BIG-IP virtual server to be used as origin.",
											Optional:            true,
										},
									},
								},
								"consul_service": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with Hashi Corp Consul service name and site information.",
									Attributes: map[string]schema.Attribute{
										"service_name": schema.StringAttribute{
											MarkdownDescription: "Consul service name of this origin server will be listed, including cluster-ID. The format is servicename:cluster-ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Message defines a reference to a site or virtual site object.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
								"custom_endpoint_object": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with a reference to endpoint object.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"endpoint": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"k8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with K8s service name and site information.",
									Attributes: map[string]schema.Attribute{
										"protocol": schema.StringAttribute{
											MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP - PROTOCOL_UDP: UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
											Optional:            true,
										},
										"service_name": schema.StringAttribute{
											MarkdownDescription: "K8s service name of the origin server will be listed, including the namespace and cluster-ID. For vK8s services, you need to enter a string with the format servicename.namespace:cluster-ID. If the servicename is 'frontend', namespace is 'speedtest' and cluster-ID is 'prod'..",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Message defines a reference to a site or virtual site object.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
										"vk8s_networks": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"labels": schema.SingleNestedBlock{
									MarkdownDescription: "Add Labels for this origin server, these labels can be used to form subset.",
								},
								"private_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with private or public IP address and site information.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IP. Private IPv4 address.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"segment": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Message defines a reference to a site or virtual site object.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
								"private_name": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with private or public DNS name and site information.",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name .",
											Optional:            true,
										},
										"refresh_interval": schema.Int64Attribute{
											MarkdownDescription: "Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/HTML/rfc8767.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"inside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"outside_network": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"segment": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"site_locator": schema.SingleNestedBlock{
											MarkdownDescription: "Message defines a reference to a site or virtual site object.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"no_snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"snat_pool": schema.SingleNestedBlock{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Attributes: map[string]schema.Attribute{
														"prefixes": schema.ListAttribute{
															MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
								"public_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with public IP address.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Public IPv4. Public IPv4 address.",
											Optional:            true,
										},
									},
								},
								"public_name": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with public DNS name.",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name .",
											Optional:            true,
										},
										"refresh_interval": schema.Int64Attribute{
											MarkdownDescription: "Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/HTML/rfc8767.",
											Optional:            true,
										},
									},
								},
								"vn_private_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with IP on Virtual Network.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IPv4. IPv4 address.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"vn_private_name": schema.SingleNestedBlock{
									MarkdownDescription: "Specify origin server with DNS name on Virtual Network.",
									Attributes: map[string]schema.Attribute{
										"dns_name": schema.StringAttribute{
											MarkdownDescription: "DNS Name. DNS Name .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"private_network": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"same_as_endpoint_port": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"upstream_conn_pool_reuse_type": schema.SingleNestedBlock{
						MarkdownDescription: "Select upstream connection pool reuse state for every downstream connection. This configuration choice is for HTTP(S) LB only.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"disable_conn_pool_reuse": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_conn_pool_reuse": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"use_tls": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters for Origin Servers. Upstream TLS Parameters.",
						Attributes: map[string]schema.Attribute{
							"max_session_keys": schema.Int64Attribute{
								MarkdownDescription: "Number of session keys that are cached.",
								Optional:            true,
							},
							"sni": schema.StringAttribute{
								MarkdownDescription: "SNI value to be used.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"default_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_session_key_caching": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"skip_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_host_header_as_sni": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "MTLS Certificate. MTLS Client Certificate.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "MTLS Client Certificate. MTLS Client Certificate .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional:            true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies the hash algorithms to be used.",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
									},
								},
							},
							"use_mtls_obj": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"use_server_verification": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Validation Context for Origin Servers. Upstream TLS Validation Context.",
								Attributes: map[string]schema.Attribute{
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Origin Pool for verification of server's certificate.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
								},
							},
							"volterra_trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"view_internal": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"default_pool_list": schema.SingleNestedBlock{
				MarkdownDescription: "Origin Pool List Type. List of Origin Pools.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"pools": schema.ListNestedBlock{
						MarkdownDescription: "Origin Pools. List of Origin Pools.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"priority": schema.Int64Attribute{
									MarkdownDescription: "Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the..",
									Optional:            true,
								},
								"weight": schema.Int64Attribute{
									MarkdownDescription: "Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"cluster": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"endpoint_subsets": schema.SingleNestedBlock{
									MarkdownDescription: "Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8s or Consul..",
								},
								"pool": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"default_route_pools": schema.ListNestedBlock{
				MarkdownDescription: "Origin Pools used when no route is specified (default route).",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"priority": schema.Int64Attribute{
							MarkdownDescription: "Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the..",
							Optional:            true,
						},
						"weight": schema.Int64Attribute{
							MarkdownDescription: "Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"cluster": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
						"endpoint_subsets": schema.SingleNestedBlock{
							MarkdownDescription: "Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8s or Consul..",
						},
						"pool": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"default_sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_sensitive_data_policy, sensitive_data_policy; Default: default_sensitive_data_policy] Enable this option",
			},
			"disable_api_definition": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_api_discovery, enable_api_discovery; Default: disable_api_discovery] Enable this option",
			},
			"disable_api_testing": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_bot_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_caching": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_client_side_defense": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ip_reputation, enable_ip_reputation; Default: disable_ip_reputation] Enable this option",
			},
			"disable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_malicious_user_detection, enable_malicious_user_detection; Default: disable_malicious_user_detection] Enable this option",
			},
			"disable_malware_protection": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_malware_protection, malware_protection_settings; Default: disable_malware_protection] Enable this option",
			},
			"disable_rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"disable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_threat_mesh, enable_threat_mesh; Default: disable_threat_mesh] Enable this option",
			},
			"disable_trust_client_ip_headers": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_trust_client_ip_headers, enable_trust_client_ip_headers; Default: disable_trust_client_ip_headers] Enable this option",
			},
			"disable_waf": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"do_not_advertise": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"enable_api_discovery": schema.SingleNestedBlock{
				MarkdownDescription: "Specifies the settings used for API discovery.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"api_crawler": schema.SingleNestedBlock{
						MarkdownDescription: "API Crawling. API Crawler message.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"api_crawler_config": schema.SingleNestedBlock{
								MarkdownDescription: "Crawler Configure.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"domains": schema.ListNestedBlock{
										MarkdownDescription: "Enter domains and their credentials to allow authenticated API crawling. You can only include domains you own that are associated with this Load Balancer.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"domain": schema.StringAttribute{
													MarkdownDescription: "Select the domain to execute API Crawling with given credentials.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"simple_login": schema.SingleNestedBlock{
													MarkdownDescription: "Simple Login.",
													Attributes: map[string]schema.Attribute{
														"user": schema.StringAttribute{
															MarkdownDescription: "Enter the username to assign credentials for the selected domain to crawl.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"password": schema.SingleNestedBlock{
															MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"blindfold_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																	Attributes: map[string]schema.Attribute{
																		"decryption_provider": schema.StringAttribute{
																			MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																			Optional:            true,
																		},
																		"location": schema.StringAttribute{
																			MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																			Optional:            true,
																		},
																		"store_provider": schema.StringAttribute{
																			MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																	},
																},
																"clear_secret_info": schema.SingleNestedBlock{
																	MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																	Attributes: map[string]schema.Attribute{
																		"provider_ref": schema.StringAttribute{
																			MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																			Optional:            true,
																		},
																		"url": schema.StringAttribute{
																			MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"disable_api_crawler": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"api_discovery_from_code_scan": schema.SingleNestedBlock{
						MarkdownDescription: "Select Code Base and Repositories.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"code_base_integrations": schema.ListNestedBlock{
								MarkdownDescription: "Select Code Base Integrations. .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"all_repos": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"code_base_integration": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"selected_repos": schema.SingleNestedBlock{
											MarkdownDescription: "Select which API repositories represent the LB applications.",
											Attributes: map[string]schema.Attribute{
												"api_code_repo": schema.ListAttribute{
													MarkdownDescription: "Code repository which contain API endpoints .",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "API Discovery Advanced Settings. API Discovery Advanced settings.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"api_discovery_ref": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
						},
					},
					"default_api_auth_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"discovered_api_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Discovered API Settings. Configure Discovered API Settings.",
						Attributes: map[string]schema.Attribute{
							"purge_duration_for_inactive_discovered_apis": schema.Int64Attribute{
								MarkdownDescription: "Inactive discovered API will be deleted after configured duration.",
								Optional:            true,
							},
						},
					},
					"enable_learn_from_redirect_traffic": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"enable_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Configure auto mitigation i.e risk based challenges for malicious users.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
								Optional:            true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"enable_ip_reputation": schema.SingleNestedBlock{
				MarkdownDescription: "IP Threat Category List. List of IP threat categories.",
				Attributes: map[string]schema.Attribute{
					"ip_threat_categories": schema.ListAttribute{
						MarkdownDescription: "[Enum: SPAM_SOURCES|WINDOWS_EXPLOITS|WEB_ATTACKS|BOTNETS|SCANNERS|REPUTATION|PHISHING|PROXY|MOBILE_THREATS|TOR_PROXY|DENIAL_OF_SERVICE|NETWORK] If the source IP matches on atleast one of the enabled IP threat categories, the request will be denied. Possible values are `SPAM_SOURCES`, `WINDOWS_EXPLOITS`, `WEB_ATTACKS`, `BOTNETS`, `SCANNERS`, `REPUTATION`, `PHISHING`, `PROXY`, `MOBILE_THREATS`, `TOR_PROXY`, `DENIAL_OF_SERVICE`, `NETWORK`. Defaults to `SPAM_SOURCES`.",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
			},
			"enable_malicious_user_detection": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"enable_threat_mesh": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"enable_trust_client_ip_headers": schema.SingleNestedBlock{
				MarkdownDescription: "Trust Client IP Headers List. List of Client IP Headers.",
				Attributes: map[string]schema.Attribute{
					"client_ip_headers": schema.ListAttribute{
						MarkdownDescription: "Define the list of one or more Client IP Headers. Headers will be used in order from top to bottom, meaning if the first header is not present in the request, the system will proceed to check for the second header, and so on, until one of the listed headers is found. If none of the defined..",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
			},
			"graphql_rules": schema.ListNestedBlock{
				MarkdownDescription: "GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it easier to evolve APIs over time, and enables powerful developer tools. Policy..",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"exact_path": schema.StringAttribute{
							MarkdownDescription: "Specifies the exact path to GraphQL endpoint. Defaults to `/graphql`.",
							Optional:            true,
						},
						"exact_value": schema.StringAttribute{
							MarkdownDescription: "Exact domain name.",
							Optional:            true,
						},
						"suffix_value": schema.StringAttribute{
							MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"any_domain": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"graphql_settings": schema.SingleNestedBlock{
							MarkdownDescription: "GraphQL Settings. GraphQL configuration.",
							Attributes: map[string]schema.Attribute{
								"max_batched_queries": schema.Int64Attribute{
									MarkdownDescription: "Specify maximum number of queries in a single batched request.",
									Optional:            true,
								},
								"max_depth": schema.Int64Attribute{
									MarkdownDescription: "Specify maximum depth for the GraphQL query.",
									Optional:            true,
								},
								"max_total_length": schema.Int64Attribute{
									MarkdownDescription: "Specify maximum length in bytes for the GraphQL query.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"disable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"enable_introspection": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"method_get": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"method_post": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"http": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: http, https, https_auto_cert; Default: https_auto_cert] HTTP Choice. Choice for selecting HTTP proxy.",
				Attributes: map[string]schema.Attribute{
					"dns_volterra_managed": schema.BoolAttribute{
						MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
						Optional:            true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTP port to Listen.",
						Optional:            true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional:            true,
					},
				},
			},
			"https": schema.SingleNestedBlock{
				MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
						Optional:            true,
					},
					"append_server_name": schema.StringAttribute{
						MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
						Optional:            true,
					},
					"connection_idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
						Optional:            true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
						Optional:            true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS port to Listen.",
						Optional:            true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional:            true,
					},
					"server_name": schema.StringAttribute{
						MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"coalescing_options": schema.SingleNestedBlock{
						MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"default_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"strict_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"default_header": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"http_protocol_options": schema.SingleNestedBlock{
						MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"http_protocol_enable_v1_only": schema.SingleNestedBlock{
								MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"default_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"legacy_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"preserve_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"proper_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
								},
							},
							"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"http_protocol_enable_v2_only": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"non_default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"pass_through": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"tls_cert_params": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"certificates": schema.ListNestedBlock{
								MarkdownDescription: "Select one or more certificates with any domain names.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"tls_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"https_auto_cert": schema.SingleNestedBlock{
				MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
				Attributes: map[string]schema.Attribute{
					"add_hsts": schema.BoolAttribute{
						MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
						Optional:            true,
					},
					"append_server_name": schema.StringAttribute{
						MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
						Optional:            true,
					},
					"connection_idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
						Optional:            true,
					},
					"http_redirect": schema.BoolAttribute{
						MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
						Optional:            true,
					},
					"port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS port to Listen.",
						Optional:            true,
					},
					"port_ranges": schema.StringAttribute{
						MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
						Optional:            true,
					},
					"server_name": schema.StringAttribute{
						MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"coalescing_options": schema.SingleNestedBlock{
						MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"default_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"strict_coalescing": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"default_header": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"http_protocol_options": schema.SingleNestedBlock{
						MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"http_protocol_enable_v1_only": schema.SingleNestedBlock{
								MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"default_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"legacy_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"preserve_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"proper_case_header_transformation": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
								},
							},
							"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"http_protocol_enable_v2_only": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"no_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"non_default_loadbalancer": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"pass_through": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_security": schema.SingleNestedBlock{
								MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
								Attributes: map[string]schema.Attribute{
									"cipher_suites": schema.ListAttribute{
										MarkdownDescription: "The TLS listener will only support the specified cipher list.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"max_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
									"min_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
								},
							},
							"default_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"low_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"medium_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"use_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Validation context for downstream client TLS connections.",
						Attributes: map[string]schema.Attribute{
							"client_certificate_optional": schema.BoolAttribute{
								MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
								Optional:            true,
							},
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"crl": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"no_crl": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"xfcc_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"xfcc_options": schema.SingleNestedBlock{
								MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
								Attributes: map[string]schema.Attribute{
									"xfcc_header_elements": schema.ListAttribute{
										MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
				},
			},
			"js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional:            true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
						Optional:            true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
						Optional:            true,
					},
				},
			},
			"jwt_validation": schema.SingleNestedBlock{
				MarkdownDescription: "JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming JWTs before they are passed to your API origin. JWT Validation will also stop requests with expired tokens or tokens that are not yet valid.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"action": schema.SingleNestedBlock{
						MarkdownDescription: "Action",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"block": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"report": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"jwks_config": schema.SingleNestedBlock{
						MarkdownDescription: "The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
						Attributes: map[string]schema.Attribute{
							"cleartext": schema.StringAttribute{
								MarkdownDescription: "The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
								Optional:            true,
							},
						},
					},
					"mandatory_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Configurable Validation of mandatory Claims.",
						Attributes: map[string]schema.Attribute{
							"claim_names": schema.ListAttribute{
								MarkdownDescription: "Claim Names. Human-readable name for the resource",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"reserved_claims": schema.SingleNestedBlock{
						MarkdownDescription: "Configurable Validation of reserved Claims.",
						Attributes: map[string]schema.Attribute{
							"issuer": schema.StringAttribute{
								MarkdownDescription: "Exact Match.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"audience": schema.SingleNestedBlock{
								MarkdownDescription: "Audiences",
								Attributes: map[string]schema.Attribute{
									"audiences": schema.ListAttribute{
										MarkdownDescription: "Values.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"audience_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"issuer_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"validate_period_disable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"validate_period_enable": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"target": schema.SingleNestedBlock{
						MarkdownDescription: "Define endpoints for which JWT token validation will be performed.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"all_endpoint": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"api_groups": schema.SingleNestedBlock{
								MarkdownDescription: "API Groups.",
								Attributes: map[string]schema.Attribute{
									"api_groups": schema.ListAttribute{
										MarkdownDescription: "API Groups. .",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"base_paths": schema.SingleNestedBlock{
								MarkdownDescription: "Base Paths.",
								Attributes: map[string]schema.Attribute{
									"base_paths": schema.ListAttribute{
										MarkdownDescription: "Prefix Values. .",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
					"token_location": schema.SingleNestedBlock{
						MarkdownDescription: "Token Location. Location of JWT in HTTP request.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"bearer_token": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"l7_ddos_action_block": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: l7_ddos_action_block, l7_ddos_action_default, l7_ddos_action_js_challenge; Default: l7_ddos_action_default] Enable this option",
			},
			"l7_ddos_action_default": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"l7_ddos_action_js_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
				Attributes: map[string]schema.Attribute{
					"cookie_expiry": schema.Int64Attribute{
						MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
						Optional:            true,
					},
					"custom_page": schema.StringAttribute{
						MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
						Optional:            true,
					},
					"js_script_delay": schema.Int64Attribute{
						MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
						Optional:            true,
					},
				},
			},
			"l7_ddos_protection": schema.SingleNestedBlock{
				MarkdownDescription: "L7 DDoS protection is critical for safeguarding web applications, APIs, and services that are exposed to the internet from sophisticated, volumetric, application-level threats. Configure actions, thresholds and policies to apply during L7 DDoS attack.",
				Attributes: map[string]schema.Attribute{
					"rps_threshold": schema.Int64Attribute{
						MarkdownDescription: "Configure custom RPS threshold.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"clientside_action_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
						},
					},
					"clientside_action_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
								Optional:            true,
							},
						},
					},
					"clientside_action_none": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"ddos_policy_custom": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"ddos_policy_none": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_rps_threshold": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"mitigation_block": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"mitigation_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
						},
					},
					"mitigation_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
								Optional:            true,
							},
						},
					},
				},
			},
			"least_active": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"malware_protection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Malware Protection protects Web Apps and APIs, from malicious file uploads by scanning files in real-time.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"malware_protection_rules": schema.ListNestedBlock{
						MarkdownDescription: "Configure the match criteria to trigger Malware Protection Scan .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"http_methods": schema.ListAttribute{
									MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] HTTP Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional:            true,
									ElementType:         types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"action": schema.SingleNestedBlock{
									MarkdownDescription: "Action",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"block": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"report": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"domain": schema.SingleNestedBlock{
									MarkdownDescription: "Domain to Match. Domain to be matched.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
											Optional:            true,
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact path value to match.",
											Optional:            true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
											Optional:            true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
			"more_option": schema.SingleNestedBlock{
				MarkdownDescription: "Defines various OPTIONS to define a route.",
				Attributes: map[string]schema.Attribute{
					"disable_default_error_pages": schema.BoolAttribute{
						MarkdownDescription: "Disable the use of default F5XC error pages.",
						Optional:            true,
					},
					"idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "The amount of time that a stream can exist without upstream or downstream activity, in milliseconds. The stream is terminated with a HTTP 504 (Gateway Timeout) error code if no upstream response header has been received, otherwise the stream is reset.",
						Optional:            true,
					},
					"max_request_header_size": schema.Int64Attribute{
						MarkdownDescription: "The maximum request header size for downstream connections, in KiB. A HTTP 431 (Request Header Fields Too Large) error code is sent for requests that exceed this size. If multiple load balancers share the same advertise_policy, the highest value configured across all such load balancers is used..",
						Optional:            true,
					},
					"request_cookies_to_remove": schema.ListAttribute{
						MarkdownDescription: "List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"request_headers_to_remove": schema.ListAttribute{
						MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"response_cookies_to_remove": schema.ListAttribute{
						MarkdownDescription: "List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"response_headers_to_remove": schema.ListAttribute{
						MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
				Blocks: map[string]schema.Block{
					"buffer_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config.",
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								MarkdownDescription: "Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
								Optional:            true,
							},
							"max_request_bytes": schema.Int64Attribute{
								MarkdownDescription: "The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
								Optional:            true,
							},
						},
					},
					"compression_params": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to compress dispatched data from an upstream service upon client request. The content is compressed and then sent to the client with the appropriate headers if either response and request allow. Only GZIP compression is supported.",
						Attributes: map[string]schema.Attribute{
							"content_length": schema.Int64Attribute{
								MarkdownDescription: "Minimum response length, in bytes, which will trigger compression. The. Defaults to `30`.",
								Optional:            true,
							},
							"content_type": schema.ListAttribute{
								MarkdownDescription: "Set of strings that allows specifying which mime-types yield compression When this field is not defined, compression will be applied to the following mime-types: 'application/javascript' 'application/JSON', 'application/xhtml+XML' 'image/svg+XML' 'text/CSS' 'text/HTML' 'text/plain' 'text/XML'.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"disable_on_etag_header": schema.BoolAttribute{
								MarkdownDescription: "If true, disables compression when the response contains an etag header. When it is false, weak etags will be preserved and the ones that require strong validation will be removed.",
								Optional:            true,
							},
							"remove_accept_encoding_header": schema.BoolAttribute{
								MarkdownDescription: "If true, removes accept-encoding from the request headers before dispatching it to the upstream so that responses do not GET compressed before reaching the filter.",
								Optional:            true,
							},
						},
					},
					"custom_errors": schema.SingleNestedBlock{
						MarkdownDescription: "Map of integer error codes as keys and string values that can be used to provide custom HTTP pages for each error code. Key of the map can be either response code class or HTTP Error code. Response code classes for key is configured as follows 3 -- for 3xx response code class 4 -- for 4xx..",
					},
					"disable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_path_normalize": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"request_cookies_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the cookie in Cookie header.",
									Optional:            true,
								},
								"overwrite": schema.BoolAttribute{
									MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
									Optional:            true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value of the Cookie header.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional:            true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
													Optional:            true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"request_headers_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"append": schema.BoolAttribute{
									MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the HTTP header.",
									Optional:            true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value of the HTTP header.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional:            true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
													Optional:            true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"response_cookies_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"add_domain": schema.StringAttribute{
									MarkdownDescription: "Add domain attribute.",
									Optional:            true,
								},
								"add_expiry": schema.StringAttribute{
									MarkdownDescription: "Add expiry attribute.",
									Optional:            true,
								},
								"add_path": schema.StringAttribute{
									MarkdownDescription: "Add path attribute.",
									Optional:            true,
								},
								"max_age_value": schema.Int64Attribute{
									MarkdownDescription: "Add max age attribute.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the cookie in Cookie header.",
									Optional:            true,
								},
								"overwrite": schema.BoolAttribute{
									MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
									Optional:            true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value of the Cookie header.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"add_httponly": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"add_partitioned": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"add_secure": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_domain": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_expiry": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_httponly": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_max_age": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_partitioned": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_path": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_samesite": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_secure": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ignore_value": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"samesite_lax": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"samesite_none": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"samesite_strict": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional:            true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
													Optional:            true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"response_headers_to_add": schema.ListNestedBlock{
						MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"append": schema.BoolAttribute{
									MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the HTTP header.",
									Optional:            true,
								},
								"value": schema.StringAttribute{
									MarkdownDescription: "Value of the HTTP header.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"secret_value": schema.SingleNestedBlock{
									MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"blindfold_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
											Attributes: map[string]schema.Attribute{
												"decryption_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
													Optional:            true,
												},
												"location": schema.StringAttribute{
													MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
													Optional:            true,
												},
												"store_provider": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
											},
										},
										"clear_secret_info": schema.SingleNestedBlock{
											MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
											Attributes: map[string]schema.Attribute{
												"provider_ref": schema.StringAttribute{
													MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
													Optional:            true,
												},
												"url": schema.StringAttribute{
													MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"multi_lb_app": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: multi_lb_app, single_lb_app] Enable this option",
			},
			"no_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"origin_server_subset_rule_list": schema.SingleNestedBlock{
				MarkdownDescription: "Origin Server Subset Rule List Type. List of Origin Pools.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"origin_server_subset_rules": schema.ListNestedBlock{
						MarkdownDescription: "Origin Server Subset Rules allow users to define match condition on Client (IP address, ASN, Country), IP Reputation, Regional Edge names, Request for subset selection of origin servers. Origin Server Subset is a sequential engine where rules are evaluated one after the other. It's important to..",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"country_codes": schema.ListAttribute{
									MarkdownDescription: "[Enum: COUNTRY_NONE|COUNTRY_AD|COUNTRY_AE|COUNTRY_AF|COUNTRY_AG|COUNTRY_AI|COUNTRY_AL|COUNTRY_AM|COUNTRY_AN|COUNTRY_AO|COUNTRY_AQ|COUNTRY_AR|COUNTRY_AS|COUNTRY_AT|COUNTRY_AU|COUNTRY_AW|COUNTRY_AX|COUNTRY_AZ|COUNTRY_BA|COUNTRY_BB|COUNTRY_BD|COUNTRY_BE|COUNTRY_BF|COUNTRY_BG|COUNTRY_BH|COUNTRY_BI|COUNTRY_BJ|COUNTRY_BL|COUNTRY_BM|COUNTRY_BN|COUNTRY_BO|COUNTRY_BQ|COUNTRY_BR|COUNTRY_BS|COUNTRY_BT|COUNTRY_BV|COUNTRY_BW|COUNTRY_BY|COUNTRY_BZ|COUNTRY_CA|COUNTRY_CC|COUNTRY_CD|COUNTRY_CF|COUNTRY_CG|COUNTRY_CH|COUNTRY_CI|COUNTRY_CK|COUNTRY_CL|COUNTRY_CM|COUNTRY_CN|COUNTRY_CO|COUNTRY_CR|COUNTRY_CS|COUNTRY_CU|COUNTRY_CV|COUNTRY_CW|COUNTRY_CX|COUNTRY_CY|COUNTRY_CZ|COUNTRY_DE|COUNTRY_DJ|COUNTRY_DK|COUNTRY_DM|COUNTRY_DO|COUNTRY_DZ|COUNTRY_EC|COUNTRY_EE|COUNTRY_EG|COUNTRY_EH|COUNTRY_ER|COUNTRY_ES|COUNTRY_ET|COUNTRY_FI|COUNTRY_FJ|COUNTRY_FK|COUNTRY_FM|COUNTRY_FO|COUNTRY_FR|COUNTRY_GA|COUNTRY_GB|COUNTRY_GD|COUNTRY_GE|COUNTRY_GF|COUNTRY_GG|COUNTRY_GH|COUNTRY_GI|COUNTRY_GL|COUNTRY_GM|COUNTRY_GN|COUNTRY_GP|COUNTRY_GQ|COUNTRY_GR|COUNTRY_GS|COUNTRY_GT|COUNTRY_GU|COUNTRY_GW|COUNTRY_GY|COUNTRY_HK|COUNTRY_HM|COUNTRY_HN|COUNTRY_HR|COUNTRY_HT|COUNTRY_HU|COUNTRY_ID|COUNTRY_IE|COUNTRY_IL|COUNTRY_IM|COUNTRY_IN|COUNTRY_IO|COUNTRY_IQ|COUNTRY_IR|COUNTRY_IS|COUNTRY_IT|COUNTRY_JE|COUNTRY_JM|COUNTRY_JO|COUNTRY_JP|COUNTRY_KE|COUNTRY_KG|COUNTRY_KH|COUNTRY_KI|COUNTRY_KM|COUNTRY_KN|COUNTRY_KP|COUNTRY_KR|COUNTRY_KW|COUNTRY_KY|COUNTRY_KZ|COUNTRY_LA|COUNTRY_LB|COUNTRY_LC|COUNTRY_LI|COUNTRY_LK|COUNTRY_LR|COUNTRY_LS|COUNTRY_LT|COUNTRY_LU|COUNTRY_LV|COUNTRY_LY|COUNTRY_MA|COUNTRY_MC|COUNTRY_MD|COUNTRY_ME|COUNTRY_MF|COUNTRY_MG|COUNTRY_MH|COUNTRY_MK|COUNTRY_ML|COUNTRY_MM|COUNTRY_MN|COUNTRY_MO|COUNTRY_MP|COUNTRY_MQ|COUNTRY_MR|COUNTRY_MS|COUNTRY_MT|COUNTRY_MU|COUNTRY_MV|COUNTRY_MW|COUNTRY_MX|COUNTRY_MY|COUNTRY_MZ|COUNTRY_NA|COUNTRY_NC|COUNTRY_NE|COUNTRY_NF|COUNTRY_NG|COUNTRY_NI|COUNTRY_NL|COUNTRY_NO|COUNTRY_NP|COUNTRY_NR|COUNTRY_NU|COUNTRY_NZ|COUNTRY_OM|COUNTRY_PA|COUNTRY_PE|COUNTRY_PF|COUNTRY_PG|COUNTRY_PH|COUNTRY_PK|COUNTRY_PL|COUNTRY_PM|COUNTRY_PN|COUNTRY_PR|COUNTRY_PS|COUNTRY_PT|COUNTRY_PW|COUNTRY_PY|COUNTRY_QA|COUNTRY_RE|COUNTRY_RO|COUNTRY_RS|COUNTRY_RU|COUNTRY_RW|COUNTRY_SA|COUNTRY_SB|COUNTRY_SC|COUNTRY_SD|COUNTRY_SE|COUNTRY_SG|COUNTRY_SH|COUNTRY_SI|COUNTRY_SJ|COUNTRY_SK|COUNTRY_SL|COUNTRY_SM|COUNTRY_SN|COUNTRY_SO|COUNTRY_SR|COUNTRY_SS|COUNTRY_ST|COUNTRY_SV|COUNTRY_SX|COUNTRY_SY|COUNTRY_SZ|COUNTRY_TC|COUNTRY_TD|COUNTRY_TF|COUNTRY_TG|COUNTRY_TH|COUNTRY_TJ|COUNTRY_TK|COUNTRY_TL|COUNTRY_TM|COUNTRY_TN|COUNTRY_TO|COUNTRY_TR|COUNTRY_TT|COUNTRY_TV|COUNTRY_TW|COUNTRY_TZ|COUNTRY_UA|COUNTRY_UG|COUNTRY_UM|COUNTRY_US|COUNTRY_UY|COUNTRY_UZ|COUNTRY_VA|COUNTRY_VC|COUNTRY_VE|COUNTRY_VG|COUNTRY_VI|COUNTRY_VN|COUNTRY_VU|COUNTRY_WF|COUNTRY_WS|COUNTRY_XK|COUNTRY_XT|COUNTRY_YE|COUNTRY_YT|COUNTRY_ZA|COUNTRY_ZM|COUNTRY_ZW] Country Codes List. List of Country Codes. Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"re_name_list": schema.ListAttribute{
									MarkdownDescription: "RE Names. List of RE names for match.",
									Optional:            true,
									ElementType:         types.StringType,
								},
							},
							Blocks: map[string]schema.Block{
								"any_asn": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"any_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional:            true,
											ElementType:         types.Int64Type,
										},
									},
								},
								"asn_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"asn_sets": schema.ListNestedBlock{
											MarkdownDescription: "List of references to bgp_asn_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
									},
								},
								"client_selector": schema.SingleNestedBlock{
									MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
									Attributes: map[string]schema.Attribute{
										"expressions": schema.ListAttribute{
											MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"ip_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert IP Matcher. Invert the match result.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"prefix_sets": schema.ListNestedBlock{
											MarkdownDescription: "List of references to ip_prefix_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
									},
								},
								"ip_prefix_list": schema.SingleNestedBlock{
									MarkdownDescription: "List of IP Prefix strings to match against.",
									Attributes: map[string]schema.Attribute{
										"invert_match": schema.BoolAttribute{
											MarkdownDescription: "Invert Match Result. Invert the match result.",
											Optional:            true,
										},
										"ip_prefixes": schema.ListAttribute{
											MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"metadata": schema.SingleNestedBlock{
									MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
									Attributes: map[string]schema.Attribute{
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Human readable description.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
											Optional:            true,
										},
									},
								},
								"none": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"origin_server_subsets_action": schema.SingleNestedBlock{
									MarkdownDescription: "Add labels to select one or more origin servers.",
								},
							},
						},
					},
				},
			},
			"policy_based_challenge": schema.SingleNestedBlock{
				MarkdownDescription: "Specifies the settings for policy rule based challenge.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"always_enable_captcha_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"always_enable_js_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform captcha challenge Captcha challenge will be based on Google Recaptcha. With this feature enabled, only clients that pass the captcha challenge will be allowed to complete the HTTP request. When loadbalancer is configured to do Captcha Challenge, it will redirect..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
						},
					},
					"default_captcha_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_mitigation_settings": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_temporary_blocking_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"js_challenge_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Enables loadbalancer to perform client browser compatibility test by redirecting to a page with Javascript. With this feature enabled, only clients that are capable of executing Javascript(mostly browsers) will be allowed to complete the HTTP request. When loadbalancer is configured to do..",
						Attributes: map[string]schema.Attribute{
							"cookie_expiry": schema.Int64Attribute{
								MarkdownDescription: "Cookie expiration period, in seconds. An expired cookie causes the loadbalancer to issue a new challenge.",
								Optional:            true,
							},
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type uri_ref. Currently supported URL schemes is string:///. For string:/// scheme, message needs to be encoded in Base64 format.",
								Optional:            true,
							},
							"js_script_delay": schema.Int64Attribute{
								MarkdownDescription: "Delay introduced by Javascript, in milliseconds.",
								Optional:            true,
							},
						},
					},
					"malicious_user_mitigation": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"no_challenge": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"rule_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of challenge rules to be used in policy based challenge.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Rules that specify the match conditions and challenge type to be launched. When a challenge type is selected to be always enabled, these rules can be used to disable challenge or launch a different challenge for requests that match the specified conditions.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"spec": schema.SingleNestedBlock{
											MarkdownDescription: "Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from or derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that..",
											Attributes: map[string]schema.Attribute{
												"expiration_timestamp": schema.StringAttribute{
													MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"any_asn": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"any_client": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"any_ip": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"arg_matchers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive JSON path in the HTTP request body.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"asn_list": schema.SingleNestedBlock{
													MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
													Attributes: map[string]schema.Attribute{
														"as_numbers": schema.ListAttribute{
															MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
															Optional:            true,
															ElementType:         types.Int64Type,
														},
													},
												},
												"asn_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"asn_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to bgp_asn_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"body_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact values to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"client_selector": schema.SingleNestedBlock{
													MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
													Attributes: map[string]schema.Attribute{
														"expressions": schema.ListAttribute{
															MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"cookie_matchers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Matcher. Invert Match of the expression defined.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive cookie name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"disable_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"domain_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact values to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"enable_captcha_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"enable_javascript_challenge": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"headers": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Header Matcher. Invert the match result.",
																Optional:            true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Case-insensitive HTTP header name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"http_method": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Method Matcher. Invert the match result.",
															Optional:            true,
														},
														"methods": schema.ListAttribute{
															MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"ip_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
													Attributes: map[string]schema.Attribute{
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert IP Matcher. Invert the match result.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"prefix_sets": schema.ListNestedBlock{
															MarkdownDescription: "List of references to ip_prefix_set objects.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
													},
												},
												"ip_prefix_list": schema.SingleNestedBlock{
													MarkdownDescription: "List of IP Prefix strings to match against.",
													Attributes: map[string]schema.Attribute{
														"invert_match": schema.BoolAttribute{
															MarkdownDescription: "Invert Match Result. Invert the match result.",
															Optional:            true,
														},
														"ip_prefixes": schema.ListAttribute{
															MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"path": schema.SingleNestedBlock{
													MarkdownDescription: "Path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
													Attributes: map[string]schema.Attribute{
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact path values to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"invert_matcher": schema.BoolAttribute{
															MarkdownDescription: "Invert Path Matcher. Invert the match result.",
															Optional:            true,
														},
														"prefix_values": schema.ListAttribute{
															MarkdownDescription: "List of path prefix values to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"regex_values": schema.ListAttribute{
															MarkdownDescription: "List of regular expressions to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"suffix_values": schema.ListAttribute{
															MarkdownDescription: "List of path suffix values to match the input HTTP path against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"transformers": schema.ListAttribute{
															MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"query_params": schema.ListNestedBlock{
													MarkdownDescription: "List of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query..",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"invert_matcher": schema.BoolAttribute{
																MarkdownDescription: "Invert Query Parameter Matcher. Invert the match result.",
																Optional:            true,
															},
															"key": schema.StringAttribute{
																MarkdownDescription: "Case-sensitive HTTP query parameter name.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"check_not_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"check_present": schema.SingleNestedBlock{
																MarkdownDescription: "Enable this option",
															},
															"item": schema.SingleNestedBlock{
																MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
																Attributes: map[string]schema.Attribute{
																	"exact_values": schema.ListAttribute{
																		MarkdownDescription: "List of exact values to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"regex_values": schema.ListAttribute{
																		MarkdownDescription: "List of regular expressions to match the input against.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																	"transformers": schema.ListAttribute{
																		MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
																		Optional:            true,
																		ElementType:         types.StringType,
																	},
																},
															},
														},
													},
												},
												"tls_fingerprint_matcher": schema.SingleNestedBlock{
													MarkdownDescription: "TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied..",
													Attributes: map[string]schema.Attribute{
														"classes": schema.ListAttribute{
															MarkdownDescription: "[Enum: TLS_FINGERPRINT_NONE|ANY_MALICIOUS_FINGERPRINT|ADWARE|ADWIND|DRIDEX|GOOTKIT|GOZI|JBIFROST|QUAKBOT|RANSOMWARE|TROLDESH|TOFSEE|TORRENTLOCKER|TRICKBOT] List of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against. Possible values are `TLS_FINGERPRINT_NONE`, `ANY_MALICIOUS_FINGERPRINT`, `ADWARE`, `ADWIND`, `DRIDEX`, `GOOTKIT`, `GOZI`, `JBIFROST`, `QUAKBOT`, `RANSOMWARE`, `TROLDESH`, `TOFSEE`, `TORRENTLOCKER`, `TRICKBOT`. Defaults to `TLS_FINGERPRINT_NONE`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"exact_values": schema.ListAttribute{
															MarkdownDescription: "List of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"excluded_values": schema.ListAttribute{
															MarkdownDescription: "List of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one or more known TLS fingerprint classes in the enclosing matcher.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"temporary_user_blocking": schema.SingleNestedBlock{
						MarkdownDescription: "Specifies configuration for temporary user blocking resulting from user behavior analysis. When Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for malicious activity and the configured mitigation actions will be taken on..",
						Attributes: map[string]schema.Attribute{
							"custom_page": schema.StringAttribute{
								MarkdownDescription: "Custom message is of type . Currently supported URL schemes is . For scheme, message needs to be encoded in Base64 format. You can specify this message as base64 encoded plain text message e.g. 'Blocked.' or it can be HTML paragraph or a body string encoded as base64 string E.g. '<p> Blocked..",
								Optional:            true,
							},
						},
					},
				},
			},
			"protected_cookies": schema.ListNestedBlock{
				MarkdownDescription: "Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses. Cookie Tampering Protection prevents attackers from modifying the value of session cookies. For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"max_age_value": schema.Int64Attribute{
							MarkdownDescription: "Add max age attribute.",
							Optional:            true,
						},
						"name": schema.StringAttribute{
							MarkdownDescription: "Cookie Name. Name of the Cookie .",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"add_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"add_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"disable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"enable_tampering_protection": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_httponly": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_max_age": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_samesite": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"ignore_secure": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"samesite_lax": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"samesite_none": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"samesite_strict": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"random": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"rate_limit": schema.SingleNestedBlock{
				MarkdownDescription: "RateLimitConfigType.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"custom_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "IP Allowed list using existing ip_prefix_set objects.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rate_limiter_allowed_prefixes": schema.ListNestedBlock{
								MarkdownDescription: "References to ip_prefix_set objects. Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
						Attributes: map[string]schema.Attribute{
							"prefixes": schema.ListAttribute{
								MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"no_ip_allowed_list": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of rate limiter policies to be applied.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered list of rate limiter policies.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"rate_limiter": schema.SingleNestedBlock{
						MarkdownDescription: "Tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
						Attributes: map[string]schema.Attribute{
							"burst_multiplier": schema.Int64Attribute{
								MarkdownDescription: "The maximum burst of requests to accommodate, expressed as a multiple of the rate.",
								Optional:            true,
							},
							"period_multiplier": schema.Int64Attribute{
								MarkdownDescription: "Setting, combined with Per Period units, provides a duration.",
								Optional:            true,
							},
							"total_number": schema.Int64Attribute{
								MarkdownDescription: "The total number of allowed requests per rate-limiting period.",
								Optional:            true,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: "[Enum: SECOND|MINUTE|HOUR] Unit for the period per which the rate limit is applied. - SECOND: Second Rate limit period unit is seconds - MINUTE: Minute Rate limit period unit is minutes - HOUR: Hour Rate limit period unit is hours - DAY: Day Rate limit period unit is days. Possible values are `SECOND`, `MINUTE`, `HOUR`. Defaults to `SECOND`.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"action_block": schema.SingleNestedBlock{
								MarkdownDescription: "Action where a user is blocked from making further requests after exceeding rate limit threshold.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"hours": schema.SingleNestedBlock{
										MarkdownDescription: "Hours. Input Duration Hours.",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration. Configuration parameter for duration",
												Optional:            true,
											},
										},
									},
									"minutes": schema.SingleNestedBlock{
										MarkdownDescription: "Minutes. Input Duration Minutes.",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration. Configuration parameter for duration",
												Optional:            true,
											},
										},
									},
									"seconds": schema.SingleNestedBlock{
										MarkdownDescription: "Seconds. Input Duration Seconds.",
										Attributes: map[string]schema.Attribute{
											"duration": schema.Int64Attribute{
												MarkdownDescription: "Duration. Configuration parameter for duration",
												Optional:            true,
											},
										},
									},
								},
							},
							"disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"leaky_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Leaky-Bucket is the default rate limiter algorithm for F5.",
							},
							"token_bucket": schema.SingleNestedBlock{
								MarkdownDescription: "Token-Bucket is a rate limiter algorithm that is stricter with enforcing limits.",
							},
						},
					},
				},
			},
			"ring_hash": schema.SingleNestedBlock{
				MarkdownDescription: "Hash Policy List. List of hash policy rules.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"hash_policy": schema.ListNestedBlock{
						MarkdownDescription: "Specifies a list of hash policies to use for ring hash load balancing. Each hash policy is evaluated individually and the combined result is used to route the request .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"header_name": schema.StringAttribute{
									MarkdownDescription: "The name or key of the request header that will be used to obtain the hash key.",
									Optional:            true,
								},
								"source_ip": schema.BoolAttribute{
									MarkdownDescription: "Hash based on source IP address.",
									Optional:            true,
								},
								"terminal": schema.BoolAttribute{
									MarkdownDescription: "Terminal. Specify if its a terminal policy.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"cookie": schema.SingleNestedBlock{
									MarkdownDescription: "Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets..",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced .",
											Optional:            true,
										},
										"path": schema.StringAttribute{
											MarkdownDescription: "The name of the path for the cookie. If no path is specified here, no path will be set for the cookie.",
											Optional:            true,
										},
										"ttl": schema.Int64Attribute{
											MarkdownDescription: "If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"add_httponly": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"add_secure": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_httponly": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_samesite": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_secure": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"samesite_lax": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"samesite_none": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"samesite_strict": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
				},
			},
			"round_robin": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"routes": schema.ListNestedBlock{
				MarkdownDescription: "Routes allow users to define match condition on a path and/or HTTP method to either forward matching traffic to origin pool or redirect matching traffic to a different URL or respond directly to matching traffic.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{},
					Blocks: map[string]schema.Block{
						"custom_route_object": schema.SingleNestedBlock{
							MarkdownDescription: "Custom route uses a route object created outside of this view.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"route_ref": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
						"direct_response_route": schema.SingleNestedBlock{
							MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
							Attributes: map[string]schema.Attribute{
								"http_method": schema.StringAttribute{
									MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "Headers. List of (key, value) headers.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
								"incoming_port": schema.SingleNestedBlock{
									MarkdownDescription: "Port match of the request can be a range or a specific port.",
									Attributes: map[string]schema.Attribute{
										"port": schema.Int64Attribute{
											MarkdownDescription: "Exact Port to match.",
											Optional:            true,
										},
										"port_ranges": schema.StringAttribute{
											MarkdownDescription: "Port range to match.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"no_port_match": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact path value to match.",
											Optional:            true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
											Optional:            true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
											Optional:            true,
										},
									},
								},
								"route_direct_response": schema.SingleNestedBlock{
									MarkdownDescription: "Send this direct response in case of route match action is direct response.",
									Attributes: map[string]schema.Attribute{
										"response_body_encoded": schema.StringAttribute{
											MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
											Optional:            true,
										},
										"response_code": schema.Int64Attribute{
											MarkdownDescription: "Response Code. Response code to send.",
											Optional:            true,
										},
									},
								},
							},
						},
						"redirect_route": schema.SingleNestedBlock{
							MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
							Attributes: map[string]schema.Attribute{
								"http_method": schema.StringAttribute{
									MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "Headers. List of (key, value) headers.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
								"incoming_port": schema.SingleNestedBlock{
									MarkdownDescription: "Port match of the request can be a range or a specific port.",
									Attributes: map[string]schema.Attribute{
										"port": schema.Int64Attribute{
											MarkdownDescription: "Exact Port to match.",
											Optional:            true,
										},
										"port_ranges": schema.StringAttribute{
											MarkdownDescription: "Port range to match.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"no_port_match": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact path value to match.",
											Optional:            true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
											Optional:            true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
											Optional:            true,
										},
									},
								},
								"route_redirect": schema.SingleNestedBlock{
									MarkdownDescription: "Route redirect parameters when match action is redirect.",
									Attributes: map[string]schema.Attribute{
										"host_redirect": schema.StringAttribute{
											MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
											Optional:            true,
										},
										"path_redirect": schema.StringAttribute{
											MarkdownDescription: "swap path part of incoming URL in redirect URL.",
											Optional:            true,
										},
										"prefix_rewrite": schema.StringAttribute{
											MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
											Optional:            true,
										},
										"proto_redirect": schema.StringAttribute{
											MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
											Optional:            true,
										},
										"replace_params": schema.StringAttribute{
											MarkdownDescription: ".",
											Optional:            true,
										},
										"response_code": schema.Int64Attribute{
											MarkdownDescription: "The HTTP status code to use in the redirect response.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"remove_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"retain_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
						"simple_route": schema.SingleNestedBlock{
							MarkdownDescription: "Simple route matches on path, incoming header, incoming port and/or HTTP method and forwards the matching traffic to the associated pools.",
							Attributes: map[string]schema.Attribute{
								"host_rewrite": schema.StringAttribute{
									MarkdownDescription: "Host header will be swapped with this value.",
									Optional:            true,
								},
								"http_method": schema.StringAttribute{
									MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"advanced_options": schema.SingleNestedBlock{
									MarkdownDescription: "Configure advanced OPTIONS for route like path rewrite, hash policy, etc.",
									Attributes: map[string]schema.Attribute{
										"disable_location_add": schema.BoolAttribute{
											MarkdownDescription: "Disables append of x-F5 Distributed Cloud-location = <RE-site-name> at route level, if it is configured at virtual-host level. This configuration is ignored on CE sites.",
											Optional:            true,
										},
										"prefix_rewrite": schema.StringAttribute{
											MarkdownDescription: "prefix_rewrite indicates that during forwarding, the matched prefix (or path) should be swapped with its value. When using regex path matching, the entire path (not including the query string) will be swapped with this value.",
											Optional:            true,
										},
										"priority": schema.StringAttribute{
											MarkdownDescription: "[Enum: DEFAULT|HIGH] Priority routing for each request. Different connection pools are used based on the priority selected for the request. Also, circuit-breaker configuration at destination cluster is chosen based on selected priority. Possible values are `DEFAULT`, `HIGH`. Defaults to `DEFAULT`.",
											Optional:            true,
										},
										"request_cookies_to_remove": schema.ListAttribute{
											MarkdownDescription: "List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"request_headers_to_remove": schema.ListAttribute{
											MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"response_cookies_to_remove": schema.ListAttribute{
											MarkdownDescription: "List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"response_headers_to_remove": schema.ListAttribute{
											MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "The timeout for the route including all retries, in milliseconds. Should be set to a high value or 0 (infinite timeout) for server-side streaming.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"app_firewall": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"bot_defense_javascript_injection": schema.SingleNestedBlock{
											MarkdownDescription: "Bot Defense Javascript Injection Configuration for inline bot defense deployments.",
											Attributes: map[string]schema.Attribute{
												"javascript_location": schema.StringAttribute{
													MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"javascript_tags": schema.ListNestedBlock{
													MarkdownDescription: "Select Add item to configure your javascript tag. If adding both Bot Adv and Fraud, the Bot Javascript should be added first.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"javascript_url": schema.StringAttribute{
																MarkdownDescription: "Please enter the full URL (include domain and path), or relative path.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"tag_attributes": schema.ListNestedBlock{
																MarkdownDescription: "Add the tag attributes you want to include in your Javascript tag.",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"javascript_tag": schema.StringAttribute{
																			MarkdownDescription: "[Enum: JS_ATTR_ID|JS_ATTR_CID|JS_ATTR_CN|JS_ATTR_API_DOMAIN|JS_ATTR_API_URL|JS_ATTR_API_PATH|JS_ATTR_ASYNC|JS_ATTR_DEFER] Select from one of the predefined tag attributes. Possible values are `JS_ATTR_ID`, `JS_ATTR_CID`, `JS_ATTR_CN`, `JS_ATTR_API_DOMAIN`, `JS_ATTR_API_URL`, `JS_ATTR_API_PATH`, `JS_ATTR_ASYNC`, `JS_ATTR_DEFER`. Defaults to `JS_ATTR_ID`.",
																			Optional:            true,
																		},
																		"tag_value": schema.StringAttribute{
																			MarkdownDescription: "Value. Add the tag attribute value.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										"buffer_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config.",
											Attributes: map[string]schema.Attribute{
												"disabled": schema.BoolAttribute{
													MarkdownDescription: "Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
													Optional:            true,
												},
												"max_request_bytes": schema.Int64Attribute{
													MarkdownDescription: "The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
													Optional:            true,
												},
											},
										},
										"common_buffering": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"common_hash_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"cors_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel MAC OS X 10.5..",
											Attributes: map[string]schema.Attribute{
												"allow_credentials": schema.BoolAttribute{
													MarkdownDescription: "Specifies whether the resource allows credentials.",
													Optional:            true,
												},
												"allow_headers": schema.StringAttribute{
													MarkdownDescription: "Specifies the content for the access-control-allow-headers header.",
													Optional:            true,
												},
												"allow_methods": schema.StringAttribute{
													MarkdownDescription: "Specifies the content for the access-control-allow-methods header.",
													Optional:            true,
												},
												"allow_origin": schema.ListAttribute{
													MarkdownDescription: "Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"allow_origin_regex": schema.ListAttribute{
													MarkdownDescription: "Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match.",
													Optional:            true,
													ElementType:         types.StringType,
												},
												"disabled": schema.BoolAttribute{
													MarkdownDescription: "Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
													Optional:            true,
												},
												"expose_headers": schema.StringAttribute{
													MarkdownDescription: "Specifies the content for the access-control-expose-headers header.",
													Optional:            true,
												},
												"maximum_age": schema.Int64Attribute{
													MarkdownDescription: "Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours).",
													Optional:            true,
												},
											},
										},
										"csrf_policy": schema.SingleNestedBlock{
											MarkdownDescription: "To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.the policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to..",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"all_load_balancer_domains": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"custom_domain_list": schema.SingleNestedBlock{
													MarkdownDescription: "List of domain names used for Host header matching.",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "List of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"disabled": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
										"default_retry_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"disable_mirroring": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"disable_prefix_rewrite": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"disable_spdy": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"disable_waf": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"disable_web_socket_config": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"do_not_retract_cluster": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"enable_spdy": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"endpoint_subsets": schema.SingleNestedBlock{
											MarkdownDescription: "Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8s or Consul..",
										},
										"inherited_bot_defense_javascript_injection": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"inherited_waf": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"inherited_waf_exclusion": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"mirror_policy": schema.SingleNestedBlock{
											MarkdownDescription: "MirrorPolicy is used for shadowing traffic from one origin pool to another. The approach used is 'fire and forget', meaning it will not wait for the shadow origin pool to respond before returning the response from the primary origin pool. All normal statistics are collected for the shadow origin..",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"origin_pool": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
												"percent": schema.SingleNestedBlock{
													MarkdownDescription: "Fraction used where sampling percentages are needed. Example sampled requests.",
													Attributes: map[string]schema.Attribute{
														"denominator": schema.StringAttribute{
															MarkdownDescription: "[Enum: HUNDRED|TEN_THOUSAND|MILLION] Denominator used in fraction where sampling percentages are needed. Example sampled requests Use hundred as denominator Use ten thousand as denominator Use million as denominator. Possible values are `HUNDRED`, `TEN_THOUSAND`, `MILLION`. Defaults to `HUNDRED`.",
															Optional:            true,
														},
														"numerator": schema.Int64Attribute{
															MarkdownDescription: "Sampled parts per denominator. If denominator was 10000, then value of 5 will be 5 in 10000 .",
															Optional:            true,
														},
													},
												},
											},
										},
										"no_retry_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"regex_rewrite": schema.SingleNestedBlock{
											MarkdownDescription: "RegexMatchRewrite describes how to match a string and then produce a new string using a regular expression and a substitution string.",
											Attributes: map[string]schema.Attribute{
												"pattern": schema.StringAttribute{
													MarkdownDescription: "The regular expression used to find portions of a string that should be replaced.",
													Optional:            true,
												},
												"substitution": schema.StringAttribute{
													MarkdownDescription: "The string that should be substituted into matching portions of the subject string during a substitution operation to produce a new string.",
													Optional:            true,
												},
											},
										},
										"request_cookies_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Name of the cookie in Cookie header.",
														Optional:            true,
													},
													"overwrite": schema.BoolAttribute{
														MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
														Optional:            true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value of the Cookie header.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"request_headers_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Headers are key-value pairs to be added to HTTP request being routed towards upstream.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"append": schema.BoolAttribute{
														MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. Name of the HTTP header.",
														Optional:            true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value of the HTTP header.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"response_cookies_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"add_domain": schema.StringAttribute{
														MarkdownDescription: "Add domain attribute.",
														Optional:            true,
													},
													"add_expiry": schema.StringAttribute{
														MarkdownDescription: "Add expiry attribute.",
														Optional:            true,
													},
													"add_path": schema.StringAttribute{
														MarkdownDescription: "Add path attribute.",
														Optional:            true,
													},
													"max_age_value": schema.Int64Attribute{
														MarkdownDescription: "Add max age attribute.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name of the cookie in Cookie header.",
														Optional:            true,
													},
													"overwrite": schema.BoolAttribute{
														MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
														Optional:            true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value of the Cookie header.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"add_httponly": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"add_partitioned": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"add_secure": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_domain": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_expiry": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_httponly": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_max_age": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_partitioned": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_path": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_samesite": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_secure": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_value": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"samesite_lax": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"samesite_none": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"samesite_strict": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"response_headers_to_add": schema.ListNestedBlock{
											MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"append": schema.BoolAttribute{
														MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
														Optional:            true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Name. Name of the HTTP header.",
														Optional:            true,
													},
													"value": schema.StringAttribute{
														MarkdownDescription: "Value of the HTTP header.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"secret_value": schema.SingleNestedBlock{
														MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"blindfold_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																Attributes: map[string]schema.Attribute{
																	"decryption_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																		Optional:            true,
																	},
																	"location": schema.StringAttribute{
																		MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																		Optional:            true,
																	},
																	"store_provider": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																},
															},
															"clear_secret_info": schema.SingleNestedBlock{
																MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																Attributes: map[string]schema.Attribute{
																	"provider_ref": schema.StringAttribute{
																		MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																		Optional:            true,
																	},
																	"url": schema.StringAttribute{
																		MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
										"retract_cluster": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"retry_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Retry policy configuration for route destination.",
											Attributes: map[string]schema.Attribute{
												"num_retries": schema.Int64Attribute{
													MarkdownDescription: "Specifies the allowed number of retries. Retries can be done any number of times. An exponential back-off algorithm is used between each retry. Defaults to `1`.",
													Optional:            true,
												},
												"per_try_timeout": schema.Int64Attribute{
													MarkdownDescription: "Specifies a non-zero timeout per retry attempt. In milliseconds.",
													Optional:            true,
												},
												"retriable_status_codes": schema.ListAttribute{
													MarkdownDescription: "HTTP status codes that should trigger a retry in addition to those specified by retry_on.",
													Optional:            true,
													ElementType:         types.Int64Type,
												},
												"retry_condition": schema.ListAttribute{
													MarkdownDescription: "Specifies the conditions under which retry takes place. Retries can be on different types of condition depending on application requirements. For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc The possible values are '5xx' : Retry will be done if the..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"back_off": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies parameters that control retry back off.",
													Attributes: map[string]schema.Attribute{
														"base_interval": schema.Int64Attribute{
															MarkdownDescription: "Specifies the base interval between retries in milliseconds.",
															Optional:            true,
														},
														"max_interval": schema.Int64Attribute{
															MarkdownDescription: "Specifies the maximum interval between retries in milliseconds. This parameter is optional, but must be greater than or equal to the base_interval if set. The  times the base_interval. Defaults to `10`.",
															Optional:            true,
														},
													},
												},
											},
										},
										"specific_hash_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Policy List. List of hash policy rules.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"hash_policy": schema.ListNestedBlock{
													MarkdownDescription: "Specifies a list of hash policies to use for ring hash load balancing. Each hash policy is evaluated individually and the combined result is used to route the request .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"header_name": schema.StringAttribute{
																MarkdownDescription: "The name or key of the request header that will be used to obtain the hash key.",
																Optional:            true,
															},
															"source_ip": schema.BoolAttribute{
																MarkdownDescription: "Hash based on source IP address.",
																Optional:            true,
															},
															"terminal": schema.BoolAttribute{
																MarkdownDescription: "Terminal. Specify if its a terminal policy.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"cookie": schema.SingleNestedBlock{
																MarkdownDescription: "Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets..",
																Attributes: map[string]schema.Attribute{
																	"name": schema.StringAttribute{
																		MarkdownDescription: "The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced .",
																		Optional:            true,
																	},
																	"path": schema.StringAttribute{
																		MarkdownDescription: "The name of the path for the cookie. If no path is specified here, no path will be set for the cookie.",
																		Optional:            true,
																	},
																	"ttl": schema.Int64Attribute{
																		MarkdownDescription: "If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds.",
																		Optional:            true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"add_httponly": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"add_secure": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"ignore_httponly": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"ignore_samesite": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"ignore_secure": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"samesite_lax": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"samesite_none": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																	"samesite_strict": schema.SingleNestedBlock{
																		MarkdownDescription: "Enable this option",
																	},
																},
															},
														},
													},
												},
											},
										},
										"waf_exclusion_policy": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"web_socket_config": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration to allow Websocket Request headers of such upgrade looks like below 'connection', 'Upgrade' 'upgrade', 'websocket' With configuration to allow websocket upgrade, ADC will produce following response 'HTTP/1.1 101 Switching Protocols 'Upgrade': 'websocket' 'Connection': 'Upgrade'.",
											Attributes: map[string]schema.Attribute{
												"use_websocket": schema.BoolAttribute{
													MarkdownDescription: "Specifies that the HTTP client connection to this route is allowed to upgrade to a WebSocket connection.",
													Optional:            true,
												},
											},
										},
									},
								},
								"auto_host_rewrite": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"disable_host_rewrite": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "Headers. List of (key, value) headers.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
								"incoming_port": schema.SingleNestedBlock{
									MarkdownDescription: "Port match of the request can be a range or a specific port.",
									Attributes: map[string]schema.Attribute{
										"port": schema.Int64Attribute{
											MarkdownDescription: "Exact Port to match.",
											Optional:            true,
										},
										"port_ranges": schema.StringAttribute{
											MarkdownDescription: "Port range to match.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"no_port_match": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"origin_pools": schema.ListNestedBlock{
									MarkdownDescription: "Origin Pools for this route .",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"priority": schema.Int64Attribute{
												MarkdownDescription: "Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the..",
												Optional:            true,
											},
											"weight": schema.Int64Attribute{
												MarkdownDescription: "Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"cluster": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"endpoint_subsets": schema.SingleNestedBlock{
												MarkdownDescription: "Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8s or Consul..",
											},
											"pool": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Exact path value to match.",
											Optional:            true,
										},
										"prefix": schema.StringAttribute{
											MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
											Optional:            true,
										},
										"regex": schema.StringAttribute{
											MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
											Optional:            true,
										},
									},
								},
								"query_params": schema.SingleNestedBlock{
									MarkdownDescription: "Handling of incoming query parameters in simple route.",
									Attributes: map[string]schema.Attribute{
										"replace_params": schema.StringAttribute{
											MarkdownDescription: ".",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"remove_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"retain_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
				},
			},
			"sensitive_data_disclosure_rules": schema.SingleNestedBlock{
				MarkdownDescription: "Sensitive Data Exposure Rules allows specifying rules to mask sensitive data fields in API responses.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"sensitive_data_types_in_response": schema.ListNestedBlock{
						MarkdownDescription: "Sensitive Data Exposure Rules allows specifying rules to mask sensitive data fields in API responses.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"api_endpoint": schema.SingleNestedBlock{
									MarkdownDescription: "API Endpoint. This defines API endpoint.",
									Attributes: map[string]schema.Attribute{
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path to be matched .",
											Optional:            true,
										},
									},
								},
								"body": schema.SingleNestedBlock{
									MarkdownDescription: "Body Section Masking OPTIONS. OPTIONS for HTTP Body Masking.",
									Attributes: map[string]schema.Attribute{
										"fields": schema.ListAttribute{
											MarkdownDescription: "List of JSON Path field values. Use square brackets with an underscore [_] to indicate array elements (e.g., person.emails[_]). To reference JSON keys that contain spaces, enclose the entire path in double quotes.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"mask": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"report": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
				},
			},
			"sensitive_data_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Sensitive Data Discovery. Settings for data type policy.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"sensitive_data_policy_ref": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"service_policies_from_namespace": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"single_lb_app": schema.SingleNestedBlock{
				MarkdownDescription: "Specific settings for Machine learning analysis on this HTTP LB, independently from other LBs.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_malicious_user_detection": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_discovery": schema.SingleNestedBlock{
						MarkdownDescription: "Specifies the settings used for API discovery.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"api_crawler": schema.SingleNestedBlock{
								MarkdownDescription: "API Crawling. API Crawler message.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"api_crawler_config": schema.SingleNestedBlock{
										MarkdownDescription: "Crawler Configure.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"domains": schema.ListNestedBlock{
												MarkdownDescription: "Enter domains and their credentials to allow authenticated API crawling. You can only include domains you own that are associated with this Load Balancer.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"domain": schema.StringAttribute{
															MarkdownDescription: "Select the domain to execute API Crawling with given credentials.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"simple_login": schema.SingleNestedBlock{
															MarkdownDescription: "Simple Login.",
															Attributes: map[string]schema.Attribute{
																"user": schema.StringAttribute{
																	MarkdownDescription: "Enter the username to assign credentials for the selected domain to crawl.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"password": schema.SingleNestedBlock{
																	MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"blindfold_secret_info": schema.SingleNestedBlock{
																			MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																			Attributes: map[string]schema.Attribute{
																				"decryption_provider": schema.StringAttribute{
																					MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																					Optional:            true,
																				},
																				"location": schema.StringAttribute{
																					MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																					Optional:            true,
																				},
																				"store_provider": schema.StringAttribute{
																					MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																					Optional:            true,
																				},
																			},
																		},
																		"clear_secret_info": schema.SingleNestedBlock{
																			MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																			Attributes: map[string]schema.Attribute{
																				"provider_ref": schema.StringAttribute{
																					MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																					Optional:            true,
																				},
																				"url": schema.StringAttribute{
																					MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																					Optional:            true,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"disable_api_crawler": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"api_discovery_from_code_scan": schema.SingleNestedBlock{
								MarkdownDescription: "Select Code Base and Repositories.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"code_base_integrations": schema.ListNestedBlock{
										MarkdownDescription: "Select Code Base Integrations. .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"all_repos": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"code_base_integration": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
												"selected_repos": schema.SingleNestedBlock{
													MarkdownDescription: "Select which API repositories represent the LB applications.",
													Attributes: map[string]schema.Attribute{
														"api_code_repo": schema.ListAttribute{
															MarkdownDescription: "Code repository which contain API endpoints .",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
											},
										},
									},
								},
							},
							"custom_api_auth_discovery": schema.SingleNestedBlock{
								MarkdownDescription: "API Discovery Advanced Settings. API Discovery Advanced settings.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"api_discovery_ref": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
								},
							},
							"default_api_auth_discovery": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_learn_from_redirect_traffic": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"discovered_api_settings": schema.SingleNestedBlock{
								MarkdownDescription: "Discovered API Settings. Configure Discovered API Settings.",
								Attributes: map[string]schema.Attribute{
									"purge_duration_for_inactive_discovered_apis": schema.Int64Attribute{
										MarkdownDescription: "Inactive discovered API will be deleted after configured duration.",
										Optional:            true,
									},
								},
							},
							"enable_learn_from_redirect_traffic": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"enable_malicious_user_detection": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"slow_ddos_mitigation": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: slow_ddos_mitigation, system_default_timeouts; Default: system_default_timeouts] 'Slow and low' attacks tie up server resources, leaving none available for servicing requests from actual users.",
				Attributes: map[string]schema.Attribute{
					"request_headers_timeout": schema.Int64Attribute{
						MarkdownDescription: "The amount of time the client has to send only the headers on the request stream before the stream is cancelled. The  milliseconds. This setting provides protection against Slowloris attacks. Defaults to `10000`.",
						Optional:            true,
					},
					"request_timeout": schema.Int64Attribute{
						MarkdownDescription: ".",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_request_timeout": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"source_ip_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"system_default_timeouts": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"trusted_clients": schema.ListNestedBlock{
				MarkdownDescription: "Define rules to skip processing of one or more features such as WAF, Bot Defense etc.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListAttribute{
							MarkdownDescription: "[Enum: SKIP_PROCESSING_WAF|SKIP_PROCESSING_BOT|SKIP_PROCESSING_MUM|SKIP_PROCESSING_IP_REPUTATION|SKIP_PROCESSING_API_PROTECTION|SKIP_PROCESSING_OAS_VALIDATION|SKIP_PROCESSING_DDOS_PROTECTION|SKIP_PROCESSING_THREAT_MESH|SKIP_PROCESSING_MALWARE_PROTECTION] Actions that should be taken when client identifier matches the rule. Possible values are `SKIP_PROCESSING_WAF`, `SKIP_PROCESSING_BOT`, `SKIP_PROCESSING_MUM`, `SKIP_PROCESSING_IP_REPUTATION`, `SKIP_PROCESSING_API_PROTECTION`, `SKIP_PROCESSING_OAS_VALIDATION`, `SKIP_PROCESSING_DDOS_PROTECTION`, `SKIP_PROCESSING_THREAT_MESH`, `SKIP_PROCESSING_MALWARE_PROTECTION`. Defaults to `SKIP_PROCESSING_WAF`.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"as_number": schema.Int64Attribute{
							MarkdownDescription: "RFC 6793 defined 4-byte AS number.",
							Optional:            true,
						},
						"expiration_timestamp": schema.StringAttribute{
							MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
							Optional:            true,
						},
						"ip_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv4 prefix string.",
							Optional:            true,
						},
						"ipv6_prefix": schema.StringAttribute{
							MarkdownDescription: "IPv6 prefix string.",
							Optional:            true,
						},
						"user_identifier": schema.StringAttribute{
							MarkdownDescription: "Identify user based on user identifier. User identifier value needs to be copied from security event.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"http_header": schema.SingleNestedBlock{
							MarkdownDescription: "HTTP Header. Request header name and value pairs.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "List of HTTP header name and value pairs .",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"exact": schema.StringAttribute{
												MarkdownDescription: "Header value to match exactly.",
												Optional:            true,
											},
											"invert_match": schema.BoolAttribute{
												MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. Name of the header .",
												Optional:            true,
											},
											"presence": schema.BoolAttribute{
												MarkdownDescription: "If true, check for presence of header.",
												Optional:            true,
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regex match of the header value in re2 format.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"waf_skip_processing": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
					},
				},
			},
			"user_id_client_ip": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: user_id_client_ip, user_identification] Enable this option",
			},
			"user_identification": schema.SingleNestedBlock{
				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"waf_exclusion": schema.SingleNestedBlock{
				MarkdownDescription: "WAF Exclusion.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"waf_exclusion_inline_rules": schema.SingleNestedBlock{
						MarkdownDescription: "List of WAF exclusion rules that will be applied inline.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"rules": schema.ListNestedBlock{
								MarkdownDescription: "Ordered list of WAF Exclusions specific to this Load Balancer.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"exact_value": schema.StringAttribute{
											MarkdownDescription: "Exact domain name.",
											Optional:            true,
										},
										"expiration_timestamp": schema.StringAttribute{
											MarkdownDescription: "Specifies expiration_timestamp the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in the configuration but is not applied anymore.",
											Optional:            true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Methods. Methods to be matched. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"path_prefix": schema.StringAttribute{
											MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths).",
											Optional:            true,
										},
										"path_regex": schema.StringAttribute{
											MarkdownDescription: "Define the regex for the path. For example, the regex ^/.*$ will match on all paths.",
											Optional:            true,
										},
										"suffix_value": schema.StringAttribute{
											MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"any_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"any_path": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"app_firewall_detection_control": schema.SingleNestedBlock{
											MarkdownDescription: "Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"exclude_attack_type_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Attack Types to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "[Enum: CONTEXT_ANY|CONTEXT_BODY|CONTEXT_REQUEST|CONTEXT_RESPONSE|CONTEXT_PARAMETER|CONTEXT_HEADER|CONTEXT_COOKIE|CONTEXT_URL|CONTEXT_URI] The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE.. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional:            true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional:            true,
															},
															"exclude_attack_type": schema.StringAttribute{
																MarkdownDescription: "[Enum: ATTACK_TYPE_NONE|ATTACK_TYPE_NON_BROWSER_CLIENT|ATTACK_TYPE_OTHER_APPLICATION_ATTACKS|ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE|ATTACK_TYPE_DETECTION_EVASION|ATTACK_TYPE_VULNERABILITY_SCAN|ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY|ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS|ATTACK_TYPE_BUFFER_OVERFLOW|ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION|ATTACK_TYPE_INFORMATION_LEAKAGE|ATTACK_TYPE_DIRECTORY_INDEXING|ATTACK_TYPE_PATH_TRAVERSAL|ATTACK_TYPE_XPATH_INJECTION|ATTACK_TYPE_LDAP_INJECTION|ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION|ATTACK_TYPE_COMMAND_EXECUTION|ATTACK_TYPE_SQL_INJECTION|ATTACK_TYPE_CROSS_SITE_SCRIPTING|ATTACK_TYPE_DENIAL_OF_SERVICE|ATTACK_TYPE_HTTP_PARSER_ATTACK|ATTACK_TYPE_SESSION_HIJACKING|ATTACK_TYPE_HTTP_RESPONSE_SPLITTING|ATTACK_TYPE_FORCEFUL_BROWSING|ATTACK_TYPE_REMOTE_FILE_INCLUDE|ATTACK_TYPE_MALICIOUS_FILE_UPLOAD|ATTACK_TYPE_GRAPHQL_PARSER_ATTACK] List of all Attack Types ATTACK_TYPE_NONE ATTACK_TYPE_NON_BROWSER_CLIENT ATTACK_TYPE_OTHER_APPLICATION_ATTACKS ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE ATTACK_TYPE_DETECTION_EVASION ATTACK_TYPE_VULNERABILITY_SCAN ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS.. Possible values are `ATTACK_TYPE_NONE`, `ATTACK_TYPE_NON_BROWSER_CLIENT`, `ATTACK_TYPE_OTHER_APPLICATION_ATTACKS`, `ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE`, `ATTACK_TYPE_DETECTION_EVASION`, `ATTACK_TYPE_VULNERABILITY_SCAN`, `ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY`, `ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS`, `ATTACK_TYPE_BUFFER_OVERFLOW`, `ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION`, `ATTACK_TYPE_INFORMATION_LEAKAGE`, `ATTACK_TYPE_DIRECTORY_INDEXING`, `ATTACK_TYPE_PATH_TRAVERSAL`, `ATTACK_TYPE_XPATH_INJECTION`, `ATTACK_TYPE_LDAP_INJECTION`, `ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION`, `ATTACK_TYPE_COMMAND_EXECUTION`, `ATTACK_TYPE_SQL_INJECTION`, `ATTACK_TYPE_CROSS_SITE_SCRIPTING`, `ATTACK_TYPE_DENIAL_OF_SERVICE`, `ATTACK_TYPE_HTTP_PARSER_ATTACK`, `ATTACK_TYPE_SESSION_HIJACKING`, `ATTACK_TYPE_HTTP_RESPONSE_SPLITTING`, `ATTACK_TYPE_FORCEFUL_BROWSING`, `ATTACK_TYPE_REMOTE_FILE_INCLUDE`, `ATTACK_TYPE_MALICIOUS_FILE_UPLOAD`, `ATTACK_TYPE_GRAPHQL_PARSER_ATTACK`. Defaults to `ATTACK_TYPE_NONE`.",
																Optional:            true,
															},
														},
													},
												},
												"exclude_bot_name_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Bot Names to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"bot_name": schema.StringAttribute{
																MarkdownDescription: "Bot Name.",
																Optional:            true,
															},
														},
													},
												},
												"exclude_signature_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Signature IDs to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "[Enum: CONTEXT_ANY|CONTEXT_BODY|CONTEXT_REQUEST|CONTEXT_RESPONSE|CONTEXT_PARAMETER|CONTEXT_HEADER|CONTEXT_COOKIE|CONTEXT_URL|CONTEXT_URI] The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE.. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional:            true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional:            true,
															},
															"signature_id": schema.Int64Attribute{
																MarkdownDescription: "The allowed values for signature ID are 0 and in the range of 200000001-299999999. 0 implies that all signatures will be excluded for the specified context.",
																Optional:            true,
															},
														},
													},
												},
												"exclude_violation_contexts": schema.ListNestedBlock{
													MarkdownDescription: "Violations to be excluded for the defined match criteria.",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"context": schema.StringAttribute{
																MarkdownDescription: "[Enum: CONTEXT_ANY|CONTEXT_BODY|CONTEXT_REQUEST|CONTEXT_RESPONSE|CONTEXT_PARAMETER|CONTEXT_HEADER|CONTEXT_COOKIE|CONTEXT_URL|CONTEXT_URI] The available contexts for Exclusion rules. - CONTEXT_ANY: CONTEXT_ANY Detection will be excluded for all contexts. - CONTEXT_BODY: CONTEXT_BODY Detection will be excluded for the request body. - CONTEXT_REQUEST: CONTEXT_REQUEST Detection will be excluded for the request. - CONTEXT_RESPONSE.. Possible values are `CONTEXT_ANY`, `CONTEXT_BODY`, `CONTEXT_REQUEST`, `CONTEXT_RESPONSE`, `CONTEXT_PARAMETER`, `CONTEXT_HEADER`, `CONTEXT_COOKIE`, `CONTEXT_URL`, `CONTEXT_URI`. Defaults to `CONTEXT_ANY`.",
																Optional:            true,
															},
															"context_name": schema.StringAttribute{
																MarkdownDescription: "Relevant only for contexts: Header, Cookie and Parameter. Name of the Context that the WAF Exclusion Rules will check. Wildcard matching can be used by prefixing or suffixing the context name with an wildcard asterisk (*).",
																Optional:            true,
															},
															"exclude_violation": schema.StringAttribute{
																MarkdownDescription: "[Enum: VIOL_NONE|VIOL_FILETYPE|VIOL_METHOD|VIOL_MANDATORY_HEADER|VIOL_HTTP_RESPONSE_STATUS|VIOL_REQUEST_MAX_LENGTH|VIOL_FILE_UPLOAD|VIOL_FILE_UPLOAD_IN_BODY|VIOL_XML_MALFORMED|VIOL_JSON_MALFORMED|VIOL_ASM_COOKIE_MODIFIED|VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS|VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE|VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT|VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST|VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION|VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS|VIOL_EVASION_DIRECTORY_TRAVERSALS|VIOL_MALFORMED_REQUEST|VIOL_EVASION_MULTIPLE_DECODING|VIOL_DATA_GUARD|VIOL_EVASION_APACHE_WHITESPACE|VIOL_COOKIE_MODIFIED|VIOL_EVASION_IIS_UNICODE_CODEPOINTS|VIOL_EVASION_IIS_BACKSLASHES|VIOL_EVASION_PERCENT_U_DECODING|VIOL_EVASION_BARE_BYTE_DECODING|VIOL_EVASION_BAD_UNESCAPE|VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST|VIOL_ENCODING|VIOL_COOKIE_MALFORMED|VIOL_GRAPHQL_FORMAT|VIOL_GRAPHQL_MALFORMED|VIOL_GRAPHQL_INTROSPECTION_QUERY] List of all supported Violation Types VIOL_NONE VIOL_FILETYPE VIOL_METHOD VIOL_MANDATORY_HEADER VIOL_HTTP_RESPONSE_STATUS VIOL_REQUEST_MAX_LENGTH VIOL_FILE_UPLOAD VIOL_FILE_UPLOAD_IN_BODY VIOL_XML_MALFORMED VIOL_JSON_MALFORMED VIOL_ASM_COOKIE_MODIFIED VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS.. Possible values are `VIOL_NONE`, `VIOL_FILETYPE`, `VIOL_METHOD`, `VIOL_MANDATORY_HEADER`, `VIOL_HTTP_RESPONSE_STATUS`, `VIOL_REQUEST_MAX_LENGTH`, `VIOL_FILE_UPLOAD`, `VIOL_FILE_UPLOAD_IN_BODY`, `VIOL_XML_MALFORMED`, `VIOL_JSON_MALFORMED`, `VIOL_ASM_COOKIE_MODIFIED`, `VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS`, `VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE`, `VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT`, `VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST`, `VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION`, `VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS`, `VIOL_EVASION_DIRECTORY_TRAVERSALS`, `VIOL_MALFORMED_REQUEST`, `VIOL_EVASION_MULTIPLE_DECODING`, `VIOL_DATA_GUARD`, `VIOL_EVASION_APACHE_WHITESPACE`, `VIOL_COOKIE_MODIFIED`, `VIOL_EVASION_IIS_UNICODE_CODEPOINTS`, `VIOL_EVASION_IIS_BACKSLASHES`, `VIOL_EVASION_PERCENT_U_DECODING`, `VIOL_EVASION_BARE_BYTE_DECODING`, `VIOL_EVASION_BAD_UNESCAPE`, `VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST`, `VIOL_ENCODING`, `VIOL_COOKIE_MALFORMED`, `VIOL_GRAPHQL_FORMAT`, `VIOL_GRAPHQL_MALFORMED`, `VIOL_GRAPHQL_INTROSPECTION_QUERY`. Defaults to `VIOL_NONE`.",
																Optional:            true,
															},
														},
													},
												},
											},
										},
										"metadata": schema.SingleNestedBlock{
											MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
											Attributes: map[string]schema.Attribute{
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Human readable description.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
													Optional:            true,
												},
											},
										},
										"waf_skip_processing": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"waf_exclusion_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *HTTPLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *HTTPLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *HTTPLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the http_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan HTTPLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *HTTPLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := HTTPLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *HTTPLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating http_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.HTTPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		createReq.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		createReq.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		createReq.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		createReq.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.APIProtectionRules != nil {
		api_protection_rulesMap := make(map[string]interface{})
		if len(data.APIProtectionRules.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if len(data.APIProtectionRules.APIGroupsRules) > 0 {
			var api_groups_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIGroupsRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_groups_rulesList = append(api_groups_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_groups_rules"] = api_groups_rulesList
		}
		createReq.Spec["api_protection_rules"] = api_protection_rulesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		createReq.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		createReq.Spec["api_specification"] = api_specificationMap
	}
	if data.APITesting != nil {
		api_testingMap := make(map[string]interface{})
		if !data.APITesting.CustomHeaderValue.IsNull() && !data.APITesting.CustomHeaderValue.IsUnknown() {
			api_testingMap["custom_header_value"] = data.APITesting.CustomHeaderValue.ValueString()
		}
		if len(data.APITesting.Domains) > 0 {
			var domainsList []map[string]interface{}
			for _, listItem := range data.APITesting.Domains {
				listItemMap := make(map[string]interface{})
				if !listItem.AllowDestructiveMethods.IsNull() && !listItem.AllowDestructiveMethods.IsUnknown() {
					listItemMap["allow_destructive_methods"] = listItem.AllowDestructiveMethods.ValueBool()
				}
				if !listItem.Domain.IsNull() && !listItem.Domain.IsUnknown() {
					listItemMap["domain"] = listItem.Domain.ValueString()
				}
				domainsList = append(domainsList, listItemMap)
			}
			api_testingMap["domains"] = domainsList
		}
		if data.APITesting.EveryDay != nil {
			api_testingMap["every_day"] = map[string]interface{}{}
		}
		if data.APITesting.EveryMonth != nil {
			api_testingMap["every_month"] = map[string]interface{}{}
		}
		if data.APITesting.EveryWeek != nil {
			api_testingMap["every_week"] = map[string]interface{}{}
		}
		createReq.Spec["api_testing"] = api_testingMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		createReq.Spec["app_firewall"] = app_firewallMap
	}
	if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
		var blocked_clientsItems []HTTPLoadBalancerBlockedClientsModel
		diags := data.BlockedClients.ElementsAs(ctx, &blocked_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(blocked_clientsItems) > 0 {
			var blocked_clientsList []map[string]interface{}
			for _, item := range blocked_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				blocked_clientsList = append(blocked_clientsList, itemMap)
			}
			createReq.Spec["blocked_clients"] = blocked_clientsList
		}
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCORSSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCORSSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		createReq.Spec["bot_defense"] = bot_defenseMap
	}
	if data.BotDefenseAdvanced != nil {
		bot_defense_advancedMap := make(map[string]interface{})
		if data.BotDefenseAdvanced.DisableJsInsert != nil {
			bot_defense_advancedMap["disable_js_insert"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.DisableMobileSdk != nil {
			bot_defense_advancedMap["disable_mobile_sdk"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.JsInsertAllPages != nil {
			js_insert_all_pagesNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsUnknown() {
				js_insert_all_pagesNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages"] = js_insert_all_pagesNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertAllPagesExcept != nil {
			js_insert_all_pages_exceptNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsUnknown() {
				js_insert_all_pages_exceptNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages_except"] = js_insert_all_pages_exceptNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertionRules != nil {
			js_insertion_rulesNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["js_insertion_rules"] = js_insertion_rulesNestedMap
		}
		if data.BotDefenseAdvanced.Mobile != nil {
			mobileNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Mobile.Name.IsNull() && !data.BotDefenseAdvanced.Mobile.Name.IsUnknown() {
				mobileNestedMap["name"] = data.BotDefenseAdvanced.Mobile.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Namespace.IsNull() && !data.BotDefenseAdvanced.Mobile.Namespace.IsUnknown() {
				mobileNestedMap["namespace"] = data.BotDefenseAdvanced.Mobile.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Tenant.IsNull() && !data.BotDefenseAdvanced.Mobile.Tenant.IsUnknown() {
				mobileNestedMap["tenant"] = data.BotDefenseAdvanced.Mobile.Tenant.ValueString()
			}
			bot_defense_advancedMap["mobile"] = mobileNestedMap
		}
		if data.BotDefenseAdvanced.MobileSdkConfig != nil {
			mobile_sdk_configNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["mobile_sdk_config"] = mobile_sdk_configNestedMap
		}
		if data.BotDefenseAdvanced.Web != nil {
			webNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Web.Name.IsNull() && !data.BotDefenseAdvanced.Web.Name.IsUnknown() {
				webNestedMap["name"] = data.BotDefenseAdvanced.Web.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Namespace.IsNull() && !data.BotDefenseAdvanced.Web.Namespace.IsUnknown() {
				webNestedMap["namespace"] = data.BotDefenseAdvanced.Web.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Tenant.IsNull() && !data.BotDefenseAdvanced.Web.Tenant.IsUnknown() {
				webNestedMap["tenant"] = data.BotDefenseAdvanced.Web.Tenant.ValueString()
			}
			bot_defense_advancedMap["web"] = webNestedMap
		}
		createReq.Spec["bot_defense_advanced"] = bot_defense_advancedMap
	}
	if data.CachingPolicy != nil {
		caching_policyMap := make(map[string]interface{})
		if data.CachingPolicy.CustomCacheRule != nil {
			custom_cache_ruleNestedMap := make(map[string]interface{})
			caching_policyMap["custom_cache_rule"] = custom_cache_ruleNestedMap
		}
		if data.CachingPolicy.DefaultCacheAction != nil {
			default_cache_actionNestedMap := make(map[string]interface{})
			if !data.CachingPolicy.DefaultCacheAction.CacheTTLDefault.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTTLDefault.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_default"] = data.CachingPolicy.DefaultCacheAction.CacheTTLDefault.ValueString()
			}
			if !data.CachingPolicy.DefaultCacheAction.CacheTTLOverride.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTTLOverride.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_override"] = data.CachingPolicy.DefaultCacheAction.CacheTTLOverride.ValueString()
			}
			caching_policyMap["default_cache_action"] = default_cache_actionNestedMap
		}
		createReq.Spec["caching_policy"] = caching_policyMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		createReq.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		createReq.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CookieStickiness != nil {
		cookie_stickinessMap := make(map[string]interface{})
		if data.CookieStickiness.AddHttponly != nil {
			cookie_stickinessMap["add_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.AddSecure != nil {
			cookie_stickinessMap["add_secure"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreHttponly != nil {
			cookie_stickinessMap["ignore_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSamesite != nil {
			cookie_stickinessMap["ignore_samesite"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSecure != nil {
			cookie_stickinessMap["ignore_secure"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.Name.IsNull() && !data.CookieStickiness.Name.IsUnknown() {
			cookie_stickinessMap["name"] = data.CookieStickiness.Name.ValueString()
		}
		if !data.CookieStickiness.Path.IsNull() && !data.CookieStickiness.Path.IsUnknown() {
			cookie_stickinessMap["path"] = data.CookieStickiness.Path.ValueString()
		}
		if data.CookieStickiness.SamesiteLax != nil {
			cookie_stickinessMap["samesite_lax"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteNone != nil {
			cookie_stickinessMap["samesite_none"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteStrict != nil {
			cookie_stickinessMap["samesite_strict"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.TTL.IsNull() && !data.CookieStickiness.TTL.IsUnknown() {
			cookie_stickinessMap["ttl"] = data.CookieStickiness.TTL.ValueInt64()
		}
		createReq.Spec["cookie_stickiness"] = cookie_stickinessMap
	}
	if data.CORSPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CORSPolicy.AllowCredentials.IsNull() && !data.CORSPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CORSPolicy.AllowCredentials.ValueBool()
		}
		if !data.CORSPolicy.AllowHeaders.IsNull() && !data.CORSPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CORSPolicy.AllowHeaders.ValueString()
		}
		if !data.CORSPolicy.AllowMethods.IsNull() && !data.CORSPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CORSPolicy.AllowMethods.ValueString()
		}
		if !data.CORSPolicy.AllowOrigin.IsNull() && !data.CORSPolicy.AllowOrigin.IsUnknown() {
			var allow_originItems []string
			diags := data.CORSPolicy.AllowOrigin.ElementsAs(ctx, &allow_originItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin"] = allow_originItems
			}
		}
		if !data.CORSPolicy.AllowOriginRegex.IsNull() && !data.CORSPolicy.AllowOriginRegex.IsUnknown() {
			var allow_origin_regexItems []string
			diags := data.CORSPolicy.AllowOriginRegex.ElementsAs(ctx, &allow_origin_regexItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin_regex"] = allow_origin_regexItems
			}
		}
		if !data.CORSPolicy.Disabled.IsNull() && !data.CORSPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CORSPolicy.Disabled.ValueBool()
		}
		if !data.CORSPolicy.ExposeHeaders.IsNull() && !data.CORSPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CORSPolicy.ExposeHeaders.ValueString()
		}
		if !data.CORSPolicy.MaximumAge.IsNull() && !data.CORSPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CORSPolicy.MaximumAge.ValueInt64()
		}
		createReq.Spec["cors_policy"] = cors_policyMap
	}
	if data.CSRFPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CSRFPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CSRFPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CSRFPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		createReq.Spec["csrf_policy"] = csrf_policyMap
	}
	if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
		var data_guard_rulesItems []HTTPLoadBalancerDataGuardRulesModel
		diags := data.DataGuardRules.ElementsAs(ctx, &data_guard_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(data_guard_rulesItems) > 0 {
			var data_guard_rulesList []map[string]interface{}
			for _, item := range data_guard_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if item.ApplyDataGuard != nil {
					itemMap["apply_data_guard"] = map[string]interface{}{}
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.Path != nil {
					pathNestedMap := make(map[string]interface{})
					if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
						pathNestedMap["path"] = item.Path.Path.ValueString()
					}
					if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
						pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
					}
					if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
						pathNestedMap["regex"] = item.Path.Regex.ValueString()
					}
					itemMap["path"] = pathNestedMap
				}
				if item.SkipDataGuard != nil {
					itemMap["skip_data_guard"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				data_guard_rulesList = append(data_guard_rulesList, itemMap)
			}
			createReq.Spec["data_guard_rules"] = data_guard_rulesList
		}
	}
	if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
		var ddos_mitigation_rulesItems []HTTPLoadBalancerDDOSMitigationRulesModel
		diags := data.DDOSMitigationRules.ElementsAs(ctx, &ddos_mitigation_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(ddos_mitigation_rulesItems) > 0 {
			var ddos_mitigation_rulesList []map[string]interface{}
			for _, item := range ddos_mitigation_rulesItems {
				itemMap := make(map[string]interface{})
				if item.Block != nil {
					itemMap["block"] = map[string]interface{}{}
				}
				if item.DDOSClientSource != nil {
					ddos_client_sourceNestedMap := make(map[string]interface{})
					if item.DDOSClientSource.AsnList != nil {
						asn_listDeepMap := make(map[string]interface{})
						ddos_client_sourceNestedMap["asn_list"] = asn_listDeepMap
					}
					if !item.DDOSClientSource.CountryList.IsNull() && !item.DDOSClientSource.CountryList.IsUnknown() {
						var CountryListItems []string
						diags := item.DDOSClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
						if !diags.HasError() {
							ddos_client_sourceNestedMap["country_list"] = CountryListItems
						}
					}
					if item.DDOSClientSource.Ja4TLSFingerprintMatcher != nil {
						ja4_tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								ja4_tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						ddos_client_sourceNestedMap["ja4_tls_fingerprint_matcher"] = ja4_tls_fingerprint_matcherDeepMap
					}
					if item.DDOSClientSource.TLSFingerprintMatcher != nil {
						tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsUnknown() {
							var ClassesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.Classes.ElementsAs(ctx, &ClassesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["classes"] = ClassesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsUnknown() {
							var ExcludedValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.ElementsAs(ctx, &ExcludedValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["excluded_values"] = ExcludedValuesItems
							}
						}
						ddos_client_sourceNestedMap["tls_fingerprint_matcher"] = tls_fingerprint_matcherDeepMap
					}
					itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.IPPrefixList != nil {
					ip_prefix_listNestedMap := make(map[string]interface{})
					if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
					}
					if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
						var IPPrefixesItems []string
						diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
						if !diags.HasError() {
							ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
						}
					}
					itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
			}
			createReq.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
		}
	}
	if data.DefaultPool != nil {
		default_poolMap := make(map[string]interface{})
		if data.DefaultPool.AdvancedOptions != nil {
			advanced_optionsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsUnknown() {
				advanced_optionsNestedMap["connection_timeout"] = data.DefaultPool.AdvancedOptions.ConnectionTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsUnknown() {
				advanced_optionsNestedMap["http_idle_timeout"] = data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.PanicThreshold.IsNull() && !data.DefaultPool.AdvancedOptions.PanicThreshold.IsUnknown() {
				advanced_optionsNestedMap["panic_threshold"] = data.DefaultPool.AdvancedOptions.PanicThreshold.ValueInt64()
			}
			default_poolMap["advanced_options"] = advanced_optionsNestedMap
		}
		if data.DefaultPool.AutomaticPort != nil {
			default_poolMap["automatic_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.EndpointSelection.IsNull() && !data.DefaultPool.EndpointSelection.IsUnknown() {
			default_poolMap["endpoint_selection"] = data.DefaultPool.EndpointSelection.ValueString()
		}
		if !data.DefaultPool.HealthCheckPort.IsNull() && !data.DefaultPool.HealthCheckPort.IsUnknown() {
			default_poolMap["health_check_port"] = data.DefaultPool.HealthCheckPort.ValueInt64()
		}
		if len(data.DefaultPool.Healthcheck) > 0 {
			var healthcheckList []map[string]interface{}
			for _, listItem := range data.DefaultPool.Healthcheck {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				healthcheckList = append(healthcheckList, listItemMap)
			}
			default_poolMap["healthcheck"] = healthcheckList
		}
		if data.DefaultPool.LBPort != nil {
			default_poolMap["lb_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.LoadBalancerAlgorithm.IsNull() && !data.DefaultPool.LoadBalancerAlgorithm.IsUnknown() {
			default_poolMap["loadbalancer_algorithm"] = data.DefaultPool.LoadBalancerAlgorithm.ValueString()
		}
		if data.DefaultPool.NoTLS != nil {
			default_poolMap["no_tls"] = map[string]interface{}{}
		}
		if len(data.DefaultPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.DefaultPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if listItem.CbipService != nil {
					cbip_serviceDeepMap := make(map[string]interface{})
					if !listItem.CbipService.ServiceName.IsNull() && !listItem.CbipService.ServiceName.IsUnknown() {
						cbip_serviceDeepMap["service_name"] = listItem.CbipService.ServiceName.ValueString()
					}
					listItemMap["cbip_service"] = cbip_serviceDeepMap
				}
				if listItem.ConsulService != nil {
					consul_serviceDeepMap := make(map[string]interface{})
					if listItem.ConsulService.InsideNetwork != nil {
						consul_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.ConsulService.OutsideNetwork != nil {
						consul_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.ConsulService.ServiceName.IsNull() && !listItem.ConsulService.ServiceName.IsUnknown() {
						consul_serviceDeepMap["service_name"] = listItem.ConsulService.ServiceName.ValueString()
					}
					listItemMap["consul_service"] = consul_serviceDeepMap
				}
				if listItem.CustomEndpointObject != nil {
					custom_endpoint_objectDeepMap := make(map[string]interface{})
					listItemMap["custom_endpoint_object"] = custom_endpoint_objectDeepMap
				}
				if listItem.K8SService != nil {
					k8s_serviceDeepMap := make(map[string]interface{})
					if listItem.K8SService.InsideNetwork != nil {
						k8s_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.K8SService.OutsideNetwork != nil {
						k8s_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.K8SService.Protocol.IsNull() && !listItem.K8SService.Protocol.IsUnknown() {
						k8s_serviceDeepMap["protocol"] = listItem.K8SService.Protocol.ValueString()
					}
					if !listItem.K8SService.ServiceName.IsNull() && !listItem.K8SService.ServiceName.IsUnknown() {
						k8s_serviceDeepMap["service_name"] = listItem.K8SService.ServiceName.ValueString()
					}
					if listItem.K8SService.Vk8sNetworks != nil {
						k8s_serviceDeepMap["vk8s_networks"] = map[string]interface{}{}
					}
					listItemMap["k8s_service"] = k8s_serviceDeepMap
				}
				if listItem.Labels != nil {
					listItemMap["labels"] = map[string]interface{}{}
				}
				if listItem.PrivateIP != nil {
					private_ipDeepMap := make(map[string]interface{})
					if listItem.PrivateIP.InsideNetwork != nil {
						private_ipDeepMap["inside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateIP.IP.IsNull() && !listItem.PrivateIP.IP.IsUnknown() {
						private_ipDeepMap["ip"] = listItem.PrivateIP.IP.ValueString()
					}
					if listItem.PrivateIP.OutsideNetwork != nil {
						private_ipDeepMap["outside_network"] = map[string]interface{}{}
					}
					listItemMap["private_ip"] = private_ipDeepMap
				}
				if listItem.PrivateName != nil {
					private_nameDeepMap := make(map[string]interface{})
					if !listItem.PrivateName.DNSName.IsNull() && !listItem.PrivateName.DNSName.IsUnknown() {
						private_nameDeepMap["dns_name"] = listItem.PrivateName.DNSName.ValueString()
					}
					if listItem.PrivateName.InsideNetwork != nil {
						private_nameDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.PrivateName.OutsideNetwork != nil {
						private_nameDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateName.RefreshInterval.IsNull() && !listItem.PrivateName.RefreshInterval.IsUnknown() {
						private_nameDeepMap["refresh_interval"] = listItem.PrivateName.RefreshInterval.ValueInt64()
					}
					listItemMap["private_name"] = private_nameDeepMap
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				if listItem.VnPrivateIP != nil {
					vn_private_ipDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateIP.IP.IsNull() && !listItem.VnPrivateIP.IP.IsUnknown() {
						vn_private_ipDeepMap["ip"] = listItem.VnPrivateIP.IP.ValueString()
					}
					listItemMap["vn_private_ip"] = vn_private_ipDeepMap
				}
				if listItem.VnPrivateName != nil {
					vn_private_nameDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateName.DNSName.IsNull() && !listItem.VnPrivateName.DNSName.IsUnknown() {
						vn_private_nameDeepMap["dns_name"] = listItem.VnPrivateName.DNSName.ValueString()
					}
					listItemMap["vn_private_name"] = vn_private_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			default_poolMap["origin_servers"] = origin_serversList
		}
		if !data.DefaultPool.Port.IsNull() && !data.DefaultPool.Port.IsUnknown() {
			default_poolMap["port"] = data.DefaultPool.Port.ValueInt64()
		}
		if data.DefaultPool.SameAsEndpointPort != nil {
			default_poolMap["same_as_endpoint_port"] = map[string]interface{}{}
		}
		if data.DefaultPool.UpstreamConnPoolReuseType != nil {
			upstream_conn_pool_reuse_typeNestedMap := make(map[string]interface{})
			default_poolMap["upstream_conn_pool_reuse_type"] = upstream_conn_pool_reuse_typeNestedMap
		}
		if data.DefaultPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.UseTLS.MaxSessionKeys.IsNull() && !data.DefaultPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.DefaultPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.DefaultPool.UseTLS.Sni.IsNull() && !data.DefaultPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.DefaultPool.UseTLS.Sni.ValueString()
			}
			default_poolMap["use_tls"] = use_tlsNestedMap
		}
		if data.DefaultPool.ViewInternal != nil {
			view_internalNestedMap := make(map[string]interface{})
			if !data.DefaultPool.ViewInternal.Name.IsNull() && !data.DefaultPool.ViewInternal.Name.IsUnknown() {
				view_internalNestedMap["name"] = data.DefaultPool.ViewInternal.Name.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Namespace.IsNull() && !data.DefaultPool.ViewInternal.Namespace.IsUnknown() {
				view_internalNestedMap["namespace"] = data.DefaultPool.ViewInternal.Namespace.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Tenant.IsNull() && !data.DefaultPool.ViewInternal.Tenant.IsUnknown() {
				view_internalNestedMap["tenant"] = data.DefaultPool.ViewInternal.Tenant.ValueString()
			}
			default_poolMap["view_internal"] = view_internalNestedMap
		}
		createReq.Spec["default_pool"] = default_poolMap
	}
	if data.DefaultPoolList != nil {
		default_pool_listMap := make(map[string]interface{})
		if len(data.DefaultPoolList.Pools) > 0 {
			var poolsList []map[string]interface{}
			for _, listItem := range data.DefaultPoolList.Pools {
				listItemMap := make(map[string]interface{})
				if listItem.Cluster != nil {
					clusterDeepMap := make(map[string]interface{})
					if !listItem.Cluster.Name.IsNull() && !listItem.Cluster.Name.IsUnknown() {
						clusterDeepMap["name"] = listItem.Cluster.Name.ValueString()
					}
					if !listItem.Cluster.Namespace.IsNull() && !listItem.Cluster.Namespace.IsUnknown() {
						clusterDeepMap["namespace"] = listItem.Cluster.Namespace.ValueString()
					}
					if !listItem.Cluster.Tenant.IsNull() && !listItem.Cluster.Tenant.IsUnknown() {
						clusterDeepMap["tenant"] = listItem.Cluster.Tenant.ValueString()
					}
					listItemMap["cluster"] = clusterDeepMap
				}
				if listItem.EndpointSubsets != nil {
					listItemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if listItem.Pool != nil {
					poolDeepMap := make(map[string]interface{})
					if !listItem.Pool.Name.IsNull() && !listItem.Pool.Name.IsUnknown() {
						poolDeepMap["name"] = listItem.Pool.Name.ValueString()
					}
					if !listItem.Pool.Namespace.IsNull() && !listItem.Pool.Namespace.IsUnknown() {
						poolDeepMap["namespace"] = listItem.Pool.Namespace.ValueString()
					}
					if !listItem.Pool.Tenant.IsNull() && !listItem.Pool.Tenant.IsUnknown() {
						poolDeepMap["tenant"] = listItem.Pool.Tenant.ValueString()
					}
					listItemMap["pool"] = poolDeepMap
				}
				if !listItem.Priority.IsNull() && !listItem.Priority.IsUnknown() {
					listItemMap["priority"] = listItem.Priority.ValueInt64()
				}
				if !listItem.Weight.IsNull() && !listItem.Weight.IsUnknown() {
					listItemMap["weight"] = listItem.Weight.ValueInt64()
				}
				poolsList = append(poolsList, listItemMap)
			}
			default_pool_listMap["pools"] = poolsList
		}
		createReq.Spec["default_pool_list"] = default_pool_listMap
	}
	if !data.DefaultRoutePools.IsNull() && !data.DefaultRoutePools.IsUnknown() {
		var default_route_poolsItems []HTTPLoadBalancerDefaultRoutePoolsModel
		diags := data.DefaultRoutePools.ElementsAs(ctx, &default_route_poolsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(default_route_poolsItems) > 0 {
			var default_route_poolsList []map[string]interface{}
			for _, item := range default_route_poolsItems {
				itemMap := make(map[string]interface{})
				if item.Cluster != nil {
					clusterNestedMap := make(map[string]interface{})
					if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
						clusterNestedMap["name"] = item.Cluster.Name.ValueString()
					}
					if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
						clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
					}
					if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
						clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
					}
					itemMap["cluster"] = clusterNestedMap
				}
				if item.EndpointSubsets != nil {
					itemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if item.Pool != nil {
					poolNestedMap := make(map[string]interface{})
					if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
						poolNestedMap["name"] = item.Pool.Name.ValueString()
					}
					if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
						poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
					}
					if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
						poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
					}
					itemMap["pool"] = poolNestedMap
				}
				if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
					itemMap["priority"] = item.Priority.ValueInt64()
				}
				if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
					itemMap["weight"] = item.Weight.ValueInt64()
				}
				default_route_poolsList = append(default_route_poolsList, itemMap)
			}
			createReq.Spec["default_route_pools"] = default_route_poolsList
		}
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		createReq.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		createReq.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		createReq.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableAPITesting != nil {
		disable_api_testingMap := make(map[string]interface{})
		createReq.Spec["disable_api_testing"] = disable_api_testingMap
	}
	if data.DisableBotDefense != nil {
		disable_bot_defenseMap := make(map[string]interface{})
		createReq.Spec["disable_bot_defense"] = disable_bot_defenseMap
	}
	if data.DisableCaching != nil {
		disable_cachingMap := make(map[string]interface{})
		createReq.Spec["disable_caching"] = disable_cachingMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		createReq.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		createReq.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		createReq.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableMalwareProtection != nil {
		disable_malware_protectionMap := make(map[string]interface{})
		createReq.Spec["disable_malware_protection"] = disable_malware_protectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		createReq.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		createReq.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableTrustClientIPHeaders != nil {
		disable_trust_client_ip_headersMap := make(map[string]interface{})
		createReq.Spec["disable_trust_client_ip_headers"] = disable_trust_client_ip_headersMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		createReq.Spec["disable_waf"] = disable_wafMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		createReq.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			createReq.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		createReq.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		createReq.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		if !data.EnableIPReputation.IPThreatCategories.IsNull() && !data.EnableIPReputation.IPThreatCategories.IsUnknown() {
			var ip_threat_categoriesItems []string
			diags := data.EnableIPReputation.IPThreatCategories.ElementsAs(ctx, &ip_threat_categoriesItems, false)
			if !diags.HasError() {
				enable_ip_reputationMap["ip_threat_categories"] = ip_threat_categoriesItems
			}
		}
		createReq.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		createReq.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		createReq.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if data.EnableTrustClientIPHeaders != nil {
		enable_trust_client_ip_headersMap := make(map[string]interface{})
		if !data.EnableTrustClientIPHeaders.ClientIPHeaders.IsNull() && !data.EnableTrustClientIPHeaders.ClientIPHeaders.IsUnknown() {
			var client_ip_headersItems []string
			diags := data.EnableTrustClientIPHeaders.ClientIPHeaders.ElementsAs(ctx, &client_ip_headersItems, false)
			if !diags.HasError() {
				enable_trust_client_ip_headersMap["client_ip_headers"] = client_ip_headersItems
			}
		}
		createReq.Spec["enable_trust_client_ip_headers"] = enable_trust_client_ip_headersMap
	}
	if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
		var graphql_rulesItems []HTTPLoadBalancerGraphqlRulesModel
		diags := data.GraphqlRules.ElementsAs(ctx, &graphql_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(graphql_rulesItems) > 0 {
			var graphql_rulesList []map[string]interface{}
			for _, item := range graphql_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
					itemMap["exact_path"] = item.ExactPath.ValueString()
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.GraphqlSettings != nil {
					graphql_settingsNestedMap := make(map[string]interface{})
					if item.GraphqlSettings.DisableIntrospection != nil {
						graphql_settingsNestedMap["disable_introspection"] = map[string]interface{}{}
					}
					if item.GraphqlSettings.EnableIntrospection != nil {
						graphql_settingsNestedMap["enable_introspection"] = map[string]interface{}{}
					}
					if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
						graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
					}
					if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
						graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
					}
					if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
						graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
					}
					itemMap["graphql_settings"] = graphql_settingsNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.MethodGet != nil {
					itemMap["method_get"] = map[string]interface{}{}
				}
				if item.MethodPost != nil {
					itemMap["method_post"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				graphql_rulesList = append(graphql_rulesList, itemMap)
			}
			createReq.Spec["graphql_rules"] = graphql_rulesList
		}
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		createReq.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.AppendServerName.IsNull() && !data.HTTPS.AppendServerName.IsUnknown() {
			httpsMap["append_server_name"] = data.HTTPS.AppendServerName.ValueString()
		}
		if data.HTTPS.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			httpsMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPS.ConnectionIdleTimeout.IsNull() && !data.HTTPS.ConnectionIdleTimeout.IsUnknown() {
			httpsMap["connection_idle_timeout"] = data.HTTPS.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPS.DefaultHeader != nil {
			httpsMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPS.DefaultLoadBalancer != nil {
			httpsMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.DisablePathNormalize != nil {
			httpsMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.EnablePathNormalize != nil {
			httpsMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			httpsMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.NonDefaultLoadBalancer != nil {
			httpsMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.PassThrough != nil {
			httpsMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPS.Port.IsNull() && !data.HTTPS.Port.IsUnknown() {
			httpsMap["port"] = data.HTTPS.Port.ValueInt64()
		}
		if !data.HTTPS.PortRanges.IsNull() && !data.HTTPS.PortRanges.IsUnknown() {
			httpsMap["port_ranges"] = data.HTTPS.PortRanges.ValueString()
		}
		if !data.HTTPS.ServerName.IsNull() && !data.HTTPS.ServerName.IsUnknown() {
			httpsMap["server_name"] = data.HTTPS.ServerName.ValueString()
		}
		if data.HTTPS.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.HTTPS.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			httpsMap["tls_parameters"] = tls_parametersNestedMap
		}
		createReq.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.AppendServerName.IsNull() && !data.HTTPSAutoCert.AppendServerName.IsUnknown() {
			https_auto_certMap["append_server_name"] = data.HTTPSAutoCert.AppendServerName.ValueString()
		}
		if data.HTTPSAutoCert.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPSAutoCert.ConnectionIdleTimeout.IsNull() && !data.HTTPSAutoCert.ConnectionIdleTimeout.IsUnknown() {
			https_auto_certMap["connection_idle_timeout"] = data.HTTPSAutoCert.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPSAutoCert.DefaultHeader != nil {
			https_auto_certMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DefaultLoadBalancer != nil {
			https_auto_certMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DisablePathNormalize != nil {
			https_auto_certMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.EnablePathNormalize != nil {
			https_auto_certMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.NoMtls != nil {
			https_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.NonDefaultLoadBalancer != nil {
			https_auto_certMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.PassThrough != nil {
			https_auto_certMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPSAutoCert.Port.IsNull() && !data.HTTPSAutoCert.Port.IsUnknown() {
			https_auto_certMap["port"] = data.HTTPSAutoCert.Port.ValueInt64()
		}
		if !data.HTTPSAutoCert.PortRanges.IsNull() && !data.HTTPSAutoCert.PortRanges.IsUnknown() {
			https_auto_certMap["port_ranges"] = data.HTTPSAutoCert.PortRanges.ValueString()
		}
		if !data.HTTPSAutoCert.ServerName.IsNull() && !data.HTTPSAutoCert.ServerName.IsUnknown() {
			https_auto_certMap["server_name"] = data.HTTPSAutoCert.ServerName.ValueString()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.HTTPSAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.HTTPSAutoCert.UseMtls.TrustedCAURL.IsNull() && !data.HTTPSAutoCert.UseMtls.TrustedCAURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.HTTPSAutoCert.UseMtls.TrustedCAURL.ValueString()
			}
			https_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		createReq.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		createReq.Spec["js_challenge"] = js_challengeMap
	}
	if data.JWTValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JWTValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JWTValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JWTValidation.JwksConfig.Cleartext.IsNull() && !data.JWTValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JWTValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JWTValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JWTValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JWTValidation.ReservedClaims.Issuer.IsNull() && !data.JWTValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JWTValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JWTValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JWTValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		createReq.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DDOSActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		createReq.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DDOSActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		createReq.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DDOSActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DDOSActionJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DDOSActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DDOSActionJsChallenge.CustomPage.IsNull() && !data.L7DDOSActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DDOSActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DDOSActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DDOSActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		createReq.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.L7DDOSProtection != nil {
		l7_ddos_protectionMap := make(map[string]interface{})
		if data.L7DDOSProtection.ClientsideActionCaptchaChallenge != nil {
			clientside_action_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CustomPage.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["custom_page"] = data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["clientside_action_captcha_challenge"] = clientside_action_captcha_challengeNestedMap
		}
		if data.L7DDOSProtection.ClientsideActionJsChallenge != nil {
			clientside_action_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.ClientsideActionJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.ClientsideActionJsChallenge.CookieExpiry.IsUnknown() {
				clientside_action_js_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.ClientsideActionJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.ClientsideActionJsChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.ClientsideActionJsChallenge.CustomPage.IsUnknown() {
				clientside_action_js_challengeNestedMap["custom_page"] = data.L7DDOSProtection.ClientsideActionJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DDOSProtection.ClientsideActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSProtection.ClientsideActionJsChallenge.JsScriptDelay.IsUnknown() {
				clientside_action_js_challengeNestedMap["js_script_delay"] = data.L7DDOSProtection.ClientsideActionJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["clientside_action_js_challenge"] = clientside_action_js_challengeNestedMap
		}
		if data.L7DDOSProtection.ClientsideActionNone != nil {
			l7_ddos_protectionMap["clientside_action_none"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.DDOSPolicyCustom != nil {
			ddos_policy_customNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.DDOSPolicyCustom.Name.IsNull() && !data.L7DDOSProtection.DDOSPolicyCustom.Name.IsUnknown() {
				ddos_policy_customNestedMap["name"] = data.L7DDOSProtection.DDOSPolicyCustom.Name.ValueString()
			}
			if !data.L7DDOSProtection.DDOSPolicyCustom.Namespace.IsNull() && !data.L7DDOSProtection.DDOSPolicyCustom.Namespace.IsUnknown() {
				ddos_policy_customNestedMap["namespace"] = data.L7DDOSProtection.DDOSPolicyCustom.Namespace.ValueString()
			}
			if !data.L7DDOSProtection.DDOSPolicyCustom.Tenant.IsNull() && !data.L7DDOSProtection.DDOSPolicyCustom.Tenant.IsUnknown() {
				ddos_policy_customNestedMap["tenant"] = data.L7DDOSProtection.DDOSPolicyCustom.Tenant.ValueString()
			}
			l7_ddos_protectionMap["ddos_policy_custom"] = ddos_policy_customNestedMap
		}
		if data.L7DDOSProtection.DDOSPolicyNone != nil {
			l7_ddos_protectionMap["ddos_policy_none"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.DefaultRpsThreshold != nil {
			l7_ddos_protectionMap["default_rps_threshold"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.MitigationBlock != nil {
			l7_ddos_protectionMap["mitigation_block"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.MitigationCaptchaChallenge != nil {
			mitigation_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.MitigationCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.MitigationCaptchaChallenge.CookieExpiry.IsUnknown() {
				mitigation_captcha_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.MitigationCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.MitigationCaptchaChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.MitigationCaptchaChallenge.CustomPage.IsUnknown() {
				mitigation_captcha_challengeNestedMap["custom_page"] = data.L7DDOSProtection.MitigationCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["mitigation_captcha_challenge"] = mitigation_captcha_challengeNestedMap
		}
		if data.L7DDOSProtection.MitigationJsChallenge != nil {
			mitigation_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.MitigationJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.MitigationJsChallenge.CookieExpiry.IsUnknown() {
				mitigation_js_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.MitigationJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.MitigationJsChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.MitigationJsChallenge.CustomPage.IsUnknown() {
				mitigation_js_challengeNestedMap["custom_page"] = data.L7DDOSProtection.MitigationJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DDOSProtection.MitigationJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSProtection.MitigationJsChallenge.JsScriptDelay.IsUnknown() {
				mitigation_js_challengeNestedMap["js_script_delay"] = data.L7DDOSProtection.MitigationJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["mitigation_js_challenge"] = mitigation_js_challengeNestedMap
		}
		if !data.L7DDOSProtection.RpsThreshold.IsNull() && !data.L7DDOSProtection.RpsThreshold.IsUnknown() {
			l7_ddos_protectionMap["rps_threshold"] = data.L7DDOSProtection.RpsThreshold.ValueInt64()
		}
		createReq.Spec["l7_ddos_protection"] = l7_ddos_protectionMap
	}
	if data.LeastActive != nil {
		least_activeMap := make(map[string]interface{})
		createReq.Spec["least_active"] = least_activeMap
	}
	if data.MalwareProtectionSettings != nil {
		malware_protection_settingsMap := make(map[string]interface{})
		if len(data.MalwareProtectionSettings.MalwareProtectionRules) > 0 {
			var malware_protection_rulesList []map[string]interface{}
			for _, listItem := range data.MalwareProtectionSettings.MalwareProtectionRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Block != nil {
						actionDeepMap["block"] = map[string]interface{}{}
					}
					if listItem.Action.Report != nil {
						actionDeepMap["report"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.Domain != nil {
					domainDeepMap := make(map[string]interface{})
					if listItem.Domain.AnyDomain != nil {
						domainDeepMap["any_domain"] = map[string]interface{}{}
					}
					listItemMap["domain"] = domainDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.Path != nil {
					pathDeepMap := make(map[string]interface{})
					if !listItem.Path.Path.IsNull() && !listItem.Path.Path.IsUnknown() {
						pathDeepMap["path"] = listItem.Path.Path.ValueString()
					}
					if !listItem.Path.Prefix.IsNull() && !listItem.Path.Prefix.IsUnknown() {
						pathDeepMap["prefix"] = listItem.Path.Prefix.ValueString()
					}
					if !listItem.Path.Regex.IsNull() && !listItem.Path.Regex.IsUnknown() {
						pathDeepMap["regex"] = listItem.Path.Regex.ValueString()
					}
					listItemMap["path"] = pathDeepMap
				}
				malware_protection_rulesList = append(malware_protection_rulesList, listItemMap)
			}
			malware_protection_settingsMap["malware_protection_rules"] = malware_protection_rulesList
		}
		createReq.Spec["malware_protection_settings"] = malware_protection_settingsMap
	}
	if data.MoreOption != nil {
		more_optionMap := make(map[string]interface{})
		if data.MoreOption.BufferPolicy != nil {
			buffer_policyNestedMap := make(map[string]interface{})
			if !data.MoreOption.BufferPolicy.Disabled.IsNull() && !data.MoreOption.BufferPolicy.Disabled.IsUnknown() {
				buffer_policyNestedMap["disabled"] = data.MoreOption.BufferPolicy.Disabled.ValueBool()
			}
			if !data.MoreOption.BufferPolicy.MaxRequestBytes.IsNull() && !data.MoreOption.BufferPolicy.MaxRequestBytes.IsUnknown() {
				buffer_policyNestedMap["max_request_bytes"] = data.MoreOption.BufferPolicy.MaxRequestBytes.ValueInt64()
			}
			more_optionMap["buffer_policy"] = buffer_policyNestedMap
		}
		if data.MoreOption.CompressionParams != nil {
			compression_paramsNestedMap := make(map[string]interface{})
			if !data.MoreOption.CompressionParams.ContentLength.IsNull() && !data.MoreOption.CompressionParams.ContentLength.IsUnknown() {
				compression_paramsNestedMap["content_length"] = data.MoreOption.CompressionParams.ContentLength.ValueInt64()
			}
			if !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsNull() && !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsUnknown() {
				compression_paramsNestedMap["disable_on_etag_header"] = data.MoreOption.CompressionParams.DisableOnEtagHeader.ValueBool()
			}
			if !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsNull() && !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsUnknown() {
				compression_paramsNestedMap["remove_accept_encoding_header"] = data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.ValueBool()
			}
			more_optionMap["compression_params"] = compression_paramsNestedMap
		}
		if data.MoreOption.CustomErrors != nil {
			more_optionMap["custom_errors"] = map[string]interface{}{}
		}
		if !data.MoreOption.DisableDefaultErrorPages.IsNull() && !data.MoreOption.DisableDefaultErrorPages.IsUnknown() {
			more_optionMap["disable_default_error_pages"] = data.MoreOption.DisableDefaultErrorPages.ValueBool()
		}
		if data.MoreOption.DisablePathNormalize != nil {
			more_optionMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.MoreOption.EnablePathNormalize != nil {
			more_optionMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if !data.MoreOption.IdleTimeout.IsNull() && !data.MoreOption.IdleTimeout.IsUnknown() {
			more_optionMap["idle_timeout"] = data.MoreOption.IdleTimeout.ValueInt64()
		}
		if !data.MoreOption.MaxRequestHeaderSize.IsNull() && !data.MoreOption.MaxRequestHeaderSize.IsUnknown() {
			more_optionMap["max_request_header_size"] = data.MoreOption.MaxRequestHeaderSize.ValueInt64()
		}
		if len(data.MoreOption.RequestCookiesToAdd) > 0 {
			var request_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_cookies_to_addList = append(request_cookies_to_addList, listItemMap)
			}
			more_optionMap["request_cookies_to_add"] = request_cookies_to_addList
		}
		if !data.MoreOption.RequestCookiesToRemove.IsNull() && !data.MoreOption.RequestCookiesToRemove.IsUnknown() {
			var request_cookies_to_removeItems []string
			diags := data.MoreOption.RequestCookiesToRemove.ElementsAs(ctx, &request_cookies_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["request_cookies_to_remove"] = request_cookies_to_removeItems
			}
		}
		if len(data.MoreOption.RequestHeadersToAdd) > 0 {
			var request_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_headers_to_addList = append(request_headers_to_addList, listItemMap)
			}
			more_optionMap["request_headers_to_add"] = request_headers_to_addList
		}
		if !data.MoreOption.RequestHeadersToRemove.IsNull() && !data.MoreOption.RequestHeadersToRemove.IsUnknown() {
			var request_headers_to_removeItems []string
			diags := data.MoreOption.RequestHeadersToRemove.ElementsAs(ctx, &request_headers_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["request_headers_to_remove"] = request_headers_to_removeItems
			}
		}
		if len(data.MoreOption.ResponseCookiesToAdd) > 0 {
			var response_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.AddDomain.IsNull() && !listItem.AddDomain.IsUnknown() {
					listItemMap["add_domain"] = listItem.AddDomain.ValueString()
				}
				if !listItem.AddExpiry.IsNull() && !listItem.AddExpiry.IsUnknown() {
					listItemMap["add_expiry"] = listItem.AddExpiry.ValueString()
				}
				if listItem.AddHttponly != nil {
					listItemMap["add_httponly"] = map[string]interface{}{}
				}
				if listItem.AddPartitioned != nil {
					listItemMap["add_partitioned"] = map[string]interface{}{}
				}
				if !listItem.AddPath.IsNull() && !listItem.AddPath.IsUnknown() {
					listItemMap["add_path"] = listItem.AddPath.ValueString()
				}
				if listItem.AddSecure != nil {
					listItemMap["add_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreDomain != nil {
					listItemMap["ignore_domain"] = map[string]interface{}{}
				}
				if listItem.IgnoreExpiry != nil {
					listItemMap["ignore_expiry"] = map[string]interface{}{}
				}
				if listItem.IgnoreHttponly != nil {
					listItemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if listItem.IgnoreMaxAge != nil {
					listItemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if listItem.IgnorePartitioned != nil {
					listItemMap["ignore_partitioned"] = map[string]interface{}{}
				}
				if listItem.IgnorePath != nil {
					listItemMap["ignore_path"] = map[string]interface{}{}
				}
				if listItem.IgnoreSamesite != nil {
					listItemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if listItem.IgnoreSecure != nil {
					listItemMap["ignore_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreValue != nil {
					listItemMap["ignore_value"] = map[string]interface{}{}
				}
				if !listItem.MaxAgeValue.IsNull() && !listItem.MaxAgeValue.IsUnknown() {
					listItemMap["max_age_value"] = listItem.MaxAgeValue.ValueInt64()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SamesiteLax != nil {
					listItemMap["samesite_lax"] = map[string]interface{}{}
				}
				if listItem.SamesiteNone != nil {
					listItemMap["samesite_none"] = map[string]interface{}{}
				}
				if listItem.SamesiteStrict != nil {
					listItemMap["samesite_strict"] = map[string]interface{}{}
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_cookies_to_addList = append(response_cookies_to_addList, listItemMap)
			}
			more_optionMap["response_cookies_to_add"] = response_cookies_to_addList
		}
		if !data.MoreOption.ResponseCookiesToRemove.IsNull() && !data.MoreOption.ResponseCookiesToRemove.IsUnknown() {
			var response_cookies_to_removeItems []string
			diags := data.MoreOption.ResponseCookiesToRemove.ElementsAs(ctx, &response_cookies_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["response_cookies_to_remove"] = response_cookies_to_removeItems
			}
		}
		if len(data.MoreOption.ResponseHeadersToAdd) > 0 {
			var response_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_headers_to_addList = append(response_headers_to_addList, listItemMap)
			}
			more_optionMap["response_headers_to_add"] = response_headers_to_addList
		}
		if !data.MoreOption.ResponseHeadersToRemove.IsNull() && !data.MoreOption.ResponseHeadersToRemove.IsUnknown() {
			var response_headers_to_removeItems []string
			diags := data.MoreOption.ResponseHeadersToRemove.ElementsAs(ctx, &response_headers_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["response_headers_to_remove"] = response_headers_to_removeItems
			}
		}
		createReq.Spec["more_option"] = more_optionMap
	}
	if data.MultiLBApp != nil {
		multi_lb_appMap := make(map[string]interface{})
		createReq.Spec["multi_lb_app"] = multi_lb_appMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		createReq.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		createReq.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginServerSubsetRuleList != nil {
		origin_server_subset_rule_listMap := make(map[string]interface{})
		if len(data.OriginServerSubsetRuleList.OriginServerSubsetRules) > 0 {
			var origin_server_subset_rulesList []map[string]interface{}
			for _, listItem := range data.OriginServerSubsetRuleList.OriginServerSubsetRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyAsn != nil {
					listItemMap["any_asn"] = map[string]interface{}{}
				}
				if listItem.AnyIP != nil {
					listItemMap["any_ip"] = map[string]interface{}{}
				}
				if listItem.AsnList != nil {
					asn_listDeepMap := make(map[string]interface{})
					listItemMap["asn_list"] = asn_listDeepMap
				}
				if listItem.AsnMatcher != nil {
					asn_matcherDeepMap := make(map[string]interface{})
					listItemMap["asn_matcher"] = asn_matcherDeepMap
				}
				if listItem.ClientSelector != nil {
					client_selectorDeepMap := make(map[string]interface{})
					listItemMap["client_selector"] = client_selectorDeepMap
				}
				if listItem.IPMatcher != nil {
					ip_matcherDeepMap := make(map[string]interface{})
					if !listItem.IPMatcher.InvertMatcher.IsNull() && !listItem.IPMatcher.InvertMatcher.IsUnknown() {
						ip_matcherDeepMap["invert_matcher"] = listItem.IPMatcher.InvertMatcher.ValueBool()
					}
					listItemMap["ip_matcher"] = ip_matcherDeepMap
				}
				if listItem.IPPrefixList != nil {
					ip_prefix_listDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixList.InvertMatch.IsNull() && !listItem.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listDeepMap["invert_match"] = listItem.IPPrefixList.InvertMatch.ValueBool()
					}
					listItemMap["ip_prefix_list"] = ip_prefix_listDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.None != nil {
					listItemMap["none"] = map[string]interface{}{}
				}
				if listItem.OriginServerSubsetsAction != nil {
					listItemMap["origin_server_subsets_action"] = map[string]interface{}{}
				}
				origin_server_subset_rulesList = append(origin_server_subset_rulesList, listItemMap)
			}
			origin_server_subset_rule_listMap["origin_server_subset_rules"] = origin_server_subset_rulesList
		}
		createReq.Spec["origin_server_subset_rule_list"] = origin_server_subset_rule_listMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		createReq.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
		var protected_cookiesItems []HTTPLoadBalancerProtectedCookiesModel
		diags := data.ProtectedCookies.ElementsAs(ctx, &protected_cookiesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(protected_cookiesItems) > 0 {
			var protected_cookiesList []map[string]interface{}
			for _, item := range protected_cookiesItems {
				itemMap := make(map[string]interface{})
				if item.AddHttponly != nil {
					itemMap["add_httponly"] = map[string]interface{}{}
				}
				if item.AddSecure != nil {
					itemMap["add_secure"] = map[string]interface{}{}
				}
				if item.DisableTamperingProtection != nil {
					itemMap["disable_tampering_protection"] = map[string]interface{}{}
				}
				if item.EnableTamperingProtection != nil {
					itemMap["enable_tampering_protection"] = map[string]interface{}{}
				}
				if item.IgnoreHttponly != nil {
					itemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if item.IgnoreMaxAge != nil {
					itemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if item.IgnoreSamesite != nil {
					itemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if item.IgnoreSecure != nil {
					itemMap["ignore_secure"] = map[string]interface{}{}
				}
				if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
					itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
				}
				if !item.Name.IsNull() && !item.Name.IsUnknown() {
					itemMap["name"] = item.Name.ValueString()
				}
				if item.SamesiteLax != nil {
					itemMap["samesite_lax"] = map[string]interface{}{}
				}
				if item.SamesiteNone != nil {
					itemMap["samesite_none"] = map[string]interface{}{}
				}
				if item.SamesiteStrict != nil {
					itemMap["samesite_strict"] = map[string]interface{}{}
				}
				protected_cookiesList = append(protected_cookiesList, itemMap)
			}
			createReq.Spec["protected_cookies"] = protected_cookiesList
		}
	}
	if data.Random != nil {
		randomMap := make(map[string]interface{})
		createReq.Spec["random"] = randomMap
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		createReq.Spec["rate_limit"] = rate_limitMap
	}
	if data.RingHash != nil {
		ring_hashMap := make(map[string]interface{})
		if len(data.RingHash.HashPolicy) > 0 {
			var hash_policyList []map[string]interface{}
			for _, listItem := range data.RingHash.HashPolicy {
				listItemMap := make(map[string]interface{})
				if listItem.Cookie != nil {
					cookieDeepMap := make(map[string]interface{})
					if listItem.Cookie.AddHttponly != nil {
						cookieDeepMap["add_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.AddSecure != nil {
						cookieDeepMap["add_secure"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreHttponly != nil {
						cookieDeepMap["ignore_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSamesite != nil {
						cookieDeepMap["ignore_samesite"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSecure != nil {
						cookieDeepMap["ignore_secure"] = map[string]interface{}{}
					}
					if !listItem.Cookie.Name.IsNull() && !listItem.Cookie.Name.IsUnknown() {
						cookieDeepMap["name"] = listItem.Cookie.Name.ValueString()
					}
					if !listItem.Cookie.Path.IsNull() && !listItem.Cookie.Path.IsUnknown() {
						cookieDeepMap["path"] = listItem.Cookie.Path.ValueString()
					}
					if listItem.Cookie.SamesiteLax != nil {
						cookieDeepMap["samesite_lax"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteNone != nil {
						cookieDeepMap["samesite_none"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteStrict != nil {
						cookieDeepMap["samesite_strict"] = map[string]interface{}{}
					}
					if !listItem.Cookie.TTL.IsNull() && !listItem.Cookie.TTL.IsUnknown() {
						cookieDeepMap["ttl"] = listItem.Cookie.TTL.ValueInt64()
					}
					listItemMap["cookie"] = cookieDeepMap
				}
				if !listItem.HeaderName.IsNull() && !listItem.HeaderName.IsUnknown() {
					listItemMap["header_name"] = listItem.HeaderName.ValueString()
				}
				if !listItem.SourceIP.IsNull() && !listItem.SourceIP.IsUnknown() {
					listItemMap["source_ip"] = listItem.SourceIP.ValueBool()
				}
				if !listItem.Terminal.IsNull() && !listItem.Terminal.IsUnknown() {
					listItemMap["terminal"] = listItem.Terminal.ValueBool()
				}
				hash_policyList = append(hash_policyList, listItemMap)
			}
			ring_hashMap["hash_policy"] = hash_policyList
		}
		createReq.Spec["ring_hash"] = ring_hashMap
	}
	if data.RoundRobin != nil {
		round_robinMap := make(map[string]interface{})
		createReq.Spec["round_robin"] = round_robinMap
	}
	if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
		var routesItems []HTTPLoadBalancerRoutesModel
		diags := data.Routes.ElementsAs(ctx, &routesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(routesItems) > 0 {
			var routesList []map[string]interface{}
			for _, item := range routesItems {
				itemMap := make(map[string]interface{})
				if item.CustomRouteObject != nil {
					custom_route_objectNestedMap := make(map[string]interface{})
					if item.CustomRouteObject.RouteRef != nil {
						route_refDeepMap := make(map[string]interface{})
						if !item.CustomRouteObject.RouteRef.Name.IsNull() && !item.CustomRouteObject.RouteRef.Name.IsUnknown() {
							route_refDeepMap["name"] = item.CustomRouteObject.RouteRef.Name.ValueString()
						}
						if !item.CustomRouteObject.RouteRef.Namespace.IsNull() && !item.CustomRouteObject.RouteRef.Namespace.IsUnknown() {
							route_refDeepMap["namespace"] = item.CustomRouteObject.RouteRef.Namespace.ValueString()
						}
						if !item.CustomRouteObject.RouteRef.Tenant.IsNull() && !item.CustomRouteObject.RouteRef.Tenant.IsUnknown() {
							route_refDeepMap["tenant"] = item.CustomRouteObject.RouteRef.Tenant.ValueString()
						}
						custom_route_objectNestedMap["route_ref"] = route_refDeepMap
					}
					itemMap["custom_route_object"] = custom_route_objectNestedMap
				}
				if item.DirectResponseRoute != nil {
					direct_response_routeNestedMap := make(map[string]interface{})
					if len(item.DirectResponseRoute.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.DirectResponseRoute.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						direct_response_routeNestedMap["headers"] = headersDeepList
					}
					if !item.DirectResponseRoute.HTTPMethod.IsNull() && !item.DirectResponseRoute.HTTPMethod.IsUnknown() {
						direct_response_routeNestedMap["http_method"] = item.DirectResponseRoute.HTTPMethod.ValueString()
					}
					if item.DirectResponseRoute.IncomingPort != nil {
						incoming_portDeepMap := make(map[string]interface{})
						if item.DirectResponseRoute.IncomingPort.NoPortMatch != nil {
							incoming_portDeepMap["no_port_match"] = map[string]interface{}{}
						}
						if !item.DirectResponseRoute.IncomingPort.Port.IsNull() && !item.DirectResponseRoute.IncomingPort.Port.IsUnknown() {
							incoming_portDeepMap["port"] = item.DirectResponseRoute.IncomingPort.Port.ValueInt64()
						}
						if !item.DirectResponseRoute.IncomingPort.PortRanges.IsNull() && !item.DirectResponseRoute.IncomingPort.PortRanges.IsUnknown() {
							incoming_portDeepMap["port_ranges"] = item.DirectResponseRoute.IncomingPort.PortRanges.ValueString()
						}
						direct_response_routeNestedMap["incoming_port"] = incoming_portDeepMap
					}
					if item.DirectResponseRoute.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.DirectResponseRoute.Path.Path.IsNull() && !item.DirectResponseRoute.Path.Path.IsUnknown() {
							pathDeepMap["path"] = item.DirectResponseRoute.Path.Path.ValueString()
						}
						if !item.DirectResponseRoute.Path.Prefix.IsNull() && !item.DirectResponseRoute.Path.Prefix.IsUnknown() {
							pathDeepMap["prefix"] = item.DirectResponseRoute.Path.Prefix.ValueString()
						}
						if !item.DirectResponseRoute.Path.Regex.IsNull() && !item.DirectResponseRoute.Path.Regex.IsUnknown() {
							pathDeepMap["regex"] = item.DirectResponseRoute.Path.Regex.ValueString()
						}
						direct_response_routeNestedMap["path"] = pathDeepMap
					}
					if item.DirectResponseRoute.RouteDirectResponse != nil {
						route_direct_responseDeepMap := make(map[string]interface{})
						if !item.DirectResponseRoute.RouteDirectResponse.ResponseBodyEncoded.IsNull() && !item.DirectResponseRoute.RouteDirectResponse.ResponseBodyEncoded.IsUnknown() {
							route_direct_responseDeepMap["response_body_encoded"] = item.DirectResponseRoute.RouteDirectResponse.ResponseBodyEncoded.ValueString()
						}
						if !item.DirectResponseRoute.RouteDirectResponse.ResponseCode.IsNull() && !item.DirectResponseRoute.RouteDirectResponse.ResponseCode.IsUnknown() {
							route_direct_responseDeepMap["response_code"] = item.DirectResponseRoute.RouteDirectResponse.ResponseCode.ValueInt64()
						}
						direct_response_routeNestedMap["route_direct_response"] = route_direct_responseDeepMap
					}
					itemMap["direct_response_route"] = direct_response_routeNestedMap
				}
				if item.RedirectRoute != nil {
					redirect_routeNestedMap := make(map[string]interface{})
					if len(item.RedirectRoute.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.RedirectRoute.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						redirect_routeNestedMap["headers"] = headersDeepList
					}
					if !item.RedirectRoute.HTTPMethod.IsNull() && !item.RedirectRoute.HTTPMethod.IsUnknown() {
						redirect_routeNestedMap["http_method"] = item.RedirectRoute.HTTPMethod.ValueString()
					}
					if item.RedirectRoute.IncomingPort != nil {
						incoming_portDeepMap := make(map[string]interface{})
						if item.RedirectRoute.IncomingPort.NoPortMatch != nil {
							incoming_portDeepMap["no_port_match"] = map[string]interface{}{}
						}
						if !item.RedirectRoute.IncomingPort.Port.IsNull() && !item.RedirectRoute.IncomingPort.Port.IsUnknown() {
							incoming_portDeepMap["port"] = item.RedirectRoute.IncomingPort.Port.ValueInt64()
						}
						if !item.RedirectRoute.IncomingPort.PortRanges.IsNull() && !item.RedirectRoute.IncomingPort.PortRanges.IsUnknown() {
							incoming_portDeepMap["port_ranges"] = item.RedirectRoute.IncomingPort.PortRanges.ValueString()
						}
						redirect_routeNestedMap["incoming_port"] = incoming_portDeepMap
					}
					if item.RedirectRoute.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.RedirectRoute.Path.Path.IsNull() && !item.RedirectRoute.Path.Path.IsUnknown() {
							pathDeepMap["path"] = item.RedirectRoute.Path.Path.ValueString()
						}
						if !item.RedirectRoute.Path.Prefix.IsNull() && !item.RedirectRoute.Path.Prefix.IsUnknown() {
							pathDeepMap["prefix"] = item.RedirectRoute.Path.Prefix.ValueString()
						}
						if !item.RedirectRoute.Path.Regex.IsNull() && !item.RedirectRoute.Path.Regex.IsUnknown() {
							pathDeepMap["regex"] = item.RedirectRoute.Path.Regex.ValueString()
						}
						redirect_routeNestedMap["path"] = pathDeepMap
					}
					if item.RedirectRoute.RouteRedirect != nil {
						route_redirectDeepMap := make(map[string]interface{})
						if !item.RedirectRoute.RouteRedirect.HostRedirect.IsNull() && !item.RedirectRoute.RouteRedirect.HostRedirect.IsUnknown() {
							route_redirectDeepMap["host_redirect"] = item.RedirectRoute.RouteRedirect.HostRedirect.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.PathRedirect.IsNull() && !item.RedirectRoute.RouteRedirect.PathRedirect.IsUnknown() {
							route_redirectDeepMap["path_redirect"] = item.RedirectRoute.RouteRedirect.PathRedirect.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.PrefixRewrite.IsNull() && !item.RedirectRoute.RouteRedirect.PrefixRewrite.IsUnknown() {
							route_redirectDeepMap["prefix_rewrite"] = item.RedirectRoute.RouteRedirect.PrefixRewrite.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.ProtoRedirect.IsNull() && !item.RedirectRoute.RouteRedirect.ProtoRedirect.IsUnknown() {
							route_redirectDeepMap["proto_redirect"] = item.RedirectRoute.RouteRedirect.ProtoRedirect.ValueString()
						}
						if item.RedirectRoute.RouteRedirect.RemoveAllParams != nil {
							route_redirectDeepMap["remove_all_params"] = map[string]interface{}{}
						}
						if !item.RedirectRoute.RouteRedirect.ReplaceParams.IsNull() && !item.RedirectRoute.RouteRedirect.ReplaceParams.IsUnknown() {
							route_redirectDeepMap["replace_params"] = item.RedirectRoute.RouteRedirect.ReplaceParams.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.ResponseCode.IsNull() && !item.RedirectRoute.RouteRedirect.ResponseCode.IsUnknown() {
							route_redirectDeepMap["response_code"] = item.RedirectRoute.RouteRedirect.ResponseCode.ValueInt64()
						}
						if item.RedirectRoute.RouteRedirect.RetainAllParams != nil {
							route_redirectDeepMap["retain_all_params"] = map[string]interface{}{}
						}
						redirect_routeNestedMap["route_redirect"] = route_redirectDeepMap
					}
					itemMap["redirect_route"] = redirect_routeNestedMap
				}
				if item.SimpleRoute != nil {
					simple_routeNestedMap := make(map[string]interface{})
					if item.SimpleRoute.AdvancedOptions != nil {
						advanced_optionsDeepMap := make(map[string]interface{})
						if item.SimpleRoute.AdvancedOptions.CommonBuffering != nil {
							advanced_optionsDeepMap["common_buffering"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.CommonHashPolicy != nil {
							advanced_optionsDeepMap["common_hash_policy"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DefaultRetryPolicy != nil {
							advanced_optionsDeepMap["default_retry_policy"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.AdvancedOptions.DisableLocationAdd.IsNull() && !item.SimpleRoute.AdvancedOptions.DisableLocationAdd.IsUnknown() {
							advanced_optionsDeepMap["disable_location_add"] = item.SimpleRoute.AdvancedOptions.DisableLocationAdd.ValueBool()
						}
						if item.SimpleRoute.AdvancedOptions.DisableMirroring != nil {
							advanced_optionsDeepMap["disable_mirroring"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisablePrefixRewrite != nil {
							advanced_optionsDeepMap["disable_prefix_rewrite"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisableSpdy != nil {
							advanced_optionsDeepMap["disable_spdy"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisableWAF != nil {
							advanced_optionsDeepMap["disable_waf"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisableWebSocketConfig != nil {
							advanced_optionsDeepMap["disable_web_socket_config"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DoNotRetractCluster != nil {
							advanced_optionsDeepMap["do_not_retract_cluster"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.EnableSpdy != nil {
							advanced_optionsDeepMap["enable_spdy"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.EndpointSubsets != nil {
							advanced_optionsDeepMap["endpoint_subsets"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.InheritedBotDefenseJavascriptInjection != nil {
							advanced_optionsDeepMap["inherited_bot_defense_javascript_injection"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.InheritedWAF != nil {
							advanced_optionsDeepMap["inherited_waf"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.InheritedWAFExclusion != nil {
							advanced_optionsDeepMap["inherited_waf_exclusion"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.NoRetryPolicy != nil {
							advanced_optionsDeepMap["no_retry_policy"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.AdvancedOptions.PrefixRewrite.IsNull() && !item.SimpleRoute.AdvancedOptions.PrefixRewrite.IsUnknown() {
							advanced_optionsDeepMap["prefix_rewrite"] = item.SimpleRoute.AdvancedOptions.PrefixRewrite.ValueString()
						}
						if !item.SimpleRoute.AdvancedOptions.Priority.IsNull() && !item.SimpleRoute.AdvancedOptions.Priority.IsUnknown() {
							advanced_optionsDeepMap["priority"] = item.SimpleRoute.AdvancedOptions.Priority.ValueString()
						}
						if !item.SimpleRoute.AdvancedOptions.RequestCookiesToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.RequestCookiesToRemove.IsUnknown() {
							var RequestCookiesToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.RequestCookiesToRemove.ElementsAs(ctx, &RequestCookiesToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["request_cookies_to_remove"] = RequestCookiesToRemoveItems
							}
						}
						if !item.SimpleRoute.AdvancedOptions.RequestHeadersToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.RequestHeadersToRemove.IsUnknown() {
							var RequestHeadersToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.RequestHeadersToRemove.ElementsAs(ctx, &RequestHeadersToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["request_headers_to_remove"] = RequestHeadersToRemoveItems
							}
						}
						if !item.SimpleRoute.AdvancedOptions.ResponseCookiesToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.ResponseCookiesToRemove.IsUnknown() {
							var ResponseCookiesToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.ResponseCookiesToRemove.ElementsAs(ctx, &ResponseCookiesToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["response_cookies_to_remove"] = ResponseCookiesToRemoveItems
							}
						}
						if !item.SimpleRoute.AdvancedOptions.ResponseHeadersToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.ResponseHeadersToRemove.IsUnknown() {
							var ResponseHeadersToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.ResponseHeadersToRemove.ElementsAs(ctx, &ResponseHeadersToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["response_headers_to_remove"] = ResponseHeadersToRemoveItems
							}
						}
						if item.SimpleRoute.AdvancedOptions.RetractCluster != nil {
							advanced_optionsDeepMap["retract_cluster"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.AdvancedOptions.Timeout.IsNull() && !item.SimpleRoute.AdvancedOptions.Timeout.IsUnknown() {
							advanced_optionsDeepMap["timeout"] = item.SimpleRoute.AdvancedOptions.Timeout.ValueInt64()
						}
						simple_routeNestedMap["advanced_options"] = advanced_optionsDeepMap
					}
					if item.SimpleRoute.AutoHostRewrite != nil {
						simple_routeNestedMap["auto_host_rewrite"] = map[string]interface{}{}
					}
					if item.SimpleRoute.DisableHostRewrite != nil {
						simple_routeNestedMap["disable_host_rewrite"] = map[string]interface{}{}
					}
					if len(item.SimpleRoute.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.SimpleRoute.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						simple_routeNestedMap["headers"] = headersDeepList
					}
					if !item.SimpleRoute.HostRewrite.IsNull() && !item.SimpleRoute.HostRewrite.IsUnknown() {
						simple_routeNestedMap["host_rewrite"] = item.SimpleRoute.HostRewrite.ValueString()
					}
					if !item.SimpleRoute.HTTPMethod.IsNull() && !item.SimpleRoute.HTTPMethod.IsUnknown() {
						simple_routeNestedMap["http_method"] = item.SimpleRoute.HTTPMethod.ValueString()
					}
					if item.SimpleRoute.IncomingPort != nil {
						incoming_portDeepMap := make(map[string]interface{})
						if item.SimpleRoute.IncomingPort.NoPortMatch != nil {
							incoming_portDeepMap["no_port_match"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.IncomingPort.Port.IsNull() && !item.SimpleRoute.IncomingPort.Port.IsUnknown() {
							incoming_portDeepMap["port"] = item.SimpleRoute.IncomingPort.Port.ValueInt64()
						}
						if !item.SimpleRoute.IncomingPort.PortRanges.IsNull() && !item.SimpleRoute.IncomingPort.PortRanges.IsUnknown() {
							incoming_portDeepMap["port_ranges"] = item.SimpleRoute.IncomingPort.PortRanges.ValueString()
						}
						simple_routeNestedMap["incoming_port"] = incoming_portDeepMap
					}
					if len(item.SimpleRoute.OriginPools) > 0 {
						var origin_poolsDeepList []map[string]interface{}
						for _, deepListItem := range item.SimpleRoute.OriginPools {
							deepListItemMap := make(map[string]interface{})
							if deepListItem.EndpointSubsets != nil {
								deepListItemMap["endpoint_subsets"] = map[string]interface{}{}
							}
							if !deepListItem.Priority.IsNull() && !deepListItem.Priority.IsUnknown() {
								deepListItemMap["priority"] = deepListItem.Priority.ValueInt64()
							}
							if !deepListItem.Weight.IsNull() && !deepListItem.Weight.IsUnknown() {
								deepListItemMap["weight"] = deepListItem.Weight.ValueInt64()
							}
							origin_poolsDeepList = append(origin_poolsDeepList, deepListItemMap)
						}
						simple_routeNestedMap["origin_pools"] = origin_poolsDeepList
					}
					if item.SimpleRoute.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.SimpleRoute.Path.Path.IsNull() && !item.SimpleRoute.Path.Path.IsUnknown() {
							pathDeepMap["path"] = item.SimpleRoute.Path.Path.ValueString()
						}
						if !item.SimpleRoute.Path.Prefix.IsNull() && !item.SimpleRoute.Path.Prefix.IsUnknown() {
							pathDeepMap["prefix"] = item.SimpleRoute.Path.Prefix.ValueString()
						}
						if !item.SimpleRoute.Path.Regex.IsNull() && !item.SimpleRoute.Path.Regex.IsUnknown() {
							pathDeepMap["regex"] = item.SimpleRoute.Path.Regex.ValueString()
						}
						simple_routeNestedMap["path"] = pathDeepMap
					}
					if item.SimpleRoute.QueryParams != nil {
						query_paramsDeepMap := make(map[string]interface{})
						if item.SimpleRoute.QueryParams.RemoveAllParams != nil {
							query_paramsDeepMap["remove_all_params"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.QueryParams.ReplaceParams.IsNull() && !item.SimpleRoute.QueryParams.ReplaceParams.IsUnknown() {
							query_paramsDeepMap["replace_params"] = item.SimpleRoute.QueryParams.ReplaceParams.ValueString()
						}
						if item.SimpleRoute.QueryParams.RetainAllParams != nil {
							query_paramsDeepMap["retain_all_params"] = map[string]interface{}{}
						}
						simple_routeNestedMap["query_params"] = query_paramsDeepMap
					}
					itemMap["simple_route"] = simple_routeNestedMap
				}
				routesList = append(routesList, itemMap)
			}
			createReq.Spec["routes"] = routesList
		}
	}
	if data.SensitiveDataDisclosureRules != nil {
		sensitive_data_disclosure_rulesMap := make(map[string]interface{})
		if len(data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse) > 0 {
			var sensitive_data_types_in_responseList []map[string]interface{}
			for _, listItem := range data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse {
				listItemMap := make(map[string]interface{})
				if listItem.APIEndpoint != nil {
					api_endpointDeepMap := make(map[string]interface{})
					if !listItem.APIEndpoint.Path.IsNull() && !listItem.APIEndpoint.Path.IsUnknown() {
						api_endpointDeepMap["path"] = listItem.APIEndpoint.Path.ValueString()
					}
					listItemMap["api_endpoint"] = api_endpointDeepMap
				}
				if listItem.Body != nil {
					bodyDeepMap := make(map[string]interface{})
					listItemMap["body"] = bodyDeepMap
				}
				if listItem.Mask != nil {
					listItemMap["mask"] = map[string]interface{}{}
				}
				if listItem.Report != nil {
					listItemMap["report"] = map[string]interface{}{}
				}
				sensitive_data_types_in_responseList = append(sensitive_data_types_in_responseList, listItemMap)
			}
			sensitive_data_disclosure_rulesMap["sensitive_data_types_in_response"] = sensitive_data_types_in_responseList
		}
		createReq.Spec["sensitive_data_disclosure_rules"] = sensitive_data_disclosure_rulesMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		createReq.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		createReq.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SingleLBApp != nil {
		single_lb_appMap := make(map[string]interface{})
		if data.SingleLBApp.DisableDiscovery != nil {
			single_lb_appMap["disable_discovery"] = map[string]interface{}{}
		}
		if data.SingleLBApp.DisableMaliciousUserDetection != nil {
			single_lb_appMap["disable_malicious_user_detection"] = map[string]interface{}{}
		}
		if data.SingleLBApp.EnableDiscovery != nil {
			enable_discoveryNestedMap := make(map[string]interface{})
			single_lb_appMap["enable_discovery"] = enable_discoveryNestedMap
		}
		if data.SingleLBApp.EnableMaliciousUserDetection != nil {
			single_lb_appMap["enable_malicious_user_detection"] = map[string]interface{}{}
		}
		createReq.Spec["single_lb_app"] = single_lb_appMap
	}
	if data.SlowDDOSMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDDOSMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDDOSMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDDOSMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDDOSMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDDOSMitigation.RequestTimeout.IsNull() && !data.SlowDDOSMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDDOSMitigation.RequestTimeout.ValueInt64()
		}
		createReq.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SourceIPStickiness != nil {
		source_ip_stickinessMap := make(map[string]interface{})
		createReq.Spec["source_ip_stickiness"] = source_ip_stickinessMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		createReq.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
		var trusted_clientsItems []HTTPLoadBalancerTrustedClientsModel
		diags := data.TrustedClients.ElementsAs(ctx, &trusted_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(trusted_clientsItems) > 0 {
			var trusted_clientsList []map[string]interface{}
			for _, item := range trusted_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				trusted_clientsList = append(trusted_clientsList, itemMap)
			}
			createReq.Spec["trusted_clients"] = trusted_clientsList
		}
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		createReq.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		createReq.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		createReq.Spec["waf_exclusion"] = waf_exclusionMap
	}
	if !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		createReq.Spec["add_location"] = data.AddLocation.ValueBool()
	}

	apiResource, err := r.client.CreateHTTPLoadBalancer(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create HTTPLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &HTTPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []HTTPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &HTTPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &HTTPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_protection_rules"].(map[string]interface{}); ok && (isImport || data.APIProtectionRules != nil) {
		data.APIProtectionRules = &HTTPLoadBalancerAPIProtectionRulesModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			APIGroupsRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel {
				if listData, ok := blockData["api_groups_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &HTTPLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel{}
				}
				return nil
			}(),
			IPAllowedList: func() *HTTPLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []HTTPLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &HTTPLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_testing"].(map[string]interface{}); ok && (isImport || data.APITesting != nil) {
		data.APITesting = &HTTPLoadBalancerAPITestingModel{
			CustomHeaderValue: func() types.String {
				if v, ok := blockData["custom_header_value"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domains: func() []HTTPLoadBalancerAPITestingDomainsModel {
				if listData, ok := blockData["domains"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPITestingDomainsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPITestingDomainsModel{
								AllowDestructiveMethods: func() types.Bool {
									if v, ok := itemMap["allow_destructive_methods"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Domain: func() types.String {
									if v, ok := itemMap["domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			EveryDay: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryDay
				}
				// Import case: read from API
				if _, ok := blockData["every_day"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryMonth: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryMonth
				}
				// Import case: read from API
				if _, ok := blockData["every_month"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryWeek: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryWeek
				}
				// Import case: read from API
				if _, ok := blockData["every_week"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &HTTPLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []HTTPLoadBalancerBlockedClientsModel
		var existingBlockedClientsItems []HTTPLoadBalancerBlockedClientsModel
		if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
			data.BlockedClients.ElementsAs(ctx, &existingBlockedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, HTTPLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].BotSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].SkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsModelAttrTypes}, blocked_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.BlockedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.BlockedClients = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &HTTPLoadBalancerBotDefenseModel{
			DisableCORSSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCORSSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *HTTPLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if !isImport && data.BotDefense != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.BotDefense.Timeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["bot_defense_advanced"].(map[string]interface{}); ok && isImport && data.BotDefenseAdvanced == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BotDefenseAdvanced = &HTTPLoadBalancerBotDefenseAdvancedModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["caching_policy"].(map[string]interface{}); ok && isImport && data.CachingPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CachingPolicy = &HTTPLoadBalancerCachingPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &HTTPLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CaptchaChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CaptchaChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &HTTPLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cookie_stickiness"].(map[string]interface{}); ok && (isImport || data.CookieStickiness != nil) {
		data.CookieStickiness = &HTTPLoadBalancerCookieStickinessModel{
			AddHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddHttponly
				}
				// Import case: read from API
				if _, ok := blockData["add_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			AddSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddSecure
				}
				// Import case: read from API
				if _, ok := blockData["add_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreHttponly
				}
				// Import case: read from API
				if _, ok := blockData["ignore_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSamesite
				}
				// Import case: read from API
				if _, ok := blockData["ignore_samesite"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSecure
				}
				// Import case: read from API
				if _, ok := blockData["ignore_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Path: func() types.String {
				if v, ok := blockData["path"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteLax
				}
				// Import case: read from API
				if _, ok := blockData["samesite_lax"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteNone
				}
				// Import case: read from API
				if _, ok := blockData["samesite_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteStrict
				}
				// Import case: read from API
				if _, ok := blockData["samesite_strict"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			TTL: func() types.Int64 {
				if !isImport && data.CookieStickiness != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieStickiness.TTL
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["ttl"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CORSPolicy != nil) {
		data.CORSPolicy = &HTTPLoadBalancerCORSPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.AllowCredentials
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.Disabled
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CORSPolicy.MaximumAge
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CSRFPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CSRFPolicy = &HTTPLoadBalancerCSRFPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []HTTPLoadBalancerDataGuardRulesModel
		var existingDataGuardRulesItems []HTTPLoadBalancerDataGuardRulesModel
		if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
			data.DataGuardRules.ElementsAs(ctx, &existingDataGuardRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, HTTPLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].AnyDomain != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].ApplyDataGuard != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *HTTPLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].SkipDataGuard != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesModelAttrTypes}, data_guard_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DataGuardRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DataGuardRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesModelAttrTypes})
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []HTTPLoadBalancerDDOSMitigationRulesModel
		var existingDDOSMitigationRulesItems []HTTPLoadBalancerDDOSMitigationRulesModel
		if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
			data.DDOSMitigationRules.ElementsAs(ctx, &existingDDOSMitigationRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, HTTPLoadBalancerDDOSMitigationRulesModel{
					Block: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDDOSMitigationRulesItems) > listIdx && existingDDOSMitigationRulesItems[listIdx].Block != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DDOSClientSource: func() *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerDDOSMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes}, ddos_mitigation_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DDOSMitigationRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DDOSMitigationRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["default_pool"].(map[string]interface{}); ok && (isImport || data.DefaultPool != nil) {
		data.DefaultPool = &HTTPLoadBalancerDefaultPoolModel{
			AdvancedOptions: func() *HTTPLoadBalancerDefaultPoolAdvancedOptionsModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.AdvancedOptions != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.AdvancedOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["advanced_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolAdvancedOptionsModel{
						ConnectionTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["connection_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						HTTPIdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["http_idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PanicThreshold: func() types.Int64 {
							if v, ok := nestedBlockData["panic_threshold"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			AutomaticPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.AutomaticPort
				}
				// Import case: read from API
				if _, ok := blockData["automatic_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EndpointSelection: func() types.String {
				if v, ok := blockData["endpoint_selection"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HealthCheckPort: func() types.Int64 {
				if !isImport && data.DefaultPool != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DefaultPool.HealthCheckPort
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["health_check_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Healthcheck: func() []HTTPLoadBalancerDefaultPoolHealthcheckModel {
				if listData, ok := blockData["healthcheck"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolHealthcheckModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolHealthcheckModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			LBPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.LBPort
				}
				// Import case: read from API
				if _, ok := blockData["lb_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			LoadBalancerAlgorithm: func() types.String {
				if v, ok := blockData["loadbalancer_algorithm"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoTLS: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginServers: func() []HTTPLoadBalancerDefaultPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolOriginServersModel{
								CbipService: func() *HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel {
									if deepMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel{
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ConsulService: func() *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel {
									if deepMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								CustomEndpointObject: func() *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel {
									if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel{}
									}
									return nil
								}(),
								K8SService: func() *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel {
									if deepMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Protocol: func() types.String {
												if v, ok := deepMap["protocol"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Vk8sNetworks: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["vk8s_networks"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Labels: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								PrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel {
									if deepMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								PrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel {
									if deepMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								PublicIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel {
									if deepMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel {
									if deepMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.DefaultPool != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DefaultPool.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SameAsEndpointPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.SameAsEndpointPort
				}
				// Import case: read from API
				if _, ok := blockData["same_as_endpoint_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			UpstreamConnPoolReuseType: func() *HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UpstreamConnPoolReuseType != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UpstreamConnPoolReuseType
				}
				// Import case: read from API
				if _, ok := blockData["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel{}
				}
				return nil
			}(),
			UseTLS: func() *HTTPLoadBalancerDefaultPoolUseTLSModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ViewInternal: func() *HTTPLoadBalancerDefaultPoolViewInternalModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.ViewInternal != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.ViewInternal
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["view_internal"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolViewInternalModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["default_pool_list"].(map[string]interface{}); ok && (isImport || data.DefaultPoolList != nil) {
		data.DefaultPoolList = &HTTPLoadBalancerDefaultPoolListModel{
			Pools: func() []HTTPLoadBalancerDefaultPoolListPoolsModel {
				if listData, ok := blockData["pools"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolListPoolsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolListPoolsModel{
								Cluster: func() *HTTPLoadBalancerDefaultPoolListPoolsClusterModel {
									if deepMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsClusterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["endpoint_subsets"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Pool: func() *HTTPLoadBalancerDefaultPoolListPoolsPoolModel {
									if deepMap, ok := itemMap["pool"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsPoolModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Priority: func() types.Int64 {
									if v, ok := itemMap["priority"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Weight: func() types.Int64 {
									if v, ok := itemMap["weight"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["default_route_pools"].([]interface{}); ok && len(listData) > 0 {
		var default_route_poolsList []HTTPLoadBalancerDefaultRoutePoolsModel
		var existingDefaultRoutePoolsItems []HTTPLoadBalancerDefaultRoutePoolsModel
		if !data.DefaultRoutePools.IsNull() && !data.DefaultRoutePools.IsUnknown() {
			data.DefaultRoutePools.ElementsAs(ctx, &existingDefaultRoutePoolsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				default_route_poolsList = append(default_route_poolsList, HTTPLoadBalancerDefaultRoutePoolsModel{
					Cluster: func() *HTTPLoadBalancerDefaultRoutePoolsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDefaultRoutePoolsItems) > listIdx && existingDefaultRoutePoolsItems[listIdx].EndpointSubsets != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *HTTPLoadBalancerDefaultRoutePoolsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes}, default_route_poolsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DefaultRoutePools = listVal
		}
	} else {
		// No data from API - set to null list
		data.DefaultRoutePools = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_testing"].(map[string]interface{}); ok && isImport && data.DisableAPITesting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPITesting = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_bot_defense"].(map[string]interface{}); ok && isImport && data.DisableBotDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableBotDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_caching"].(map[string]interface{}); ok && isImport && data.DisableCaching == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableCaching = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malware_protection"].(map[string]interface{}); ok && isImport && data.DisableMalwareProtection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMalwareProtection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_trust_client_ip_headers"].(map[string]interface{}); ok && isImport && data.DisableTrustClientIPHeaders == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableTrustClientIPHeaders = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &HTTPLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &HTTPLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &HTTPLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_trust_client_ip_headers"].(map[string]interface{}); ok && (isImport || data.EnableTrustClientIPHeaders != nil) {
		data.EnableTrustClientIPHeaders = &HTTPLoadBalancerEnableTrustClientIPHeadersModel{
			ClientIPHeaders: func() types.List {
				if v, ok := blockData["client_ip_headers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []HTTPLoadBalancerGraphqlRulesModel
		var existingGraphqlRulesItems []HTTPLoadBalancerGraphqlRulesModel
		if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
			data.GraphqlRules.ElementsAs(ctx, &existingGraphqlRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, HTTPLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].AnyDomain != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel{
								DisableIntrospection: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.DisableIntrospection != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								EnableIntrospection: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.EnableIntrospection != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodGet != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodPost != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesModelAttrTypes}, graphql_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.GraphqlRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.GraphqlRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &HTTPLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTP.DNSVolterraManaged
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTP.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &HTTPLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSCoalescingOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSCoalescingOptionsModel{}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPS.ConnectionIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel{}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPS.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSCertParams: func() *HTTPLoadBalancerHTTPSTLSCertParamsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertParams != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertParams
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSCertParamsModel{}
				}
				return nil
			}(),
			TLSParameters: func() *HTTPLoadBalancerHTTPSTLSParametersModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSParameters != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSParameters
				}
				// Import case: read from API
				if _, ok := blockData["tls_parameters"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSParametersModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &HTTPLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel{}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSAutoCert.ConnectionIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel{}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NoMtls: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSAutoCert.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *HTTPLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertTLSConfigModel{}
				}
				return nil
			}(),
			UseMtls: func() *HTTPLoadBalancerHTTPSAutoCertUseMtlsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.UseMtls
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertUseMtlsModel{
						ClientCertificateOptional: func() types.Bool {
							if v, ok := nestedBlockData["client_certificate_optional"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						TrustedCAURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &HTTPLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JWTValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JWTValidation = &HTTPLoadBalancerJWTValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DDOSActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionBlock = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DDOSActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionDefault = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DDOSActionJsChallenge != nil) {
		data.L7DDOSActionJsChallenge = &HTTPLoadBalancerL7DDOSActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["l7_ddos_protection"].(map[string]interface{}); ok && (isImport || data.L7DDOSProtection != nil) {
		data.L7DDOSProtection = &HTTPLoadBalancerL7DDOSProtectionModel{
			ClientsideActionCaptchaChallenge: func() *HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.ClientsideActionCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.ClientsideActionCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionJsChallenge: func() *HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.ClientsideActionJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.ClientsideActionJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.ClientsideActionNone
				}
				// Import case: read from API
				if _, ok := blockData["clientside_action_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DDOSPolicyCustom: func() *HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.DDOSPolicyCustom != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.DDOSPolicyCustom
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ddos_policy_custom"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DDOSPolicyNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.DDOSPolicyNone
				}
				// Import case: read from API
				if _, ok := blockData["ddos_policy_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultRpsThreshold: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.DefaultRpsThreshold
				}
				// Import case: read from API
				if _, ok := blockData["default_rps_threshold"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationBlock: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.MitigationBlock
				}
				// Import case: read from API
				if _, ok := blockData["mitigation_block"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationCaptchaChallenge: func() *HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.MitigationCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.MitigationCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MitigationJsChallenge: func() *HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.MitigationJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.MitigationJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			RpsThreshold: func() types.Int64 {
				if !isImport && data.L7DDOSProtection != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSProtection.RpsThreshold
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["rps_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["least_active"].(map[string]interface{}); ok && isImport && data.LeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LeastActive = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["malware_protection_settings"].(map[string]interface{}); ok && (isImport || data.MalwareProtectionSettings != nil) {
		data.MalwareProtectionSettings = &HTTPLoadBalancerMalwareProtectionSettingsModel{
			MalwareProtectionRules: func() []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel {
				if listData, ok := blockData["malware_protection_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel{
								Action: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel{
											Block: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["block"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Report: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["report"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Domain: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel {
									if deepMap, ok := itemMap["domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel{
											AnyDomain: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_domain"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Path: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel {
									if deepMap, ok := itemMap["path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Prefix: func() types.String {
												if v, ok := deepMap["prefix"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Regex: func() types.String {
												if v, ok := deepMap["regex"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["more_option"].(map[string]interface{}); ok && (isImport || data.MoreOption != nil) {
		data.MoreOption = &HTTPLoadBalancerMoreOptionModel{
			BufferPolicy: func() *HTTPLoadBalancerMoreOptionBufferPolicyModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.BufferPolicy != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.BufferPolicy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["buffer_policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionBufferPolicyModel{
						Disabled: func() types.Bool {
							if v, ok := nestedBlockData["disabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						MaxRequestBytes: func() types.Int64 {
							if v, ok := nestedBlockData["max_request_bytes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			CompressionParams: func() *HTTPLoadBalancerMoreOptionCompressionParamsModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.CompressionParams != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.CompressionParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["compression_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionCompressionParamsModel{
						ContentLength: func() types.Int64 {
							if v, ok := nestedBlockData["content_length"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ContentType: func() types.List {
							if v, ok := nestedBlockData["content_type"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						DisableOnEtagHeader: func() types.Bool {
							if v, ok := nestedBlockData["disable_on_etag_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						RemoveAcceptEncodingHeader: func() types.Bool {
							if v, ok := nestedBlockData["remove_accept_encoding_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			CustomErrors: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.CustomErrors
				}
				// Import case: read from API
				if _, ok := blockData["custom_errors"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisableDefaultErrorPages: func() types.Bool {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.MoreOption.DisableDefaultErrorPages
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disable_default_error_pages"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IdleTimeout: func() types.Int64 {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.MoreOption.IdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MaxRequestHeaderSize: func() types.Int64 {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.MoreOption.MaxRequestHeaderSize
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["max_request_header_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestCookiesToAdd: func() []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel {
				if listData, ok := blockData["request_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestCookiesToAddModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestCookiesToRemove: func() types.List {
				if v, ok := blockData["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RequestHeadersToAdd: func() []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel {
				if listData, ok := blockData["request_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestHeadersToRemove: func() types.List {
				if v, ok := blockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseCookiesToAdd: func() []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel {
				if listData, ok := blockData["response_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseCookiesToAddModel{
								AddDomain: func() types.String {
									if v, ok := itemMap["add_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddExpiry: func() types.String {
									if v, ok := itemMap["add_expiry"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPath: func() types.String {
									if v, ok := itemMap["add_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreExpiry: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_expiry"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_max_age"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePath: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_samesite"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreValue: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxAgeValue: func() types.Int64 {
									if v, ok := itemMap["max_age_value"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_lax"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_strict"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseCookiesToRemove: func() types.List {
				if v, ok := blockData["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseHeadersToAdd: func() []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel {
				if listData, ok := blockData["response_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseHeadersToRemove: func() types.List {
				if v, ok := blockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["multi_lb_app"].(map[string]interface{}); ok && isImport && data.MultiLBApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.MultiLBApp = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_server_subset_rule_list"].(map[string]interface{}); ok && (isImport || data.OriginServerSubsetRuleList != nil) {
		data.OriginServerSubsetRuleList = &HTTPLoadBalancerOriginServerSubsetRuleListModel{
			OriginServerSubsetRules: func() []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel {
				if listData, ok := blockData["origin_server_subset_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel{
								AnyAsn: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_asn"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AsnList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel {
									if _, ok := itemMap["asn_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel{}
									}
									return nil
								}(),
								AsnMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel {
									if _, ok := itemMap["asn_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel{}
									}
									return nil
								}(),
								ClientSelector: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel {
									if _, ok := itemMap["client_selector"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel{}
									}
									return nil
								}(),
								IPMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel {
									if deepMap, ok := itemMap["ip_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								IPPrefixList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel {
									if deepMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel{
											InvertMatch: func() types.Bool {
												if v, ok := deepMap["invert_match"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								None: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								OriginServerSubsetsAction: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["origin_server_subsets_action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &HTTPLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []HTTPLoadBalancerProtectedCookiesModel
		var existingProtectedCookiesItems []HTTPLoadBalancerProtectedCookiesModel
		if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
			data.ProtectedCookies.ElementsAs(ctx, &existingProtectedCookiesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, HTTPLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddHttponly != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddSecure != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].DisableTamperingProtection != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].EnableTamperingProtection != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreHttponly != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreMaxAge != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSamesite != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSecure != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteLax != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteNone != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteStrict != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerProtectedCookiesModelAttrTypes}, protected_cookiesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.ProtectedCookies = listVal
		}
	} else {
		// No data from API - set to null list
		data.ProtectedCookies = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerProtectedCookiesModelAttrTypes})
	}
	if _, ok := apiResource.Spec["random"].(map[string]interface{}); ok && isImport && data.Random == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Random = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &HTTPLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ring_hash"].(map[string]interface{}); ok && (isImport || data.RingHash != nil) {
		data.RingHash = &HTTPLoadBalancerRingHashModel{
			HashPolicy: func() []HTTPLoadBalancerRingHashHashPolicyModel {
				if listData, ok := blockData["hash_policy"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerRingHashHashPolicyModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerRingHashHashPolicyModel{
								Cookie: func() *HTTPLoadBalancerRingHashHashPolicyCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerRingHashHashPolicyCookieModel{
											AddHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AddSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_samesite"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_lax"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_none"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_strict"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											TTL: func() types.Int64 {
												if v, ok := deepMap["ttl"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HeaderName: func() types.String {
									if v, ok := itemMap["header_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SourceIP: func() types.Bool {
									if v, ok := itemMap["source_ip"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Terminal: func() types.Bool {
									if v, ok := itemMap["terminal"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["round_robin"].(map[string]interface{}); ok && isImport && data.RoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RoundRobin = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []HTTPLoadBalancerRoutesModel
		var existingRoutesItems []HTTPLoadBalancerRoutesModel
		if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
			data.Routes.ElementsAs(ctx, &existingRoutesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, HTTPLoadBalancerRoutesModel{
					CustomRouteObject: func() *HTTPLoadBalancerRoutesCustomRouteObjectModel {
						if _, ok := itemMap["custom_route_object"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesCustomRouteObjectModel{}
						}
						return nil
					}(),
					DirectResponseRoute: func() *HTTPLoadBalancerRoutesDirectResponseRouteModel {
						if nestedMap, ok := itemMap["direct_response_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesDirectResponseRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					RedirectRoute: func() *HTTPLoadBalancerRoutesRedirectRouteModel {
						if nestedMap, ok := itemMap["redirect_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesRedirectRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SimpleRoute: func() *HTTPLoadBalancerRoutesSimpleRouteModel {
						if nestedMap, ok := itemMap["simple_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesSimpleRouteModel{
								AutoHostRewrite: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].SimpleRoute != nil && existingRoutesItems[listIdx].SimpleRoute.AutoHostRewrite != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								DisableHostRewrite: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].SimpleRoute != nil && existingRoutesItems[listIdx].SimpleRoute.DisableHostRewrite != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesModelAttrTypes}, routesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Routes = listVal
		}
	} else {
		// No data from API - set to null list
		data.Routes = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["sensitive_data_disclosure_rules"].(map[string]interface{}); ok && (isImport || data.SensitiveDataDisclosureRules != nil) {
		data.SensitiveDataDisclosureRules = &HTTPLoadBalancerSensitiveDataDisclosureRulesModel{
			SensitiveDataTypesInResponse: func() []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel {
				if listData, ok := blockData["sensitive_data_types_in_response"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel{
								APIEndpoint: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel {
									if deepMap, ok := itemMap["api_endpoint"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Body: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel {
									if _, ok := itemMap["body"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel{}
									}
									return nil
								}(),
								Mask: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["mask"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Report: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["report"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &HTTPLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["single_lb_app"].(map[string]interface{}); ok && isImport && data.SingleLBApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SingleLBApp = &HTTPLoadBalancerSingleLBAppModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDDOSMitigation != nil) {
		data.SlowDDOSMitigation = &HTTPLoadBalancerSlowDDOSMitigationModel{
			DisableRequestTimeout: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDDOSMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestHeadersTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.SourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SourceIPStickiness = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []HTTPLoadBalancerTrustedClientsModel
		var existingTrustedClientsItems []HTTPLoadBalancerTrustedClientsModel
		if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
			data.TrustedClients.ElementsAs(ctx, &existingTrustedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, HTTPLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].BotSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].SkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsModelAttrTypes}, trusted_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.TrustedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.TrustedClients = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &HTTPLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &HTTPLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["add_location"].(bool); ok {
			data.AddLocation = types.BoolValue(v)
		} else {
			data.AddLocation = types.BoolNull()
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created HTTPLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HTTPLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetHTTPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "HTTPLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read HTTPLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The http_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &HTTPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []HTTPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &HTTPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &HTTPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_protection_rules"].(map[string]interface{}); ok && (isImport || data.APIProtectionRules != nil) {
		data.APIProtectionRules = &HTTPLoadBalancerAPIProtectionRulesModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			APIGroupsRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel {
				if listData, ok := blockData["api_groups_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &HTTPLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel{}
				}
				return nil
			}(),
			IPAllowedList: func() *HTTPLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []HTTPLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &HTTPLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_testing"].(map[string]interface{}); ok && (isImport || data.APITesting != nil) {
		data.APITesting = &HTTPLoadBalancerAPITestingModel{
			CustomHeaderValue: func() types.String {
				if v, ok := blockData["custom_header_value"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domains: func() []HTTPLoadBalancerAPITestingDomainsModel {
				if listData, ok := blockData["domains"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPITestingDomainsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPITestingDomainsModel{
								AllowDestructiveMethods: func() types.Bool {
									if v, ok := itemMap["allow_destructive_methods"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Domain: func() types.String {
									if v, ok := itemMap["domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			EveryDay: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryDay
				}
				// Import case: read from API
				if _, ok := blockData["every_day"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryMonth: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryMonth
				}
				// Import case: read from API
				if _, ok := blockData["every_month"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryWeek: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryWeek
				}
				// Import case: read from API
				if _, ok := blockData["every_week"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &HTTPLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []HTTPLoadBalancerBlockedClientsModel
		var existingBlockedClientsItems []HTTPLoadBalancerBlockedClientsModel
		if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
			data.BlockedClients.ElementsAs(ctx, &existingBlockedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, HTTPLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].BotSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].SkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsModelAttrTypes}, blocked_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.BlockedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.BlockedClients = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &HTTPLoadBalancerBotDefenseModel{
			DisableCORSSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCORSSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *HTTPLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if !isImport && data.BotDefense != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.BotDefense.Timeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["bot_defense_advanced"].(map[string]interface{}); ok && isImport && data.BotDefenseAdvanced == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BotDefenseAdvanced = &HTTPLoadBalancerBotDefenseAdvancedModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["caching_policy"].(map[string]interface{}); ok && isImport && data.CachingPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CachingPolicy = &HTTPLoadBalancerCachingPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &HTTPLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CaptchaChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CaptchaChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &HTTPLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cookie_stickiness"].(map[string]interface{}); ok && (isImport || data.CookieStickiness != nil) {
		data.CookieStickiness = &HTTPLoadBalancerCookieStickinessModel{
			AddHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddHttponly
				}
				// Import case: read from API
				if _, ok := blockData["add_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			AddSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddSecure
				}
				// Import case: read from API
				if _, ok := blockData["add_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreHttponly
				}
				// Import case: read from API
				if _, ok := blockData["ignore_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSamesite
				}
				// Import case: read from API
				if _, ok := blockData["ignore_samesite"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSecure
				}
				// Import case: read from API
				if _, ok := blockData["ignore_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Path: func() types.String {
				if v, ok := blockData["path"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteLax
				}
				// Import case: read from API
				if _, ok := blockData["samesite_lax"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteNone
				}
				// Import case: read from API
				if _, ok := blockData["samesite_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteStrict
				}
				// Import case: read from API
				if _, ok := blockData["samesite_strict"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			TTL: func() types.Int64 {
				if !isImport && data.CookieStickiness != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieStickiness.TTL
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["ttl"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CORSPolicy != nil) {
		data.CORSPolicy = &HTTPLoadBalancerCORSPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.AllowCredentials
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.Disabled
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CORSPolicy.MaximumAge
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CSRFPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CSRFPolicy = &HTTPLoadBalancerCSRFPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []HTTPLoadBalancerDataGuardRulesModel
		var existingDataGuardRulesItems []HTTPLoadBalancerDataGuardRulesModel
		if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
			data.DataGuardRules.ElementsAs(ctx, &existingDataGuardRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, HTTPLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].AnyDomain != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].ApplyDataGuard != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *HTTPLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].SkipDataGuard != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesModelAttrTypes}, data_guard_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DataGuardRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DataGuardRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesModelAttrTypes})
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []HTTPLoadBalancerDDOSMitigationRulesModel
		var existingDDOSMitigationRulesItems []HTTPLoadBalancerDDOSMitigationRulesModel
		if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
			data.DDOSMitigationRules.ElementsAs(ctx, &existingDDOSMitigationRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, HTTPLoadBalancerDDOSMitigationRulesModel{
					Block: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDDOSMitigationRulesItems) > listIdx && existingDDOSMitigationRulesItems[listIdx].Block != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DDOSClientSource: func() *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerDDOSMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes}, ddos_mitigation_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DDOSMitigationRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DDOSMitigationRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["default_pool"].(map[string]interface{}); ok && (isImport || data.DefaultPool != nil) {
		data.DefaultPool = &HTTPLoadBalancerDefaultPoolModel{
			AdvancedOptions: func() *HTTPLoadBalancerDefaultPoolAdvancedOptionsModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.AdvancedOptions != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.AdvancedOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["advanced_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolAdvancedOptionsModel{
						ConnectionTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["connection_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						HTTPIdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["http_idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PanicThreshold: func() types.Int64 {
							if v, ok := nestedBlockData["panic_threshold"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			AutomaticPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.AutomaticPort
				}
				// Import case: read from API
				if _, ok := blockData["automatic_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EndpointSelection: func() types.String {
				if v, ok := blockData["endpoint_selection"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HealthCheckPort: func() types.Int64 {
				if !isImport && data.DefaultPool != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DefaultPool.HealthCheckPort
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["health_check_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Healthcheck: func() []HTTPLoadBalancerDefaultPoolHealthcheckModel {
				if listData, ok := blockData["healthcheck"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolHealthcheckModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolHealthcheckModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			LBPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.LBPort
				}
				// Import case: read from API
				if _, ok := blockData["lb_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			LoadBalancerAlgorithm: func() types.String {
				if v, ok := blockData["loadbalancer_algorithm"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoTLS: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginServers: func() []HTTPLoadBalancerDefaultPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolOriginServersModel{
								CbipService: func() *HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel {
									if deepMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel{
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ConsulService: func() *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel {
									if deepMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								CustomEndpointObject: func() *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel {
									if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel{}
									}
									return nil
								}(),
								K8SService: func() *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel {
									if deepMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Protocol: func() types.String {
												if v, ok := deepMap["protocol"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Vk8sNetworks: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["vk8s_networks"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Labels: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								PrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel {
									if deepMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								PrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel {
									if deepMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								PublicIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel {
									if deepMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel {
									if deepMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.DefaultPool != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DefaultPool.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SameAsEndpointPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.SameAsEndpointPort
				}
				// Import case: read from API
				if _, ok := blockData["same_as_endpoint_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			UpstreamConnPoolReuseType: func() *HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UpstreamConnPoolReuseType != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UpstreamConnPoolReuseType
				}
				// Import case: read from API
				if _, ok := blockData["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel{}
				}
				return nil
			}(),
			UseTLS: func() *HTTPLoadBalancerDefaultPoolUseTLSModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ViewInternal: func() *HTTPLoadBalancerDefaultPoolViewInternalModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.ViewInternal != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.ViewInternal
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["view_internal"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolViewInternalModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["default_pool_list"].(map[string]interface{}); ok && (isImport || data.DefaultPoolList != nil) {
		data.DefaultPoolList = &HTTPLoadBalancerDefaultPoolListModel{
			Pools: func() []HTTPLoadBalancerDefaultPoolListPoolsModel {
				if listData, ok := blockData["pools"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolListPoolsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolListPoolsModel{
								Cluster: func() *HTTPLoadBalancerDefaultPoolListPoolsClusterModel {
									if deepMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsClusterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["endpoint_subsets"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Pool: func() *HTTPLoadBalancerDefaultPoolListPoolsPoolModel {
									if deepMap, ok := itemMap["pool"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsPoolModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Priority: func() types.Int64 {
									if v, ok := itemMap["priority"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Weight: func() types.Int64 {
									if v, ok := itemMap["weight"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["default_route_pools"].([]interface{}); ok && len(listData) > 0 {
		var default_route_poolsList []HTTPLoadBalancerDefaultRoutePoolsModel
		var existingDefaultRoutePoolsItems []HTTPLoadBalancerDefaultRoutePoolsModel
		if !data.DefaultRoutePools.IsNull() && !data.DefaultRoutePools.IsUnknown() {
			data.DefaultRoutePools.ElementsAs(ctx, &existingDefaultRoutePoolsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				default_route_poolsList = append(default_route_poolsList, HTTPLoadBalancerDefaultRoutePoolsModel{
					Cluster: func() *HTTPLoadBalancerDefaultRoutePoolsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDefaultRoutePoolsItems) > listIdx && existingDefaultRoutePoolsItems[listIdx].EndpointSubsets != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *HTTPLoadBalancerDefaultRoutePoolsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes}, default_route_poolsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DefaultRoutePools = listVal
		}
	} else {
		// No data from API - set to null list
		data.DefaultRoutePools = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_testing"].(map[string]interface{}); ok && isImport && data.DisableAPITesting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPITesting = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_bot_defense"].(map[string]interface{}); ok && isImport && data.DisableBotDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableBotDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_caching"].(map[string]interface{}); ok && isImport && data.DisableCaching == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableCaching = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malware_protection"].(map[string]interface{}); ok && isImport && data.DisableMalwareProtection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMalwareProtection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_trust_client_ip_headers"].(map[string]interface{}); ok && isImport && data.DisableTrustClientIPHeaders == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableTrustClientIPHeaders = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &HTTPLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &HTTPLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &HTTPLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_trust_client_ip_headers"].(map[string]interface{}); ok && (isImport || data.EnableTrustClientIPHeaders != nil) {
		data.EnableTrustClientIPHeaders = &HTTPLoadBalancerEnableTrustClientIPHeadersModel{
			ClientIPHeaders: func() types.List {
				if v, ok := blockData["client_ip_headers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []HTTPLoadBalancerGraphqlRulesModel
		var existingGraphqlRulesItems []HTTPLoadBalancerGraphqlRulesModel
		if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
			data.GraphqlRules.ElementsAs(ctx, &existingGraphqlRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, HTTPLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].AnyDomain != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel{
								DisableIntrospection: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.DisableIntrospection != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								EnableIntrospection: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.EnableIntrospection != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodGet != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodPost != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesModelAttrTypes}, graphql_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.GraphqlRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.GraphqlRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &HTTPLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTP.DNSVolterraManaged
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTP.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &HTTPLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSCoalescingOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSCoalescingOptionsModel{}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPS.ConnectionIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel{}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPS.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSCertParams: func() *HTTPLoadBalancerHTTPSTLSCertParamsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertParams != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertParams
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSCertParamsModel{}
				}
				return nil
			}(),
			TLSParameters: func() *HTTPLoadBalancerHTTPSTLSParametersModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSParameters != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSParameters
				}
				// Import case: read from API
				if _, ok := blockData["tls_parameters"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSParametersModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &HTTPLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel{}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSAutoCert.ConnectionIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel{}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NoMtls: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSAutoCert.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *HTTPLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertTLSConfigModel{}
				}
				return nil
			}(),
			UseMtls: func() *HTTPLoadBalancerHTTPSAutoCertUseMtlsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.UseMtls
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertUseMtlsModel{
						ClientCertificateOptional: func() types.Bool {
							if v, ok := nestedBlockData["client_certificate_optional"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						TrustedCAURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &HTTPLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JWTValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JWTValidation = &HTTPLoadBalancerJWTValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DDOSActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionBlock = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DDOSActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionDefault = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DDOSActionJsChallenge != nil) {
		data.L7DDOSActionJsChallenge = &HTTPLoadBalancerL7DDOSActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["l7_ddos_protection"].(map[string]interface{}); ok && (isImport || data.L7DDOSProtection != nil) {
		data.L7DDOSProtection = &HTTPLoadBalancerL7DDOSProtectionModel{
			ClientsideActionCaptchaChallenge: func() *HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.ClientsideActionCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.ClientsideActionCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionJsChallenge: func() *HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.ClientsideActionJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.ClientsideActionJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.ClientsideActionNone
				}
				// Import case: read from API
				if _, ok := blockData["clientside_action_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DDOSPolicyCustom: func() *HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.DDOSPolicyCustom != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.DDOSPolicyCustom
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ddos_policy_custom"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DDOSPolicyNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.DDOSPolicyNone
				}
				// Import case: read from API
				if _, ok := blockData["ddos_policy_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultRpsThreshold: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.DefaultRpsThreshold
				}
				// Import case: read from API
				if _, ok := blockData["default_rps_threshold"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationBlock: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.MitigationBlock
				}
				// Import case: read from API
				if _, ok := blockData["mitigation_block"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationCaptchaChallenge: func() *HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.MitigationCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.MitigationCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MitigationJsChallenge: func() *HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.MitigationJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.MitigationJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			RpsThreshold: func() types.Int64 {
				if !isImport && data.L7DDOSProtection != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSProtection.RpsThreshold
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["rps_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["least_active"].(map[string]interface{}); ok && isImport && data.LeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LeastActive = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["malware_protection_settings"].(map[string]interface{}); ok && (isImport || data.MalwareProtectionSettings != nil) {
		data.MalwareProtectionSettings = &HTTPLoadBalancerMalwareProtectionSettingsModel{
			MalwareProtectionRules: func() []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel {
				if listData, ok := blockData["malware_protection_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel{
								Action: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel{
											Block: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["block"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Report: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["report"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Domain: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel {
									if deepMap, ok := itemMap["domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel{
											AnyDomain: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_domain"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Path: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel {
									if deepMap, ok := itemMap["path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Prefix: func() types.String {
												if v, ok := deepMap["prefix"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Regex: func() types.String {
												if v, ok := deepMap["regex"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["more_option"].(map[string]interface{}); ok && (isImport || data.MoreOption != nil) {
		data.MoreOption = &HTTPLoadBalancerMoreOptionModel{
			BufferPolicy: func() *HTTPLoadBalancerMoreOptionBufferPolicyModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.BufferPolicy != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.BufferPolicy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["buffer_policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionBufferPolicyModel{
						Disabled: func() types.Bool {
							if v, ok := nestedBlockData["disabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						MaxRequestBytes: func() types.Int64 {
							if v, ok := nestedBlockData["max_request_bytes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			CompressionParams: func() *HTTPLoadBalancerMoreOptionCompressionParamsModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.CompressionParams != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.CompressionParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["compression_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionCompressionParamsModel{
						ContentLength: func() types.Int64 {
							if v, ok := nestedBlockData["content_length"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ContentType: func() types.List {
							if v, ok := nestedBlockData["content_type"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						DisableOnEtagHeader: func() types.Bool {
							if v, ok := nestedBlockData["disable_on_etag_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						RemoveAcceptEncodingHeader: func() types.Bool {
							if v, ok := nestedBlockData["remove_accept_encoding_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			CustomErrors: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.CustomErrors
				}
				// Import case: read from API
				if _, ok := blockData["custom_errors"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisableDefaultErrorPages: func() types.Bool {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.MoreOption.DisableDefaultErrorPages
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disable_default_error_pages"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IdleTimeout: func() types.Int64 {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.MoreOption.IdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MaxRequestHeaderSize: func() types.Int64 {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.MoreOption.MaxRequestHeaderSize
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["max_request_header_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestCookiesToAdd: func() []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel {
				if listData, ok := blockData["request_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestCookiesToAddModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestCookiesToRemove: func() types.List {
				if v, ok := blockData["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RequestHeadersToAdd: func() []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel {
				if listData, ok := blockData["request_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestHeadersToRemove: func() types.List {
				if v, ok := blockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseCookiesToAdd: func() []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel {
				if listData, ok := blockData["response_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseCookiesToAddModel{
								AddDomain: func() types.String {
									if v, ok := itemMap["add_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddExpiry: func() types.String {
									if v, ok := itemMap["add_expiry"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPath: func() types.String {
									if v, ok := itemMap["add_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreExpiry: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_expiry"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_max_age"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePath: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_samesite"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreValue: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxAgeValue: func() types.Int64 {
									if v, ok := itemMap["max_age_value"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_lax"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_strict"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseCookiesToRemove: func() types.List {
				if v, ok := blockData["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseHeadersToAdd: func() []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel {
				if listData, ok := blockData["response_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseHeadersToRemove: func() types.List {
				if v, ok := blockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["multi_lb_app"].(map[string]interface{}); ok && isImport && data.MultiLBApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.MultiLBApp = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_server_subset_rule_list"].(map[string]interface{}); ok && (isImport || data.OriginServerSubsetRuleList != nil) {
		data.OriginServerSubsetRuleList = &HTTPLoadBalancerOriginServerSubsetRuleListModel{
			OriginServerSubsetRules: func() []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel {
				if listData, ok := blockData["origin_server_subset_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel{
								AnyAsn: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_asn"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AsnList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel {
									if _, ok := itemMap["asn_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel{}
									}
									return nil
								}(),
								AsnMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel {
									if _, ok := itemMap["asn_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel{}
									}
									return nil
								}(),
								ClientSelector: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel {
									if _, ok := itemMap["client_selector"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel{}
									}
									return nil
								}(),
								IPMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel {
									if deepMap, ok := itemMap["ip_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								IPPrefixList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel {
									if deepMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel{
											InvertMatch: func() types.Bool {
												if v, ok := deepMap["invert_match"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								None: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								OriginServerSubsetsAction: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["origin_server_subsets_action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &HTTPLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []HTTPLoadBalancerProtectedCookiesModel
		var existingProtectedCookiesItems []HTTPLoadBalancerProtectedCookiesModel
		if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
			data.ProtectedCookies.ElementsAs(ctx, &existingProtectedCookiesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, HTTPLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddHttponly != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddSecure != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].DisableTamperingProtection != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].EnableTamperingProtection != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreHttponly != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreMaxAge != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSamesite != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSecure != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteLax != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteNone != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteStrict != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerProtectedCookiesModelAttrTypes}, protected_cookiesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.ProtectedCookies = listVal
		}
	} else {
		// No data from API - set to null list
		data.ProtectedCookies = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerProtectedCookiesModelAttrTypes})
	}
	if _, ok := apiResource.Spec["random"].(map[string]interface{}); ok && isImport && data.Random == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Random = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &HTTPLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ring_hash"].(map[string]interface{}); ok && (isImport || data.RingHash != nil) {
		data.RingHash = &HTTPLoadBalancerRingHashModel{
			HashPolicy: func() []HTTPLoadBalancerRingHashHashPolicyModel {
				if listData, ok := blockData["hash_policy"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerRingHashHashPolicyModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerRingHashHashPolicyModel{
								Cookie: func() *HTTPLoadBalancerRingHashHashPolicyCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerRingHashHashPolicyCookieModel{
											AddHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AddSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_samesite"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_lax"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_none"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_strict"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											TTL: func() types.Int64 {
												if v, ok := deepMap["ttl"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HeaderName: func() types.String {
									if v, ok := itemMap["header_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SourceIP: func() types.Bool {
									if v, ok := itemMap["source_ip"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Terminal: func() types.Bool {
									if v, ok := itemMap["terminal"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["round_robin"].(map[string]interface{}); ok && isImport && data.RoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RoundRobin = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []HTTPLoadBalancerRoutesModel
		var existingRoutesItems []HTTPLoadBalancerRoutesModel
		if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
			data.Routes.ElementsAs(ctx, &existingRoutesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, HTTPLoadBalancerRoutesModel{
					CustomRouteObject: func() *HTTPLoadBalancerRoutesCustomRouteObjectModel {
						if _, ok := itemMap["custom_route_object"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesCustomRouteObjectModel{}
						}
						return nil
					}(),
					DirectResponseRoute: func() *HTTPLoadBalancerRoutesDirectResponseRouteModel {
						if nestedMap, ok := itemMap["direct_response_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesDirectResponseRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					RedirectRoute: func() *HTTPLoadBalancerRoutesRedirectRouteModel {
						if nestedMap, ok := itemMap["redirect_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesRedirectRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SimpleRoute: func() *HTTPLoadBalancerRoutesSimpleRouteModel {
						if nestedMap, ok := itemMap["simple_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesSimpleRouteModel{
								AutoHostRewrite: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].SimpleRoute != nil && existingRoutesItems[listIdx].SimpleRoute.AutoHostRewrite != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								DisableHostRewrite: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].SimpleRoute != nil && existingRoutesItems[listIdx].SimpleRoute.DisableHostRewrite != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesModelAttrTypes}, routesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Routes = listVal
		}
	} else {
		// No data from API - set to null list
		data.Routes = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["sensitive_data_disclosure_rules"].(map[string]interface{}); ok && (isImport || data.SensitiveDataDisclosureRules != nil) {
		data.SensitiveDataDisclosureRules = &HTTPLoadBalancerSensitiveDataDisclosureRulesModel{
			SensitiveDataTypesInResponse: func() []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel {
				if listData, ok := blockData["sensitive_data_types_in_response"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel{
								APIEndpoint: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel {
									if deepMap, ok := itemMap["api_endpoint"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Body: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel {
									if _, ok := itemMap["body"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel{}
									}
									return nil
								}(),
								Mask: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["mask"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Report: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["report"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &HTTPLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["single_lb_app"].(map[string]interface{}); ok && isImport && data.SingleLBApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SingleLBApp = &HTTPLoadBalancerSingleLBAppModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDDOSMitigation != nil) {
		data.SlowDDOSMitigation = &HTTPLoadBalancerSlowDDOSMitigationModel{
			DisableRequestTimeout: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDDOSMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestHeadersTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.SourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SourceIPStickiness = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []HTTPLoadBalancerTrustedClientsModel
		var existingTrustedClientsItems []HTTPLoadBalancerTrustedClientsModel
		if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
			data.TrustedClients.ElementsAs(ctx, &existingTrustedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, HTTPLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].BotSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].SkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsModelAttrTypes}, trusted_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.TrustedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.TrustedClients = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &HTTPLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &HTTPLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["add_location"].(bool); ok {
			data.AddLocation = types.BoolValue(v)
		} else {
			data.AddLocation = types.BoolNull()
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HTTPLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.HTTPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		apiResource.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		apiResource.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.APIProtectionRules != nil {
		api_protection_rulesMap := make(map[string]interface{})
		if len(data.APIProtectionRules.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if len(data.APIProtectionRules.APIGroupsRules) > 0 {
			var api_groups_rulesList []map[string]interface{}
			for _, listItem := range data.APIProtectionRules.APIGroupsRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Allow != nil {
						actionDeepMap["allow"] = map[string]interface{}{}
					}
					if listItem.Action.Deny != nil {
						actionDeepMap["deny"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_groups_rulesList = append(api_groups_rulesList, listItemMap)
			}
			api_protection_rulesMap["api_groups_rules"] = api_groups_rulesList
		}
		apiResource.Spec["api_protection_rules"] = api_protection_rulesMap
	}
	if data.APIRateLimit != nil {
		api_rate_limitMap := make(map[string]interface{})
		if len(data.APIRateLimit.APIEndpointRules) > 0 {
			var api_endpoint_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.APIEndpointRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if listItem.APIEndpointMethod != nil {
					api_endpoint_methodDeepMap := make(map[string]interface{})
					if !listItem.APIEndpointMethod.InvertMatcher.IsNull() && !listItem.APIEndpointMethod.InvertMatcher.IsUnknown() {
						api_endpoint_methodDeepMap["invert_matcher"] = listItem.APIEndpointMethod.InvertMatcher.ValueBool()
					}
					listItemMap["api_endpoint_method"] = api_endpoint_methodDeepMap
				}
				if !listItem.APIEndpointPath.IsNull() && !listItem.APIEndpointPath.IsUnknown() {
					listItemMap["api_endpoint_path"] = listItem.APIEndpointPath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				api_endpoint_rulesList = append(api_endpoint_rulesList, listItemMap)
			}
			api_rate_limitMap["api_endpoint_rules"] = api_endpoint_rulesList
		}
		if data.APIRateLimit.BypassRateLimitingRules != nil {
			bypass_rate_limiting_rulesNestedMap := make(map[string]interface{})
			api_rate_limitMap["bypass_rate_limiting_rules"] = bypass_rate_limiting_rulesNestedMap
		}
		if data.APIRateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.APIRateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			api_rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.APIRateLimit.NoIPAllowedList != nil {
			api_rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if len(data.APIRateLimit.ServerURLRules) > 0 {
			var server_url_rulesList []map[string]interface{}
			for _, listItem := range data.APIRateLimit.ServerURLRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyDomain != nil {
					listItemMap["any_domain"] = map[string]interface{}{}
				}
				if !listItem.APIGroup.IsNull() && !listItem.APIGroup.IsUnknown() {
					listItemMap["api_group"] = listItem.APIGroup.ValueString()
				}
				if !listItem.BasePath.IsNull() && !listItem.BasePath.IsUnknown() {
					listItemMap["base_path"] = listItem.BasePath.ValueString()
				}
				if listItem.ClientMatcher != nil {
					client_matcherDeepMap := make(map[string]interface{})
					if listItem.ClientMatcher.AnyClient != nil {
						client_matcherDeepMap["any_client"] = map[string]interface{}{}
					}
					if listItem.ClientMatcher.AnyIP != nil {
						client_matcherDeepMap["any_ip"] = map[string]interface{}{}
					}
					listItemMap["client_matcher"] = client_matcherDeepMap
				}
				if listItem.InlineRateLimiter != nil {
					inline_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.InlineRateLimiter.Threshold.IsNull() && !listItem.InlineRateLimiter.Threshold.IsUnknown() {
						inline_rate_limiterDeepMap["threshold"] = listItem.InlineRateLimiter.Threshold.ValueInt64()
					}
					if !listItem.InlineRateLimiter.Unit.IsNull() && !listItem.InlineRateLimiter.Unit.IsUnknown() {
						inline_rate_limiterDeepMap["unit"] = listItem.InlineRateLimiter.Unit.ValueString()
					}
					if listItem.InlineRateLimiter.UseHTTPLBUserID != nil {
						inline_rate_limiterDeepMap["use_http_lb_user_id"] = map[string]interface{}{}
					}
					listItemMap["inline_rate_limiter"] = inline_rate_limiterDeepMap
				}
				if listItem.RefRateLimiter != nil {
					ref_rate_limiterDeepMap := make(map[string]interface{})
					if !listItem.RefRateLimiter.Name.IsNull() && !listItem.RefRateLimiter.Name.IsUnknown() {
						ref_rate_limiterDeepMap["name"] = listItem.RefRateLimiter.Name.ValueString()
					}
					if !listItem.RefRateLimiter.Namespace.IsNull() && !listItem.RefRateLimiter.Namespace.IsUnknown() {
						ref_rate_limiterDeepMap["namespace"] = listItem.RefRateLimiter.Namespace.ValueString()
					}
					if !listItem.RefRateLimiter.Tenant.IsNull() && !listItem.RefRateLimiter.Tenant.IsUnknown() {
						ref_rate_limiterDeepMap["tenant"] = listItem.RefRateLimiter.Tenant.ValueString()
					}
					listItemMap["ref_rate_limiter"] = ref_rate_limiterDeepMap
				}
				if listItem.RequestMatcher != nil {
					request_matcherDeepMap := make(map[string]interface{})
					listItemMap["request_matcher"] = request_matcherDeepMap
				}
				if !listItem.SpecificDomain.IsNull() && !listItem.SpecificDomain.IsUnknown() {
					listItemMap["specific_domain"] = listItem.SpecificDomain.ValueString()
				}
				server_url_rulesList = append(server_url_rulesList, listItemMap)
			}
			api_rate_limitMap["server_url_rules"] = server_url_rulesList
		}
		apiResource.Spec["api_rate_limit"] = api_rate_limitMap
	}
	if data.APISpecification != nil {
		api_specificationMap := make(map[string]interface{})
		if data.APISpecification.APIDefinition != nil {
			api_definitionNestedMap := make(map[string]interface{})
			if !data.APISpecification.APIDefinition.Name.IsNull() && !data.APISpecification.APIDefinition.Name.IsUnknown() {
				api_definitionNestedMap["name"] = data.APISpecification.APIDefinition.Name.ValueString()
			}
			if !data.APISpecification.APIDefinition.Namespace.IsNull() && !data.APISpecification.APIDefinition.Namespace.IsUnknown() {
				api_definitionNestedMap["namespace"] = data.APISpecification.APIDefinition.Namespace.ValueString()
			}
			if !data.APISpecification.APIDefinition.Tenant.IsNull() && !data.APISpecification.APIDefinition.Tenant.IsUnknown() {
				api_definitionNestedMap["tenant"] = data.APISpecification.APIDefinition.Tenant.ValueString()
			}
			api_specificationMap["api_definition"] = api_definitionNestedMap
		}
		if data.APISpecification.ValidationAllSpecEndpoints != nil {
			validation_all_spec_endpointsNestedMap := make(map[string]interface{})
			api_specificationMap["validation_all_spec_endpoints"] = validation_all_spec_endpointsNestedMap
		}
		if data.APISpecification.ValidationCustomList != nil {
			validation_custom_listNestedMap := make(map[string]interface{})
			api_specificationMap["validation_custom_list"] = validation_custom_listNestedMap
		}
		if data.APISpecification.ValidationDisabled != nil {
			api_specificationMap["validation_disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["api_specification"] = api_specificationMap
	}
	if data.APITesting != nil {
		api_testingMap := make(map[string]interface{})
		if !data.APITesting.CustomHeaderValue.IsNull() && !data.APITesting.CustomHeaderValue.IsUnknown() {
			api_testingMap["custom_header_value"] = data.APITesting.CustomHeaderValue.ValueString()
		}
		if len(data.APITesting.Domains) > 0 {
			var domainsList []map[string]interface{}
			for _, listItem := range data.APITesting.Domains {
				listItemMap := make(map[string]interface{})
				if !listItem.AllowDestructiveMethods.IsNull() && !listItem.AllowDestructiveMethods.IsUnknown() {
					listItemMap["allow_destructive_methods"] = listItem.AllowDestructiveMethods.ValueBool()
				}
				if !listItem.Domain.IsNull() && !listItem.Domain.IsUnknown() {
					listItemMap["domain"] = listItem.Domain.ValueString()
				}
				domainsList = append(domainsList, listItemMap)
			}
			api_testingMap["domains"] = domainsList
		}
		if data.APITesting.EveryDay != nil {
			api_testingMap["every_day"] = map[string]interface{}{}
		}
		if data.APITesting.EveryMonth != nil {
			api_testingMap["every_month"] = map[string]interface{}{}
		}
		if data.APITesting.EveryWeek != nil {
			api_testingMap["every_week"] = map[string]interface{}{}
		}
		apiResource.Spec["api_testing"] = api_testingMap
	}
	if data.AppFirewall != nil {
		app_firewallMap := make(map[string]interface{})
		if !data.AppFirewall.Name.IsNull() && !data.AppFirewall.Name.IsUnknown() {
			app_firewallMap["name"] = data.AppFirewall.Name.ValueString()
		}
		if !data.AppFirewall.Namespace.IsNull() && !data.AppFirewall.Namespace.IsUnknown() {
			app_firewallMap["namespace"] = data.AppFirewall.Namespace.ValueString()
		}
		if !data.AppFirewall.Tenant.IsNull() && !data.AppFirewall.Tenant.IsUnknown() {
			app_firewallMap["tenant"] = data.AppFirewall.Tenant.ValueString()
		}
		apiResource.Spec["app_firewall"] = app_firewallMap
	}
	if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
		var blocked_clientsItems []HTTPLoadBalancerBlockedClientsModel
		diags := data.BlockedClients.ElementsAs(ctx, &blocked_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(blocked_clientsItems) > 0 {
			var blocked_clientsList []map[string]interface{}
			for _, item := range blocked_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				blocked_clientsList = append(blocked_clientsList, itemMap)
			}
			apiResource.Spec["blocked_clients"] = blocked_clientsList
		}
	}
	if data.BotDefense != nil {
		bot_defenseMap := make(map[string]interface{})
		if data.BotDefense.DisableCORSSupport != nil {
			bot_defenseMap["disable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.EnableCORSSupport != nil {
			bot_defenseMap["enable_cors_support"] = map[string]interface{}{}
		}
		if data.BotDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			if !data.BotDefense.Policy.JavascriptMode.IsNull() && !data.BotDefense.Policy.JavascriptMode.IsUnknown() {
				policyNestedMap["javascript_mode"] = data.BotDefense.Policy.JavascriptMode.ValueString()
			}
			if !data.BotDefense.Policy.JsDownloadPath.IsNull() && !data.BotDefense.Policy.JsDownloadPath.IsUnknown() {
				policyNestedMap["js_download_path"] = data.BotDefense.Policy.JsDownloadPath.ValueString()
			}
			bot_defenseMap["policy"] = policyNestedMap
		}
		if !data.BotDefense.RegionalEndpoint.IsNull() && !data.BotDefense.RegionalEndpoint.IsUnknown() {
			bot_defenseMap["regional_endpoint"] = data.BotDefense.RegionalEndpoint.ValueString()
		}
		if !data.BotDefense.Timeout.IsNull() && !data.BotDefense.Timeout.IsUnknown() {
			bot_defenseMap["timeout"] = data.BotDefense.Timeout.ValueInt64()
		}
		apiResource.Spec["bot_defense"] = bot_defenseMap
	}
	if data.BotDefenseAdvanced != nil {
		bot_defense_advancedMap := make(map[string]interface{})
		if data.BotDefenseAdvanced.DisableJsInsert != nil {
			bot_defense_advancedMap["disable_js_insert"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.DisableMobileSdk != nil {
			bot_defense_advancedMap["disable_mobile_sdk"] = map[string]interface{}{}
		}
		if data.BotDefenseAdvanced.JsInsertAllPages != nil {
			js_insert_all_pagesNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.IsUnknown() {
				js_insert_all_pagesNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPages.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages"] = js_insert_all_pagesNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertAllPagesExcept != nil {
			js_insert_all_pages_exceptNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsNull() && !data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.IsUnknown() {
				js_insert_all_pages_exceptNestedMap["javascript_location"] = data.BotDefenseAdvanced.JsInsertAllPagesExcept.JavascriptLocation.ValueString()
			}
			bot_defense_advancedMap["js_insert_all_pages_except"] = js_insert_all_pages_exceptNestedMap
		}
		if data.BotDefenseAdvanced.JsInsertionRules != nil {
			js_insertion_rulesNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["js_insertion_rules"] = js_insertion_rulesNestedMap
		}
		if data.BotDefenseAdvanced.Mobile != nil {
			mobileNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Mobile.Name.IsNull() && !data.BotDefenseAdvanced.Mobile.Name.IsUnknown() {
				mobileNestedMap["name"] = data.BotDefenseAdvanced.Mobile.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Namespace.IsNull() && !data.BotDefenseAdvanced.Mobile.Namespace.IsUnknown() {
				mobileNestedMap["namespace"] = data.BotDefenseAdvanced.Mobile.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Mobile.Tenant.IsNull() && !data.BotDefenseAdvanced.Mobile.Tenant.IsUnknown() {
				mobileNestedMap["tenant"] = data.BotDefenseAdvanced.Mobile.Tenant.ValueString()
			}
			bot_defense_advancedMap["mobile"] = mobileNestedMap
		}
		if data.BotDefenseAdvanced.MobileSdkConfig != nil {
			mobile_sdk_configNestedMap := make(map[string]interface{})
			bot_defense_advancedMap["mobile_sdk_config"] = mobile_sdk_configNestedMap
		}
		if data.BotDefenseAdvanced.Web != nil {
			webNestedMap := make(map[string]interface{})
			if !data.BotDefenseAdvanced.Web.Name.IsNull() && !data.BotDefenseAdvanced.Web.Name.IsUnknown() {
				webNestedMap["name"] = data.BotDefenseAdvanced.Web.Name.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Namespace.IsNull() && !data.BotDefenseAdvanced.Web.Namespace.IsUnknown() {
				webNestedMap["namespace"] = data.BotDefenseAdvanced.Web.Namespace.ValueString()
			}
			if !data.BotDefenseAdvanced.Web.Tenant.IsNull() && !data.BotDefenseAdvanced.Web.Tenant.IsUnknown() {
				webNestedMap["tenant"] = data.BotDefenseAdvanced.Web.Tenant.ValueString()
			}
			bot_defense_advancedMap["web"] = webNestedMap
		}
		apiResource.Spec["bot_defense_advanced"] = bot_defense_advancedMap
	}
	if data.CachingPolicy != nil {
		caching_policyMap := make(map[string]interface{})
		if data.CachingPolicy.CustomCacheRule != nil {
			custom_cache_ruleNestedMap := make(map[string]interface{})
			caching_policyMap["custom_cache_rule"] = custom_cache_ruleNestedMap
		}
		if data.CachingPolicy.DefaultCacheAction != nil {
			default_cache_actionNestedMap := make(map[string]interface{})
			if !data.CachingPolicy.DefaultCacheAction.CacheTTLDefault.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTTLDefault.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_default"] = data.CachingPolicy.DefaultCacheAction.CacheTTLDefault.ValueString()
			}
			if !data.CachingPolicy.DefaultCacheAction.CacheTTLOverride.IsNull() && !data.CachingPolicy.DefaultCacheAction.CacheTTLOverride.IsUnknown() {
				default_cache_actionNestedMap["cache_ttl_override"] = data.CachingPolicy.DefaultCacheAction.CacheTTLOverride.ValueString()
			}
			caching_policyMap["default_cache_action"] = default_cache_actionNestedMap
		}
		apiResource.Spec["caching_policy"] = caching_policyMap
	}
	if data.CaptchaChallenge != nil {
		captcha_challengeMap := make(map[string]interface{})
		if !data.CaptchaChallenge.CookieExpiry.IsNull() && !data.CaptchaChallenge.CookieExpiry.IsUnknown() {
			captcha_challengeMap["cookie_expiry"] = data.CaptchaChallenge.CookieExpiry.ValueInt64()
		}
		if !data.CaptchaChallenge.CustomPage.IsNull() && !data.CaptchaChallenge.CustomPage.IsUnknown() {
			captcha_challengeMap["custom_page"] = data.CaptchaChallenge.CustomPage.ValueString()
		}
		apiResource.Spec["captcha_challenge"] = captcha_challengeMap
	}
	if data.ClientSideDefense != nil {
		client_side_defenseMap := make(map[string]interface{})
		if data.ClientSideDefense.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			client_side_defenseMap["policy"] = policyNestedMap
		}
		apiResource.Spec["client_side_defense"] = client_side_defenseMap
	}
	if data.CookieStickiness != nil {
		cookie_stickinessMap := make(map[string]interface{})
		if data.CookieStickiness.AddHttponly != nil {
			cookie_stickinessMap["add_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.AddSecure != nil {
			cookie_stickinessMap["add_secure"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreHttponly != nil {
			cookie_stickinessMap["ignore_httponly"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSamesite != nil {
			cookie_stickinessMap["ignore_samesite"] = map[string]interface{}{}
		}
		if data.CookieStickiness.IgnoreSecure != nil {
			cookie_stickinessMap["ignore_secure"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.Name.IsNull() && !data.CookieStickiness.Name.IsUnknown() {
			cookie_stickinessMap["name"] = data.CookieStickiness.Name.ValueString()
		}
		if !data.CookieStickiness.Path.IsNull() && !data.CookieStickiness.Path.IsUnknown() {
			cookie_stickinessMap["path"] = data.CookieStickiness.Path.ValueString()
		}
		if data.CookieStickiness.SamesiteLax != nil {
			cookie_stickinessMap["samesite_lax"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteNone != nil {
			cookie_stickinessMap["samesite_none"] = map[string]interface{}{}
		}
		if data.CookieStickiness.SamesiteStrict != nil {
			cookie_stickinessMap["samesite_strict"] = map[string]interface{}{}
		}
		if !data.CookieStickiness.TTL.IsNull() && !data.CookieStickiness.TTL.IsUnknown() {
			cookie_stickinessMap["ttl"] = data.CookieStickiness.TTL.ValueInt64()
		}
		apiResource.Spec["cookie_stickiness"] = cookie_stickinessMap
	}
	if data.CORSPolicy != nil {
		cors_policyMap := make(map[string]interface{})
		if !data.CORSPolicy.AllowCredentials.IsNull() && !data.CORSPolicy.AllowCredentials.IsUnknown() {
			cors_policyMap["allow_credentials"] = data.CORSPolicy.AllowCredentials.ValueBool()
		}
		if !data.CORSPolicy.AllowHeaders.IsNull() && !data.CORSPolicy.AllowHeaders.IsUnknown() {
			cors_policyMap["allow_headers"] = data.CORSPolicy.AllowHeaders.ValueString()
		}
		if !data.CORSPolicy.AllowMethods.IsNull() && !data.CORSPolicy.AllowMethods.IsUnknown() {
			cors_policyMap["allow_methods"] = data.CORSPolicy.AllowMethods.ValueString()
		}
		if !data.CORSPolicy.AllowOrigin.IsNull() && !data.CORSPolicy.AllowOrigin.IsUnknown() {
			var allow_originItems []string
			diags := data.CORSPolicy.AllowOrigin.ElementsAs(ctx, &allow_originItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin"] = allow_originItems
			}
		}
		if !data.CORSPolicy.AllowOriginRegex.IsNull() && !data.CORSPolicy.AllowOriginRegex.IsUnknown() {
			var allow_origin_regexItems []string
			diags := data.CORSPolicy.AllowOriginRegex.ElementsAs(ctx, &allow_origin_regexItems, false)
			if !diags.HasError() {
				cors_policyMap["allow_origin_regex"] = allow_origin_regexItems
			}
		}
		if !data.CORSPolicy.Disabled.IsNull() && !data.CORSPolicy.Disabled.IsUnknown() {
			cors_policyMap["disabled"] = data.CORSPolicy.Disabled.ValueBool()
		}
		if !data.CORSPolicy.ExposeHeaders.IsNull() && !data.CORSPolicy.ExposeHeaders.IsUnknown() {
			cors_policyMap["expose_headers"] = data.CORSPolicy.ExposeHeaders.ValueString()
		}
		if !data.CORSPolicy.MaximumAge.IsNull() && !data.CORSPolicy.MaximumAge.IsUnknown() {
			cors_policyMap["maximum_age"] = data.CORSPolicy.MaximumAge.ValueInt64()
		}
		apiResource.Spec["cors_policy"] = cors_policyMap
	}
	if data.CSRFPolicy != nil {
		csrf_policyMap := make(map[string]interface{})
		if data.CSRFPolicy.AllLoadBalancerDomains != nil {
			csrf_policyMap["all_load_balancer_domains"] = map[string]interface{}{}
		}
		if data.CSRFPolicy.CustomDomainList != nil {
			custom_domain_listNestedMap := make(map[string]interface{})
			csrf_policyMap["custom_domain_list"] = custom_domain_listNestedMap
		}
		if data.CSRFPolicy.Disabled != nil {
			csrf_policyMap["disabled"] = map[string]interface{}{}
		}
		apiResource.Spec["csrf_policy"] = csrf_policyMap
	}
	if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
		var data_guard_rulesItems []HTTPLoadBalancerDataGuardRulesModel
		diags := data.DataGuardRules.ElementsAs(ctx, &data_guard_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(data_guard_rulesItems) > 0 {
			var data_guard_rulesList []map[string]interface{}
			for _, item := range data_guard_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if item.ApplyDataGuard != nil {
					itemMap["apply_data_guard"] = map[string]interface{}{}
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.Path != nil {
					pathNestedMap := make(map[string]interface{})
					if !item.Path.Path.IsNull() && !item.Path.Path.IsUnknown() {
						pathNestedMap["path"] = item.Path.Path.ValueString()
					}
					if !item.Path.Prefix.IsNull() && !item.Path.Prefix.IsUnknown() {
						pathNestedMap["prefix"] = item.Path.Prefix.ValueString()
					}
					if !item.Path.Regex.IsNull() && !item.Path.Regex.IsUnknown() {
						pathNestedMap["regex"] = item.Path.Regex.ValueString()
					}
					itemMap["path"] = pathNestedMap
				}
				if item.SkipDataGuard != nil {
					itemMap["skip_data_guard"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				data_guard_rulesList = append(data_guard_rulesList, itemMap)
			}
			apiResource.Spec["data_guard_rules"] = data_guard_rulesList
		}
	}
	if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
		var ddos_mitigation_rulesItems []HTTPLoadBalancerDDOSMitigationRulesModel
		diags := data.DDOSMitigationRules.ElementsAs(ctx, &ddos_mitigation_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(ddos_mitigation_rulesItems) > 0 {
			var ddos_mitigation_rulesList []map[string]interface{}
			for _, item := range ddos_mitigation_rulesItems {
				itemMap := make(map[string]interface{})
				if item.Block != nil {
					itemMap["block"] = map[string]interface{}{}
				}
				if item.DDOSClientSource != nil {
					ddos_client_sourceNestedMap := make(map[string]interface{})
					if item.DDOSClientSource.AsnList != nil {
						asn_listDeepMap := make(map[string]interface{})
						ddos_client_sourceNestedMap["asn_list"] = asn_listDeepMap
					}
					if !item.DDOSClientSource.CountryList.IsNull() && !item.DDOSClientSource.CountryList.IsUnknown() {
						var CountryListItems []string
						diags := item.DDOSClientSource.CountryList.ElementsAs(ctx, &CountryListItems, false)
						if !diags.HasError() {
							ddos_client_sourceNestedMap["country_list"] = CountryListItems
						}
					}
					if item.DDOSClientSource.Ja4TLSFingerprintMatcher != nil {
						ja4_tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.Ja4TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								ja4_tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						ddos_client_sourceNestedMap["ja4_tls_fingerprint_matcher"] = ja4_tls_fingerprint_matcherDeepMap
					}
					if item.DDOSClientSource.TLSFingerprintMatcher != nil {
						tls_fingerprint_matcherDeepMap := make(map[string]interface{})
						if !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.Classes.IsUnknown() {
							var ClassesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.Classes.ElementsAs(ctx, &ClassesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["classes"] = ClassesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsNull() && !item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.IsUnknown() {
							var ExcludedValuesItems []string
							diags := item.DDOSClientSource.TLSFingerprintMatcher.ExcludedValues.ElementsAs(ctx, &ExcludedValuesItems, false)
							if !diags.HasError() {
								tls_fingerprint_matcherDeepMap["excluded_values"] = ExcludedValuesItems
							}
						}
						ddos_client_sourceNestedMap["tls_fingerprint_matcher"] = tls_fingerprint_matcherDeepMap
					}
					itemMap["ddos_client_source"] = ddos_client_sourceNestedMap
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.IPPrefixList != nil {
					ip_prefix_listNestedMap := make(map[string]interface{})
					if !item.IPPrefixList.InvertMatch.IsNull() && !item.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listNestedMap["invert_match"] = item.IPPrefixList.InvertMatch.ValueBool()
					}
					if !item.IPPrefixList.IPPrefixes.IsNull() && !item.IPPrefixList.IPPrefixes.IsUnknown() {
						var IPPrefixesItems []string
						diags := item.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
						if !diags.HasError() {
							ip_prefix_listNestedMap["ip_prefixes"] = IPPrefixesItems
						}
					}
					itemMap["ip_prefix_list"] = ip_prefix_listNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, itemMap)
			}
			apiResource.Spec["ddos_mitigation_rules"] = ddos_mitigation_rulesList
		}
	}
	if data.DefaultPool != nil {
		default_poolMap := make(map[string]interface{})
		if data.DefaultPool.AdvancedOptions != nil {
			advanced_optionsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.ConnectionTimeout.IsUnknown() {
				advanced_optionsNestedMap["connection_timeout"] = data.DefaultPool.AdvancedOptions.ConnectionTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsNull() && !data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.IsUnknown() {
				advanced_optionsNestedMap["http_idle_timeout"] = data.DefaultPool.AdvancedOptions.HTTPIdleTimeout.ValueInt64()
			}
			if !data.DefaultPool.AdvancedOptions.PanicThreshold.IsNull() && !data.DefaultPool.AdvancedOptions.PanicThreshold.IsUnknown() {
				advanced_optionsNestedMap["panic_threshold"] = data.DefaultPool.AdvancedOptions.PanicThreshold.ValueInt64()
			}
			default_poolMap["advanced_options"] = advanced_optionsNestedMap
		}
		if data.DefaultPool.AutomaticPort != nil {
			default_poolMap["automatic_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.EndpointSelection.IsNull() && !data.DefaultPool.EndpointSelection.IsUnknown() {
			default_poolMap["endpoint_selection"] = data.DefaultPool.EndpointSelection.ValueString()
		}
		if !data.DefaultPool.HealthCheckPort.IsNull() && !data.DefaultPool.HealthCheckPort.IsUnknown() {
			default_poolMap["health_check_port"] = data.DefaultPool.HealthCheckPort.ValueInt64()
		}
		if len(data.DefaultPool.Healthcheck) > 0 {
			var healthcheckList []map[string]interface{}
			for _, listItem := range data.DefaultPool.Healthcheck {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				healthcheckList = append(healthcheckList, listItemMap)
			}
			default_poolMap["healthcheck"] = healthcheckList
		}
		if data.DefaultPool.LBPort != nil {
			default_poolMap["lb_port"] = map[string]interface{}{}
		}
		if !data.DefaultPool.LoadBalancerAlgorithm.IsNull() && !data.DefaultPool.LoadBalancerAlgorithm.IsUnknown() {
			default_poolMap["loadbalancer_algorithm"] = data.DefaultPool.LoadBalancerAlgorithm.ValueString()
		}
		if data.DefaultPool.NoTLS != nil {
			default_poolMap["no_tls"] = map[string]interface{}{}
		}
		if len(data.DefaultPool.OriginServers) > 0 {
			var origin_serversList []map[string]interface{}
			for _, listItem := range data.DefaultPool.OriginServers {
				listItemMap := make(map[string]interface{})
				if listItem.CbipService != nil {
					cbip_serviceDeepMap := make(map[string]interface{})
					if !listItem.CbipService.ServiceName.IsNull() && !listItem.CbipService.ServiceName.IsUnknown() {
						cbip_serviceDeepMap["service_name"] = listItem.CbipService.ServiceName.ValueString()
					}
					listItemMap["cbip_service"] = cbip_serviceDeepMap
				}
				if listItem.ConsulService != nil {
					consul_serviceDeepMap := make(map[string]interface{})
					if listItem.ConsulService.InsideNetwork != nil {
						consul_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.ConsulService.OutsideNetwork != nil {
						consul_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.ConsulService.ServiceName.IsNull() && !listItem.ConsulService.ServiceName.IsUnknown() {
						consul_serviceDeepMap["service_name"] = listItem.ConsulService.ServiceName.ValueString()
					}
					listItemMap["consul_service"] = consul_serviceDeepMap
				}
				if listItem.CustomEndpointObject != nil {
					custom_endpoint_objectDeepMap := make(map[string]interface{})
					listItemMap["custom_endpoint_object"] = custom_endpoint_objectDeepMap
				}
				if listItem.K8SService != nil {
					k8s_serviceDeepMap := make(map[string]interface{})
					if listItem.K8SService.InsideNetwork != nil {
						k8s_serviceDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.K8SService.OutsideNetwork != nil {
						k8s_serviceDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.K8SService.Protocol.IsNull() && !listItem.K8SService.Protocol.IsUnknown() {
						k8s_serviceDeepMap["protocol"] = listItem.K8SService.Protocol.ValueString()
					}
					if !listItem.K8SService.ServiceName.IsNull() && !listItem.K8SService.ServiceName.IsUnknown() {
						k8s_serviceDeepMap["service_name"] = listItem.K8SService.ServiceName.ValueString()
					}
					if listItem.K8SService.Vk8sNetworks != nil {
						k8s_serviceDeepMap["vk8s_networks"] = map[string]interface{}{}
					}
					listItemMap["k8s_service"] = k8s_serviceDeepMap
				}
				if listItem.Labels != nil {
					listItemMap["labels"] = map[string]interface{}{}
				}
				if listItem.PrivateIP != nil {
					private_ipDeepMap := make(map[string]interface{})
					if listItem.PrivateIP.InsideNetwork != nil {
						private_ipDeepMap["inside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateIP.IP.IsNull() && !listItem.PrivateIP.IP.IsUnknown() {
						private_ipDeepMap["ip"] = listItem.PrivateIP.IP.ValueString()
					}
					if listItem.PrivateIP.OutsideNetwork != nil {
						private_ipDeepMap["outside_network"] = map[string]interface{}{}
					}
					listItemMap["private_ip"] = private_ipDeepMap
				}
				if listItem.PrivateName != nil {
					private_nameDeepMap := make(map[string]interface{})
					if !listItem.PrivateName.DNSName.IsNull() && !listItem.PrivateName.DNSName.IsUnknown() {
						private_nameDeepMap["dns_name"] = listItem.PrivateName.DNSName.ValueString()
					}
					if listItem.PrivateName.InsideNetwork != nil {
						private_nameDeepMap["inside_network"] = map[string]interface{}{}
					}
					if listItem.PrivateName.OutsideNetwork != nil {
						private_nameDeepMap["outside_network"] = map[string]interface{}{}
					}
					if !listItem.PrivateName.RefreshInterval.IsNull() && !listItem.PrivateName.RefreshInterval.IsUnknown() {
						private_nameDeepMap["refresh_interval"] = listItem.PrivateName.RefreshInterval.ValueInt64()
					}
					listItemMap["private_name"] = private_nameDeepMap
				}
				if listItem.PublicIP != nil {
					public_ipDeepMap := make(map[string]interface{})
					if !listItem.PublicIP.IP.IsNull() && !listItem.PublicIP.IP.IsUnknown() {
						public_ipDeepMap["ip"] = listItem.PublicIP.IP.ValueString()
					}
					listItemMap["public_ip"] = public_ipDeepMap
				}
				if listItem.PublicName != nil {
					public_nameDeepMap := make(map[string]interface{})
					if !listItem.PublicName.DNSName.IsNull() && !listItem.PublicName.DNSName.IsUnknown() {
						public_nameDeepMap["dns_name"] = listItem.PublicName.DNSName.ValueString()
					}
					if !listItem.PublicName.RefreshInterval.IsNull() && !listItem.PublicName.RefreshInterval.IsUnknown() {
						public_nameDeepMap["refresh_interval"] = listItem.PublicName.RefreshInterval.ValueInt64()
					}
					listItemMap["public_name"] = public_nameDeepMap
				}
				if listItem.VnPrivateIP != nil {
					vn_private_ipDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateIP.IP.IsNull() && !listItem.VnPrivateIP.IP.IsUnknown() {
						vn_private_ipDeepMap["ip"] = listItem.VnPrivateIP.IP.ValueString()
					}
					listItemMap["vn_private_ip"] = vn_private_ipDeepMap
				}
				if listItem.VnPrivateName != nil {
					vn_private_nameDeepMap := make(map[string]interface{})
					if !listItem.VnPrivateName.DNSName.IsNull() && !listItem.VnPrivateName.DNSName.IsUnknown() {
						vn_private_nameDeepMap["dns_name"] = listItem.VnPrivateName.DNSName.ValueString()
					}
					listItemMap["vn_private_name"] = vn_private_nameDeepMap
				}
				origin_serversList = append(origin_serversList, listItemMap)
			}
			default_poolMap["origin_servers"] = origin_serversList
		}
		if !data.DefaultPool.Port.IsNull() && !data.DefaultPool.Port.IsUnknown() {
			default_poolMap["port"] = data.DefaultPool.Port.ValueInt64()
		}
		if data.DefaultPool.SameAsEndpointPort != nil {
			default_poolMap["same_as_endpoint_port"] = map[string]interface{}{}
		}
		if data.DefaultPool.UpstreamConnPoolReuseType != nil {
			upstream_conn_pool_reuse_typeNestedMap := make(map[string]interface{})
			default_poolMap["upstream_conn_pool_reuse_type"] = upstream_conn_pool_reuse_typeNestedMap
		}
		if data.DefaultPool.UseTLS != nil {
			use_tlsNestedMap := make(map[string]interface{})
			if !data.DefaultPool.UseTLS.MaxSessionKeys.IsNull() && !data.DefaultPool.UseTLS.MaxSessionKeys.IsUnknown() {
				use_tlsNestedMap["max_session_keys"] = data.DefaultPool.UseTLS.MaxSessionKeys.ValueInt64()
			}
			if !data.DefaultPool.UseTLS.Sni.IsNull() && !data.DefaultPool.UseTLS.Sni.IsUnknown() {
				use_tlsNestedMap["sni"] = data.DefaultPool.UseTLS.Sni.ValueString()
			}
			default_poolMap["use_tls"] = use_tlsNestedMap
		}
		if data.DefaultPool.ViewInternal != nil {
			view_internalNestedMap := make(map[string]interface{})
			if !data.DefaultPool.ViewInternal.Name.IsNull() && !data.DefaultPool.ViewInternal.Name.IsUnknown() {
				view_internalNestedMap["name"] = data.DefaultPool.ViewInternal.Name.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Namespace.IsNull() && !data.DefaultPool.ViewInternal.Namespace.IsUnknown() {
				view_internalNestedMap["namespace"] = data.DefaultPool.ViewInternal.Namespace.ValueString()
			}
			if !data.DefaultPool.ViewInternal.Tenant.IsNull() && !data.DefaultPool.ViewInternal.Tenant.IsUnknown() {
				view_internalNestedMap["tenant"] = data.DefaultPool.ViewInternal.Tenant.ValueString()
			}
			default_poolMap["view_internal"] = view_internalNestedMap
		}
		apiResource.Spec["default_pool"] = default_poolMap
	}
	if data.DefaultPoolList != nil {
		default_pool_listMap := make(map[string]interface{})
		if len(data.DefaultPoolList.Pools) > 0 {
			var poolsList []map[string]interface{}
			for _, listItem := range data.DefaultPoolList.Pools {
				listItemMap := make(map[string]interface{})
				if listItem.Cluster != nil {
					clusterDeepMap := make(map[string]interface{})
					if !listItem.Cluster.Name.IsNull() && !listItem.Cluster.Name.IsUnknown() {
						clusterDeepMap["name"] = listItem.Cluster.Name.ValueString()
					}
					if !listItem.Cluster.Namespace.IsNull() && !listItem.Cluster.Namespace.IsUnknown() {
						clusterDeepMap["namespace"] = listItem.Cluster.Namespace.ValueString()
					}
					if !listItem.Cluster.Tenant.IsNull() && !listItem.Cluster.Tenant.IsUnknown() {
						clusterDeepMap["tenant"] = listItem.Cluster.Tenant.ValueString()
					}
					listItemMap["cluster"] = clusterDeepMap
				}
				if listItem.EndpointSubsets != nil {
					listItemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if listItem.Pool != nil {
					poolDeepMap := make(map[string]interface{})
					if !listItem.Pool.Name.IsNull() && !listItem.Pool.Name.IsUnknown() {
						poolDeepMap["name"] = listItem.Pool.Name.ValueString()
					}
					if !listItem.Pool.Namespace.IsNull() && !listItem.Pool.Namespace.IsUnknown() {
						poolDeepMap["namespace"] = listItem.Pool.Namespace.ValueString()
					}
					if !listItem.Pool.Tenant.IsNull() && !listItem.Pool.Tenant.IsUnknown() {
						poolDeepMap["tenant"] = listItem.Pool.Tenant.ValueString()
					}
					listItemMap["pool"] = poolDeepMap
				}
				if !listItem.Priority.IsNull() && !listItem.Priority.IsUnknown() {
					listItemMap["priority"] = listItem.Priority.ValueInt64()
				}
				if !listItem.Weight.IsNull() && !listItem.Weight.IsUnknown() {
					listItemMap["weight"] = listItem.Weight.ValueInt64()
				}
				poolsList = append(poolsList, listItemMap)
			}
			default_pool_listMap["pools"] = poolsList
		}
		apiResource.Spec["default_pool_list"] = default_pool_listMap
	}
	if !data.DefaultRoutePools.IsNull() && !data.DefaultRoutePools.IsUnknown() {
		var default_route_poolsItems []HTTPLoadBalancerDefaultRoutePoolsModel
		diags := data.DefaultRoutePools.ElementsAs(ctx, &default_route_poolsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(default_route_poolsItems) > 0 {
			var default_route_poolsList []map[string]interface{}
			for _, item := range default_route_poolsItems {
				itemMap := make(map[string]interface{})
				if item.Cluster != nil {
					clusterNestedMap := make(map[string]interface{})
					if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
						clusterNestedMap["name"] = item.Cluster.Name.ValueString()
					}
					if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
						clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
					}
					if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
						clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
					}
					itemMap["cluster"] = clusterNestedMap
				}
				if item.EndpointSubsets != nil {
					itemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if item.Pool != nil {
					poolNestedMap := make(map[string]interface{})
					if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
						poolNestedMap["name"] = item.Pool.Name.ValueString()
					}
					if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
						poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
					}
					if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
						poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
					}
					itemMap["pool"] = poolNestedMap
				}
				if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
					itemMap["priority"] = item.Priority.ValueInt64()
				}
				if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
					itemMap["weight"] = item.Weight.ValueInt64()
				}
				default_route_poolsList = append(default_route_poolsList, itemMap)
			}
			apiResource.Spec["default_route_pools"] = default_route_poolsList
		}
	}
	if data.DefaultSensitiveDataPolicy != nil {
		default_sensitive_data_policyMap := make(map[string]interface{})
		apiResource.Spec["default_sensitive_data_policy"] = default_sensitive_data_policyMap
	}
	if data.DisableAPIDefinition != nil {
		disable_api_definitionMap := make(map[string]interface{})
		apiResource.Spec["disable_api_definition"] = disable_api_definitionMap
	}
	if data.DisableAPIDiscovery != nil {
		disable_api_discoveryMap := make(map[string]interface{})
		apiResource.Spec["disable_api_discovery"] = disable_api_discoveryMap
	}
	if data.DisableAPITesting != nil {
		disable_api_testingMap := make(map[string]interface{})
		apiResource.Spec["disable_api_testing"] = disable_api_testingMap
	}
	if data.DisableBotDefense != nil {
		disable_bot_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_bot_defense"] = disable_bot_defenseMap
	}
	if data.DisableCaching != nil {
		disable_cachingMap := make(map[string]interface{})
		apiResource.Spec["disable_caching"] = disable_cachingMap
	}
	if data.DisableClientSideDefense != nil {
		disable_client_side_defenseMap := make(map[string]interface{})
		apiResource.Spec["disable_client_side_defense"] = disable_client_side_defenseMap
	}
	if data.DisableIPReputation != nil {
		disable_ip_reputationMap := make(map[string]interface{})
		apiResource.Spec["disable_ip_reputation"] = disable_ip_reputationMap
	}
	if data.DisableMaliciousUserDetection != nil {
		disable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malicious_user_detection"] = disable_malicious_user_detectionMap
	}
	if data.DisableMalwareProtection != nil {
		disable_malware_protectionMap := make(map[string]interface{})
		apiResource.Spec["disable_malware_protection"] = disable_malware_protectionMap
	}
	if data.DisableRateLimit != nil {
		disable_rate_limitMap := make(map[string]interface{})
		apiResource.Spec["disable_rate_limit"] = disable_rate_limitMap
	}
	if data.DisableThreatMesh != nil {
		disable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["disable_threat_mesh"] = disable_threat_meshMap
	}
	if data.DisableTrustClientIPHeaders != nil {
		disable_trust_client_ip_headersMap := make(map[string]interface{})
		apiResource.Spec["disable_trust_client_ip_headers"] = disable_trust_client_ip_headersMap
	}
	if data.DisableWAF != nil {
		disable_wafMap := make(map[string]interface{})
		apiResource.Spec["disable_waf"] = disable_wafMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.EnableAPIDiscovery != nil {
		enable_api_discoveryMap := make(map[string]interface{})
		if data.EnableAPIDiscovery.APICrawler != nil {
			api_crawlerNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_crawler"] = api_crawlerNestedMap
		}
		if data.EnableAPIDiscovery.APIDiscoveryFromCodeScan != nil {
			api_discovery_from_code_scanNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["api_discovery_from_code_scan"] = api_discovery_from_code_scanNestedMap
		}
		if data.EnableAPIDiscovery.CustomAPIAuthDiscovery != nil {
			custom_api_auth_discoveryNestedMap := make(map[string]interface{})
			enable_api_discoveryMap["custom_api_auth_discovery"] = custom_api_auth_discoveryNestedMap
		}
		if data.EnableAPIDiscovery.DefaultAPIAuthDiscovery != nil {
			enable_api_discoveryMap["default_api_auth_discovery"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DisableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["disable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		if data.EnableAPIDiscovery.DiscoveredAPISettings != nil {
			discovered_api_settingsNestedMap := make(map[string]interface{})
			if !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsNull() && !data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.IsUnknown() {
				discovered_api_settingsNestedMap["purge_duration_for_inactive_discovered_apis"] = data.EnableAPIDiscovery.DiscoveredAPISettings.PurgeDurationForInactiveDiscoveredApis.ValueInt64()
			}
			enable_api_discoveryMap["discovered_api_settings"] = discovered_api_settingsNestedMap
		}
		if data.EnableAPIDiscovery.EnableLearnFromRedirectTraffic != nil {
			enable_api_discoveryMap["enable_learn_from_redirect_traffic"] = map[string]interface{}{}
		}
		apiResource.Spec["enable_api_discovery"] = enable_api_discoveryMap
	}
	if data.EnableChallenge != nil {
		enable_challengeMap := make(map[string]interface{})
		if data.EnableChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			enable_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.EnableChallenge.DefaultCaptchaChallengeParameters != nil {
			enable_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultJsChallengeParameters != nil {
			enable_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.EnableChallenge.DefaultMitigationSettings != nil {
			enable_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.EnableChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.EnableChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.EnableChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.EnableChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.EnableChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.EnableChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.EnableChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.EnableChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			enable_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.EnableChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.EnableChallenge.MaliciousUserMitigation.Name.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.EnableChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.EnableChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.EnableChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.EnableChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			enable_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		apiResource.Spec["enable_challenge"] = enable_challengeMap
	}
	if data.EnableIPReputation != nil {
		enable_ip_reputationMap := make(map[string]interface{})
		if !data.EnableIPReputation.IPThreatCategories.IsNull() && !data.EnableIPReputation.IPThreatCategories.IsUnknown() {
			var ip_threat_categoriesItems []string
			diags := data.EnableIPReputation.IPThreatCategories.ElementsAs(ctx, &ip_threat_categoriesItems, false)
			if !diags.HasError() {
				enable_ip_reputationMap["ip_threat_categories"] = ip_threat_categoriesItems
			}
		}
		apiResource.Spec["enable_ip_reputation"] = enable_ip_reputationMap
	}
	if data.EnableMaliciousUserDetection != nil {
		enable_malicious_user_detectionMap := make(map[string]interface{})
		apiResource.Spec["enable_malicious_user_detection"] = enable_malicious_user_detectionMap
	}
	if data.EnableThreatMesh != nil {
		enable_threat_meshMap := make(map[string]interface{})
		apiResource.Spec["enable_threat_mesh"] = enable_threat_meshMap
	}
	if data.EnableTrustClientIPHeaders != nil {
		enable_trust_client_ip_headersMap := make(map[string]interface{})
		if !data.EnableTrustClientIPHeaders.ClientIPHeaders.IsNull() && !data.EnableTrustClientIPHeaders.ClientIPHeaders.IsUnknown() {
			var client_ip_headersItems []string
			diags := data.EnableTrustClientIPHeaders.ClientIPHeaders.ElementsAs(ctx, &client_ip_headersItems, false)
			if !diags.HasError() {
				enable_trust_client_ip_headersMap["client_ip_headers"] = client_ip_headersItems
			}
		}
		apiResource.Spec["enable_trust_client_ip_headers"] = enable_trust_client_ip_headersMap
	}
	if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
		var graphql_rulesItems []HTTPLoadBalancerGraphqlRulesModel
		diags := data.GraphqlRules.ElementsAs(ctx, &graphql_rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(graphql_rulesItems) > 0 {
			var graphql_rulesList []map[string]interface{}
			for _, item := range graphql_rulesItems {
				itemMap := make(map[string]interface{})
				if item.AnyDomain != nil {
					itemMap["any_domain"] = map[string]interface{}{}
				}
				if !item.ExactPath.IsNull() && !item.ExactPath.IsUnknown() {
					itemMap["exact_path"] = item.ExactPath.ValueString()
				}
				if !item.ExactValue.IsNull() && !item.ExactValue.IsUnknown() {
					itemMap["exact_value"] = item.ExactValue.ValueString()
				}
				if item.GraphqlSettings != nil {
					graphql_settingsNestedMap := make(map[string]interface{})
					if item.GraphqlSettings.DisableIntrospection != nil {
						graphql_settingsNestedMap["disable_introspection"] = map[string]interface{}{}
					}
					if item.GraphqlSettings.EnableIntrospection != nil {
						graphql_settingsNestedMap["enable_introspection"] = map[string]interface{}{}
					}
					if !item.GraphqlSettings.MaxBatchedQueries.IsNull() && !item.GraphqlSettings.MaxBatchedQueries.IsUnknown() {
						graphql_settingsNestedMap["max_batched_queries"] = item.GraphqlSettings.MaxBatchedQueries.ValueInt64()
					}
					if !item.GraphqlSettings.MaxDepth.IsNull() && !item.GraphqlSettings.MaxDepth.IsUnknown() {
						graphql_settingsNestedMap["max_depth"] = item.GraphqlSettings.MaxDepth.ValueInt64()
					}
					if !item.GraphqlSettings.MaxTotalLength.IsNull() && !item.GraphqlSettings.MaxTotalLength.IsUnknown() {
						graphql_settingsNestedMap["max_total_length"] = item.GraphqlSettings.MaxTotalLength.ValueInt64()
					}
					itemMap["graphql_settings"] = graphql_settingsNestedMap
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.MethodGet != nil {
					itemMap["method_get"] = map[string]interface{}{}
				}
				if item.MethodPost != nil {
					itemMap["method_post"] = map[string]interface{}{}
				}
				if !item.SuffixValue.IsNull() && !item.SuffixValue.IsUnknown() {
					itemMap["suffix_value"] = item.SuffixValue.ValueString()
				}
				graphql_rulesList = append(graphql_rulesList, itemMap)
			}
			apiResource.Spec["graphql_rules"] = graphql_rulesList
		}
	}
	if data.HTTP != nil {
		httpMap := make(map[string]interface{})
		if !data.HTTP.DNSVolterraManaged.IsNull() && !data.HTTP.DNSVolterraManaged.IsUnknown() {
			httpMap["dns_volterra_managed"] = data.HTTP.DNSVolterraManaged.ValueBool()
		}
		if !data.HTTP.Port.IsNull() && !data.HTTP.Port.IsUnknown() {
			httpMap["port"] = data.HTTP.Port.ValueInt64()
		}
		if !data.HTTP.PortRanges.IsNull() && !data.HTTP.PortRanges.IsUnknown() {
			httpMap["port_ranges"] = data.HTTP.PortRanges.ValueString()
		}
		apiResource.Spec["http"] = httpMap
	}
	if data.HTTPS != nil {
		httpsMap := make(map[string]interface{})
		if !data.HTTPS.AddHsts.IsNull() && !data.HTTPS.AddHsts.IsUnknown() {
			httpsMap["add_hsts"] = data.HTTPS.AddHsts.ValueBool()
		}
		if !data.HTTPS.AppendServerName.IsNull() && !data.HTTPS.AppendServerName.IsUnknown() {
			httpsMap["append_server_name"] = data.HTTPS.AppendServerName.ValueString()
		}
		if data.HTTPS.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			httpsMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPS.ConnectionIdleTimeout.IsNull() && !data.HTTPS.ConnectionIdleTimeout.IsUnknown() {
			httpsMap["connection_idle_timeout"] = data.HTTPS.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPS.DefaultHeader != nil {
			httpsMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPS.DefaultLoadBalancer != nil {
			httpsMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.DisablePathNormalize != nil {
			httpsMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.EnablePathNormalize != nil {
			httpsMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPS.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			httpsMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPS.HTTPRedirect.IsNull() && !data.HTTPS.HTTPRedirect.IsUnknown() {
			httpsMap["http_redirect"] = data.HTTPS.HTTPRedirect.ValueBool()
		}
		if data.HTTPS.NonDefaultLoadBalancer != nil {
			httpsMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPS.PassThrough != nil {
			httpsMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPS.Port.IsNull() && !data.HTTPS.Port.IsUnknown() {
			httpsMap["port"] = data.HTTPS.Port.ValueInt64()
		}
		if !data.HTTPS.PortRanges.IsNull() && !data.HTTPS.PortRanges.IsUnknown() {
			httpsMap["port_ranges"] = data.HTTPS.PortRanges.ValueString()
		}
		if !data.HTTPS.ServerName.IsNull() && !data.HTTPS.ServerName.IsUnknown() {
			httpsMap["server_name"] = data.HTTPS.ServerName.ValueString()
		}
		if data.HTTPS.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			httpsMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.HTTPS.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			httpsMap["tls_parameters"] = tls_parametersNestedMap
		}
		apiResource.Spec["https"] = httpsMap
	}
	if data.HTTPSAutoCert != nil {
		https_auto_certMap := make(map[string]interface{})
		if !data.HTTPSAutoCert.AddHsts.IsNull() && !data.HTTPSAutoCert.AddHsts.IsUnknown() {
			https_auto_certMap["add_hsts"] = data.HTTPSAutoCert.AddHsts.ValueBool()
		}
		if !data.HTTPSAutoCert.AppendServerName.IsNull() && !data.HTTPSAutoCert.AppendServerName.IsUnknown() {
			https_auto_certMap["append_server_name"] = data.HTTPSAutoCert.AppendServerName.ValueString()
		}
		if data.HTTPSAutoCert.CoalescingOptions != nil {
			coalescing_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["coalescing_options"] = coalescing_optionsNestedMap
		}
		if !data.HTTPSAutoCert.ConnectionIdleTimeout.IsNull() && !data.HTTPSAutoCert.ConnectionIdleTimeout.IsUnknown() {
			https_auto_certMap["connection_idle_timeout"] = data.HTTPSAutoCert.ConnectionIdleTimeout.ValueInt64()
		}
		if data.HTTPSAutoCert.DefaultHeader != nil {
			https_auto_certMap["default_header"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DefaultLoadBalancer != nil {
			https_auto_certMap["default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.DisablePathNormalize != nil {
			https_auto_certMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.EnablePathNormalize != nil {
			https_auto_certMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.HTTPProtocolOptions != nil {
			http_protocol_optionsNestedMap := make(map[string]interface{})
			https_auto_certMap["http_protocol_options"] = http_protocol_optionsNestedMap
		}
		if !data.HTTPSAutoCert.HTTPRedirect.IsNull() && !data.HTTPSAutoCert.HTTPRedirect.IsUnknown() {
			https_auto_certMap["http_redirect"] = data.HTTPSAutoCert.HTTPRedirect.ValueBool()
		}
		if data.HTTPSAutoCert.NoMtls != nil {
			https_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.NonDefaultLoadBalancer != nil {
			https_auto_certMap["non_default_loadbalancer"] = map[string]interface{}{}
		}
		if data.HTTPSAutoCert.PassThrough != nil {
			https_auto_certMap["pass_through"] = map[string]interface{}{}
		}
		if !data.HTTPSAutoCert.Port.IsNull() && !data.HTTPSAutoCert.Port.IsUnknown() {
			https_auto_certMap["port"] = data.HTTPSAutoCert.Port.ValueInt64()
		}
		if !data.HTTPSAutoCert.PortRanges.IsNull() && !data.HTTPSAutoCert.PortRanges.IsUnknown() {
			https_auto_certMap["port_ranges"] = data.HTTPSAutoCert.PortRanges.ValueString()
		}
		if !data.HTTPSAutoCert.ServerName.IsNull() && !data.HTTPSAutoCert.ServerName.IsUnknown() {
			https_auto_certMap["server_name"] = data.HTTPSAutoCert.ServerName.ValueString()
		}
		if data.HTTPSAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			https_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.HTTPSAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.HTTPSAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.HTTPSAutoCert.UseMtls.TrustedCAURL.IsNull() && !data.HTTPSAutoCert.UseMtls.TrustedCAURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.HTTPSAutoCert.UseMtls.TrustedCAURL.ValueString()
			}
			https_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		apiResource.Spec["https_auto_cert"] = https_auto_certMap
	}
	if data.JsChallenge != nil {
		js_challengeMap := make(map[string]interface{})
		if !data.JsChallenge.CookieExpiry.IsNull() && !data.JsChallenge.CookieExpiry.IsUnknown() {
			js_challengeMap["cookie_expiry"] = data.JsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.JsChallenge.CustomPage.IsNull() && !data.JsChallenge.CustomPage.IsUnknown() {
			js_challengeMap["custom_page"] = data.JsChallenge.CustomPage.ValueString()
		}
		if !data.JsChallenge.JsScriptDelay.IsNull() && !data.JsChallenge.JsScriptDelay.IsUnknown() {
			js_challengeMap["js_script_delay"] = data.JsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["js_challenge"] = js_challengeMap
	}
	if data.JWTValidation != nil {
		jwt_validationMap := make(map[string]interface{})
		if data.JWTValidation.Action != nil {
			actionNestedMap := make(map[string]interface{})
			jwt_validationMap["action"] = actionNestedMap
		}
		if data.JWTValidation.JwksConfig != nil {
			jwks_configNestedMap := make(map[string]interface{})
			if !data.JWTValidation.JwksConfig.Cleartext.IsNull() && !data.JWTValidation.JwksConfig.Cleartext.IsUnknown() {
				jwks_configNestedMap["cleartext"] = data.JWTValidation.JwksConfig.Cleartext.ValueString()
			}
			jwt_validationMap["jwks_config"] = jwks_configNestedMap
		}
		if data.JWTValidation.MandatoryClaims != nil {
			mandatory_claimsNestedMap := make(map[string]interface{})
			jwt_validationMap["mandatory_claims"] = mandatory_claimsNestedMap
		}
		if data.JWTValidation.ReservedClaims != nil {
			reserved_claimsNestedMap := make(map[string]interface{})
			if !data.JWTValidation.ReservedClaims.Issuer.IsNull() && !data.JWTValidation.ReservedClaims.Issuer.IsUnknown() {
				reserved_claimsNestedMap["issuer"] = data.JWTValidation.ReservedClaims.Issuer.ValueString()
			}
			jwt_validationMap["reserved_claims"] = reserved_claimsNestedMap
		}
		if data.JWTValidation.Target != nil {
			targetNestedMap := make(map[string]interface{})
			jwt_validationMap["target"] = targetNestedMap
		}
		if data.JWTValidation.TokenLocation != nil {
			token_locationNestedMap := make(map[string]interface{})
			jwt_validationMap["token_location"] = token_locationNestedMap
		}
		apiResource.Spec["jwt_validation"] = jwt_validationMap
	}
	if data.L7DDOSActionBlock != nil {
		l7_ddos_action_blockMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_block"] = l7_ddos_action_blockMap
	}
	if data.L7DDOSActionDefault != nil {
		l7_ddos_action_defaultMap := make(map[string]interface{})
		apiResource.Spec["l7_ddos_action_default"] = l7_ddos_action_defaultMap
	}
	if data.L7DDOSActionJsChallenge != nil {
		l7_ddos_action_js_challengeMap := make(map[string]interface{})
		if !data.L7DDOSActionJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSActionJsChallenge.CookieExpiry.IsUnknown() {
			l7_ddos_action_js_challengeMap["cookie_expiry"] = data.L7DDOSActionJsChallenge.CookieExpiry.ValueInt64()
		}
		if !data.L7DDOSActionJsChallenge.CustomPage.IsNull() && !data.L7DDOSActionJsChallenge.CustomPage.IsUnknown() {
			l7_ddos_action_js_challengeMap["custom_page"] = data.L7DDOSActionJsChallenge.CustomPage.ValueString()
		}
		if !data.L7DDOSActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSActionJsChallenge.JsScriptDelay.IsUnknown() {
			l7_ddos_action_js_challengeMap["js_script_delay"] = data.L7DDOSActionJsChallenge.JsScriptDelay.ValueInt64()
		}
		apiResource.Spec["l7_ddos_action_js_challenge"] = l7_ddos_action_js_challengeMap
	}
	if data.L7DDOSProtection != nil {
		l7_ddos_protectionMap := make(map[string]interface{})
		if data.L7DDOSProtection.ClientsideActionCaptchaChallenge != nil {
			clientside_action_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CookieExpiry.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CustomPage.IsUnknown() {
				clientside_action_captcha_challengeNestedMap["custom_page"] = data.L7DDOSProtection.ClientsideActionCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["clientside_action_captcha_challenge"] = clientside_action_captcha_challengeNestedMap
		}
		if data.L7DDOSProtection.ClientsideActionJsChallenge != nil {
			clientside_action_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.ClientsideActionJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.ClientsideActionJsChallenge.CookieExpiry.IsUnknown() {
				clientside_action_js_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.ClientsideActionJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.ClientsideActionJsChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.ClientsideActionJsChallenge.CustomPage.IsUnknown() {
				clientside_action_js_challengeNestedMap["custom_page"] = data.L7DDOSProtection.ClientsideActionJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DDOSProtection.ClientsideActionJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSProtection.ClientsideActionJsChallenge.JsScriptDelay.IsUnknown() {
				clientside_action_js_challengeNestedMap["js_script_delay"] = data.L7DDOSProtection.ClientsideActionJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["clientside_action_js_challenge"] = clientside_action_js_challengeNestedMap
		}
		if data.L7DDOSProtection.ClientsideActionNone != nil {
			l7_ddos_protectionMap["clientside_action_none"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.DDOSPolicyCustom != nil {
			ddos_policy_customNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.DDOSPolicyCustom.Name.IsNull() && !data.L7DDOSProtection.DDOSPolicyCustom.Name.IsUnknown() {
				ddos_policy_customNestedMap["name"] = data.L7DDOSProtection.DDOSPolicyCustom.Name.ValueString()
			}
			if !data.L7DDOSProtection.DDOSPolicyCustom.Namespace.IsNull() && !data.L7DDOSProtection.DDOSPolicyCustom.Namespace.IsUnknown() {
				ddos_policy_customNestedMap["namespace"] = data.L7DDOSProtection.DDOSPolicyCustom.Namespace.ValueString()
			}
			if !data.L7DDOSProtection.DDOSPolicyCustom.Tenant.IsNull() && !data.L7DDOSProtection.DDOSPolicyCustom.Tenant.IsUnknown() {
				ddos_policy_customNestedMap["tenant"] = data.L7DDOSProtection.DDOSPolicyCustom.Tenant.ValueString()
			}
			l7_ddos_protectionMap["ddos_policy_custom"] = ddos_policy_customNestedMap
		}
		if data.L7DDOSProtection.DDOSPolicyNone != nil {
			l7_ddos_protectionMap["ddos_policy_none"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.DefaultRpsThreshold != nil {
			l7_ddos_protectionMap["default_rps_threshold"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.MitigationBlock != nil {
			l7_ddos_protectionMap["mitigation_block"] = map[string]interface{}{}
		}
		if data.L7DDOSProtection.MitigationCaptchaChallenge != nil {
			mitigation_captcha_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.MitigationCaptchaChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.MitigationCaptchaChallenge.CookieExpiry.IsUnknown() {
				mitigation_captcha_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.MitigationCaptchaChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.MitigationCaptchaChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.MitigationCaptchaChallenge.CustomPage.IsUnknown() {
				mitigation_captcha_challengeNestedMap["custom_page"] = data.L7DDOSProtection.MitigationCaptchaChallenge.CustomPage.ValueString()
			}
			l7_ddos_protectionMap["mitigation_captcha_challenge"] = mitigation_captcha_challengeNestedMap
		}
		if data.L7DDOSProtection.MitigationJsChallenge != nil {
			mitigation_js_challengeNestedMap := make(map[string]interface{})
			if !data.L7DDOSProtection.MitigationJsChallenge.CookieExpiry.IsNull() && !data.L7DDOSProtection.MitigationJsChallenge.CookieExpiry.IsUnknown() {
				mitigation_js_challengeNestedMap["cookie_expiry"] = data.L7DDOSProtection.MitigationJsChallenge.CookieExpiry.ValueInt64()
			}
			if !data.L7DDOSProtection.MitigationJsChallenge.CustomPage.IsNull() && !data.L7DDOSProtection.MitigationJsChallenge.CustomPage.IsUnknown() {
				mitigation_js_challengeNestedMap["custom_page"] = data.L7DDOSProtection.MitigationJsChallenge.CustomPage.ValueString()
			}
			if !data.L7DDOSProtection.MitigationJsChallenge.JsScriptDelay.IsNull() && !data.L7DDOSProtection.MitigationJsChallenge.JsScriptDelay.IsUnknown() {
				mitigation_js_challengeNestedMap["js_script_delay"] = data.L7DDOSProtection.MitigationJsChallenge.JsScriptDelay.ValueInt64()
			}
			l7_ddos_protectionMap["mitigation_js_challenge"] = mitigation_js_challengeNestedMap
		}
		if !data.L7DDOSProtection.RpsThreshold.IsNull() && !data.L7DDOSProtection.RpsThreshold.IsUnknown() {
			l7_ddos_protectionMap["rps_threshold"] = data.L7DDOSProtection.RpsThreshold.ValueInt64()
		}
		apiResource.Spec["l7_ddos_protection"] = l7_ddos_protectionMap
	}
	if data.LeastActive != nil {
		least_activeMap := make(map[string]interface{})
		apiResource.Spec["least_active"] = least_activeMap
	}
	if data.MalwareProtectionSettings != nil {
		malware_protection_settingsMap := make(map[string]interface{})
		if len(data.MalwareProtectionSettings.MalwareProtectionRules) > 0 {
			var malware_protection_rulesList []map[string]interface{}
			for _, listItem := range data.MalwareProtectionSettings.MalwareProtectionRules {
				listItemMap := make(map[string]interface{})
				if listItem.Action != nil {
					actionDeepMap := make(map[string]interface{})
					if listItem.Action.Block != nil {
						actionDeepMap["block"] = map[string]interface{}{}
					}
					if listItem.Action.Report != nil {
						actionDeepMap["report"] = map[string]interface{}{}
					}
					listItemMap["action"] = actionDeepMap
				}
				if listItem.Domain != nil {
					domainDeepMap := make(map[string]interface{})
					if listItem.Domain.AnyDomain != nil {
						domainDeepMap["any_domain"] = map[string]interface{}{}
					}
					listItemMap["domain"] = domainDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.Path != nil {
					pathDeepMap := make(map[string]interface{})
					if !listItem.Path.Path.IsNull() && !listItem.Path.Path.IsUnknown() {
						pathDeepMap["path"] = listItem.Path.Path.ValueString()
					}
					if !listItem.Path.Prefix.IsNull() && !listItem.Path.Prefix.IsUnknown() {
						pathDeepMap["prefix"] = listItem.Path.Prefix.ValueString()
					}
					if !listItem.Path.Regex.IsNull() && !listItem.Path.Regex.IsUnknown() {
						pathDeepMap["regex"] = listItem.Path.Regex.ValueString()
					}
					listItemMap["path"] = pathDeepMap
				}
				malware_protection_rulesList = append(malware_protection_rulesList, listItemMap)
			}
			malware_protection_settingsMap["malware_protection_rules"] = malware_protection_rulesList
		}
		apiResource.Spec["malware_protection_settings"] = malware_protection_settingsMap
	}
	if data.MoreOption != nil {
		more_optionMap := make(map[string]interface{})
		if data.MoreOption.BufferPolicy != nil {
			buffer_policyNestedMap := make(map[string]interface{})
			if !data.MoreOption.BufferPolicy.Disabled.IsNull() && !data.MoreOption.BufferPolicy.Disabled.IsUnknown() {
				buffer_policyNestedMap["disabled"] = data.MoreOption.BufferPolicy.Disabled.ValueBool()
			}
			if !data.MoreOption.BufferPolicy.MaxRequestBytes.IsNull() && !data.MoreOption.BufferPolicy.MaxRequestBytes.IsUnknown() {
				buffer_policyNestedMap["max_request_bytes"] = data.MoreOption.BufferPolicy.MaxRequestBytes.ValueInt64()
			}
			more_optionMap["buffer_policy"] = buffer_policyNestedMap
		}
		if data.MoreOption.CompressionParams != nil {
			compression_paramsNestedMap := make(map[string]interface{})
			if !data.MoreOption.CompressionParams.ContentLength.IsNull() && !data.MoreOption.CompressionParams.ContentLength.IsUnknown() {
				compression_paramsNestedMap["content_length"] = data.MoreOption.CompressionParams.ContentLength.ValueInt64()
			}
			if !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsNull() && !data.MoreOption.CompressionParams.DisableOnEtagHeader.IsUnknown() {
				compression_paramsNestedMap["disable_on_etag_header"] = data.MoreOption.CompressionParams.DisableOnEtagHeader.ValueBool()
			}
			if !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsNull() && !data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.IsUnknown() {
				compression_paramsNestedMap["remove_accept_encoding_header"] = data.MoreOption.CompressionParams.RemoveAcceptEncodingHeader.ValueBool()
			}
			more_optionMap["compression_params"] = compression_paramsNestedMap
		}
		if data.MoreOption.CustomErrors != nil {
			more_optionMap["custom_errors"] = map[string]interface{}{}
		}
		if !data.MoreOption.DisableDefaultErrorPages.IsNull() && !data.MoreOption.DisableDefaultErrorPages.IsUnknown() {
			more_optionMap["disable_default_error_pages"] = data.MoreOption.DisableDefaultErrorPages.ValueBool()
		}
		if data.MoreOption.DisablePathNormalize != nil {
			more_optionMap["disable_path_normalize"] = map[string]interface{}{}
		}
		if data.MoreOption.EnablePathNormalize != nil {
			more_optionMap["enable_path_normalize"] = map[string]interface{}{}
		}
		if !data.MoreOption.IdleTimeout.IsNull() && !data.MoreOption.IdleTimeout.IsUnknown() {
			more_optionMap["idle_timeout"] = data.MoreOption.IdleTimeout.ValueInt64()
		}
		if !data.MoreOption.MaxRequestHeaderSize.IsNull() && !data.MoreOption.MaxRequestHeaderSize.IsUnknown() {
			more_optionMap["max_request_header_size"] = data.MoreOption.MaxRequestHeaderSize.ValueInt64()
		}
		if len(data.MoreOption.RequestCookiesToAdd) > 0 {
			var request_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_cookies_to_addList = append(request_cookies_to_addList, listItemMap)
			}
			more_optionMap["request_cookies_to_add"] = request_cookies_to_addList
		}
		if !data.MoreOption.RequestCookiesToRemove.IsNull() && !data.MoreOption.RequestCookiesToRemove.IsUnknown() {
			var request_cookies_to_removeItems []string
			diags := data.MoreOption.RequestCookiesToRemove.ElementsAs(ctx, &request_cookies_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["request_cookies_to_remove"] = request_cookies_to_removeItems
			}
		}
		if len(data.MoreOption.RequestHeadersToAdd) > 0 {
			var request_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.RequestHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				request_headers_to_addList = append(request_headers_to_addList, listItemMap)
			}
			more_optionMap["request_headers_to_add"] = request_headers_to_addList
		}
		if !data.MoreOption.RequestHeadersToRemove.IsNull() && !data.MoreOption.RequestHeadersToRemove.IsUnknown() {
			var request_headers_to_removeItems []string
			diags := data.MoreOption.RequestHeadersToRemove.ElementsAs(ctx, &request_headers_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["request_headers_to_remove"] = request_headers_to_removeItems
			}
		}
		if len(data.MoreOption.ResponseCookiesToAdd) > 0 {
			var response_cookies_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseCookiesToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.AddDomain.IsNull() && !listItem.AddDomain.IsUnknown() {
					listItemMap["add_domain"] = listItem.AddDomain.ValueString()
				}
				if !listItem.AddExpiry.IsNull() && !listItem.AddExpiry.IsUnknown() {
					listItemMap["add_expiry"] = listItem.AddExpiry.ValueString()
				}
				if listItem.AddHttponly != nil {
					listItemMap["add_httponly"] = map[string]interface{}{}
				}
				if listItem.AddPartitioned != nil {
					listItemMap["add_partitioned"] = map[string]interface{}{}
				}
				if !listItem.AddPath.IsNull() && !listItem.AddPath.IsUnknown() {
					listItemMap["add_path"] = listItem.AddPath.ValueString()
				}
				if listItem.AddSecure != nil {
					listItemMap["add_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreDomain != nil {
					listItemMap["ignore_domain"] = map[string]interface{}{}
				}
				if listItem.IgnoreExpiry != nil {
					listItemMap["ignore_expiry"] = map[string]interface{}{}
				}
				if listItem.IgnoreHttponly != nil {
					listItemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if listItem.IgnoreMaxAge != nil {
					listItemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if listItem.IgnorePartitioned != nil {
					listItemMap["ignore_partitioned"] = map[string]interface{}{}
				}
				if listItem.IgnorePath != nil {
					listItemMap["ignore_path"] = map[string]interface{}{}
				}
				if listItem.IgnoreSamesite != nil {
					listItemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if listItem.IgnoreSecure != nil {
					listItemMap["ignore_secure"] = map[string]interface{}{}
				}
				if listItem.IgnoreValue != nil {
					listItemMap["ignore_value"] = map[string]interface{}{}
				}
				if !listItem.MaxAgeValue.IsNull() && !listItem.MaxAgeValue.IsUnknown() {
					listItemMap["max_age_value"] = listItem.MaxAgeValue.ValueInt64()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Overwrite.IsNull() && !listItem.Overwrite.IsUnknown() {
					listItemMap["overwrite"] = listItem.Overwrite.ValueBool()
				}
				if listItem.SamesiteLax != nil {
					listItemMap["samesite_lax"] = map[string]interface{}{}
				}
				if listItem.SamesiteNone != nil {
					listItemMap["samesite_none"] = map[string]interface{}{}
				}
				if listItem.SamesiteStrict != nil {
					listItemMap["samesite_strict"] = map[string]interface{}{}
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_cookies_to_addList = append(response_cookies_to_addList, listItemMap)
			}
			more_optionMap["response_cookies_to_add"] = response_cookies_to_addList
		}
		if !data.MoreOption.ResponseCookiesToRemove.IsNull() && !data.MoreOption.ResponseCookiesToRemove.IsUnknown() {
			var response_cookies_to_removeItems []string
			diags := data.MoreOption.ResponseCookiesToRemove.ElementsAs(ctx, &response_cookies_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["response_cookies_to_remove"] = response_cookies_to_removeItems
			}
		}
		if len(data.MoreOption.ResponseHeadersToAdd) > 0 {
			var response_headers_to_addList []map[string]interface{}
			for _, listItem := range data.MoreOption.ResponseHeadersToAdd {
				listItemMap := make(map[string]interface{})
				if !listItem.Append.IsNull() && !listItem.Append.IsUnknown() {
					listItemMap["append"] = listItem.Append.ValueBool()
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.SecretValue != nil {
					secret_valueDeepMap := make(map[string]interface{})
					listItemMap["secret_value"] = secret_valueDeepMap
				}
				if !listItem.Value.IsNull() && !listItem.Value.IsUnknown() {
					listItemMap["value"] = listItem.Value.ValueString()
				}
				response_headers_to_addList = append(response_headers_to_addList, listItemMap)
			}
			more_optionMap["response_headers_to_add"] = response_headers_to_addList
		}
		if !data.MoreOption.ResponseHeadersToRemove.IsNull() && !data.MoreOption.ResponseHeadersToRemove.IsUnknown() {
			var response_headers_to_removeItems []string
			diags := data.MoreOption.ResponseHeadersToRemove.ElementsAs(ctx, &response_headers_to_removeItems, false)
			if !diags.HasError() {
				more_optionMap["response_headers_to_remove"] = response_headers_to_removeItems
			}
		}
		apiResource.Spec["more_option"] = more_optionMap
	}
	if data.MultiLBApp != nil {
		multi_lb_appMap := make(map[string]interface{})
		apiResource.Spec["multi_lb_app"] = multi_lb_appMap
	}
	if data.NoChallenge != nil {
		no_challengeMap := make(map[string]interface{})
		apiResource.Spec["no_challenge"] = no_challengeMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.OriginServerSubsetRuleList != nil {
		origin_server_subset_rule_listMap := make(map[string]interface{})
		if len(data.OriginServerSubsetRuleList.OriginServerSubsetRules) > 0 {
			var origin_server_subset_rulesList []map[string]interface{}
			for _, listItem := range data.OriginServerSubsetRuleList.OriginServerSubsetRules {
				listItemMap := make(map[string]interface{})
				if listItem.AnyAsn != nil {
					listItemMap["any_asn"] = map[string]interface{}{}
				}
				if listItem.AnyIP != nil {
					listItemMap["any_ip"] = map[string]interface{}{}
				}
				if listItem.AsnList != nil {
					asn_listDeepMap := make(map[string]interface{})
					listItemMap["asn_list"] = asn_listDeepMap
				}
				if listItem.AsnMatcher != nil {
					asn_matcherDeepMap := make(map[string]interface{})
					listItemMap["asn_matcher"] = asn_matcherDeepMap
				}
				if listItem.ClientSelector != nil {
					client_selectorDeepMap := make(map[string]interface{})
					listItemMap["client_selector"] = client_selectorDeepMap
				}
				if listItem.IPMatcher != nil {
					ip_matcherDeepMap := make(map[string]interface{})
					if !listItem.IPMatcher.InvertMatcher.IsNull() && !listItem.IPMatcher.InvertMatcher.IsUnknown() {
						ip_matcherDeepMap["invert_matcher"] = listItem.IPMatcher.InvertMatcher.ValueBool()
					}
					listItemMap["ip_matcher"] = ip_matcherDeepMap
				}
				if listItem.IPPrefixList != nil {
					ip_prefix_listDeepMap := make(map[string]interface{})
					if !listItem.IPPrefixList.InvertMatch.IsNull() && !listItem.IPPrefixList.InvertMatch.IsUnknown() {
						ip_prefix_listDeepMap["invert_match"] = listItem.IPPrefixList.InvertMatch.ValueBool()
					}
					listItemMap["ip_prefix_list"] = ip_prefix_listDeepMap
				}
				if listItem.Metadata != nil {
					metadataDeepMap := make(map[string]interface{})
					if !listItem.Metadata.DescriptionSpec.IsNull() && !listItem.Metadata.DescriptionSpec.IsUnknown() {
						metadataDeepMap["description"] = listItem.Metadata.DescriptionSpec.ValueString()
					}
					if !listItem.Metadata.Name.IsNull() && !listItem.Metadata.Name.IsUnknown() {
						metadataDeepMap["name"] = listItem.Metadata.Name.ValueString()
					}
					listItemMap["metadata"] = metadataDeepMap
				}
				if listItem.None != nil {
					listItemMap["none"] = map[string]interface{}{}
				}
				if listItem.OriginServerSubsetsAction != nil {
					listItemMap["origin_server_subsets_action"] = map[string]interface{}{}
				}
				origin_server_subset_rulesList = append(origin_server_subset_rulesList, listItemMap)
			}
			origin_server_subset_rule_listMap["origin_server_subset_rules"] = origin_server_subset_rulesList
		}
		apiResource.Spec["origin_server_subset_rule_list"] = origin_server_subset_rule_listMap
	}
	if data.PolicyBasedChallenge != nil {
		policy_based_challengeMap := make(map[string]interface{})
		if data.PolicyBasedChallenge.AlwaysEnableCaptchaChallenge != nil {
			policy_based_challengeMap["always_enable_captcha_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.AlwaysEnableJsChallenge != nil {
			policy_based_challengeMap["always_enable_js_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.CaptchaChallengeParameters != nil {
			captcha_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.IsUnknown() {
				captcha_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.IsUnknown() {
				captcha_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.CaptchaChallengeParameters.CustomPage.ValueString()
			}
			policy_based_challengeMap["captcha_challenge_parameters"] = captcha_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.DefaultCaptchaChallengeParameters != nil {
			policy_based_challengeMap["default_captcha_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultJsChallengeParameters != nil {
			policy_based_challengeMap["default_js_challenge_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultMitigationSettings != nil {
			policy_based_challengeMap["default_mitigation_settings"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.DefaultTemporaryBlockingParameters != nil {
			policy_based_challengeMap["default_temporary_blocking_parameters"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.JsChallengeParameters != nil {
			js_challenge_parametersNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.IsUnknown() {
				js_challenge_parametersNestedMap["cookie_expiry"] = data.PolicyBasedChallenge.JsChallengeParameters.CookieExpiry.ValueInt64()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.IsUnknown() {
				js_challenge_parametersNestedMap["custom_page"] = data.PolicyBasedChallenge.JsChallengeParameters.CustomPage.ValueString()
			}
			if !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsNull() && !data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.IsUnknown() {
				js_challenge_parametersNestedMap["js_script_delay"] = data.PolicyBasedChallenge.JsChallengeParameters.JsScriptDelay.ValueInt64()
			}
			policy_based_challengeMap["js_challenge_parameters"] = js_challenge_parametersNestedMap
		}
		if data.PolicyBasedChallenge.MaliciousUserMitigation != nil {
			malicious_user_mitigationNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Name.IsUnknown() {
				malicious_user_mitigationNestedMap["name"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Name.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.IsUnknown() {
				malicious_user_mitigationNestedMap["namespace"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Namespace.ValueString()
			}
			if !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsNull() && !data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.IsUnknown() {
				malicious_user_mitigationNestedMap["tenant"] = data.PolicyBasedChallenge.MaliciousUserMitigation.Tenant.ValueString()
			}
			policy_based_challengeMap["malicious_user_mitigation"] = malicious_user_mitigationNestedMap
		}
		if data.PolicyBasedChallenge.NoChallenge != nil {
			policy_based_challengeMap["no_challenge"] = map[string]interface{}{}
		}
		if data.PolicyBasedChallenge.RuleList != nil {
			rule_listNestedMap := make(map[string]interface{})
			policy_based_challengeMap["rule_list"] = rule_listNestedMap
		}
		if data.PolicyBasedChallenge.TemporaryUserBlocking != nil {
			temporary_user_blockingNestedMap := make(map[string]interface{})
			if !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsNull() && !data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.IsUnknown() {
				temporary_user_blockingNestedMap["custom_page"] = data.PolicyBasedChallenge.TemporaryUserBlocking.CustomPage.ValueString()
			}
			policy_based_challengeMap["temporary_user_blocking"] = temporary_user_blockingNestedMap
		}
		apiResource.Spec["policy_based_challenge"] = policy_based_challengeMap
	}
	if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
		var protected_cookiesItems []HTTPLoadBalancerProtectedCookiesModel
		diags := data.ProtectedCookies.ElementsAs(ctx, &protected_cookiesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(protected_cookiesItems) > 0 {
			var protected_cookiesList []map[string]interface{}
			for _, item := range protected_cookiesItems {
				itemMap := make(map[string]interface{})
				if item.AddHttponly != nil {
					itemMap["add_httponly"] = map[string]interface{}{}
				}
				if item.AddSecure != nil {
					itemMap["add_secure"] = map[string]interface{}{}
				}
				if item.DisableTamperingProtection != nil {
					itemMap["disable_tampering_protection"] = map[string]interface{}{}
				}
				if item.EnableTamperingProtection != nil {
					itemMap["enable_tampering_protection"] = map[string]interface{}{}
				}
				if item.IgnoreHttponly != nil {
					itemMap["ignore_httponly"] = map[string]interface{}{}
				}
				if item.IgnoreMaxAge != nil {
					itemMap["ignore_max_age"] = map[string]interface{}{}
				}
				if item.IgnoreSamesite != nil {
					itemMap["ignore_samesite"] = map[string]interface{}{}
				}
				if item.IgnoreSecure != nil {
					itemMap["ignore_secure"] = map[string]interface{}{}
				}
				if !item.MaxAgeValue.IsNull() && !item.MaxAgeValue.IsUnknown() {
					itemMap["max_age_value"] = item.MaxAgeValue.ValueInt64()
				}
				if !item.Name.IsNull() && !item.Name.IsUnknown() {
					itemMap["name"] = item.Name.ValueString()
				}
				if item.SamesiteLax != nil {
					itemMap["samesite_lax"] = map[string]interface{}{}
				}
				if item.SamesiteNone != nil {
					itemMap["samesite_none"] = map[string]interface{}{}
				}
				if item.SamesiteStrict != nil {
					itemMap["samesite_strict"] = map[string]interface{}{}
				}
				protected_cookiesList = append(protected_cookiesList, itemMap)
			}
			apiResource.Spec["protected_cookies"] = protected_cookiesList
		}
	}
	if data.Random != nil {
		randomMap := make(map[string]interface{})
		apiResource.Spec["random"] = randomMap
	}
	if data.RateLimit != nil {
		rate_limitMap := make(map[string]interface{})
		if data.RateLimit.CustomIPAllowedList != nil {
			custom_ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["custom_ip_allowed_list"] = custom_ip_allowed_listNestedMap
		}
		if data.RateLimit.IPAllowedList != nil {
			ip_allowed_listNestedMap := make(map[string]interface{})
			rate_limitMap["ip_allowed_list"] = ip_allowed_listNestedMap
		}
		if data.RateLimit.NoIPAllowedList != nil {
			rate_limitMap["no_ip_allowed_list"] = map[string]interface{}{}
		}
		if data.RateLimit.NoPolicies != nil {
			rate_limitMap["no_policies"] = map[string]interface{}{}
		}
		if data.RateLimit.Policies != nil {
			policiesNestedMap := make(map[string]interface{})
			rate_limitMap["policies"] = policiesNestedMap
		}
		if data.RateLimit.RateLimiter != nil {
			rate_limiterNestedMap := make(map[string]interface{})
			if !data.RateLimit.RateLimiter.BurstMultiplier.IsNull() && !data.RateLimit.RateLimiter.BurstMultiplier.IsUnknown() {
				rate_limiterNestedMap["burst_multiplier"] = data.RateLimit.RateLimiter.BurstMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.PeriodMultiplier.IsNull() && !data.RateLimit.RateLimiter.PeriodMultiplier.IsUnknown() {
				rate_limiterNestedMap["period_multiplier"] = data.RateLimit.RateLimiter.PeriodMultiplier.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.TotalNumber.IsNull() && !data.RateLimit.RateLimiter.TotalNumber.IsUnknown() {
				rate_limiterNestedMap["total_number"] = data.RateLimit.RateLimiter.TotalNumber.ValueInt64()
			}
			if !data.RateLimit.RateLimiter.Unit.IsNull() && !data.RateLimit.RateLimiter.Unit.IsUnknown() {
				rate_limiterNestedMap["unit"] = data.RateLimit.RateLimiter.Unit.ValueString()
			}
			rate_limitMap["rate_limiter"] = rate_limiterNestedMap
		}
		apiResource.Spec["rate_limit"] = rate_limitMap
	}
	if data.RingHash != nil {
		ring_hashMap := make(map[string]interface{})
		if len(data.RingHash.HashPolicy) > 0 {
			var hash_policyList []map[string]interface{}
			for _, listItem := range data.RingHash.HashPolicy {
				listItemMap := make(map[string]interface{})
				if listItem.Cookie != nil {
					cookieDeepMap := make(map[string]interface{})
					if listItem.Cookie.AddHttponly != nil {
						cookieDeepMap["add_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.AddSecure != nil {
						cookieDeepMap["add_secure"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreHttponly != nil {
						cookieDeepMap["ignore_httponly"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSamesite != nil {
						cookieDeepMap["ignore_samesite"] = map[string]interface{}{}
					}
					if listItem.Cookie.IgnoreSecure != nil {
						cookieDeepMap["ignore_secure"] = map[string]interface{}{}
					}
					if !listItem.Cookie.Name.IsNull() && !listItem.Cookie.Name.IsUnknown() {
						cookieDeepMap["name"] = listItem.Cookie.Name.ValueString()
					}
					if !listItem.Cookie.Path.IsNull() && !listItem.Cookie.Path.IsUnknown() {
						cookieDeepMap["path"] = listItem.Cookie.Path.ValueString()
					}
					if listItem.Cookie.SamesiteLax != nil {
						cookieDeepMap["samesite_lax"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteNone != nil {
						cookieDeepMap["samesite_none"] = map[string]interface{}{}
					}
					if listItem.Cookie.SamesiteStrict != nil {
						cookieDeepMap["samesite_strict"] = map[string]interface{}{}
					}
					if !listItem.Cookie.TTL.IsNull() && !listItem.Cookie.TTL.IsUnknown() {
						cookieDeepMap["ttl"] = listItem.Cookie.TTL.ValueInt64()
					}
					listItemMap["cookie"] = cookieDeepMap
				}
				if !listItem.HeaderName.IsNull() && !listItem.HeaderName.IsUnknown() {
					listItemMap["header_name"] = listItem.HeaderName.ValueString()
				}
				if !listItem.SourceIP.IsNull() && !listItem.SourceIP.IsUnknown() {
					listItemMap["source_ip"] = listItem.SourceIP.ValueBool()
				}
				if !listItem.Terminal.IsNull() && !listItem.Terminal.IsUnknown() {
					listItemMap["terminal"] = listItem.Terminal.ValueBool()
				}
				hash_policyList = append(hash_policyList, listItemMap)
			}
			ring_hashMap["hash_policy"] = hash_policyList
		}
		apiResource.Spec["ring_hash"] = ring_hashMap
	}
	if data.RoundRobin != nil {
		round_robinMap := make(map[string]interface{})
		apiResource.Spec["round_robin"] = round_robinMap
	}
	if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
		var routesItems []HTTPLoadBalancerRoutesModel
		diags := data.Routes.ElementsAs(ctx, &routesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(routesItems) > 0 {
			var routesList []map[string]interface{}
			for _, item := range routesItems {
				itemMap := make(map[string]interface{})
				if item.CustomRouteObject != nil {
					custom_route_objectNestedMap := make(map[string]interface{})
					if item.CustomRouteObject.RouteRef != nil {
						route_refDeepMap := make(map[string]interface{})
						if !item.CustomRouteObject.RouteRef.Name.IsNull() && !item.CustomRouteObject.RouteRef.Name.IsUnknown() {
							route_refDeepMap["name"] = item.CustomRouteObject.RouteRef.Name.ValueString()
						}
						if !item.CustomRouteObject.RouteRef.Namespace.IsNull() && !item.CustomRouteObject.RouteRef.Namespace.IsUnknown() {
							route_refDeepMap["namespace"] = item.CustomRouteObject.RouteRef.Namespace.ValueString()
						}
						if !item.CustomRouteObject.RouteRef.Tenant.IsNull() && !item.CustomRouteObject.RouteRef.Tenant.IsUnknown() {
							route_refDeepMap["tenant"] = item.CustomRouteObject.RouteRef.Tenant.ValueString()
						}
						custom_route_objectNestedMap["route_ref"] = route_refDeepMap
					}
					itemMap["custom_route_object"] = custom_route_objectNestedMap
				}
				if item.DirectResponseRoute != nil {
					direct_response_routeNestedMap := make(map[string]interface{})
					if len(item.DirectResponseRoute.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.DirectResponseRoute.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						direct_response_routeNestedMap["headers"] = headersDeepList
					}
					if !item.DirectResponseRoute.HTTPMethod.IsNull() && !item.DirectResponseRoute.HTTPMethod.IsUnknown() {
						direct_response_routeNestedMap["http_method"] = item.DirectResponseRoute.HTTPMethod.ValueString()
					}
					if item.DirectResponseRoute.IncomingPort != nil {
						incoming_portDeepMap := make(map[string]interface{})
						if item.DirectResponseRoute.IncomingPort.NoPortMatch != nil {
							incoming_portDeepMap["no_port_match"] = map[string]interface{}{}
						}
						if !item.DirectResponseRoute.IncomingPort.Port.IsNull() && !item.DirectResponseRoute.IncomingPort.Port.IsUnknown() {
							incoming_portDeepMap["port"] = item.DirectResponseRoute.IncomingPort.Port.ValueInt64()
						}
						if !item.DirectResponseRoute.IncomingPort.PortRanges.IsNull() && !item.DirectResponseRoute.IncomingPort.PortRanges.IsUnknown() {
							incoming_portDeepMap["port_ranges"] = item.DirectResponseRoute.IncomingPort.PortRanges.ValueString()
						}
						direct_response_routeNestedMap["incoming_port"] = incoming_portDeepMap
					}
					if item.DirectResponseRoute.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.DirectResponseRoute.Path.Path.IsNull() && !item.DirectResponseRoute.Path.Path.IsUnknown() {
							pathDeepMap["path"] = item.DirectResponseRoute.Path.Path.ValueString()
						}
						if !item.DirectResponseRoute.Path.Prefix.IsNull() && !item.DirectResponseRoute.Path.Prefix.IsUnknown() {
							pathDeepMap["prefix"] = item.DirectResponseRoute.Path.Prefix.ValueString()
						}
						if !item.DirectResponseRoute.Path.Regex.IsNull() && !item.DirectResponseRoute.Path.Regex.IsUnknown() {
							pathDeepMap["regex"] = item.DirectResponseRoute.Path.Regex.ValueString()
						}
						direct_response_routeNestedMap["path"] = pathDeepMap
					}
					if item.DirectResponseRoute.RouteDirectResponse != nil {
						route_direct_responseDeepMap := make(map[string]interface{})
						if !item.DirectResponseRoute.RouteDirectResponse.ResponseBodyEncoded.IsNull() && !item.DirectResponseRoute.RouteDirectResponse.ResponseBodyEncoded.IsUnknown() {
							route_direct_responseDeepMap["response_body_encoded"] = item.DirectResponseRoute.RouteDirectResponse.ResponseBodyEncoded.ValueString()
						}
						if !item.DirectResponseRoute.RouteDirectResponse.ResponseCode.IsNull() && !item.DirectResponseRoute.RouteDirectResponse.ResponseCode.IsUnknown() {
							route_direct_responseDeepMap["response_code"] = item.DirectResponseRoute.RouteDirectResponse.ResponseCode.ValueInt64()
						}
						direct_response_routeNestedMap["route_direct_response"] = route_direct_responseDeepMap
					}
					itemMap["direct_response_route"] = direct_response_routeNestedMap
				}
				if item.RedirectRoute != nil {
					redirect_routeNestedMap := make(map[string]interface{})
					if len(item.RedirectRoute.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.RedirectRoute.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						redirect_routeNestedMap["headers"] = headersDeepList
					}
					if !item.RedirectRoute.HTTPMethod.IsNull() && !item.RedirectRoute.HTTPMethod.IsUnknown() {
						redirect_routeNestedMap["http_method"] = item.RedirectRoute.HTTPMethod.ValueString()
					}
					if item.RedirectRoute.IncomingPort != nil {
						incoming_portDeepMap := make(map[string]interface{})
						if item.RedirectRoute.IncomingPort.NoPortMatch != nil {
							incoming_portDeepMap["no_port_match"] = map[string]interface{}{}
						}
						if !item.RedirectRoute.IncomingPort.Port.IsNull() && !item.RedirectRoute.IncomingPort.Port.IsUnknown() {
							incoming_portDeepMap["port"] = item.RedirectRoute.IncomingPort.Port.ValueInt64()
						}
						if !item.RedirectRoute.IncomingPort.PortRanges.IsNull() && !item.RedirectRoute.IncomingPort.PortRanges.IsUnknown() {
							incoming_portDeepMap["port_ranges"] = item.RedirectRoute.IncomingPort.PortRanges.ValueString()
						}
						redirect_routeNestedMap["incoming_port"] = incoming_portDeepMap
					}
					if item.RedirectRoute.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.RedirectRoute.Path.Path.IsNull() && !item.RedirectRoute.Path.Path.IsUnknown() {
							pathDeepMap["path"] = item.RedirectRoute.Path.Path.ValueString()
						}
						if !item.RedirectRoute.Path.Prefix.IsNull() && !item.RedirectRoute.Path.Prefix.IsUnknown() {
							pathDeepMap["prefix"] = item.RedirectRoute.Path.Prefix.ValueString()
						}
						if !item.RedirectRoute.Path.Regex.IsNull() && !item.RedirectRoute.Path.Regex.IsUnknown() {
							pathDeepMap["regex"] = item.RedirectRoute.Path.Regex.ValueString()
						}
						redirect_routeNestedMap["path"] = pathDeepMap
					}
					if item.RedirectRoute.RouteRedirect != nil {
						route_redirectDeepMap := make(map[string]interface{})
						if !item.RedirectRoute.RouteRedirect.HostRedirect.IsNull() && !item.RedirectRoute.RouteRedirect.HostRedirect.IsUnknown() {
							route_redirectDeepMap["host_redirect"] = item.RedirectRoute.RouteRedirect.HostRedirect.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.PathRedirect.IsNull() && !item.RedirectRoute.RouteRedirect.PathRedirect.IsUnknown() {
							route_redirectDeepMap["path_redirect"] = item.RedirectRoute.RouteRedirect.PathRedirect.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.PrefixRewrite.IsNull() && !item.RedirectRoute.RouteRedirect.PrefixRewrite.IsUnknown() {
							route_redirectDeepMap["prefix_rewrite"] = item.RedirectRoute.RouteRedirect.PrefixRewrite.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.ProtoRedirect.IsNull() && !item.RedirectRoute.RouteRedirect.ProtoRedirect.IsUnknown() {
							route_redirectDeepMap["proto_redirect"] = item.RedirectRoute.RouteRedirect.ProtoRedirect.ValueString()
						}
						if item.RedirectRoute.RouteRedirect.RemoveAllParams != nil {
							route_redirectDeepMap["remove_all_params"] = map[string]interface{}{}
						}
						if !item.RedirectRoute.RouteRedirect.ReplaceParams.IsNull() && !item.RedirectRoute.RouteRedirect.ReplaceParams.IsUnknown() {
							route_redirectDeepMap["replace_params"] = item.RedirectRoute.RouteRedirect.ReplaceParams.ValueString()
						}
						if !item.RedirectRoute.RouteRedirect.ResponseCode.IsNull() && !item.RedirectRoute.RouteRedirect.ResponseCode.IsUnknown() {
							route_redirectDeepMap["response_code"] = item.RedirectRoute.RouteRedirect.ResponseCode.ValueInt64()
						}
						if item.RedirectRoute.RouteRedirect.RetainAllParams != nil {
							route_redirectDeepMap["retain_all_params"] = map[string]interface{}{}
						}
						redirect_routeNestedMap["route_redirect"] = route_redirectDeepMap
					}
					itemMap["redirect_route"] = redirect_routeNestedMap
				}
				if item.SimpleRoute != nil {
					simple_routeNestedMap := make(map[string]interface{})
					if item.SimpleRoute.AdvancedOptions != nil {
						advanced_optionsDeepMap := make(map[string]interface{})
						if item.SimpleRoute.AdvancedOptions.CommonBuffering != nil {
							advanced_optionsDeepMap["common_buffering"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.CommonHashPolicy != nil {
							advanced_optionsDeepMap["common_hash_policy"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DefaultRetryPolicy != nil {
							advanced_optionsDeepMap["default_retry_policy"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.AdvancedOptions.DisableLocationAdd.IsNull() && !item.SimpleRoute.AdvancedOptions.DisableLocationAdd.IsUnknown() {
							advanced_optionsDeepMap["disable_location_add"] = item.SimpleRoute.AdvancedOptions.DisableLocationAdd.ValueBool()
						}
						if item.SimpleRoute.AdvancedOptions.DisableMirroring != nil {
							advanced_optionsDeepMap["disable_mirroring"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisablePrefixRewrite != nil {
							advanced_optionsDeepMap["disable_prefix_rewrite"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisableSpdy != nil {
							advanced_optionsDeepMap["disable_spdy"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisableWAF != nil {
							advanced_optionsDeepMap["disable_waf"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DisableWebSocketConfig != nil {
							advanced_optionsDeepMap["disable_web_socket_config"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.DoNotRetractCluster != nil {
							advanced_optionsDeepMap["do_not_retract_cluster"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.EnableSpdy != nil {
							advanced_optionsDeepMap["enable_spdy"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.EndpointSubsets != nil {
							advanced_optionsDeepMap["endpoint_subsets"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.InheritedBotDefenseJavascriptInjection != nil {
							advanced_optionsDeepMap["inherited_bot_defense_javascript_injection"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.InheritedWAF != nil {
							advanced_optionsDeepMap["inherited_waf"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.InheritedWAFExclusion != nil {
							advanced_optionsDeepMap["inherited_waf_exclusion"] = map[string]interface{}{}
						}
						if item.SimpleRoute.AdvancedOptions.NoRetryPolicy != nil {
							advanced_optionsDeepMap["no_retry_policy"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.AdvancedOptions.PrefixRewrite.IsNull() && !item.SimpleRoute.AdvancedOptions.PrefixRewrite.IsUnknown() {
							advanced_optionsDeepMap["prefix_rewrite"] = item.SimpleRoute.AdvancedOptions.PrefixRewrite.ValueString()
						}
						if !item.SimpleRoute.AdvancedOptions.Priority.IsNull() && !item.SimpleRoute.AdvancedOptions.Priority.IsUnknown() {
							advanced_optionsDeepMap["priority"] = item.SimpleRoute.AdvancedOptions.Priority.ValueString()
						}
						if !item.SimpleRoute.AdvancedOptions.RequestCookiesToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.RequestCookiesToRemove.IsUnknown() {
							var RequestCookiesToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.RequestCookiesToRemove.ElementsAs(ctx, &RequestCookiesToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["request_cookies_to_remove"] = RequestCookiesToRemoveItems
							}
						}
						if !item.SimpleRoute.AdvancedOptions.RequestHeadersToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.RequestHeadersToRemove.IsUnknown() {
							var RequestHeadersToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.RequestHeadersToRemove.ElementsAs(ctx, &RequestHeadersToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["request_headers_to_remove"] = RequestHeadersToRemoveItems
							}
						}
						if !item.SimpleRoute.AdvancedOptions.ResponseCookiesToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.ResponseCookiesToRemove.IsUnknown() {
							var ResponseCookiesToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.ResponseCookiesToRemove.ElementsAs(ctx, &ResponseCookiesToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["response_cookies_to_remove"] = ResponseCookiesToRemoveItems
							}
						}
						if !item.SimpleRoute.AdvancedOptions.ResponseHeadersToRemove.IsNull() && !item.SimpleRoute.AdvancedOptions.ResponseHeadersToRemove.IsUnknown() {
							var ResponseHeadersToRemoveItems []string
							diags := item.SimpleRoute.AdvancedOptions.ResponseHeadersToRemove.ElementsAs(ctx, &ResponseHeadersToRemoveItems, false)
							if !diags.HasError() {
								advanced_optionsDeepMap["response_headers_to_remove"] = ResponseHeadersToRemoveItems
							}
						}
						if item.SimpleRoute.AdvancedOptions.RetractCluster != nil {
							advanced_optionsDeepMap["retract_cluster"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.AdvancedOptions.Timeout.IsNull() && !item.SimpleRoute.AdvancedOptions.Timeout.IsUnknown() {
							advanced_optionsDeepMap["timeout"] = item.SimpleRoute.AdvancedOptions.Timeout.ValueInt64()
						}
						simple_routeNestedMap["advanced_options"] = advanced_optionsDeepMap
					}
					if item.SimpleRoute.AutoHostRewrite != nil {
						simple_routeNestedMap["auto_host_rewrite"] = map[string]interface{}{}
					}
					if item.SimpleRoute.DisableHostRewrite != nil {
						simple_routeNestedMap["disable_host_rewrite"] = map[string]interface{}{}
					}
					if len(item.SimpleRoute.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.SimpleRoute.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						simple_routeNestedMap["headers"] = headersDeepList
					}
					if !item.SimpleRoute.HostRewrite.IsNull() && !item.SimpleRoute.HostRewrite.IsUnknown() {
						simple_routeNestedMap["host_rewrite"] = item.SimpleRoute.HostRewrite.ValueString()
					}
					if !item.SimpleRoute.HTTPMethod.IsNull() && !item.SimpleRoute.HTTPMethod.IsUnknown() {
						simple_routeNestedMap["http_method"] = item.SimpleRoute.HTTPMethod.ValueString()
					}
					if item.SimpleRoute.IncomingPort != nil {
						incoming_portDeepMap := make(map[string]interface{})
						if item.SimpleRoute.IncomingPort.NoPortMatch != nil {
							incoming_portDeepMap["no_port_match"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.IncomingPort.Port.IsNull() && !item.SimpleRoute.IncomingPort.Port.IsUnknown() {
							incoming_portDeepMap["port"] = item.SimpleRoute.IncomingPort.Port.ValueInt64()
						}
						if !item.SimpleRoute.IncomingPort.PortRanges.IsNull() && !item.SimpleRoute.IncomingPort.PortRanges.IsUnknown() {
							incoming_portDeepMap["port_ranges"] = item.SimpleRoute.IncomingPort.PortRanges.ValueString()
						}
						simple_routeNestedMap["incoming_port"] = incoming_portDeepMap
					}
					if len(item.SimpleRoute.OriginPools) > 0 {
						var origin_poolsDeepList []map[string]interface{}
						for _, deepListItem := range item.SimpleRoute.OriginPools {
							deepListItemMap := make(map[string]interface{})
							if deepListItem.EndpointSubsets != nil {
								deepListItemMap["endpoint_subsets"] = map[string]interface{}{}
							}
							if !deepListItem.Priority.IsNull() && !deepListItem.Priority.IsUnknown() {
								deepListItemMap["priority"] = deepListItem.Priority.ValueInt64()
							}
							if !deepListItem.Weight.IsNull() && !deepListItem.Weight.IsUnknown() {
								deepListItemMap["weight"] = deepListItem.Weight.ValueInt64()
							}
							origin_poolsDeepList = append(origin_poolsDeepList, deepListItemMap)
						}
						simple_routeNestedMap["origin_pools"] = origin_poolsDeepList
					}
					if item.SimpleRoute.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.SimpleRoute.Path.Path.IsNull() && !item.SimpleRoute.Path.Path.IsUnknown() {
							pathDeepMap["path"] = item.SimpleRoute.Path.Path.ValueString()
						}
						if !item.SimpleRoute.Path.Prefix.IsNull() && !item.SimpleRoute.Path.Prefix.IsUnknown() {
							pathDeepMap["prefix"] = item.SimpleRoute.Path.Prefix.ValueString()
						}
						if !item.SimpleRoute.Path.Regex.IsNull() && !item.SimpleRoute.Path.Regex.IsUnknown() {
							pathDeepMap["regex"] = item.SimpleRoute.Path.Regex.ValueString()
						}
						simple_routeNestedMap["path"] = pathDeepMap
					}
					if item.SimpleRoute.QueryParams != nil {
						query_paramsDeepMap := make(map[string]interface{})
						if item.SimpleRoute.QueryParams.RemoveAllParams != nil {
							query_paramsDeepMap["remove_all_params"] = map[string]interface{}{}
						}
						if !item.SimpleRoute.QueryParams.ReplaceParams.IsNull() && !item.SimpleRoute.QueryParams.ReplaceParams.IsUnknown() {
							query_paramsDeepMap["replace_params"] = item.SimpleRoute.QueryParams.ReplaceParams.ValueString()
						}
						if item.SimpleRoute.QueryParams.RetainAllParams != nil {
							query_paramsDeepMap["retain_all_params"] = map[string]interface{}{}
						}
						simple_routeNestedMap["query_params"] = query_paramsDeepMap
					}
					itemMap["simple_route"] = simple_routeNestedMap
				}
				routesList = append(routesList, itemMap)
			}
			apiResource.Spec["routes"] = routesList
		}
	}
	if data.SensitiveDataDisclosureRules != nil {
		sensitive_data_disclosure_rulesMap := make(map[string]interface{})
		if len(data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse) > 0 {
			var sensitive_data_types_in_responseList []map[string]interface{}
			for _, listItem := range data.SensitiveDataDisclosureRules.SensitiveDataTypesInResponse {
				listItemMap := make(map[string]interface{})
				if listItem.APIEndpoint != nil {
					api_endpointDeepMap := make(map[string]interface{})
					if !listItem.APIEndpoint.Path.IsNull() && !listItem.APIEndpoint.Path.IsUnknown() {
						api_endpointDeepMap["path"] = listItem.APIEndpoint.Path.ValueString()
					}
					listItemMap["api_endpoint"] = api_endpointDeepMap
				}
				if listItem.Body != nil {
					bodyDeepMap := make(map[string]interface{})
					listItemMap["body"] = bodyDeepMap
				}
				if listItem.Mask != nil {
					listItemMap["mask"] = map[string]interface{}{}
				}
				if listItem.Report != nil {
					listItemMap["report"] = map[string]interface{}{}
				}
				sensitive_data_types_in_responseList = append(sensitive_data_types_in_responseList, listItemMap)
			}
			sensitive_data_disclosure_rulesMap["sensitive_data_types_in_response"] = sensitive_data_types_in_responseList
		}
		apiResource.Spec["sensitive_data_disclosure_rules"] = sensitive_data_disclosure_rulesMap
	}
	if data.SensitiveDataPolicy != nil {
		sensitive_data_policyMap := make(map[string]interface{})
		if data.SensitiveDataPolicy.SensitiveDataPolicyRef != nil {
			sensitive_data_policy_refNestedMap := make(map[string]interface{})
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.IsUnknown() {
				sensitive_data_policy_refNestedMap["name"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Name.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.IsUnknown() {
				sensitive_data_policy_refNestedMap["namespace"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Namespace.ValueString()
			}
			if !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsNull() && !data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.IsUnknown() {
				sensitive_data_policy_refNestedMap["tenant"] = data.SensitiveDataPolicy.SensitiveDataPolicyRef.Tenant.ValueString()
			}
			sensitive_data_policyMap["sensitive_data_policy_ref"] = sensitive_data_policy_refNestedMap
		}
		apiResource.Spec["sensitive_data_policy"] = sensitive_data_policyMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.SingleLBApp != nil {
		single_lb_appMap := make(map[string]interface{})
		if data.SingleLBApp.DisableDiscovery != nil {
			single_lb_appMap["disable_discovery"] = map[string]interface{}{}
		}
		if data.SingleLBApp.DisableMaliciousUserDetection != nil {
			single_lb_appMap["disable_malicious_user_detection"] = map[string]interface{}{}
		}
		if data.SingleLBApp.EnableDiscovery != nil {
			enable_discoveryNestedMap := make(map[string]interface{})
			single_lb_appMap["enable_discovery"] = enable_discoveryNestedMap
		}
		if data.SingleLBApp.EnableMaliciousUserDetection != nil {
			single_lb_appMap["enable_malicious_user_detection"] = map[string]interface{}{}
		}
		apiResource.Spec["single_lb_app"] = single_lb_appMap
	}
	if data.SlowDDOSMitigation != nil {
		slow_ddos_mitigationMap := make(map[string]interface{})
		if data.SlowDDOSMitigation.DisableRequestTimeout != nil {
			slow_ddos_mitigationMap["disable_request_timeout"] = map[string]interface{}{}
		}
		if !data.SlowDDOSMitigation.RequestHeadersTimeout.IsNull() && !data.SlowDDOSMitigation.RequestHeadersTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_headers_timeout"] = data.SlowDDOSMitigation.RequestHeadersTimeout.ValueInt64()
		}
		if !data.SlowDDOSMitigation.RequestTimeout.IsNull() && !data.SlowDDOSMitigation.RequestTimeout.IsUnknown() {
			slow_ddos_mitigationMap["request_timeout"] = data.SlowDDOSMitigation.RequestTimeout.ValueInt64()
		}
		apiResource.Spec["slow_ddos_mitigation"] = slow_ddos_mitigationMap
	}
	if data.SourceIPStickiness != nil {
		source_ip_stickinessMap := make(map[string]interface{})
		apiResource.Spec["source_ip_stickiness"] = source_ip_stickinessMap
	}
	if data.SystemDefaultTimeouts != nil {
		system_default_timeoutsMap := make(map[string]interface{})
		apiResource.Spec["system_default_timeouts"] = system_default_timeoutsMap
	}
	if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
		var trusted_clientsItems []HTTPLoadBalancerTrustedClientsModel
		diags := data.TrustedClients.ElementsAs(ctx, &trusted_clientsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(trusted_clientsItems) > 0 {
			var trusted_clientsList []map[string]interface{}
			for _, item := range trusted_clientsItems {
				itemMap := make(map[string]interface{})
				if !item.AsNumber.IsNull() && !item.AsNumber.IsUnknown() {
					itemMap["as_number"] = item.AsNumber.ValueInt64()
				}
				if item.BotSkipProcessing != nil {
					itemMap["bot_skip_processing"] = map[string]interface{}{}
				}
				if !item.ExpirationTimestamp.IsNull() && !item.ExpirationTimestamp.IsUnknown() {
					itemMap["expiration_timestamp"] = item.ExpirationTimestamp.ValueString()
				}
				if item.HTTPHeader != nil {
					http_headerNestedMap := make(map[string]interface{})
					if len(item.HTTPHeader.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.HTTPHeader.Headers {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.Exact.IsNull() && !deepListItem.Exact.IsUnknown() {
								deepListItemMap["exact"] = deepListItem.Exact.ValueString()
							}
							if !deepListItem.InvertMatch.IsNull() && !deepListItem.InvertMatch.IsUnknown() {
								deepListItemMap["invert_match"] = deepListItem.InvertMatch.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							if !deepListItem.Presence.IsNull() && !deepListItem.Presence.IsUnknown() {
								deepListItemMap["presence"] = deepListItem.Presence.ValueBool()
							}
							if !deepListItem.Regex.IsNull() && !deepListItem.Regex.IsUnknown() {
								deepListItemMap["regex"] = deepListItem.Regex.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						http_headerNestedMap["headers"] = headersDeepList
					}
					itemMap["http_header"] = http_headerNestedMap
				}
				if !item.IPPrefix.IsNull() && !item.IPPrefix.IsUnknown() {
					itemMap["ip_prefix"] = item.IPPrefix.ValueString()
				}
				if !item.Ipv6Prefix.IsNull() && !item.Ipv6Prefix.IsUnknown() {
					itemMap["ipv6_prefix"] = item.Ipv6Prefix.ValueString()
				}
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.SkipProcessing != nil {
					itemMap["skip_processing"] = map[string]interface{}{}
				}
				if !item.UserIdentifier.IsNull() && !item.UserIdentifier.IsUnknown() {
					itemMap["user_identifier"] = item.UserIdentifier.ValueString()
				}
				if item.WAFSkipProcessing != nil {
					itemMap["waf_skip_processing"] = map[string]interface{}{}
				}
				trusted_clientsList = append(trusted_clientsList, itemMap)
			}
			apiResource.Spec["trusted_clients"] = trusted_clientsList
		}
	}
	if data.UserIDClientIP != nil {
		user_id_client_ipMap := make(map[string]interface{})
		apiResource.Spec["user_id_client_ip"] = user_id_client_ipMap
	}
	if data.UserIdentification != nil {
		user_identificationMap := make(map[string]interface{})
		if !data.UserIdentification.Name.IsNull() && !data.UserIdentification.Name.IsUnknown() {
			user_identificationMap["name"] = data.UserIdentification.Name.ValueString()
		}
		if !data.UserIdentification.Namespace.IsNull() && !data.UserIdentification.Namespace.IsUnknown() {
			user_identificationMap["namespace"] = data.UserIdentification.Namespace.ValueString()
		}
		if !data.UserIdentification.Tenant.IsNull() && !data.UserIdentification.Tenant.IsUnknown() {
			user_identificationMap["tenant"] = data.UserIdentification.Tenant.ValueString()
		}
		apiResource.Spec["user_identification"] = user_identificationMap
	}
	if data.WAFExclusion != nil {
		waf_exclusionMap := make(map[string]interface{})
		if data.WAFExclusion.WAFExclusionInlineRules != nil {
			waf_exclusion_inline_rulesNestedMap := make(map[string]interface{})
			waf_exclusionMap["waf_exclusion_inline_rules"] = waf_exclusion_inline_rulesNestedMap
		}
		if data.WAFExclusion.WAFExclusionPolicy != nil {
			waf_exclusion_policyNestedMap := make(map[string]interface{})
			if !data.WAFExclusion.WAFExclusionPolicy.Name.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Name.IsUnknown() {
				waf_exclusion_policyNestedMap["name"] = data.WAFExclusion.WAFExclusionPolicy.Name.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Namespace.IsUnknown() {
				waf_exclusion_policyNestedMap["namespace"] = data.WAFExclusion.WAFExclusionPolicy.Namespace.ValueString()
			}
			if !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsNull() && !data.WAFExclusion.WAFExclusionPolicy.Tenant.IsUnknown() {
				waf_exclusion_policyNestedMap["tenant"] = data.WAFExclusion.WAFExclusionPolicy.Tenant.ValueString()
			}
			waf_exclusionMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
		}
		apiResource.Spec["waf_exclusion"] = waf_exclusionMap
	}
	if !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		apiResource.Spec["add_location"] = data.AddLocation.ValueBool()
	}

	_, err := r.client.UpdateHTTPLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update HTTPLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetHTTPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read HTTPLoadBalancer after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["add_location"].(bool); ok {
		data.AddLocation = types.BoolValue(v)
	} else if data.AddLocation.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.AddLocation = types.BoolNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &HTTPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []HTTPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &HTTPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &HTTPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_protection_rules"].(map[string]interface{}); ok && (isImport || data.APIProtectionRules != nil) {
		data.APIProtectionRules = &HTTPLoadBalancerAPIProtectionRulesModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			APIGroupsRules: func() []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel {
				if listData, ok := blockData["api_groups_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesModel{
								Action: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesActionModel{
											Allow: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["allow"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Deny: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["deny"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIProtectionRulesAPIGroupsRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["api_rate_limit"].(map[string]interface{}); ok && (isImport || data.APIRateLimit != nil) {
		data.APIRateLimit = &HTTPLoadBalancerAPIRateLimitModel{
			APIEndpointRules: func() []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel {
				if listData, ok := blockData["api_endpoint_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitAPIEndpointRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIEndpointMethod: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel {
									if deepMap, ok := itemMap["api_endpoint_method"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesAPIEndpointMethodModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								APIEndpointPath: func() types.String {
									if v, ok := itemMap["api_endpoint_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitAPIEndpointRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			BypassRateLimitingRules: func() *HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.BypassRateLimitingRules != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.BypassRateLimitingRules
				}
				// Import case: read from API
				if _, ok := blockData["bypass_rate_limiting_rules"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitBypassRateLimitingRulesModel{}
				}
				return nil
			}(),
			CustomIPAllowedList: func() *HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.CustomIPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.CustomIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["custom_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitCustomIPAllowedListModel{}
				}
				return nil
			}(),
			IPAllowedList: func() *HTTPLoadBalancerAPIRateLimitIPAllowedListModel {
				if !isImport && data.APIRateLimit != nil && data.APIRateLimit.IPAllowedList != nil {
					// Normal Read: preserve existing state value
					return data.APIRateLimit.IPAllowedList
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerAPIRateLimitIPAllowedListModel{
						Prefixes: func() types.List {
							if v, ok := nestedBlockData["prefixes"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			NoIPAllowedList: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APIRateLimit != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APIRateLimit.NoIPAllowedList
				}
				// Import case: read from API
				if _, ok := blockData["no_ip_allowed_list"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			ServerURLRules: func() []HTTPLoadBalancerAPIRateLimitServerURLRulesModel {
				if listData, ok := blockData["server_url_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPIRateLimitServerURLRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPIRateLimitServerURLRulesModel{
								AnyDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								APIGroup: func() types.String {
									if v, ok := itemMap["api_group"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								BasePath: func() types.String {
									if v, ok := itemMap["base_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ClientMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel {
									if deepMap, ok := itemMap["client_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesClientMatcherModel{
											AnyClient: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_client"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AnyIP: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_ip"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								InlineRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel {
									if deepMap, ok := itemMap["inline_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesInlineRateLimiterModel{
											Threshold: func() types.Int64 {
												if v, ok := deepMap["threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Unit: func() types.String {
												if v, ok := deepMap["unit"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											UseHTTPLBUserID: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["use_http_lb_user_id"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								RefRateLimiter: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel {
									if deepMap, ok := itemMap["ref_rate_limiter"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRefRateLimiterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								RequestMatcher: func() *HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel {
									if _, ok := itemMap["request_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerAPIRateLimitServerURLRulesRequestMatcherModel{}
									}
									return nil
								}(),
								SpecificDomain: func() types.String {
									if v, ok := itemMap["specific_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["api_specification"].(map[string]interface{}); ok && isImport && data.APISpecification == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.APISpecification = &HTTPLoadBalancerAPISpecificationModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["api_testing"].(map[string]interface{}); ok && (isImport || data.APITesting != nil) {
		data.APITesting = &HTTPLoadBalancerAPITestingModel{
			CustomHeaderValue: func() types.String {
				if v, ok := blockData["custom_header_value"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domains: func() []HTTPLoadBalancerAPITestingDomainsModel {
				if listData, ok := blockData["domains"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerAPITestingDomainsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerAPITestingDomainsModel{
								AllowDestructiveMethods: func() types.Bool {
									if v, ok := itemMap["allow_destructive_methods"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Domain: func() types.String {
									if v, ok := itemMap["domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			EveryDay: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryDay
				}
				// Import case: read from API
				if _, ok := blockData["every_day"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryMonth: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryMonth
				}
				// Import case: read from API
				if _, ok := blockData["every_month"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EveryWeek: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.APITesting != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.APITesting.EveryWeek
				}
				// Import case: read from API
				if _, ok := blockData["every_week"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["app_firewall"].(map[string]interface{}); ok && (isImport || data.AppFirewall != nil) {
		data.AppFirewall = &HTTPLoadBalancerAppFirewallModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if listData, ok := apiResource.Spec["blocked_clients"].([]interface{}); ok && len(listData) > 0 {
		var blocked_clientsList []HTTPLoadBalancerBlockedClientsModel
		var existingBlockedClientsItems []HTTPLoadBalancerBlockedClientsModel
		if !data.BlockedClients.IsNull() && !data.BlockedClients.IsUnknown() {
			data.BlockedClients.ElementsAs(ctx, &existingBlockedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				blocked_clientsList = append(blocked_clientsList, HTTPLoadBalancerBlockedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].BotSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerBlockedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerBlockedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerBlockedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].SkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingBlockedClientsItems) > listIdx && existingBlockedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsModelAttrTypes}, blocked_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.BlockedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.BlockedClients = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerBlockedClientsModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["bot_defense"].(map[string]interface{}); ok && (isImport || data.BotDefense != nil) {
		data.BotDefense = &HTTPLoadBalancerBotDefenseModel{
			DisableCORSSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.DisableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["disable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnableCORSSupport: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.BotDefense != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.BotDefense.EnableCORSSupport
				}
				// Import case: read from API
				if _, ok := blockData["enable_cors_support"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *HTTPLoadBalancerBotDefensePolicyModel {
				if !isImport && data.BotDefense != nil && data.BotDefense.Policy != nil {
					// Normal Read: preserve existing state value
					return data.BotDefense.Policy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerBotDefensePolicyModel{
						JavascriptMode: func() types.String {
							if v, ok := nestedBlockData["javascript_mode"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsDownloadPath: func() types.String {
							if v, ok := nestedBlockData["js_download_path"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RegionalEndpoint: func() types.String {
				if v, ok := blockData["regional_endpoint"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Timeout: func() types.Int64 {
				if !isImport && data.BotDefense != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.BotDefense.Timeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["bot_defense_advanced"].(map[string]interface{}); ok && isImport && data.BotDefenseAdvanced == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BotDefenseAdvanced = &HTTPLoadBalancerBotDefenseAdvancedModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["caching_policy"].(map[string]interface{}); ok && isImport && data.CachingPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CachingPolicy = &HTTPLoadBalancerCachingPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["captcha_challenge"].(map[string]interface{}); ok && (isImport || data.CaptchaChallenge != nil) {
		data.CaptchaChallenge = &HTTPLoadBalancerCaptchaChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.CaptchaChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CaptchaChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["client_side_defense"].(map[string]interface{}); ok && isImport && data.ClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ClientSideDefense = &HTTPLoadBalancerClientSideDefenseModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["cookie_stickiness"].(map[string]interface{}); ok && (isImport || data.CookieStickiness != nil) {
		data.CookieStickiness = &HTTPLoadBalancerCookieStickinessModel{
			AddHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddHttponly
				}
				// Import case: read from API
				if _, ok := blockData["add_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			AddSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.AddSecure
				}
				// Import case: read from API
				if _, ok := blockData["add_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreHttponly
				}
				// Import case: read from API
				if _, ok := blockData["ignore_httponly"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSamesite
				}
				// Import case: read from API
				if _, ok := blockData["ignore_samesite"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.IgnoreSecure
				}
				// Import case: read from API
				if _, ok := blockData["ignore_secure"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Path: func() types.String {
				if v, ok := blockData["path"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteLax
				}
				// Import case: read from API
				if _, ok := blockData["samesite_lax"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteNone
				}
				// Import case: read from API
				if _, ok := blockData["samesite_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.CookieStickiness != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CookieStickiness.SamesiteStrict
				}
				// Import case: read from API
				if _, ok := blockData["samesite_strict"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			TTL: func() types.Int64 {
				if !isImport && data.CookieStickiness != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CookieStickiness.TTL
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["ttl"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["cors_policy"].(map[string]interface{}); ok && (isImport || data.CORSPolicy != nil) {
		data.CORSPolicy = &HTTPLoadBalancerCORSPolicyModel{
			AllowCredentials: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.AllowCredentials
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["allow_credentials"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowHeaders: func() types.String {
				if v, ok := blockData["allow_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowMethods: func() types.String {
				if v, ok := blockData["allow_methods"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AllowOrigin: func() types.List {
				if v, ok := blockData["allow_origin"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowOriginRegex: func() types.List {
				if v, ok := blockData["allow_origin_regex"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			Disabled: func() types.Bool {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.CORSPolicy.Disabled
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disabled"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ExposeHeaders: func() types.String {
				if v, ok := blockData["expose_headers"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MaximumAge: func() types.Int64 {
				if !isImport && data.CORSPolicy != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.CORSPolicy.MaximumAge
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["maximum_age"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["csrf_policy"].(map[string]interface{}); ok && isImport && data.CSRFPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.CSRFPolicy = &HTTPLoadBalancerCSRFPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["data_guard_rules"].([]interface{}); ok && len(listData) > 0 {
		var data_guard_rulesList []HTTPLoadBalancerDataGuardRulesModel
		var existingDataGuardRulesItems []HTTPLoadBalancerDataGuardRulesModel
		if !data.DataGuardRules.IsNull() && !data.DataGuardRules.IsUnknown() {
			data.DataGuardRules.ElementsAs(ctx, &existingDataGuardRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				data_guard_rulesList = append(data_guard_rulesList, HTTPLoadBalancerDataGuardRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].AnyDomain != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ApplyDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].ApplyDataGuard != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerDataGuardRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Path: func() *HTTPLoadBalancerDataGuardRulesPathModel {
						if nestedMap, ok := itemMap["path"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDataGuardRulesPathModel{
								Path: func() types.String {
									if v, ok := nestedMap["path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Prefix: func() types.String {
									if v, ok := nestedMap["prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Regex: func() types.String {
									if v, ok := nestedMap["regex"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipDataGuard: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDataGuardRulesItems) > listIdx && existingDataGuardRulesItems[listIdx].SkipDataGuard != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesModelAttrTypes}, data_guard_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DataGuardRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DataGuardRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDataGuardRulesModelAttrTypes})
	}
	if listData, ok := apiResource.Spec["ddos_mitigation_rules"].([]interface{}); ok && len(listData) > 0 {
		var ddos_mitigation_rulesList []HTTPLoadBalancerDDOSMitigationRulesModel
		var existingDDOSMitigationRulesItems []HTTPLoadBalancerDDOSMitigationRulesModel
		if !data.DDOSMitigationRules.IsNull() && !data.DDOSMitigationRules.IsUnknown() {
			data.DDOSMitigationRules.ElementsAs(ctx, &existingDDOSMitigationRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				ddos_mitigation_rulesList = append(ddos_mitigation_rulesList, HTTPLoadBalancerDDOSMitigationRulesModel{
					Block: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDDOSMitigationRulesItems) > listIdx && existingDDOSMitigationRulesItems[listIdx].Block != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DDOSClientSource: func() *HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel {
						if nestedMap, ok := itemMap["ddos_client_source"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesDDOSClientSourceModel{
								CountryList: func() types.List {
									if v, ok := nestedMap["country_list"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					IPPrefixList: func() *HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel {
						if nestedMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesIPPrefixListModel{
								InvertMatch: func() types.Bool {
									if v, ok := nestedMap["invert_match"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								IPPrefixes: func() types.List {
									if v, ok := nestedMap["ip_prefixes"].([]interface{}); ok && len(v) > 0 {
										var items []string
										for _, item := range v {
											if s, ok := item.(string); ok {
												items = append(items, s)
											}
										}
										listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
										return listVal
									}
									return types.ListNull(types.StringType)
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerDDOSMitigationRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDDOSMitigationRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes}, ddos_mitigation_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DDOSMitigationRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.DDOSMitigationRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDDOSMitigationRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["default_pool"].(map[string]interface{}); ok && (isImport || data.DefaultPool != nil) {
		data.DefaultPool = &HTTPLoadBalancerDefaultPoolModel{
			AdvancedOptions: func() *HTTPLoadBalancerDefaultPoolAdvancedOptionsModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.AdvancedOptions != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.AdvancedOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["advanced_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolAdvancedOptionsModel{
						ConnectionTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["connection_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						HTTPIdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["http_idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PanicThreshold: func() types.Int64 {
							if v, ok := nestedBlockData["panic_threshold"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			AutomaticPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.AutomaticPort
				}
				// Import case: read from API
				if _, ok := blockData["automatic_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EndpointSelection: func() types.String {
				if v, ok := blockData["endpoint_selection"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HealthCheckPort: func() types.Int64 {
				if !isImport && data.DefaultPool != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DefaultPool.HealthCheckPort
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["health_check_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Healthcheck: func() []HTTPLoadBalancerDefaultPoolHealthcheckModel {
				if listData, ok := blockData["healthcheck"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolHealthcheckModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolHealthcheckModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			LBPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.LBPort
				}
				// Import case: read from API
				if _, ok := blockData["lb_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			LoadBalancerAlgorithm: func() types.String {
				if v, ok := blockData["loadbalancer_algorithm"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoTLS: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.NoTLS
				}
				// Import case: read from API
				if _, ok := blockData["no_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			OriginServers: func() []HTTPLoadBalancerDefaultPoolOriginServersModel {
				if listData, ok := blockData["origin_servers"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolOriginServersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolOriginServersModel{
								CbipService: func() *HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel {
									if deepMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCbipServiceModel{
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ConsulService: func() *HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel {
									if deepMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersConsulServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								CustomEndpointObject: func() *HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel {
									if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersCustomEndpointObjectModel{}
									}
									return nil
								}(),
								K8SService: func() *HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel {
									if deepMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersK8SServiceModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Protocol: func() types.String {
												if v, ok := deepMap["protocol"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											ServiceName: func() types.String {
												if v, ok := deepMap["service_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Vk8sNetworks: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["vk8s_networks"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Labels: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								PrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel {
									if deepMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateIPModel{
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								PrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel {
									if deepMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											InsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["inside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											OutsideNetwork: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["outside_network"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								PublicIP: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel {
									if deepMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								PublicName: func() *HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel {
									if deepMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersPublicNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											RefreshInterval: func() types.Int64 {
												if v, ok := deepMap["refresh_interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateIP: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel {
									if deepMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VnPrivateName: func() *HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel {
									if deepMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolOriginServersVnPrivateNameModel{
											DNSName: func() types.String {
												if v, ok := deepMap["dns_name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.DefaultPool != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DefaultPool.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SameAsEndpointPort: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.DefaultPool != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DefaultPool.SameAsEndpointPort
				}
				// Import case: read from API
				if _, ok := blockData["same_as_endpoint_port"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			UpstreamConnPoolReuseType: func() *HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UpstreamConnPoolReuseType != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UpstreamConnPoolReuseType
				}
				// Import case: read from API
				if _, ok := blockData["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUpstreamConnPoolReuseTypeModel{}
				}
				return nil
			}(),
			UseTLS: func() *HTTPLoadBalancerDefaultPoolUseTLSModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.UseTLS != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.UseTLS
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_tls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolUseTLSModel{
						MaxSessionKeys: func() types.Int64 {
							if v, ok := nestedBlockData["max_session_keys"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Sni: func() types.String {
							if v, ok := nestedBlockData["sni"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ViewInternal: func() *HTTPLoadBalancerDefaultPoolViewInternalModel {
				if !isImport && data.DefaultPool != nil && data.DefaultPool.ViewInternal != nil {
					// Normal Read: preserve existing state value
					return data.DefaultPool.ViewInternal
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["view_internal"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerDefaultPoolViewInternalModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["default_pool_list"].(map[string]interface{}); ok && (isImport || data.DefaultPoolList != nil) {
		data.DefaultPoolList = &HTTPLoadBalancerDefaultPoolListModel{
			Pools: func() []HTTPLoadBalancerDefaultPoolListPoolsModel {
				if listData, ok := blockData["pools"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerDefaultPoolListPoolsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerDefaultPoolListPoolsModel{
								Cluster: func() *HTTPLoadBalancerDefaultPoolListPoolsClusterModel {
									if deepMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsClusterModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["endpoint_subsets"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Pool: func() *HTTPLoadBalancerDefaultPoolListPoolsPoolModel {
									if deepMap, ok := itemMap["pool"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerDefaultPoolListPoolsPoolModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Priority: func() types.Int64 {
									if v, ok := itemMap["priority"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Weight: func() types.Int64 {
									if v, ok := itemMap["weight"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if listData, ok := apiResource.Spec["default_route_pools"].([]interface{}); ok && len(listData) > 0 {
		var default_route_poolsList []HTTPLoadBalancerDefaultRoutePoolsModel
		var existingDefaultRoutePoolsItems []HTTPLoadBalancerDefaultRoutePoolsModel
		if !data.DefaultRoutePools.IsNull() && !data.DefaultRoutePools.IsUnknown() {
			data.DefaultRoutePools.ElementsAs(ctx, &existingDefaultRoutePoolsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				default_route_poolsList = append(default_route_poolsList, HTTPLoadBalancerDefaultRoutePoolsModel{
					Cluster: func() *HTTPLoadBalancerDefaultRoutePoolsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingDefaultRoutePoolsItems) > listIdx && existingDefaultRoutePoolsItems[listIdx].EndpointSubsets != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *HTTPLoadBalancerDefaultRoutePoolsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerDefaultRoutePoolsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes}, default_route_poolsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.DefaultRoutePools = listVal
		}
	} else {
		// No data from API - set to null list
		data.DefaultRoutePools = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerDefaultRoutePoolsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["default_sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.DefaultSensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultSensitiveDataPolicy = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_definition"].(map[string]interface{}); ok && isImport && data.DisableAPIDefinition == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDefinition = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_discovery"].(map[string]interface{}); ok && isImport && data.DisableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPIDiscovery = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_api_testing"].(map[string]interface{}); ok && isImport && data.DisableAPITesting == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableAPITesting = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_bot_defense"].(map[string]interface{}); ok && isImport && data.DisableBotDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableBotDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_caching"].(map[string]interface{}); ok && isImport && data.DisableCaching == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableCaching = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_client_side_defense"].(map[string]interface{}); ok && isImport && data.DisableClientSideDefense == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableClientSideDefense = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ip_reputation"].(map[string]interface{}); ok && isImport && data.DisableIPReputation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableIPReputation = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.DisableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_malware_protection"].(map[string]interface{}); ok && isImport && data.DisableMalwareProtection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableMalwareProtection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_rate_limit"].(map[string]interface{}); ok && isImport && data.DisableRateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableRateLimit = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_threat_mesh"].(map[string]interface{}); ok && isImport && data.DisableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_trust_client_ip_headers"].(map[string]interface{}); ok && isImport && data.DisableTrustClientIPHeaders == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableTrustClientIPHeaders = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_waf"].(map[string]interface{}); ok && isImport && data.DisableWAF == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableWAF = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["enable_api_discovery"].(map[string]interface{}); ok && isImport && data.EnableAPIDiscovery == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableAPIDiscovery = &HTTPLoadBalancerEnableAPIDiscoveryModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_challenge"].(map[string]interface{}); ok && isImport && data.EnableChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableChallenge = &HTTPLoadBalancerEnableChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_ip_reputation"].(map[string]interface{}); ok && (isImport || data.EnableIPReputation != nil) {
		data.EnableIPReputation = &HTTPLoadBalancerEnableIPReputationModel{
			IPThreatCategories: func() types.List {
				if v, ok := blockData["ip_threat_categories"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["enable_malicious_user_detection"].(map[string]interface{}); ok && isImport && data.EnableMaliciousUserDetection == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableMaliciousUserDetection = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_threat_mesh"].(map[string]interface{}); ok && isImport && data.EnableThreatMesh == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableThreatMesh = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enable_trust_client_ip_headers"].(map[string]interface{}); ok && (isImport || data.EnableTrustClientIPHeaders != nil) {
		data.EnableTrustClientIPHeaders = &HTTPLoadBalancerEnableTrustClientIPHeadersModel{
			ClientIPHeaders: func() types.List {
				if v, ok := blockData["client_ip_headers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if listData, ok := apiResource.Spec["graphql_rules"].([]interface{}); ok && len(listData) > 0 {
		var graphql_rulesList []HTTPLoadBalancerGraphqlRulesModel
		var existingGraphqlRulesItems []HTTPLoadBalancerGraphqlRulesModel
		if !data.GraphqlRules.IsNull() && !data.GraphqlRules.IsUnknown() {
			data.GraphqlRules.ElementsAs(ctx, &existingGraphqlRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				graphql_rulesList = append(graphql_rulesList, HTTPLoadBalancerGraphqlRulesModel{
					AnyDomain: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].AnyDomain != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExactPath: func() types.String {
						if v, ok := itemMap["exact_path"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					ExactValue: func() types.String {
						if v, ok := itemMap["exact_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					GraphqlSettings: func() *HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel {
						if nestedMap, ok := itemMap["graphql_settings"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesGraphqlSettingsModel{
								DisableIntrospection: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.DisableIntrospection != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								EnableIntrospection: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].GraphqlSettings != nil && existingGraphqlRulesItems[listIdx].GraphqlSettings.EnableIntrospection != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxBatchedQueries: func() types.Int64 {
									if v, ok := nestedMap["max_batched_queries"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxDepth: func() types.Int64 {
									if v, ok := nestedMap["max_depth"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								MaxTotalLength: func() types.Int64 {
									if v, ok := nestedMap["max_total_length"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					Metadata: func() *HTTPLoadBalancerGraphqlRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerGraphqlRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					MethodGet: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodGet != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MethodPost: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingGraphqlRulesItems) > listIdx && existingGraphqlRulesItems[listIdx].MethodPost != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SuffixValue: func() types.String {
						if v, ok := itemMap["suffix_value"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesModelAttrTypes}, graphql_rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.GraphqlRules = listVal
		}
	} else {
		// No data from API - set to null list
		data.GraphqlRules = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerGraphqlRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["http"].(map[string]interface{}); ok && (isImport || data.HTTP != nil) {
		data.HTTP = &HTTPLoadBalancerHTTPModel{
			DNSVolterraManaged: func() types.Bool {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTP.DNSVolterraManaged
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["dns_volterra_managed"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTP != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTP.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https"].(map[string]interface{}); ok && (isImport || data.HTTPS != nil) {
		data.HTTPS = &HTTPLoadBalancerHTTPSModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSCoalescingOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSCoalescingOptionsModel{}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPS.ConnectionIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSHTTPProtocolOptionsModel{}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPS.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPS.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTPS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPS.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSCertParams: func() *HTTPLoadBalancerHTTPSTLSCertParamsModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSCertParams != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSCertParams
				}
				// Import case: read from API
				if _, ok := blockData["tls_cert_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSCertParamsModel{}
				}
				return nil
			}(),
			TLSParameters: func() *HTTPLoadBalancerHTTPSTLSParametersModel {
				if !isImport && data.HTTPS != nil && data.HTTPS.TLSParameters != nil {
					// Normal Read: preserve existing state value
					return data.HTTPS.TLSParameters
				}
				// Import case: read from API
				if _, ok := blockData["tls_parameters"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSTLSParametersModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_auto_cert"].(map[string]interface{}); ok && (isImport || data.HTTPSAutoCert != nil) {
		data.HTTPSAutoCert = &HTTPLoadBalancerHTTPSAutoCertModel{
			AddHsts: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.AddHsts
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["add_hsts"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AppendServerName: func() types.String {
				if v, ok := blockData["append_server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CoalescingOptions: func() *HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.CoalescingOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.CoalescingOptions
				}
				// Import case: read from API
				if _, ok := blockData["coalescing_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel{}
				}
				return nil
			}(),
			ConnectionIdleTimeout: func() types.Int64 {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSAutoCert.ConnectionIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultHeader: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultHeader
				}
				// Import case: read from API
				if _, ok := blockData["default_header"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			HTTPProtocolOptions: func() *HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.HTTPProtocolOptions != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.HTTPProtocolOptions
				}
				// Import case: read from API
				if _, ok := blockData["http_protocol_options"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel{}
				}
				return nil
			}(),
			HTTPRedirect: func() types.Bool {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.HTTPSAutoCert.HTTPRedirect
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["http_redirect"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			NoMtls: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			NonDefaultLoadBalancer: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.NonDefaultLoadBalancer
				}
				// Import case: read from API
				if _, ok := blockData["non_default_loadbalancer"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			PassThrough: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.HTTPSAutoCert != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSAutoCert.PassThrough
				}
				// Import case: read from API
				if _, ok := blockData["pass_through"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			Port: func() types.Int64 {
				if !isImport && data.HTTPSAutoCert != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.HTTPSAutoCert.Port
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PortRanges: func() types.String {
				if v, ok := blockData["port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ServerName: func() types.String {
				if v, ok := blockData["server_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *HTTPLoadBalancerHTTPSAutoCertTLSConfigModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertTLSConfigModel{}
				}
				return nil
			}(),
			UseMtls: func() *HTTPLoadBalancerHTTPSAutoCertUseMtlsModel {
				if !isImport && data.HTTPSAutoCert != nil && data.HTTPSAutoCert.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSAutoCert.UseMtls
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerHTTPSAutoCertUseMtlsModel{
						ClientCertificateOptional: func() types.Bool {
							if v, ok := nestedBlockData["client_certificate_optional"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						TrustedCAURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["js_challenge"].(map[string]interface{}); ok && (isImport || data.JsChallenge != nil) {
		data.JsChallenge = &HTTPLoadBalancerJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.JsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.JsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["jwt_validation"].(map[string]interface{}); ok && isImport && data.JWTValidation == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.JWTValidation = &HTTPLoadBalancerJWTValidationModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_block"].(map[string]interface{}); ok && isImport && data.L7DDOSActionBlock == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionBlock = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["l7_ddos_action_default"].(map[string]interface{}); ok && isImport && data.L7DDOSActionDefault == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.L7DDOSActionDefault = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["l7_ddos_action_js_challenge"].(map[string]interface{}); ok && (isImport || data.L7DDOSActionJsChallenge != nil) {
		data.L7DDOSActionJsChallenge = &HTTPLoadBalancerL7DDOSActionJsChallengeModel{
			CookieExpiry: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.CookieExpiry
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["cookie_expiry"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			CustomPage: func() types.String {
				if v, ok := blockData["custom_page"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JsScriptDelay: func() types.Int64 {
				if !isImport && data.L7DDOSActionJsChallenge != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSActionJsChallenge.JsScriptDelay
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["js_script_delay"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["l7_ddos_protection"].(map[string]interface{}); ok && (isImport || data.L7DDOSProtection != nil) {
		data.L7DDOSProtection = &HTTPLoadBalancerL7DDOSProtectionModel{
			ClientsideActionCaptchaChallenge: func() *HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.ClientsideActionCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.ClientsideActionCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionClientsideActionCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionJsChallenge: func() *HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.ClientsideActionJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.ClientsideActionJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["clientside_action_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionClientsideActionJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ClientsideActionNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.ClientsideActionNone
				}
				// Import case: read from API
				if _, ok := blockData["clientside_action_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DDOSPolicyCustom: func() *HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.DDOSPolicyCustom != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.DDOSPolicyCustom
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["ddos_policy_custom"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionDDOSPolicyCustomModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DDOSPolicyNone: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.DDOSPolicyNone
				}
				// Import case: read from API
				if _, ok := blockData["ddos_policy_none"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DefaultRpsThreshold: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.DefaultRpsThreshold
				}
				// Import case: read from API
				if _, ok := blockData["default_rps_threshold"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationBlock: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.L7DDOSProtection != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.L7DDOSProtection.MitigationBlock
				}
				// Import case: read from API
				if _, ok := blockData["mitigation_block"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			MitigationCaptchaChallenge: func() *HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.MitigationCaptchaChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.MitigationCaptchaChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_captcha_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionMitigationCaptchaChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MitigationJsChallenge: func() *HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel {
				if !isImport && data.L7DDOSProtection != nil && data.L7DDOSProtection.MitigationJsChallenge != nil {
					// Normal Read: preserve existing state value
					return data.L7DDOSProtection.MitigationJsChallenge
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["mitigation_js_challenge"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerL7DDOSProtectionMitigationJsChallengeModel{
						CookieExpiry: func() types.Int64 {
							if v, ok := nestedBlockData["cookie_expiry"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						CustomPage: func() types.String {
							if v, ok := nestedBlockData["custom_page"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						JsScriptDelay: func() types.Int64 {
							if v, ok := nestedBlockData["js_script_delay"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			RpsThreshold: func() types.Int64 {
				if !isImport && data.L7DDOSProtection != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.L7DDOSProtection.RpsThreshold
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["rps_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["least_active"].(map[string]interface{}); ok && isImport && data.LeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LeastActive = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["malware_protection_settings"].(map[string]interface{}); ok && (isImport || data.MalwareProtectionSettings != nil) {
		data.MalwareProtectionSettings = &HTTPLoadBalancerMalwareProtectionSettingsModel{
			MalwareProtectionRules: func() []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel {
				if listData, ok := blockData["malware_protection_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesModel{
								Action: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel {
									if deepMap, ok := itemMap["action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesActionModel{
											Block: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["block"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Report: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["report"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Domain: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel {
									if deepMap, ok := itemMap["domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesDomainModel{
											AnyDomain: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["any_domain"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Path: func() *HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel {
									if deepMap, ok := itemMap["path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMalwareProtectionSettingsMalwareProtectionRulesPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Prefix: func() types.String {
												if v, ok := deepMap["prefix"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Regex: func() types.String {
												if v, ok := deepMap["regex"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["more_option"].(map[string]interface{}); ok && (isImport || data.MoreOption != nil) {
		data.MoreOption = &HTTPLoadBalancerMoreOptionModel{
			BufferPolicy: func() *HTTPLoadBalancerMoreOptionBufferPolicyModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.BufferPolicy != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.BufferPolicy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["buffer_policy"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionBufferPolicyModel{
						Disabled: func() types.Bool {
							if v, ok := nestedBlockData["disabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						MaxRequestBytes: func() types.Int64 {
							if v, ok := nestedBlockData["max_request_bytes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			CompressionParams: func() *HTTPLoadBalancerMoreOptionCompressionParamsModel {
				if !isImport && data.MoreOption != nil && data.MoreOption.CompressionParams != nil {
					// Normal Read: preserve existing state value
					return data.MoreOption.CompressionParams
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["compression_params"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerMoreOptionCompressionParamsModel{
						ContentLength: func() types.Int64 {
							if v, ok := nestedBlockData["content_length"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ContentType: func() types.List {
							if v, ok := nestedBlockData["content_type"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						DisableOnEtagHeader: func() types.Bool {
							if v, ok := nestedBlockData["disable_on_etag_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						RemoveAcceptEncodingHeader: func() types.Bool {
							if v, ok := nestedBlockData["remove_accept_encoding_header"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			CustomErrors: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.CustomErrors
				}
				// Import case: read from API
				if _, ok := blockData["custom_errors"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			DisableDefaultErrorPages: func() types.Bool {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults from overwriting user intent
					return data.MoreOption.DisableDefaultErrorPages
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.BoolNull()
				}
				// Import case: read from API
				if v, ok := blockData["disable_default_error_pages"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.DisablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["disable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			EnablePathNormalize: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.MoreOption != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.MoreOption.EnablePathNormalize
				}
				// Import case: read from API
				if _, ok := blockData["enable_path_normalize"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			IdleTimeout: func() types.Int64 {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.MoreOption.IdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MaxRequestHeaderSize: func() types.Int64 {
				if !isImport && data.MoreOption != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.MoreOption.MaxRequestHeaderSize
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["max_request_header_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestCookiesToAdd: func() []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel {
				if listData, ok := blockData["request_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestCookiesToAddModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestCookiesToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestCookiesToRemove: func() types.List {
				if v, ok := blockData["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RequestHeadersToAdd: func() []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel {
				if listData, ok := blockData["request_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionRequestHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionRequestHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionRequestHeadersToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			RequestHeadersToRemove: func() types.List {
				if v, ok := blockData["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseCookiesToAdd: func() []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel {
				if listData, ok := blockData["response_cookies_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseCookiesToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseCookiesToAddModel{
								AddDomain: func() types.String {
									if v, ok := itemMap["add_domain"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddExpiry: func() types.String {
									if v, ok := itemMap["add_expiry"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AddPath: func() types.String {
									if v, ok := itemMap["add_path"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								AddSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["add_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreDomain: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_domain"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreExpiry: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_expiry"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_httponly"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_max_age"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePartitioned: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_partitioned"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnorePath: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_path"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_samesite"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_secure"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								IgnoreValue: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["ignore_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								MaxAgeValue: func() types.Int64 {
									if v, ok := itemMap["max_age_value"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Overwrite: func() types.Bool {
									if v, ok := itemMap["overwrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_lax"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["samesite_strict"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseCookiesToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseCookiesToRemove: func() types.List {
				if v, ok := blockData["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			ResponseHeadersToAdd: func() []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel {
				if listData, ok := blockData["response_headers_to_add"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerMoreOptionResponseHeadersToAddModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerMoreOptionResponseHeadersToAddModel{
								Append: func() types.Bool {
									if v, ok := itemMap["append"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SecretValue: func() *HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel {
									if _, ok := itemMap["secret_value"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerMoreOptionResponseHeadersToAddSecretValueModel{}
									}
									return nil
								}(),
								Value: func() types.String {
									if v, ok := itemMap["value"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ResponseHeadersToRemove: func() types.List {
				if v, ok := blockData["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if _, ok := apiResource.Spec["multi_lb_app"].(map[string]interface{}); ok && isImport && data.MultiLBApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.MultiLBApp = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_challenge"].(map[string]interface{}); ok && isImport && data.NoChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoChallenge = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["origin_server_subset_rule_list"].(map[string]interface{}); ok && (isImport || data.OriginServerSubsetRuleList != nil) {
		data.OriginServerSubsetRuleList = &HTTPLoadBalancerOriginServerSubsetRuleListModel{
			OriginServerSubsetRules: func() []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel {
				if listData, ok := blockData["origin_server_subset_rules"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesModel{
								AnyAsn: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_asn"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["any_ip"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								AsnList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel {
									if _, ok := itemMap["asn_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnListModel{}
									}
									return nil
								}(),
								AsnMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel {
									if _, ok := itemMap["asn_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesAsnMatcherModel{}
									}
									return nil
								}(),
								ClientSelector: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel {
									if _, ok := itemMap["client_selector"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesClientSelectorModel{}
									}
									return nil
								}(),
								IPMatcher: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel {
									if deepMap, ok := itemMap["ip_matcher"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPMatcherModel{
											InvertMatcher: func() types.Bool {
												if v, ok := deepMap["invert_matcher"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								IPPrefixList: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel {
									if deepMap, ok := itemMap["ip_prefix_list"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesIPPrefixListModel{
											InvertMatch: func() types.Bool {
												if v, ok := deepMap["invert_match"].(bool); ok {
													return types.BoolValue(v)
												}
												return types.BoolNull()
											}(),
										}
									}
									return nil
								}(),
								Metadata: func() *HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel {
									if deepMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerOriginServerSubsetRuleListOriginServerSubsetRulesMetadataModel{
											DescriptionSpec: func() types.String {
												if v, ok := deepMap["description"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								None: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["none"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								OriginServerSubsetsAction: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["origin_server_subsets_action"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["policy_based_challenge"].(map[string]interface{}); ok && isImport && data.PolicyBasedChallenge == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PolicyBasedChallenge = &HTTPLoadBalancerPolicyBasedChallengeModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["protected_cookies"].([]interface{}); ok && len(listData) > 0 {
		var protected_cookiesList []HTTPLoadBalancerProtectedCookiesModel
		var existingProtectedCookiesItems []HTTPLoadBalancerProtectedCookiesModel
		if !data.ProtectedCookies.IsNull() && !data.ProtectedCookies.IsUnknown() {
			data.ProtectedCookies.ElementsAs(ctx, &existingProtectedCookiesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				protected_cookiesList = append(protected_cookiesList, HTTPLoadBalancerProtectedCookiesModel{
					AddHttponly: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddHttponly != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					AddSecure: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].AddSecure != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					DisableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].DisableTamperingProtection != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					EnableTamperingProtection: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].EnableTamperingProtection != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreHttponly != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreMaxAge: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreMaxAge != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSamesite != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].IgnoreSecure != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					MaxAgeValue: func() types.Int64 {
						if v, ok := itemMap["max_age_value"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteLax != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteNone != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingProtectedCookiesItems) > listIdx && existingProtectedCookiesItems[listIdx].SamesiteStrict != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerProtectedCookiesModelAttrTypes}, protected_cookiesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.ProtectedCookies = listVal
		}
	} else {
		// No data from API - set to null list
		data.ProtectedCookies = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerProtectedCookiesModelAttrTypes})
	}
	if _, ok := apiResource.Spec["random"].(map[string]interface{}); ok && isImport && data.Random == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Random = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["rate_limit"].(map[string]interface{}); ok && isImport && data.RateLimit == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RateLimit = &HTTPLoadBalancerRateLimitModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["ring_hash"].(map[string]interface{}); ok && (isImport || data.RingHash != nil) {
		data.RingHash = &HTTPLoadBalancerRingHashModel{
			HashPolicy: func() []HTTPLoadBalancerRingHashHashPolicyModel {
				if listData, ok := blockData["hash_policy"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerRingHashHashPolicyModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerRingHashHashPolicyModel{
								Cookie: func() *HTTPLoadBalancerRingHashHashPolicyCookieModel {
									if deepMap, ok := itemMap["cookie"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerRingHashHashPolicyCookieModel{
											AddHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											AddSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["add_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreHttponly: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_httponly"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSamesite: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_samesite"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											IgnoreSecure: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["ignore_secure"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SamesiteLax: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_lax"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteNone: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_none"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SamesiteStrict: func() *HTTPLoadBalancerEmptyModel {
												if _, ok := deepMap["samesite_strict"].(map[string]interface{}); ok {
													return &HTTPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											TTL: func() types.Int64 {
												if v, ok := deepMap["ttl"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HeaderName: func() types.String {
									if v, ok := itemMap["header_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SourceIP: func() types.Bool {
									if v, ok := itemMap["source_ip"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								Terminal: func() types.Bool {
									if v, ok := itemMap["terminal"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["round_robin"].(map[string]interface{}); ok && isImport && data.RoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RoundRobin = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []HTTPLoadBalancerRoutesModel
		var existingRoutesItems []HTTPLoadBalancerRoutesModel
		if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
			data.Routes.ElementsAs(ctx, &existingRoutesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, HTTPLoadBalancerRoutesModel{
					CustomRouteObject: func() *HTTPLoadBalancerRoutesCustomRouteObjectModel {
						if _, ok := itemMap["custom_route_object"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesCustomRouteObjectModel{}
						}
						return nil
					}(),
					DirectResponseRoute: func() *HTTPLoadBalancerRoutesDirectResponseRouteModel {
						if nestedMap, ok := itemMap["direct_response_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesDirectResponseRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					RedirectRoute: func() *HTTPLoadBalancerRoutesRedirectRouteModel {
						if nestedMap, ok := itemMap["redirect_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesRedirectRouteModel{
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SimpleRoute: func() *HTTPLoadBalancerRoutesSimpleRouteModel {
						if nestedMap, ok := itemMap["simple_route"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerRoutesSimpleRouteModel{
								AutoHostRewrite: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].SimpleRoute != nil && existingRoutesItems[listIdx].SimpleRoute.AutoHostRewrite != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								DisableHostRewrite: func() *HTTPLoadBalancerEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].SimpleRoute != nil && existingRoutesItems[listIdx].SimpleRoute.DisableHostRewrite != nil {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								HTTPMethod: func() types.String {
									if v, ok := nestedMap["http_method"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesModelAttrTypes}, routesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Routes = listVal
		}
	} else {
		// No data from API - set to null list
		data.Routes = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerRoutesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["sensitive_data_disclosure_rules"].(map[string]interface{}); ok && (isImport || data.SensitiveDataDisclosureRules != nil) {
		data.SensitiveDataDisclosureRules = &HTTPLoadBalancerSensitiveDataDisclosureRulesModel{
			SensitiveDataTypesInResponse: func() []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel {
				if listData, ok := blockData["sensitive_data_types_in_response"].([]interface{}); ok && len(listData) > 0 {
					var result []HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseModel{
								APIEndpoint: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel {
									if deepMap, ok := itemMap["api_endpoint"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseAPIEndpointModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Body: func() *HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel {
									if _, ok := itemMap["body"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerSensitiveDataDisclosureRulesSensitiveDataTypesInResponseBodyModel{}
									}
									return nil
								}(),
								Mask: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["mask"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								Report: func() *HTTPLoadBalancerEmptyModel {
									if _, ok := itemMap["report"].(map[string]interface{}); ok {
										return &HTTPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["sensitive_data_policy"].(map[string]interface{}); ok && isImport && data.SensitiveDataPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SensitiveDataPolicy = &HTTPLoadBalancerSensitiveDataPolicyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["single_lb_app"].(map[string]interface{}); ok && isImport && data.SingleLBApp == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SingleLBApp = &HTTPLoadBalancerSingleLBAppModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["slow_ddos_mitigation"].(map[string]interface{}); ok && (isImport || data.SlowDDOSMitigation != nil) {
		data.SlowDDOSMitigation = &HTTPLoadBalancerSlowDDOSMitigationModel{
			DisableRequestTimeout: func() *HTTPLoadBalancerEmptyModel {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SlowDDOSMitigation.DisableRequestTimeout
				}
				// Import case: read from API
				if _, ok := blockData["disable_request_timeout"].(map[string]interface{}); ok {
					return &HTTPLoadBalancerEmptyModel{}
				}
				return nil
			}(),
			RequestHeadersTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestHeadersTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_headers_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			RequestTimeout: func() types.Int64 {
				if !isImport && data.SlowDDOSMitigation != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.SlowDDOSMitigation.RequestTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["request_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.SourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SourceIPStickiness = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["system_default_timeouts"].(map[string]interface{}); ok && isImport && data.SystemDefaultTimeouts == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SystemDefaultTimeouts = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["trusted_clients"].([]interface{}); ok && len(listData) > 0 {
		var trusted_clientsList []HTTPLoadBalancerTrustedClientsModel
		var existingTrustedClientsItems []HTTPLoadBalancerTrustedClientsModel
		if !data.TrustedClients.IsNull() && !data.TrustedClients.IsUnknown() {
			data.TrustedClients.ElementsAs(ctx, &existingTrustedClientsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				trusted_clientsList = append(trusted_clientsList, HTTPLoadBalancerTrustedClientsModel{
					Actions: func() types.List {
						if v, ok := itemMap["actions"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					AsNumber: func() types.Int64 {
						if v, ok := itemMap["as_number"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					BotSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].BotSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					ExpirationTimestamp: func() types.String {
						if v, ok := itemMap["expiration_timestamp"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					HTTPHeader: func() *HTTPLoadBalancerTrustedClientsHTTPHeaderModel {
						if _, ok := itemMap["http_header"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsHTTPHeaderModel{}
						}
						return nil
					}(),
					IPPrefix: func() types.String {
						if v, ok := itemMap["ip_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Ipv6Prefix: func() types.String {
						if v, ok := itemMap["ipv6_prefix"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Metadata: func() *HTTPLoadBalancerTrustedClientsMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &HTTPLoadBalancerTrustedClientsMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					SkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].SkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					UserIdentifier: func() types.String {
						if v, ok := itemMap["user_identifier"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					WAFSkipProcessing: func() *HTTPLoadBalancerEmptyModel {
						if !isImport && len(existingTrustedClientsItems) > listIdx && existingTrustedClientsItems[listIdx].WAFSkipProcessing != nil {
							return &HTTPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsModelAttrTypes}, trusted_clientsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.TrustedClients = listVal
		}
	} else {
		// No data from API - set to null list
		data.TrustedClients = types.ListNull(types.ObjectType{AttrTypes: HTTPLoadBalancerTrustedClientsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["user_id_client_ip"].(map[string]interface{}); ok && isImport && data.UserIDClientIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UserIDClientIP = &HTTPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["user_identification"].(map[string]interface{}); ok && (isImport || data.UserIdentification != nil) {
		data.UserIdentification = &HTTPLoadBalancerUserIdentificationModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["waf_exclusion"].(map[string]interface{}); ok && isImport && data.WAFExclusion == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.WAFExclusion = &HTTPLoadBalancerWAFExclusionModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.AddLocation.IsNull() && !data.AddLocation.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["add_location"].(bool); ok {
			data.AddLocation = types.BoolValue(v)
		} else {
			data.AddLocation = types.BoolNull()
		}
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HTTPLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data HTTPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteHTTPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "HTTPLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "HTTPLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete HTTPLoadBalancer: %s", err))
		return
	}
}

func (r *HTTPLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
