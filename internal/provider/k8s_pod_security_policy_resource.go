// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &K8SPodSecurityPolicyResource{}
	_ resource.ResourceWithConfigure      = &K8SPodSecurityPolicyResource{}
	_ resource.ResourceWithImportState    = &K8SPodSecurityPolicyResource{}
	_ resource.ResourceWithModifyPlan     = &K8SPodSecurityPolicyResource{}
	_ resource.ResourceWithUpgradeState   = &K8SPodSecurityPolicyResource{}
	_ resource.ResourceWithValidateConfig = &K8SPodSecurityPolicyResource{}
)

// k8s_pod_security_policySchemaVersion is the schema version for state upgrades
const k8s_pod_security_policySchemaVersion int64 = 1

func NewK8SPodSecurityPolicyResource() resource.Resource {
	return &K8SPodSecurityPolicyResource{}
}

type K8SPodSecurityPolicyResource struct {
	client *client.Client
}

// K8SPodSecurityPolicyEmptyModel represents empty nested blocks
type K8SPodSecurityPolicyEmptyModel struct {
}

// K8SPodSecurityPolicyPspSpecModel represents psp_spec block
type K8SPodSecurityPolicyPspSpecModel struct {
	AllowPrivilegeEscalation        types.Bool                                              `tfsdk:"allow_privilege_escalation"`
	AllowedCsiDrivers               types.List                                              `tfsdk:"allowed_csi_drivers"`
	AllowedFlexVolumes              types.List                                              `tfsdk:"allowed_flex_volumes"`
	AllowedProcMounts               types.List                                              `tfsdk:"allowed_proc_mounts"`
	AllowedUnsafeSysctls            types.List                                              `tfsdk:"allowed_unsafe_sysctls"`
	DefaultAllowPrivilegeEscalation types.Bool                                              `tfsdk:"default_allow_privilege_escalation"`
	ForbiddenSysctls                types.List                                              `tfsdk:"forbidden_sysctls"`
	HostIpc                         types.Bool                                              `tfsdk:"host_ipc"`
	HostNetwork                     types.Bool                                              `tfsdk:"host_network"`
	HostPid                         types.Bool                                              `tfsdk:"host_pid"`
	HostPortRanges                  types.String                                            `tfsdk:"host_port_ranges"`
	Privileged                      types.Bool                                              `tfsdk:"privileged"`
	ReadOnlyRootFilesystem          types.Bool                                              `tfsdk:"read_only_root_filesystem"`
	Volumes                         types.List                                              `tfsdk:"volumes"`
	AllowedCapabilities             *K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel    `tfsdk:"allowed_capabilities"`
	AllowedHostPaths                []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel      `tfsdk:"allowed_host_paths"`
	DefaultCapabilities             *K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel    `tfsdk:"default_capabilities"`
	DropCapabilities                *K8SPodSecurityPolicyPspSpecDropCapabilitiesModel       `tfsdk:"drop_capabilities"`
	FsGroupStrategyOptions          *K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel `tfsdk:"fs_group_strategy_options"`
	NoAllowedCapabilities           *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_allowed_capabilities"`
	NoDefaultCapabilities           *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_default_capabilities"`
	NoDropCapabilities              *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_drop_capabilities"`
	NoFsGroups                      *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_fs_groups"`
	NoRunAsGroup                    *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_run_as_group"`
	NoRunAsUser                     *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_run_as_user"`
	NoRuntimeClass                  *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_runtime_class"`
	NoSeLinuxOptions                *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_se_linux_options"`
	NoSupplementalGroups            *K8SPodSecurityPolicyEmptyModel                         `tfsdk:"no_supplemental_groups"`
	RunAsGroup                      *K8SPodSecurityPolicyPspSpecRunAsGroupModel             `tfsdk:"run_as_group"`
	RunAsUser                       *K8SPodSecurityPolicyPspSpecRunAsUserModel              `tfsdk:"run_as_user"`
	SupplementalGroups              *K8SPodSecurityPolicyPspSpecSupplementalGroupsModel     `tfsdk:"supplemental_groups"`
}

// K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel represents allowed_capabilities block
type K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel struct {
	Capabilities types.List `tfsdk:"capabilities"`
}

// K8SPodSecurityPolicyPspSpecAllowedHostPathsModel represents allowed_host_paths block
type K8SPodSecurityPolicyPspSpecAllowedHostPathsModel struct {
	PathPrefix types.String `tfsdk:"path_prefix"`
	ReadOnly   types.Bool   `tfsdk:"read_only"`
}

// K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel represents default_capabilities block
type K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel struct {
	Capabilities types.List `tfsdk:"capabilities"`
}

// K8SPodSecurityPolicyPspSpecDropCapabilitiesModel represents drop_capabilities block
type K8SPodSecurityPolicyPspSpecDropCapabilitiesModel struct {
	Capabilities types.List `tfsdk:"capabilities"`
}

// K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel represents fs_group_strategy_options block
type K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel struct {
	Rule     types.String                                                     `tfsdk:"rule"`
	IDRanges []K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsIDRangesModel `tfsdk:"id_ranges"`
}

// K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsIDRangesModel represents id_ranges block
type K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsIDRangesModel struct {
	MaxID types.Int64 `tfsdk:"max_id"`
	MinID types.Int64 `tfsdk:"min_id"`
}

// K8SPodSecurityPolicyPspSpecRunAsGroupModel represents run_as_group block
type K8SPodSecurityPolicyPspSpecRunAsGroupModel struct {
	Rule     types.String                                         `tfsdk:"rule"`
	IDRanges []K8SPodSecurityPolicyPspSpecRunAsGroupIDRangesModel `tfsdk:"id_ranges"`
}

// K8SPodSecurityPolicyPspSpecRunAsGroupIDRangesModel represents id_ranges block
type K8SPodSecurityPolicyPspSpecRunAsGroupIDRangesModel struct {
	MaxID types.Int64 `tfsdk:"max_id"`
	MinID types.Int64 `tfsdk:"min_id"`
}

// K8SPodSecurityPolicyPspSpecRunAsUserModel represents run_as_user block
type K8SPodSecurityPolicyPspSpecRunAsUserModel struct {
	Rule     types.String                                        `tfsdk:"rule"`
	IDRanges []K8SPodSecurityPolicyPspSpecRunAsUserIDRangesModel `tfsdk:"id_ranges"`
}

// K8SPodSecurityPolicyPspSpecRunAsUserIDRangesModel represents id_ranges block
type K8SPodSecurityPolicyPspSpecRunAsUserIDRangesModel struct {
	MaxID types.Int64 `tfsdk:"max_id"`
	MinID types.Int64 `tfsdk:"min_id"`
}

// K8SPodSecurityPolicyPspSpecSupplementalGroupsModel represents supplemental_groups block
type K8SPodSecurityPolicyPspSpecSupplementalGroupsModel struct {
	Rule     types.String                                                 `tfsdk:"rule"`
	IDRanges []K8SPodSecurityPolicyPspSpecSupplementalGroupsIDRangesModel `tfsdk:"id_ranges"`
}

// K8SPodSecurityPolicyPspSpecSupplementalGroupsIDRangesModel represents id_ranges block
type K8SPodSecurityPolicyPspSpecSupplementalGroupsIDRangesModel struct {
	MaxID types.Int64 `tfsdk:"max_id"`
	MinID types.Int64 `tfsdk:"min_id"`
}

type K8SPodSecurityPolicyResourceModel struct {
	Name        types.String                      `tfsdk:"name"`
	Namespace   types.String                      `tfsdk:"namespace"`
	Annotations types.Map                         `tfsdk:"annotations"`
	Description types.String                      `tfsdk:"description"`
	Disable     types.Bool                        `tfsdk:"disable"`
	Labels      types.Map                         `tfsdk:"labels"`
	ID          types.String                      `tfsdk:"id"`
	Yaml        types.String                      `tfsdk:"yaml"`
	Timeouts    timeouts.Value                    `tfsdk:"timeouts"`
	PspSpec     *K8SPodSecurityPolicyPspSpecModel `tfsdk:"psp_spec"`
}

func (r *K8SPodSecurityPolicyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_k8s_pod_security_policy"
}

func (r *K8SPodSecurityPolicyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             k8s_pod_security_policySchemaVersion,
		MarkdownDescription: "Manages k8s_pod_security_policy will create the object in the storage backend for namespace metadata.namespace in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the K8SPodSecurityPolicy. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the K8SPodSecurityPolicy will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"yaml": schema.StringAttribute{
				MarkdownDescription: "K8s YAML. K8s YAML for Pod Security Policy",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"psp_spec": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: psp_spec, yaml] Pod Security Policy Specification. Form based pod security specification",
				Attributes: map[string]schema.Attribute{
					"allow_privilege_escalation": schema.BoolAttribute{
						MarkdownDescription: "Allow Privilege Escalation. Pod can request to privilege escalation",
						Optional:            true,
					},
					"allowed_csi_drivers": schema.ListAttribute{
						MarkdownDescription: "Allowed CSI drivers. Restrict the available CSI drivers for POD, default all drivers are available.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"allowed_flex_volumes": schema.ListAttribute{
						MarkdownDescription: "Allowed Flex Volumes. Restrict list of Flex volumes, default all volumes are allowed",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"allowed_proc_mounts": schema.ListAttribute{
						MarkdownDescription: "Allowed Proc Mounts. allowed list of proc mounts, empty list allows default proc mounts.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"allowed_unsafe_sysctls": schema.ListAttribute{
						MarkdownDescription: "Allowed Unsafe Sysctls. allowed list of unsafe sysctls, empty list allows none. supports prefix reg-ex",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"default_allow_privilege_escalation": schema.BoolAttribute{
						MarkdownDescription: "Default Allow Privilege Escalation. Pod has permission for privilege escalation by default",
						Optional:            true,
					},
					"forbidden_sysctls": schema.ListAttribute{
						MarkdownDescription: "Forbidden Sysctls. Forbidden list of sysctls, empty list forbids none. supports prefix reg-ex",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"host_ipc": schema.BoolAttribute{
						MarkdownDescription: "Host IPC. Host IPC determines if the policy allows the use of host IPC in the pod spec.",
						Optional:            true,
					},
					"host_network": schema.BoolAttribute{
						MarkdownDescription: "Host Network. Host Network determines if the policy allows the use of host network in the pod spec.",
						Optional:            true,
					},
					"host_pid": schema.BoolAttribute{
						MarkdownDescription: "Host PID. Host PID determines if the policy allows the use of host PID in the pod spec.",
						Optional:            true,
					},
					"host_port_ranges": schema.StringAttribute{
						MarkdownDescription: "Host Ports Ranges. Host port ranges determines which ports ranges are allowed to be exposed",
						Optional:            true,
					},
					"privileged": schema.BoolAttribute{
						MarkdownDescription: "Privileged. Privileged determines if a pod can request to be run as privileged.",
						Optional:            true,
					},
					"read_only_root_filesystem": schema.BoolAttribute{
						MarkdownDescription: "Read Only Root Filesystem. Containers can only run with read only root filesystem.",
						Optional:            true,
					},
					"volumes": schema.ListAttribute{
						MarkdownDescription: "Volume. Allow List of volume plugins. Empty no volumes are allowed",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
				Blocks: map[string]schema.Block{
					"allowed_capabilities": schema.SingleNestedBlock{
						MarkdownDescription: "Capability List. List of capabilities that docker container has.",
						Attributes: map[string]schema.Attribute{
							"capabilities": schema.ListAttribute{
								MarkdownDescription: "Capability List. List of capabilities that docker container has.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"allowed_host_paths": schema.ListNestedBlock{
						MarkdownDescription: "Allowed Host Paths. Restrict list of host paths, default all host paths are allowed",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"path_prefix": schema.StringAttribute{
									MarkdownDescription: "Host Path Prefix. Host path prefix is the path prefix that the host volume must match. It does not support *.",
									Optional:            true,
								},
								"read_only": schema.BoolAttribute{
									MarkdownDescription: "Read Only. This volume will be allowed to mount read only.",
									Optional:            true,
								},
							},
						},
					},
					"default_capabilities": schema.SingleNestedBlock{
						MarkdownDescription: "Capability List. List of capabilities that docker container has.",
						Attributes: map[string]schema.Attribute{
							"capabilities": schema.ListAttribute{
								MarkdownDescription: "Capability List. List of capabilities that docker container has.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"drop_capabilities": schema.SingleNestedBlock{
						MarkdownDescription: "Capability List. List of capabilities that docker container has.",
						Attributes: map[string]schema.Attribute{
							"capabilities": schema.ListAttribute{
								MarkdownDescription: "Capability List. List of capabilities that docker container has.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
					},
					"fs_group_strategy_options": schema.SingleNestedBlock{
						MarkdownDescription: "ID(User,Group,FSGroup) Strategy. ID ranges and rules",
						Attributes: map[string]schema.Attribute{
							"rule": schema.StringAttribute{
								MarkdownDescription: "Rule. Rule indicated how the FS group ID range is used",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"id_ranges": schema.ListNestedBlock{
								MarkdownDescription: "ID Ranges. List of range of ID(s)",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"max_id": schema.Int64Attribute{
											MarkdownDescription: "Ending ID. Ending(maximum) ID for for ID range",
											Optional:            true,
										},
										"min_id": schema.Int64Attribute{
											MarkdownDescription: "Starting ID. Starting(minimum) ID for for ID range",
											Optional:            true,
										},
									},
								},
							},
						},
					},
					"no_allowed_capabilities": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_default_capabilities": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_drop_capabilities": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_fs_groups": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_run_as_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_run_as_user": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_runtime_class": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_se_linux_options": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_supplemental_groups": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"run_as_group": schema.SingleNestedBlock{
						MarkdownDescription: "ID(User,Group,FSGroup) Strategy. ID ranges and rules",
						Attributes: map[string]schema.Attribute{
							"rule": schema.StringAttribute{
								MarkdownDescription: "Rule. Rule indicated how the FS group ID range is used",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"id_ranges": schema.ListNestedBlock{
								MarkdownDescription: "ID Ranges. List of range of ID(s)",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"max_id": schema.Int64Attribute{
											MarkdownDescription: "Ending ID. Ending(maximum) ID for for ID range",
											Optional:            true,
										},
										"min_id": schema.Int64Attribute{
											MarkdownDescription: "Starting ID. Starting(minimum) ID for for ID range",
											Optional:            true,
										},
									},
								},
							},
						},
					},
					"run_as_user": schema.SingleNestedBlock{
						MarkdownDescription: "ID(User,Group,FSGroup) Strategy. ID ranges and rules",
						Attributes: map[string]schema.Attribute{
							"rule": schema.StringAttribute{
								MarkdownDescription: "Rule. Rule indicated how the FS group ID range is used",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"id_ranges": schema.ListNestedBlock{
								MarkdownDescription: "ID Ranges. List of range of ID(s)",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"max_id": schema.Int64Attribute{
											MarkdownDescription: "Ending ID. Ending(maximum) ID for for ID range",
											Optional:            true,
										},
										"min_id": schema.Int64Attribute{
											MarkdownDescription: "Starting ID. Starting(minimum) ID for for ID range",
											Optional:            true,
										},
									},
								},
							},
						},
					},
					"supplemental_groups": schema.SingleNestedBlock{
						MarkdownDescription: "ID(User,Group,FSGroup) Strategy. ID ranges and rules",
						Attributes: map[string]schema.Attribute{
							"rule": schema.StringAttribute{
								MarkdownDescription: "Rule. Rule indicated how the FS group ID range is used",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"id_ranges": schema.ListNestedBlock{
								MarkdownDescription: "ID Ranges. List of range of ID(s)",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"max_id": schema.Int64Attribute{
											MarkdownDescription: "Ending ID. Ending(maximum) ID for for ID range",
											Optional:            true,
										},
										"min_id": schema.Int64Attribute{
											MarkdownDescription: "Starting ID. Starting(minimum) ID for for ID range",
											Optional:            true,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *K8SPodSecurityPolicyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *K8SPodSecurityPolicyResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data K8SPodSecurityPolicyResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *K8SPodSecurityPolicyResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the k8s_pod_security_policy from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan K8SPodSecurityPolicyResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *K8SPodSecurityPolicyResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := K8SPodSecurityPolicyResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *K8SPodSecurityPolicyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data K8SPodSecurityPolicyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating k8s_pod_security_policy", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.K8SPodSecurityPolicy{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.PspSpec != nil {
		psp_specMap := make(map[string]interface{})
		if !data.PspSpec.AllowPrivilegeEscalation.IsNull() && !data.PspSpec.AllowPrivilegeEscalation.IsUnknown() {
			psp_specMap["allow_privilege_escalation"] = data.PspSpec.AllowPrivilegeEscalation.ValueBool()
		}
		if data.PspSpec.AllowedCapabilities != nil {
			allowed_capabilitiesNestedMap := make(map[string]interface{})
			psp_specMap["allowed_capabilities"] = allowed_capabilitiesNestedMap
		}
		if !data.PspSpec.AllowedCsiDrivers.IsNull() && !data.PspSpec.AllowedCsiDrivers.IsUnknown() {
			var allowed_csi_driversItems []string
			diags := data.PspSpec.AllowedCsiDrivers.ElementsAs(ctx, &allowed_csi_driversItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_csi_drivers"] = allowed_csi_driversItems
			}
		}
		if !data.PspSpec.AllowedFlexVolumes.IsNull() && !data.PspSpec.AllowedFlexVolumes.IsUnknown() {
			var allowed_flex_volumesItems []string
			diags := data.PspSpec.AllowedFlexVolumes.ElementsAs(ctx, &allowed_flex_volumesItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_flex_volumes"] = allowed_flex_volumesItems
			}
		}
		if len(data.PspSpec.AllowedHostPaths) > 0 {
			var allowed_host_pathsList []map[string]interface{}
			for _, listItem := range data.PspSpec.AllowedHostPaths {
				listItemMap := make(map[string]interface{})
				if !listItem.PathPrefix.IsNull() && !listItem.PathPrefix.IsUnknown() {
					listItemMap["path_prefix"] = listItem.PathPrefix.ValueString()
				}
				if !listItem.ReadOnly.IsNull() && !listItem.ReadOnly.IsUnknown() {
					listItemMap["read_only"] = listItem.ReadOnly.ValueBool()
				}
				allowed_host_pathsList = append(allowed_host_pathsList, listItemMap)
			}
			psp_specMap["allowed_host_paths"] = allowed_host_pathsList
		}
		if !data.PspSpec.AllowedProcMounts.IsNull() && !data.PspSpec.AllowedProcMounts.IsUnknown() {
			var allowed_proc_mountsItems []string
			diags := data.PspSpec.AllowedProcMounts.ElementsAs(ctx, &allowed_proc_mountsItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_proc_mounts"] = allowed_proc_mountsItems
			}
		}
		if !data.PspSpec.AllowedUnsafeSysctls.IsNull() && !data.PspSpec.AllowedUnsafeSysctls.IsUnknown() {
			var allowed_unsafe_sysctlsItems []string
			diags := data.PspSpec.AllowedUnsafeSysctls.ElementsAs(ctx, &allowed_unsafe_sysctlsItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_unsafe_sysctls"] = allowed_unsafe_sysctlsItems
			}
		}
		if !data.PspSpec.DefaultAllowPrivilegeEscalation.IsNull() && !data.PspSpec.DefaultAllowPrivilegeEscalation.IsUnknown() {
			psp_specMap["default_allow_privilege_escalation"] = data.PspSpec.DefaultAllowPrivilegeEscalation.ValueBool()
		}
		if data.PspSpec.DefaultCapabilities != nil {
			default_capabilitiesNestedMap := make(map[string]interface{})
			psp_specMap["default_capabilities"] = default_capabilitiesNestedMap
		}
		if data.PspSpec.DropCapabilities != nil {
			drop_capabilitiesNestedMap := make(map[string]interface{})
			psp_specMap["drop_capabilities"] = drop_capabilitiesNestedMap
		}
		if !data.PspSpec.ForbiddenSysctls.IsNull() && !data.PspSpec.ForbiddenSysctls.IsUnknown() {
			var forbidden_sysctlsItems []string
			diags := data.PspSpec.ForbiddenSysctls.ElementsAs(ctx, &forbidden_sysctlsItems, false)
			if !diags.HasError() {
				psp_specMap["forbidden_sysctls"] = forbidden_sysctlsItems
			}
		}
		if data.PspSpec.FsGroupStrategyOptions != nil {
			fs_group_strategy_optionsNestedMap := make(map[string]interface{})
			if !data.PspSpec.FsGroupStrategyOptions.Rule.IsNull() && !data.PspSpec.FsGroupStrategyOptions.Rule.IsUnknown() {
				fs_group_strategy_optionsNestedMap["rule"] = data.PspSpec.FsGroupStrategyOptions.Rule.ValueString()
			}
			psp_specMap["fs_group_strategy_options"] = fs_group_strategy_optionsNestedMap
		}
		if !data.PspSpec.HostIpc.IsNull() && !data.PspSpec.HostIpc.IsUnknown() {
			psp_specMap["host_ipc"] = data.PspSpec.HostIpc.ValueBool()
		}
		if !data.PspSpec.HostNetwork.IsNull() && !data.PspSpec.HostNetwork.IsUnknown() {
			psp_specMap["host_network"] = data.PspSpec.HostNetwork.ValueBool()
		}
		if !data.PspSpec.HostPid.IsNull() && !data.PspSpec.HostPid.IsUnknown() {
			psp_specMap["host_pid"] = data.PspSpec.HostPid.ValueBool()
		}
		if !data.PspSpec.HostPortRanges.IsNull() && !data.PspSpec.HostPortRanges.IsUnknown() {
			psp_specMap["host_port_ranges"] = data.PspSpec.HostPortRanges.ValueString()
		}
		if data.PspSpec.NoAllowedCapabilities != nil {
			psp_specMap["no_allowed_capabilities"] = map[string]interface{}{}
		}
		if data.PspSpec.NoDefaultCapabilities != nil {
			psp_specMap["no_default_capabilities"] = map[string]interface{}{}
		}
		if data.PspSpec.NoDropCapabilities != nil {
			psp_specMap["no_drop_capabilities"] = map[string]interface{}{}
		}
		if data.PspSpec.NoFsGroups != nil {
			psp_specMap["no_fs_groups"] = map[string]interface{}{}
		}
		if data.PspSpec.NoRunAsGroup != nil {
			psp_specMap["no_run_as_group"] = map[string]interface{}{}
		}
		if data.PspSpec.NoRunAsUser != nil {
			psp_specMap["no_run_as_user"] = map[string]interface{}{}
		}
		if data.PspSpec.NoRuntimeClass != nil {
			psp_specMap["no_runtime_class"] = map[string]interface{}{}
		}
		if data.PspSpec.NoSeLinuxOptions != nil {
			psp_specMap["no_se_linux_options"] = map[string]interface{}{}
		}
		if data.PspSpec.NoSupplementalGroups != nil {
			psp_specMap["no_supplemental_groups"] = map[string]interface{}{}
		}
		if !data.PspSpec.Privileged.IsNull() && !data.PspSpec.Privileged.IsUnknown() {
			psp_specMap["privileged"] = data.PspSpec.Privileged.ValueBool()
		}
		if !data.PspSpec.ReadOnlyRootFilesystem.IsNull() && !data.PspSpec.ReadOnlyRootFilesystem.IsUnknown() {
			psp_specMap["read_only_root_filesystem"] = data.PspSpec.ReadOnlyRootFilesystem.ValueBool()
		}
		if data.PspSpec.RunAsGroup != nil {
			run_as_groupNestedMap := make(map[string]interface{})
			if !data.PspSpec.RunAsGroup.Rule.IsNull() && !data.PspSpec.RunAsGroup.Rule.IsUnknown() {
				run_as_groupNestedMap["rule"] = data.PspSpec.RunAsGroup.Rule.ValueString()
			}
			psp_specMap["run_as_group"] = run_as_groupNestedMap
		}
		if data.PspSpec.RunAsUser != nil {
			run_as_userNestedMap := make(map[string]interface{})
			if !data.PspSpec.RunAsUser.Rule.IsNull() && !data.PspSpec.RunAsUser.Rule.IsUnknown() {
				run_as_userNestedMap["rule"] = data.PspSpec.RunAsUser.Rule.ValueString()
			}
			psp_specMap["run_as_user"] = run_as_userNestedMap
		}
		if data.PspSpec.SupplementalGroups != nil {
			supplemental_groupsNestedMap := make(map[string]interface{})
			if !data.PspSpec.SupplementalGroups.Rule.IsNull() && !data.PspSpec.SupplementalGroups.Rule.IsUnknown() {
				supplemental_groupsNestedMap["rule"] = data.PspSpec.SupplementalGroups.Rule.ValueString()
			}
			psp_specMap["supplemental_groups"] = supplemental_groupsNestedMap
		}
		if !data.PspSpec.Volumes.IsNull() && !data.PspSpec.Volumes.IsUnknown() {
			var volumesItems []string
			diags := data.PspSpec.Volumes.ElementsAs(ctx, &volumesItems, false)
			if !diags.HasError() {
				psp_specMap["volumes"] = volumesItems
			}
		}
		createReq.Spec["psp_spec"] = psp_specMap
	}
	if !data.Yaml.IsNull() && !data.Yaml.IsUnknown() {
		createReq.Spec["yaml"] = data.Yaml.ValueString()
	}

	apiResource, err := r.client.CreateK8SPodSecurityPolicy(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create K8SPodSecurityPolicy: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["psp_spec"].(map[string]interface{}); ok && (isImport || data.PspSpec != nil) {
		data.PspSpec = &K8SPodSecurityPolicyPspSpecModel{
			AllowPrivilegeEscalation: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.AllowPrivilegeEscalation
				}
				// Import case: read from API
				if v, ok := blockData["allow_privilege_escalation"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowedCapabilities: func() *K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.AllowedCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.AllowedCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["allowed_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			AllowedCsiDrivers: func() types.List {
				if v, ok := blockData["allowed_csi_drivers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedFlexVolumes: func() types.List {
				if v, ok := blockData["allowed_flex_volumes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedHostPaths: func() []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel {
				if listData, ok := blockData["allowed_host_paths"].([]interface{}); ok && len(listData) > 0 {
					var result []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, K8SPodSecurityPolicyPspSpecAllowedHostPathsModel{
								PathPrefix: func() types.String {
									if v, ok := itemMap["path_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadOnly: func() types.Bool {
									if v, ok := itemMap["read_only"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AllowedProcMounts: func() types.List {
				if v, ok := blockData["allowed_proc_mounts"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedUnsafeSysctls: func() types.List {
				if v, ok := blockData["allowed_unsafe_sysctls"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			DefaultAllowPrivilegeEscalation: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.DefaultAllowPrivilegeEscalation
				}
				// Import case: read from API
				if v, ok := blockData["default_allow_privilege_escalation"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DefaultCapabilities: func() *K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.DefaultCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.DefaultCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["default_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			DropCapabilities: func() *K8SPodSecurityPolicyPspSpecDropCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.DropCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.DropCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["drop_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecDropCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			ForbiddenSysctls: func() types.List {
				if v, ok := blockData["forbidden_sysctls"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			FsGroupStrategyOptions: func() *K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.FsGroupStrategyOptions != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.FsGroupStrategyOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["fs_group_strategy_options"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			HostIpc: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostIpc
				}
				// Import case: read from API
				if v, ok := blockData["host_ipc"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostNetwork: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostNetwork
				}
				// Import case: read from API
				if v, ok := blockData["host_network"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostPid: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostPid
				}
				// Import case: read from API
				if v, ok := blockData["host_pid"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostPortRanges: func() types.String {
				if v, ok := blockData["host_port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoAllowedCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoAllowedCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_allowed_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoDefaultCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoDefaultCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_default_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoDropCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoDropCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_drop_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoFsGroups: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoFsGroups
				}
				// Import case: read from API
				if _, ok := blockData["no_fs_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRunAsGroup: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRunAsGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_run_as_group"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRunAsUser: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRunAsUser
				}
				// Import case: read from API
				if _, ok := blockData["no_run_as_user"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRuntimeClass: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRuntimeClass
				}
				// Import case: read from API
				if _, ok := blockData["no_runtime_class"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoSeLinuxOptions: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoSeLinuxOptions
				}
				// Import case: read from API
				if _, ok := blockData["no_se_linux_options"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoSupplementalGroups: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoSupplementalGroups
				}
				// Import case: read from API
				if _, ok := blockData["no_supplemental_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			Privileged: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.Privileged
				}
				// Import case: read from API
				if v, ok := blockData["privileged"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ReadOnlyRootFilesystem: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.ReadOnlyRootFilesystem
				}
				// Import case: read from API
				if v, ok := blockData["read_only_root_filesystem"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			RunAsGroup: func() *K8SPodSecurityPolicyPspSpecRunAsGroupModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.RunAsGroup != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.RunAsGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["run_as_group"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecRunAsGroupModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RunAsUser: func() *K8SPodSecurityPolicyPspSpecRunAsUserModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.RunAsUser != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.RunAsUser
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["run_as_user"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecRunAsUserModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			SupplementalGroups: func() *K8SPodSecurityPolicyPspSpecSupplementalGroupsModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.SupplementalGroups != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.SupplementalGroups
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["supplemental_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecSupplementalGroupsModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Volumes: func() types.List {
				if v, ok := blockData["volumes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if v, ok := apiResource.Spec["yaml"].(string); ok && v != "" {
		data.Yaml = types.StringValue(v)
	} else {
		data.Yaml = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created K8SPodSecurityPolicy resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *K8SPodSecurityPolicyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data K8SPodSecurityPolicyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetK8SPodSecurityPolicy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "K8SPodSecurityPolicy not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read K8SPodSecurityPolicy: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The k8s_pod_security_policy may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["psp_spec"].(map[string]interface{}); ok && (isImport || data.PspSpec != nil) {
		data.PspSpec = &K8SPodSecurityPolicyPspSpecModel{
			AllowPrivilegeEscalation: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.AllowPrivilegeEscalation
				}
				// Import case: read from API
				if v, ok := blockData["allow_privilege_escalation"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowedCapabilities: func() *K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.AllowedCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.AllowedCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["allowed_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			AllowedCsiDrivers: func() types.List {
				if v, ok := blockData["allowed_csi_drivers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedFlexVolumes: func() types.List {
				if v, ok := blockData["allowed_flex_volumes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedHostPaths: func() []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel {
				if listData, ok := blockData["allowed_host_paths"].([]interface{}); ok && len(listData) > 0 {
					var result []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, K8SPodSecurityPolicyPspSpecAllowedHostPathsModel{
								PathPrefix: func() types.String {
									if v, ok := itemMap["path_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadOnly: func() types.Bool {
									if v, ok := itemMap["read_only"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AllowedProcMounts: func() types.List {
				if v, ok := blockData["allowed_proc_mounts"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedUnsafeSysctls: func() types.List {
				if v, ok := blockData["allowed_unsafe_sysctls"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			DefaultAllowPrivilegeEscalation: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.DefaultAllowPrivilegeEscalation
				}
				// Import case: read from API
				if v, ok := blockData["default_allow_privilege_escalation"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DefaultCapabilities: func() *K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.DefaultCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.DefaultCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["default_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			DropCapabilities: func() *K8SPodSecurityPolicyPspSpecDropCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.DropCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.DropCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["drop_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecDropCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			ForbiddenSysctls: func() types.List {
				if v, ok := blockData["forbidden_sysctls"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			FsGroupStrategyOptions: func() *K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.FsGroupStrategyOptions != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.FsGroupStrategyOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["fs_group_strategy_options"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			HostIpc: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostIpc
				}
				// Import case: read from API
				if v, ok := blockData["host_ipc"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostNetwork: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostNetwork
				}
				// Import case: read from API
				if v, ok := blockData["host_network"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostPid: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostPid
				}
				// Import case: read from API
				if v, ok := blockData["host_pid"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostPortRanges: func() types.String {
				if v, ok := blockData["host_port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoAllowedCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoAllowedCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_allowed_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoDefaultCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoDefaultCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_default_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoDropCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoDropCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_drop_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoFsGroups: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoFsGroups
				}
				// Import case: read from API
				if _, ok := blockData["no_fs_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRunAsGroup: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRunAsGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_run_as_group"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRunAsUser: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRunAsUser
				}
				// Import case: read from API
				if _, ok := blockData["no_run_as_user"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRuntimeClass: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRuntimeClass
				}
				// Import case: read from API
				if _, ok := blockData["no_runtime_class"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoSeLinuxOptions: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoSeLinuxOptions
				}
				// Import case: read from API
				if _, ok := blockData["no_se_linux_options"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoSupplementalGroups: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoSupplementalGroups
				}
				// Import case: read from API
				if _, ok := blockData["no_supplemental_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			Privileged: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.Privileged
				}
				// Import case: read from API
				if v, ok := blockData["privileged"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ReadOnlyRootFilesystem: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.ReadOnlyRootFilesystem
				}
				// Import case: read from API
				if v, ok := blockData["read_only_root_filesystem"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			RunAsGroup: func() *K8SPodSecurityPolicyPspSpecRunAsGroupModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.RunAsGroup != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.RunAsGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["run_as_group"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecRunAsGroupModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RunAsUser: func() *K8SPodSecurityPolicyPspSpecRunAsUserModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.RunAsUser != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.RunAsUser
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["run_as_user"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecRunAsUserModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			SupplementalGroups: func() *K8SPodSecurityPolicyPspSpecSupplementalGroupsModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.SupplementalGroups != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.SupplementalGroups
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["supplemental_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecSupplementalGroupsModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Volumes: func() types.List {
				if v, ok := blockData["volumes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if v, ok := apiResource.Spec["yaml"].(string); ok && v != "" {
		data.Yaml = types.StringValue(v)
	} else {
		data.Yaml = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *K8SPodSecurityPolicyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data K8SPodSecurityPolicyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.K8SPodSecurityPolicy{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.PspSpec != nil {
		psp_specMap := make(map[string]interface{})
		if !data.PspSpec.AllowPrivilegeEscalation.IsNull() && !data.PspSpec.AllowPrivilegeEscalation.IsUnknown() {
			psp_specMap["allow_privilege_escalation"] = data.PspSpec.AllowPrivilegeEscalation.ValueBool()
		}
		if data.PspSpec.AllowedCapabilities != nil {
			allowed_capabilitiesNestedMap := make(map[string]interface{})
			psp_specMap["allowed_capabilities"] = allowed_capabilitiesNestedMap
		}
		if !data.PspSpec.AllowedCsiDrivers.IsNull() && !data.PspSpec.AllowedCsiDrivers.IsUnknown() {
			var allowed_csi_driversItems []string
			diags := data.PspSpec.AllowedCsiDrivers.ElementsAs(ctx, &allowed_csi_driversItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_csi_drivers"] = allowed_csi_driversItems
			}
		}
		if !data.PspSpec.AllowedFlexVolumes.IsNull() && !data.PspSpec.AllowedFlexVolumes.IsUnknown() {
			var allowed_flex_volumesItems []string
			diags := data.PspSpec.AllowedFlexVolumes.ElementsAs(ctx, &allowed_flex_volumesItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_flex_volumes"] = allowed_flex_volumesItems
			}
		}
		if len(data.PspSpec.AllowedHostPaths) > 0 {
			var allowed_host_pathsList []map[string]interface{}
			for _, listItem := range data.PspSpec.AllowedHostPaths {
				listItemMap := make(map[string]interface{})
				if !listItem.PathPrefix.IsNull() && !listItem.PathPrefix.IsUnknown() {
					listItemMap["path_prefix"] = listItem.PathPrefix.ValueString()
				}
				if !listItem.ReadOnly.IsNull() && !listItem.ReadOnly.IsUnknown() {
					listItemMap["read_only"] = listItem.ReadOnly.ValueBool()
				}
				allowed_host_pathsList = append(allowed_host_pathsList, listItemMap)
			}
			psp_specMap["allowed_host_paths"] = allowed_host_pathsList
		}
		if !data.PspSpec.AllowedProcMounts.IsNull() && !data.PspSpec.AllowedProcMounts.IsUnknown() {
			var allowed_proc_mountsItems []string
			diags := data.PspSpec.AllowedProcMounts.ElementsAs(ctx, &allowed_proc_mountsItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_proc_mounts"] = allowed_proc_mountsItems
			}
		}
		if !data.PspSpec.AllowedUnsafeSysctls.IsNull() && !data.PspSpec.AllowedUnsafeSysctls.IsUnknown() {
			var allowed_unsafe_sysctlsItems []string
			diags := data.PspSpec.AllowedUnsafeSysctls.ElementsAs(ctx, &allowed_unsafe_sysctlsItems, false)
			if !diags.HasError() {
				psp_specMap["allowed_unsafe_sysctls"] = allowed_unsafe_sysctlsItems
			}
		}
		if !data.PspSpec.DefaultAllowPrivilegeEscalation.IsNull() && !data.PspSpec.DefaultAllowPrivilegeEscalation.IsUnknown() {
			psp_specMap["default_allow_privilege_escalation"] = data.PspSpec.DefaultAllowPrivilegeEscalation.ValueBool()
		}
		if data.PspSpec.DefaultCapabilities != nil {
			default_capabilitiesNestedMap := make(map[string]interface{})
			psp_specMap["default_capabilities"] = default_capabilitiesNestedMap
		}
		if data.PspSpec.DropCapabilities != nil {
			drop_capabilitiesNestedMap := make(map[string]interface{})
			psp_specMap["drop_capabilities"] = drop_capabilitiesNestedMap
		}
		if !data.PspSpec.ForbiddenSysctls.IsNull() && !data.PspSpec.ForbiddenSysctls.IsUnknown() {
			var forbidden_sysctlsItems []string
			diags := data.PspSpec.ForbiddenSysctls.ElementsAs(ctx, &forbidden_sysctlsItems, false)
			if !diags.HasError() {
				psp_specMap["forbidden_sysctls"] = forbidden_sysctlsItems
			}
		}
		if data.PspSpec.FsGroupStrategyOptions != nil {
			fs_group_strategy_optionsNestedMap := make(map[string]interface{})
			if !data.PspSpec.FsGroupStrategyOptions.Rule.IsNull() && !data.PspSpec.FsGroupStrategyOptions.Rule.IsUnknown() {
				fs_group_strategy_optionsNestedMap["rule"] = data.PspSpec.FsGroupStrategyOptions.Rule.ValueString()
			}
			psp_specMap["fs_group_strategy_options"] = fs_group_strategy_optionsNestedMap
		}
		if !data.PspSpec.HostIpc.IsNull() && !data.PspSpec.HostIpc.IsUnknown() {
			psp_specMap["host_ipc"] = data.PspSpec.HostIpc.ValueBool()
		}
		if !data.PspSpec.HostNetwork.IsNull() && !data.PspSpec.HostNetwork.IsUnknown() {
			psp_specMap["host_network"] = data.PspSpec.HostNetwork.ValueBool()
		}
		if !data.PspSpec.HostPid.IsNull() && !data.PspSpec.HostPid.IsUnknown() {
			psp_specMap["host_pid"] = data.PspSpec.HostPid.ValueBool()
		}
		if !data.PspSpec.HostPortRanges.IsNull() && !data.PspSpec.HostPortRanges.IsUnknown() {
			psp_specMap["host_port_ranges"] = data.PspSpec.HostPortRanges.ValueString()
		}
		if data.PspSpec.NoAllowedCapabilities != nil {
			psp_specMap["no_allowed_capabilities"] = map[string]interface{}{}
		}
		if data.PspSpec.NoDefaultCapabilities != nil {
			psp_specMap["no_default_capabilities"] = map[string]interface{}{}
		}
		if data.PspSpec.NoDropCapabilities != nil {
			psp_specMap["no_drop_capabilities"] = map[string]interface{}{}
		}
		if data.PspSpec.NoFsGroups != nil {
			psp_specMap["no_fs_groups"] = map[string]interface{}{}
		}
		if data.PspSpec.NoRunAsGroup != nil {
			psp_specMap["no_run_as_group"] = map[string]interface{}{}
		}
		if data.PspSpec.NoRunAsUser != nil {
			psp_specMap["no_run_as_user"] = map[string]interface{}{}
		}
		if data.PspSpec.NoRuntimeClass != nil {
			psp_specMap["no_runtime_class"] = map[string]interface{}{}
		}
		if data.PspSpec.NoSeLinuxOptions != nil {
			psp_specMap["no_se_linux_options"] = map[string]interface{}{}
		}
		if data.PspSpec.NoSupplementalGroups != nil {
			psp_specMap["no_supplemental_groups"] = map[string]interface{}{}
		}
		if !data.PspSpec.Privileged.IsNull() && !data.PspSpec.Privileged.IsUnknown() {
			psp_specMap["privileged"] = data.PspSpec.Privileged.ValueBool()
		}
		if !data.PspSpec.ReadOnlyRootFilesystem.IsNull() && !data.PspSpec.ReadOnlyRootFilesystem.IsUnknown() {
			psp_specMap["read_only_root_filesystem"] = data.PspSpec.ReadOnlyRootFilesystem.ValueBool()
		}
		if data.PspSpec.RunAsGroup != nil {
			run_as_groupNestedMap := make(map[string]interface{})
			if !data.PspSpec.RunAsGroup.Rule.IsNull() && !data.PspSpec.RunAsGroup.Rule.IsUnknown() {
				run_as_groupNestedMap["rule"] = data.PspSpec.RunAsGroup.Rule.ValueString()
			}
			psp_specMap["run_as_group"] = run_as_groupNestedMap
		}
		if data.PspSpec.RunAsUser != nil {
			run_as_userNestedMap := make(map[string]interface{})
			if !data.PspSpec.RunAsUser.Rule.IsNull() && !data.PspSpec.RunAsUser.Rule.IsUnknown() {
				run_as_userNestedMap["rule"] = data.PspSpec.RunAsUser.Rule.ValueString()
			}
			psp_specMap["run_as_user"] = run_as_userNestedMap
		}
		if data.PspSpec.SupplementalGroups != nil {
			supplemental_groupsNestedMap := make(map[string]interface{})
			if !data.PspSpec.SupplementalGroups.Rule.IsNull() && !data.PspSpec.SupplementalGroups.Rule.IsUnknown() {
				supplemental_groupsNestedMap["rule"] = data.PspSpec.SupplementalGroups.Rule.ValueString()
			}
			psp_specMap["supplemental_groups"] = supplemental_groupsNestedMap
		}
		if !data.PspSpec.Volumes.IsNull() && !data.PspSpec.Volumes.IsUnknown() {
			var volumesItems []string
			diags := data.PspSpec.Volumes.ElementsAs(ctx, &volumesItems, false)
			if !diags.HasError() {
				psp_specMap["volumes"] = volumesItems
			}
		}
		apiResource.Spec["psp_spec"] = psp_specMap
	}
	if !data.Yaml.IsNull() && !data.Yaml.IsUnknown() {
		apiResource.Spec["yaml"] = data.Yaml.ValueString()
	}

	_, err := r.client.UpdateK8SPodSecurityPolicy(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update K8SPodSecurityPolicy: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetK8SPodSecurityPolicy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read K8SPodSecurityPolicy after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["yaml"].(string); ok && v != "" {
		data.Yaml = types.StringValue(v)
	} else if data.Yaml.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Yaml = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["psp_spec"].(map[string]interface{}); ok && (isImport || data.PspSpec != nil) {
		data.PspSpec = &K8SPodSecurityPolicyPspSpecModel{
			AllowPrivilegeEscalation: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.AllowPrivilegeEscalation
				}
				// Import case: read from API
				if v, ok := blockData["allow_privilege_escalation"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			AllowedCapabilities: func() *K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.AllowedCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.AllowedCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["allowed_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecAllowedCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			AllowedCsiDrivers: func() types.List {
				if v, ok := blockData["allowed_csi_drivers"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedFlexVolumes: func() types.List {
				if v, ok := blockData["allowed_flex_volumes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedHostPaths: func() []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel {
				if listData, ok := blockData["allowed_host_paths"].([]interface{}); ok && len(listData) > 0 {
					var result []K8SPodSecurityPolicyPspSpecAllowedHostPathsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, K8SPodSecurityPolicyPspSpecAllowedHostPathsModel{
								PathPrefix: func() types.String {
									if v, ok := itemMap["path_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadOnly: func() types.Bool {
									if v, ok := itemMap["read_only"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			AllowedProcMounts: func() types.List {
				if v, ok := blockData["allowed_proc_mounts"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			AllowedUnsafeSysctls: func() types.List {
				if v, ok := blockData["allowed_unsafe_sysctls"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			DefaultAllowPrivilegeEscalation: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.DefaultAllowPrivilegeEscalation
				}
				// Import case: read from API
				if v, ok := blockData["default_allow_privilege_escalation"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DefaultCapabilities: func() *K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.DefaultCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.DefaultCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["default_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecDefaultCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			DropCapabilities: func() *K8SPodSecurityPolicyPspSpecDropCapabilitiesModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.DropCapabilities != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.DropCapabilities
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["drop_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecDropCapabilitiesModel{
						Capabilities: func() types.List {
							if v, ok := nestedBlockData["capabilities"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
					}
				}
				return nil
			}(),
			ForbiddenSysctls: func() types.List {
				if v, ok := blockData["forbidden_sysctls"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			FsGroupStrategyOptions: func() *K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.FsGroupStrategyOptions != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.FsGroupStrategyOptions
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["fs_group_strategy_options"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecFsGroupStrategyOptionsModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			HostIpc: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostIpc
				}
				// Import case: read from API
				if v, ok := blockData["host_ipc"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostNetwork: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostNetwork
				}
				// Import case: read from API
				if v, ok := blockData["host_network"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostPid: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.HostPid
				}
				// Import case: read from API
				if v, ok := blockData["host_pid"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			HostPortRanges: func() types.String {
				if v, ok := blockData["host_port_ranges"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NoAllowedCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoAllowedCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_allowed_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoDefaultCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoDefaultCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_default_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoDropCapabilities: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoDropCapabilities
				}
				// Import case: read from API
				if _, ok := blockData["no_drop_capabilities"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoFsGroups: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoFsGroups
				}
				// Import case: read from API
				if _, ok := blockData["no_fs_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRunAsGroup: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRunAsGroup
				}
				// Import case: read from API
				if _, ok := blockData["no_run_as_group"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRunAsUser: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRunAsUser
				}
				// Import case: read from API
				if _, ok := blockData["no_run_as_user"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoRuntimeClass: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoRuntimeClass
				}
				// Import case: read from API
				if _, ok := blockData["no_runtime_class"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoSeLinuxOptions: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoSeLinuxOptions
				}
				// Import case: read from API
				if _, ok := blockData["no_se_linux_options"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			NoSupplementalGroups: func() *K8SPodSecurityPolicyEmptyModel {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PspSpec.NoSupplementalGroups
				}
				// Import case: read from API
				if _, ok := blockData["no_supplemental_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyEmptyModel{}
				}
				return nil
			}(),
			Privileged: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.Privileged
				}
				// Import case: read from API
				if v, ok := blockData["privileged"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ReadOnlyRootFilesystem: func() types.Bool {
				if !isImport && data.PspSpec != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PspSpec.ReadOnlyRootFilesystem
				}
				// Import case: read from API
				if v, ok := blockData["read_only_root_filesystem"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			RunAsGroup: func() *K8SPodSecurityPolicyPspSpecRunAsGroupModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.RunAsGroup != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.RunAsGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["run_as_group"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecRunAsGroupModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			RunAsUser: func() *K8SPodSecurityPolicyPspSpecRunAsUserModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.RunAsUser != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.RunAsUser
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["run_as_user"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecRunAsUserModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			SupplementalGroups: func() *K8SPodSecurityPolicyPspSpecSupplementalGroupsModel {
				if !isImport && data.PspSpec != nil && data.PspSpec.SupplementalGroups != nil {
					// Normal Read: preserve existing state value
					return data.PspSpec.SupplementalGroups
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["supplemental_groups"].(map[string]interface{}); ok {
					return &K8SPodSecurityPolicyPspSpecSupplementalGroupsModel{
						Rule: func() types.String {
							if v, ok := nestedBlockData["rule"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Volumes: func() types.List {
				if v, ok := blockData["volumes"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if v, ok := apiResource.Spec["yaml"].(string); ok && v != "" {
		data.Yaml = types.StringValue(v)
	} else {
		data.Yaml = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *K8SPodSecurityPolicyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data K8SPodSecurityPolicyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteK8SPodSecurityPolicy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "K8SPodSecurityPolicy already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "K8SPodSecurityPolicy delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete K8SPodSecurityPolicy: %s", err))
		return
	}
}

func (r *K8SPodSecurityPolicyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
