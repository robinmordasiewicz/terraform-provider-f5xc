// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &NetworkInterfaceResource{}
	_ resource.ResourceWithConfigure      = &NetworkInterfaceResource{}
	_ resource.ResourceWithImportState    = &NetworkInterfaceResource{}
	_ resource.ResourceWithModifyPlan     = &NetworkInterfaceResource{}
	_ resource.ResourceWithValidateConfig = &NetworkInterfaceResource{}
)

func NewNetworkInterfaceResource() resource.Resource {
	return &NetworkInterfaceResource{}
}

type NetworkInterfaceResource struct {
	client *client.Client
}

// NetworkInterfaceEmptyModel represents empty nested blocks
type NetworkInterfaceEmptyModel struct {
}

// NetworkInterfaceDedicatedInterfaceModel represents dedicated_interface block
type NetworkInterfaceDedicatedInterfaceModel struct {
	Device          types.String                `tfsdk:"device"`
	MTU             types.Int64                 `tfsdk:"mtu"`
	Node            types.String                `tfsdk:"node"`
	Priority        types.Int64                 `tfsdk:"priority"`
	Cluster         *NetworkInterfaceEmptyModel `tfsdk:"cluster"`
	IsPrimary       *NetworkInterfaceEmptyModel `tfsdk:"is_primary"`
	Monitor         *NetworkInterfaceEmptyModel `tfsdk:"monitor"`
	MonitorDisabled *NetworkInterfaceEmptyModel `tfsdk:"monitor_disabled"`
	NotPrimary      *NetworkInterfaceEmptyModel `tfsdk:"not_primary"`
}

// NetworkInterfaceDedicatedInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceDedicatedInterfaceModel
var NetworkInterfaceDedicatedInterfaceModelAttrTypes = map[string]attr.Type{
	"device":           types.StringType,
	"mtu":              types.Int64Type,
	"node":             types.StringType,
	"priority":         types.Int64Type,
	"cluster":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"is_primary":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"monitor":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"monitor_disabled": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"not_primary":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceDedicatedManagementInterfaceModel represents dedicated_management_interface block
type NetworkInterfaceDedicatedManagementInterfaceModel struct {
	Device  types.String                `tfsdk:"device"`
	MTU     types.Int64                 `tfsdk:"mtu"`
	Node    types.String                `tfsdk:"node"`
	Cluster *NetworkInterfaceEmptyModel `tfsdk:"cluster"`
}

// NetworkInterfaceDedicatedManagementInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceDedicatedManagementInterfaceModel
var NetworkInterfaceDedicatedManagementInterfaceModelAttrTypes = map[string]attr.Type{
	"device":  types.StringType,
	"mtu":     types.Int64Type,
	"node":    types.StringType,
	"cluster": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceModel represents ethernet_interface block
type NetworkInterfaceEthernetInterfaceModel struct {
	Device                 types.String                                             `tfsdk:"device"`
	MTU                    types.Int64                                              `tfsdk:"mtu"`
	Node                   types.String                                             `tfsdk:"node"`
	Priority               types.Int64                                              `tfsdk:"priority"`
	VLANID                 types.Int64                                              `tfsdk:"vlan_id"`
	Cluster                *NetworkInterfaceEmptyModel                              `tfsdk:"cluster"`
	DHCPClient             *NetworkInterfaceEmptyModel                              `tfsdk:"dhcp_client"`
	DHCPServer             *NetworkInterfaceEthernetInterfaceDHCPServerModel        `tfsdk:"dhcp_server"`
	Ipv6AutoConfig         *NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel    `tfsdk:"ipv6_auto_config"`
	IsPrimary              *NetworkInterfaceEmptyModel                              `tfsdk:"is_primary"`
	Monitor                *NetworkInterfaceEmptyModel                              `tfsdk:"monitor"`
	MonitorDisabled        *NetworkInterfaceEmptyModel                              `tfsdk:"monitor_disabled"`
	NoIpv6Address          *NetworkInterfaceEmptyModel                              `tfsdk:"no_ipv6_address"`
	NotPrimary             *NetworkInterfaceEmptyModel                              `tfsdk:"not_primary"`
	SiteLocalInsideNetwork *NetworkInterfaceEmptyModel                              `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork       *NetworkInterfaceEmptyModel                              `tfsdk:"site_local_network"`
	StaticIP               *NetworkInterfaceEthernetInterfaceStaticIPModel          `tfsdk:"static_ip"`
	StaticIpv6Address      *NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel `tfsdk:"static_ipv6_address"`
	StorageNetwork         *NetworkInterfaceEmptyModel                              `tfsdk:"storage_network"`
	Untagged               *NetworkInterfaceEmptyModel                              `tfsdk:"untagged"`
}

// NetworkInterfaceEthernetInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceModel
var NetworkInterfaceEthernetInterfaceModelAttrTypes = map[string]attr.Type{
	"device":                    types.StringType,
	"mtu":                       types.Int64Type,
	"node":                      types.StringType,
	"priority":                  types.Int64Type,
	"vlan_id":                   types.Int64Type,
	"cluster":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"dhcp_client":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"dhcp_server":               types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceDHCPServerModelAttrTypes},
	"ipv6_auto_config":          types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigModelAttrTypes},
	"is_primary":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"monitor":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"monitor_disabled":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_ipv6_address":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"not_primary":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_local_inside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_local_network":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"static_ip":                 types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceStaticIPModelAttrTypes},
	"static_ipv6_address":       types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceStaticIpv6AddressModelAttrTypes},
	"storage_network":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"untagged":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceDHCPServerModel represents dhcp_server block
type NetworkInterfaceEthernetInterfaceDHCPServerModel struct {
	AutomaticFromEnd   *NetworkInterfaceEmptyModel                                     `tfsdk:"automatic_from_end"`
	AutomaticFromStart *NetworkInterfaceEmptyModel                                     `tfsdk:"automatic_from_start"`
	DHCPNetworks       []NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModel  `tfsdk:"dhcp_networks"`
	FixedIPMap         *NetworkInterfaceEmptyModel                                     `tfsdk:"fixed_ip_map"`
	InterfaceIPMap     *NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceEthernetInterfaceDHCPServerModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceDHCPServerModel
var NetworkInterfaceEthernetInterfaceDHCPServerModelAttrTypes = map[string]attr.Type{
	"automatic_from_end":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"automatic_from_start": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"dhcp_networks":        types.ListType{ElemType: types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModelAttrTypes}},
	"fixed_ip_map":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"interface_ip_map":     types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModel represents dhcp_networks block
type NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModel struct {
	DgwAddress    types.String                                                        `tfsdk:"dgw_address"`
	DNSAddress    types.String                                                        `tfsdk:"dns_address"`
	NetworkPrefix types.String                                                        `tfsdk:"network_prefix"`
	PoolSettings  types.String                                                        `tfsdk:"pool_settings"`
	FirstAddress  *NetworkInterfaceEmptyModel                                         `tfsdk:"first_address"`
	LastAddress   *NetworkInterfaceEmptyModel                                         `tfsdk:"last_address"`
	Pools         []NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModel `tfsdk:"pools"`
	SameAsDgw     *NetworkInterfaceEmptyModel                                         `tfsdk:"same_as_dgw"`
}

// NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModel
var NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksModelAttrTypes = map[string]attr.Type{
	"dgw_address":    types.StringType,
	"dns_address":    types.StringType,
	"network_prefix": types.StringType,
	"pool_settings":  types.StringType,
	"first_address":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"last_address":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pools":          types.ListType{ElemType: types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModelAttrTypes}},
	"same_as_dgw":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModel represents pools block
type NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModel struct {
	EndIP   types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModel
var NetworkInterfaceEthernetInterfaceDHCPServerDHCPNetworksPoolsModelAttrTypes = map[string]attr.Type{
	"end_ip":   types.StringType,
	"start_ip": types.StringType,
}

// NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModel represents interface_ip_map block
type NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModel struct {
	InterfaceIPMap *NetworkInterfaceEmptyModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModel
var NetworkInterfaceEthernetInterfaceDHCPServerInterfaceIPMapModelAttrTypes = map[string]attr.Type{
	"interface_ip_map": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel represents ipv6_auto_config block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel struct {
	Host   *NetworkInterfaceEmptyModel                                 `tfsdk:"host"`
	Router *NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModel `tfsdk:"router"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigModelAttrTypes = map[string]attr.Type{
	"host":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"router": types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModel represents router block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModel struct {
	NetworkPrefix types.String                                                         `tfsdk:"network_prefix"`
	DNSConfig     *NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful      *NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModel  `tfsdk:"stateful"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterModelAttrTypes = map[string]attr.Type{
	"network_prefix": types.StringType,
	"dns_config":     types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModelAttrTypes},
	"stateful":       types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModel represents dns_config block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS       *NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModel       `tfsdk:"local_dns"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigModelAttrTypes = map[string]attr.Type{
	"configured_list": types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModelAttrTypes},
	"local_dns":       types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigConfiguredListModelAttrTypes = map[string]attr.Type{
	"dns_list": types.ListType{ElemType: types.StringType},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String                `tfsdk:"configured_address"`
	FirstAddress      *NetworkInterfaceEmptyModel `tfsdk:"first_address"`
	LastAddress       *NetworkInterfaceEmptyModel `tfsdk:"last_address"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterDNSConfigLocalDNSModelAttrTypes = map[string]attr.Type{
	"configured_address": types.StringType,
	"first_address":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"last_address":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModel represents stateful block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd   *NetworkInterfaceEmptyModel                                                       `tfsdk:"automatic_from_end"`
	AutomaticFromStart *NetworkInterfaceEmptyModel                                                       `tfsdk:"automatic_from_start"`
	DHCPNetworks       []NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModel  `tfsdk:"dhcp_networks"`
	FixedIPMap         *NetworkInterfaceEmptyModel                                                       `tfsdk:"fixed_ip_map"`
	InterfaceIPMap     *NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulModelAttrTypes = map[string]attr.Type{
	"automatic_from_end":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"automatic_from_start": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"dhcp_networks":        types.ListType{ElemType: types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModelAttrTypes}},
	"fixed_ip_map":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"interface_ip_map":     types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModel represents dhcp_networks block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModel struct {
	NetworkPrefix types.String                                                                          `tfsdk:"network_prefix"`
	PoolSettings  types.String                                                                          `tfsdk:"pool_settings"`
	Pools         []NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModel `tfsdk:"pools"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksModelAttrTypes = map[string]attr.Type{
	"network_prefix": types.StringType,
	"pool_settings":  types.StringType,
	"pools":          types.ListType{ElemType: types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModelAttrTypes}},
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModel represents pools block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModel struct {
	EndIP   types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulDHCPNetworksPoolsModelAttrTypes = map[string]attr.Type{
	"end_ip":   types.StringType,
	"start_ip": types.StringType,
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *NetworkInterfaceEmptyModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModel
var NetworkInterfaceEthernetInterfaceIpv6AutoConfigRouterStatefulInterfaceIPMapModelAttrTypes = map[string]attr.Type{
	"interface_ip_map": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceStaticIPModel represents static_ip block
type NetworkInterfaceEthernetInterfaceStaticIPModel struct {
	ClusterStaticIP *NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP    *NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModel    `tfsdk:"node_static_ip"`
}

// NetworkInterfaceEthernetInterfaceStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceStaticIPModel
var NetworkInterfaceEthernetInterfaceStaticIPModelAttrTypes = map[string]attr.Type{
	"cluster_static_ip": types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModelAttrTypes},
	"node_static_ip":    types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModel represents cluster_static_ip block
type NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModel struct {
	InterfaceIPMap *NetworkInterfaceEmptyModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModel
var NetworkInterfaceEthernetInterfaceStaticIPClusterStaticIPModelAttrTypes = map[string]attr.Type{
	"interface_ip_map": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModel represents node_static_ip block
type NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModel
var NetworkInterfaceEthernetInterfaceStaticIPNodeStaticIPModelAttrTypes = map[string]attr.Type{
	"default_gw": types.StringType,
	"ip_address": types.StringType,
}

// NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel represents static_ipv6_address block
type NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel struct {
	ClusterStaticIP *NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP    *NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModel    `tfsdk:"node_static_ip"`
}

// NetworkInterfaceEthernetInterfaceStaticIpv6AddressModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel
var NetworkInterfaceEthernetInterfaceStaticIpv6AddressModelAttrTypes = map[string]attr.Type{
	"cluster_static_ip": types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModelAttrTypes},
	"node_static_ip":    types.ObjectType{AttrTypes: NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModelAttrTypes},
}

// NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModel represents cluster_static_ip block
type NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModel struct {
	InterfaceIPMap *NetworkInterfaceEmptyModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModel
var NetworkInterfaceEthernetInterfaceStaticIpv6AddressClusterStaticIPModelAttrTypes = map[string]attr.Type{
	"interface_ip_map": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModel represents node_static_ip block
type NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModel
var NetworkInterfaceEthernetInterfaceStaticIpv6AddressNodeStaticIPModelAttrTypes = map[string]attr.Type{
	"default_gw": types.StringType,
	"ip_address": types.StringType,
}

// NetworkInterfaceLayer2InterfaceModel represents layer2_interface block
type NetworkInterfaceLayer2InterfaceModel struct {
	L2sriovInterface   *NetworkInterfaceLayer2InterfaceL2sriovInterfaceModel   `tfsdk:"l2sriov_interface"`
	L2vlanInterface    *NetworkInterfaceLayer2InterfaceL2vlanInterfaceModel    `tfsdk:"l2vlan_interface"`
	L2vlanSloInterface *NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModel `tfsdk:"l2vlan_slo_interface"`
}

// NetworkInterfaceLayer2InterfaceModelAttrTypes defines the attribute types for NetworkInterfaceLayer2InterfaceModel
var NetworkInterfaceLayer2InterfaceModelAttrTypes = map[string]attr.Type{
	"l2sriov_interface":    types.ObjectType{AttrTypes: NetworkInterfaceLayer2InterfaceL2sriovInterfaceModelAttrTypes},
	"l2vlan_interface":     types.ObjectType{AttrTypes: NetworkInterfaceLayer2InterfaceL2vlanInterfaceModelAttrTypes},
	"l2vlan_slo_interface": types.ObjectType{AttrTypes: NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModelAttrTypes},
}

// NetworkInterfaceLayer2InterfaceL2sriovInterfaceModel represents l2sriov_interface block
type NetworkInterfaceLayer2InterfaceL2sriovInterfaceModel struct {
	Device   types.String                `tfsdk:"device"`
	VLANID   types.Int64                 `tfsdk:"vlan_id"`
	Untagged *NetworkInterfaceEmptyModel `tfsdk:"untagged"`
}

// NetworkInterfaceLayer2InterfaceL2sriovInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceLayer2InterfaceL2sriovInterfaceModel
var NetworkInterfaceLayer2InterfaceL2sriovInterfaceModelAttrTypes = map[string]attr.Type{
	"device":   types.StringType,
	"vlan_id":  types.Int64Type,
	"untagged": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceLayer2InterfaceL2vlanInterfaceModel represents l2vlan_interface block
type NetworkInterfaceLayer2InterfaceL2vlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VLANID types.Int64  `tfsdk:"vlan_id"`
}

// NetworkInterfaceLayer2InterfaceL2vlanInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceLayer2InterfaceL2vlanInterfaceModel
var NetworkInterfaceLayer2InterfaceL2vlanInterfaceModelAttrTypes = map[string]attr.Type{
	"device":  types.StringType,
	"vlan_id": types.Int64Type,
}

// NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModel represents l2vlan_slo_interface block
type NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModel struct {
	VLANID types.Int64 `tfsdk:"vlan_id"`
}

// NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModel
var NetworkInterfaceLayer2InterfaceL2vlanSloInterfaceModelAttrTypes = map[string]attr.Type{
	"vlan_id": types.Int64Type,
}

// NetworkInterfaceTunnelInterfaceModel represents tunnel_interface block
type NetworkInterfaceTunnelInterfaceModel struct {
	MTU                    types.Int64                                   `tfsdk:"mtu"`
	Node                   types.String                                  `tfsdk:"node"`
	Priority               types.Int64                                   `tfsdk:"priority"`
	SiteLocalInsideNetwork *NetworkInterfaceEmptyModel                   `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork       *NetworkInterfaceEmptyModel                   `tfsdk:"site_local_network"`
	StaticIP               *NetworkInterfaceTunnelInterfaceStaticIPModel `tfsdk:"static_ip"`
	Tunnel                 *NetworkInterfaceTunnelInterfaceTunnelModel   `tfsdk:"tunnel"`
}

// NetworkInterfaceTunnelInterfaceModelAttrTypes defines the attribute types for NetworkInterfaceTunnelInterfaceModel
var NetworkInterfaceTunnelInterfaceModelAttrTypes = map[string]attr.Type{
	"mtu":                       types.Int64Type,
	"node":                      types.StringType,
	"priority":                  types.Int64Type,
	"site_local_inside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_local_network":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"static_ip":                 types.ObjectType{AttrTypes: NetworkInterfaceTunnelInterfaceStaticIPModelAttrTypes},
	"tunnel":                    types.ObjectType{AttrTypes: NetworkInterfaceTunnelInterfaceTunnelModelAttrTypes},
}

// NetworkInterfaceTunnelInterfaceStaticIPModel represents static_ip block
type NetworkInterfaceTunnelInterfaceStaticIPModel struct {
	ClusterStaticIP *NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP    *NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModel    `tfsdk:"node_static_ip"`
}

// NetworkInterfaceTunnelInterfaceStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceTunnelInterfaceStaticIPModel
var NetworkInterfaceTunnelInterfaceStaticIPModelAttrTypes = map[string]attr.Type{
	"cluster_static_ip": types.ObjectType{AttrTypes: NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModelAttrTypes},
	"node_static_ip":    types.ObjectType{AttrTypes: NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModelAttrTypes},
}

// NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModel represents cluster_static_ip block
type NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModel struct {
	InterfaceIPMap *NetworkInterfaceEmptyModel `tfsdk:"interface_ip_map"`
}

// NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModel
var NetworkInterfaceTunnelInterfaceStaticIPClusterStaticIPModelAttrTypes = map[string]attr.Type{
	"interface_ip_map": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModel represents node_static_ip block
type NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModelAttrTypes defines the attribute types for NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModel
var NetworkInterfaceTunnelInterfaceStaticIPNodeStaticIPModelAttrTypes = map[string]attr.Type{
	"default_gw": types.StringType,
	"ip_address": types.StringType,
}

// NetworkInterfaceTunnelInterfaceTunnelModel represents tunnel block
type NetworkInterfaceTunnelInterfaceTunnelModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NetworkInterfaceTunnelInterfaceTunnelModelAttrTypes defines the attribute types for NetworkInterfaceTunnelInterfaceTunnelModel
var NetworkInterfaceTunnelInterfaceTunnelModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

type NetworkInterfaceResourceModel struct {
	Name                         types.String                                       `tfsdk:"name"`
	Namespace                    types.String                                       `tfsdk:"namespace"`
	Annotations                  types.Map                                          `tfsdk:"annotations"`
	Description                  types.String                                       `tfsdk:"description"`
	Disable                      types.Bool                                         `tfsdk:"disable"`
	Labels                       types.Map                                          `tfsdk:"labels"`
	ID                           types.String                                       `tfsdk:"id"`
	Timeouts                     timeouts.Value                                     `tfsdk:"timeouts"`
	DedicatedInterface           *NetworkInterfaceDedicatedInterfaceModel           `tfsdk:"dedicated_interface"`
	DedicatedManagementInterface *NetworkInterfaceDedicatedManagementInterfaceModel `tfsdk:"dedicated_management_interface"`
	EthernetInterface            *NetworkInterfaceEthernetInterfaceModel            `tfsdk:"ethernet_interface"`
	Layer2Interface              *NetworkInterfaceLayer2InterfaceModel              `tfsdk:"layer2_interface"`
	TunnelInterface              *NetworkInterfaceTunnelInterfaceModel              `tfsdk:"tunnel_interface"`
}

func (r *NetworkInterfaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_network_interface"
}

func (r *NetworkInterfaceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Network Interface resource in F5 Distributed Cloud for network interface represents configuration of a network device. it is created by users in system namespace. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Network Interface. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Network Interface will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"dedicated_interface": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: dedicated_interface, dedicated_management_interface, ethernet_interface, layer2_interface, tunnel_interface] Dedicated Interface. Dedicated Interface Configuration.",
				Attributes: map[string]schema.Attribute{
					"device": schema.StringAttribute{
						MarkdownDescription: "Name of the device for which interface is configured. Use wwan0 for 4G/LTE.",
						Optional:            true,
					},
					"mtu": schema.Int64Attribute{
						MarkdownDescription: "Maximum packet size (Maximum Transfer Unit) of the interface When configured, MTU must be between 512 and 16384.",
						Optional:            true,
					},
					"node": schema.StringAttribute{
						MarkdownDescription: "Configuration will apply to a device on the given node of the site.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("cluster"),
							),
						},
					},
					"priority": schema.Int64Attribute{
						MarkdownDescription: "Priority of the network interface when multiple network interfaces are present in outside network Greater the value, higher the priority.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"is_primary": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"monitor": schema.SingleNestedBlock{
						MarkdownDescription: "Link Quality Monitoring configuration for a network interface.",
					},
					"monitor_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"not_primary": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"dedicated_management_interface": schema.SingleNestedBlock{
				MarkdownDescription: "Dedicated Management Interface. Dedicated Interface Configuration.",
				Attributes: map[string]schema.Attribute{
					"device": schema.StringAttribute{
						MarkdownDescription: "Name of the device for which interface is configured .",
						Optional:            true,
					},
					"mtu": schema.Int64Attribute{
						MarkdownDescription: "Maximum packet size (Maximum Transfer Unit) of the interface When configured, MTU must be between 512 and 16384.",
						Optional:            true,
					},
					"node": schema.StringAttribute{
						MarkdownDescription: "Configuration will apply to a device on the given node of the site.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("cluster"),
							),
						},
					},
				},
				Blocks: map[string]schema.Block{
					"cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"ethernet_interface": schema.SingleNestedBlock{
				MarkdownDescription: "Ethernet Interface. Ethernet Interface Configuration.",
				Attributes: map[string]schema.Attribute{
					"device": schema.StringAttribute{
						MarkdownDescription: "Interface configuration for the ethernet device .",
						Optional:            true,
					},
					"mtu": schema.Int64Attribute{
						MarkdownDescription: "Maximum packet size (Maximum Transfer Unit) of the interface When configured, MTU must be between 512 and 16384.",
						Optional:            true,
					},
					"node": schema.StringAttribute{
						MarkdownDescription: "Configuration will apply to a device on the given node.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("cluster"),
							),
						},
					},
					"priority": schema.Int64Attribute{
						MarkdownDescription: "Priority of the network interface when multiple network interfaces are present in outside network Greater the value, higher the priority.",
						Optional:            true,
					},
					"vlan_id": schema.Int64Attribute{
						MarkdownDescription: "Configure a VLAN tagged ethernet interface.",
						Optional:            true,
						Validators: []validator.Int64{
							int64validator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("untagged"),
							),
						},
					},
				},
				Blocks: map[string]schema.Block{
					"cluster": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"dhcp_client": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"dhcp_server": schema.SingleNestedBlock{
						MarkdownDescription: "DHCPServerParametersType.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"automatic_from_end": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"automatic_from_start": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"dhcp_networks": schema.ListNestedBlock{
								MarkdownDescription: "List of networks from which DHCP Server can allocate IPv4 Addresses .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"dgw_address": schema.StringAttribute{
											MarkdownDescription: "Enter a IPv4 address from the network prefix to be used as the default gateway.",
											Optional:            true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(
													path.MatchRelative().AtParent().AtName("first_address"),
													path.MatchRelative().AtParent().AtName("last_address"),
												),
											},
										},
										"dns_address": schema.StringAttribute{
											MarkdownDescription: "Enter a IPv4 address from the network prefix to be used as the DNS server.",
											Optional:            true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(
													path.MatchRelative().AtParent().AtName("same_as_dgw"),
												),
											},
										},
										"network_prefix": schema.StringAttribute{
											MarkdownDescription: "Set the network prefix for the site. Ex: 10.1.1.0/24.",
											Optional:            true,
										},
										"pool_settings": schema.StringAttribute{
											MarkdownDescription: "[Enum: INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS|EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS] Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"first_address": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"last_address": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"pools": schema.ListNestedBlock{
											MarkdownDescription: "List of non overlapping IP address ranges.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"end_ip": schema.StringAttribute{
														MarkdownDescription: "Ending IP of the pool range. In case of address allocator, offset is derived based on network prefix. 10.1.1.200 with prefix length of 24, end offset is 0.0.0.200.",
														Optional:            true,
													},
													"start_ip": schema.StringAttribute{
														MarkdownDescription: "Starting IP of the pool range. In case of address allocator, offset is derived based on network prefix. 10.1.1.5 with prefix length of 24, start offset is 0.0.0.5.",
														Optional:            true,
													},
												},
											},
										},
										"same_as_dgw": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"fixed_ip_map": schema.SingleNestedBlock{
								MarkdownDescription: "Assign fixed IPv4 addresses based on the MAC Address of the DHCP Client.",
							},
							"interface_ip_map": schema.SingleNestedBlock{
								MarkdownDescription: "Interface IPv4 Assignments. Specify static IPv4 addresses per node.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"interface_ip_map": schema.SingleNestedBlock{
										MarkdownDescription: "Specify static IPv4 addresses per site:node.",
									},
								},
							},
						},
					},
					"ipv6_auto_config": schema.SingleNestedBlock{
						MarkdownDescription: "IPV6AutoConfigType.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"host": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"router": schema.SingleNestedBlock{
								MarkdownDescription: "IPV6AutoConfigRouterType.",
								Attributes: map[string]schema.Attribute{
									"network_prefix": schema.StringAttribute{
										MarkdownDescription: "Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("stateful"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"dns_config": schema.SingleNestedBlock{
										MarkdownDescription: "IPV6DnsConfig.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"configured_list": schema.SingleNestedBlock{
												MarkdownDescription: "IPV6DnsList.",
												Attributes: map[string]schema.Attribute{
													"dns_list": schema.ListAttribute{
														MarkdownDescription: "List of IPv6 Addresses acting as DNS servers .",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
											},
											"local_dns": schema.SingleNestedBlock{
												MarkdownDescription: "IPV6LocalDnsAddress.",
												Attributes: map[string]schema.Attribute{
													"configured_address": schema.StringAttribute{
														MarkdownDescription: "Configured address from the network prefix is chosen as DNS server.",
														Optional:            true,
														Validators: []validator.String{
															stringvalidator.ConflictsWith(
																path.MatchRelative().AtParent().AtName("first_address"),
																path.MatchRelative().AtParent().AtName("last_address"),
															),
														},
													},
												},
												Blocks: map[string]schema.Block{
													"first_address": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"last_address": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
										},
									},
									"stateful": schema.SingleNestedBlock{
										MarkdownDescription: "DHCPIPV6 Stateful Server.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"automatic_from_end": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"automatic_from_start": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"dhcp_networks": schema.ListNestedBlock{
												MarkdownDescription: "List of networks from which DHCP server can allocate IP addresses .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"network_prefix": schema.StringAttribute{
															MarkdownDescription: "Network Prefix to be used for IPv6 address auto configuration.",
															Optional:            true,
														},
														"pool_settings": schema.StringAttribute{
															MarkdownDescription: "[Enum: INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS|EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS] Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"pools": schema.ListNestedBlock{
															MarkdownDescription: "List of non overlapping IP address ranges.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"end_ip": schema.StringAttribute{
																		MarkdownDescription: "Ending IPv6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																		Optional:            true,
																	},
																	"start_ip": schema.StringAttribute{
																		MarkdownDescription: "Starting IPv6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
											"fixed_ip_map": schema.SingleNestedBlock{
												MarkdownDescription: "Fixed MAC address to IPv6 assignments, Key: MAC address, Value: IPv6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
											},
											"interface_ip_map": schema.SingleNestedBlock{
												MarkdownDescription: "Map of Interface IPv6 assignments per node.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"interface_ip_map": schema.SingleNestedBlock{
														MarkdownDescription: "Site:Node to IPv6 Mapping. Map of Site:Node to IPv6 address.",
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"is_primary": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"monitor": schema.SingleNestedBlock{
						MarkdownDescription: "Link Quality Monitoring configuration for a network interface.",
					},
					"monitor_disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_ipv6_address": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"not_primary": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"site_local_inside_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"site_local_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"static_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Static IP Parameters. Configure Static IP parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"cluster_static_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Configure Static IP parameters for cluster.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"interface_ip_map": schema.SingleNestedBlock{
										MarkdownDescription: "Map of Node to Static IP configuration value, Key:Node, Value:IP Address.",
									},
								},
							},
							"node_static_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Configure Static IP parameters for a node.",
								Attributes: map[string]schema.Attribute{
									"default_gw": schema.StringAttribute{
										MarkdownDescription: "Default Gateway. IP address of the default gateway.",
										Optional:            true,
									},
									"ip_address": schema.StringAttribute{
										MarkdownDescription: "IP address of the interface and prefix length .",
										Optional:            true,
									},
								},
							},
						},
					},
					"static_ipv6_address": schema.SingleNestedBlock{
						MarkdownDescription: "Static IP Parameters. Configure Static IP parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"cluster_static_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Configure Static IP parameters for cluster.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"interface_ip_map": schema.SingleNestedBlock{
										MarkdownDescription: "Map of Node to Static IP configuration value, Key:Node, Value:IP Address.",
									},
								},
							},
							"node_static_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Configure Static IP parameters for a node.",
								Attributes: map[string]schema.Attribute{
									"default_gw": schema.StringAttribute{
										MarkdownDescription: "Default Gateway. IP address of the default gateway.",
										Optional:            true,
									},
									"ip_address": schema.StringAttribute{
										MarkdownDescription: "IP address of the interface and prefix length .",
										Optional:            true,
									},
								},
							},
						},
					},
					"storage_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"untagged": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"layer2_interface": schema.SingleNestedBlock{
				MarkdownDescription: "Layer2 Interface. Layer2 Interface Configuration.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"l2sriov_interface": schema.SingleNestedBlock{
						MarkdownDescription: "Layer2 SR-IOV Interface. Layer2 SR-IOV Interface Configuration.",
						Attributes: map[string]schema.Attribute{
							"device": schema.StringAttribute{
								MarkdownDescription: "Physical ethernet interface .",
								Optional:            true,
							},
							"vlan_id": schema.Int64Attribute{
								MarkdownDescription: "Configure a VLAN tagged interface.",
								Optional:            true,
								Validators: []validator.Int64{
									int64validator.ConflictsWith(
										path.MatchRelative().AtParent().AtName("untagged"),
									),
								},
							},
						},
						Blocks: map[string]schema.Block{
							"untagged": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"l2vlan_interface": schema.SingleNestedBlock{
						MarkdownDescription: "Layer2 VLAN Interface. Layer2 VLAN Interface Configuration.",
						Attributes: map[string]schema.Attribute{
							"device": schema.StringAttribute{
								MarkdownDescription: "Physical ethernet interface .",
								Optional:            true,
							},
							"vlan_id": schema.Int64Attribute{
								MarkdownDescription: "VLAN ID. VLAN ID .",
								Optional:            true,
							},
						},
					},
					"l2vlan_slo_interface": schema.SingleNestedBlock{
						MarkdownDescription: "Layer2 Site Local Outside VLAN Interface Configuration.",
						Attributes: map[string]schema.Attribute{
							"vlan_id": schema.Int64Attribute{
								MarkdownDescription: "VLAN ID. VLAN ID .",
								Optional:            true,
							},
						},
					},
				},
			},
			"tunnel_interface": schema.SingleNestedBlock{
				MarkdownDescription: "Tunnel Interface. Tunnel Interface Configuration.",
				Attributes: map[string]schema.Attribute{
					"mtu": schema.Int64Attribute{
						MarkdownDescription: "Maximum packet size (Maximum Transfer Unit) of the interface When configured, MTU must be between 512 and 16384.",
						Optional:            true,
					},
					"node": schema.StringAttribute{
						MarkdownDescription: "Configuration will apply to a given device on the given node.",
						Optional:            true,
					},
					"priority": schema.Int64Attribute{
						MarkdownDescription: "Priority of the network interface when multiple network interfaces are present in outside network Greater the value, higher the priority.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"site_local_inside_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"site_local_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"static_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Static IP Parameters. Configure Static IP parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"cluster_static_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Configure Static IP parameters for cluster.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"interface_ip_map": schema.SingleNestedBlock{
										MarkdownDescription: "Map of Node to Static IP configuration value, Key:Node, Value:IP Address.",
									},
								},
							},
							"node_static_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Configure Static IP parameters for a node.",
								Attributes: map[string]schema.Attribute{
									"default_gw": schema.StringAttribute{
										MarkdownDescription: "Default Gateway. IP address of the default gateway.",
										Optional:            true,
									},
									"ip_address": schema.StringAttribute{
										MarkdownDescription: "IP address of the interface and prefix length .",
										Optional:            true,
									},
								},
							},
						},
					},
					"tunnel": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *NetworkInterfaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *NetworkInterfaceResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data NetworkInterfaceResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *NetworkInterfaceResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the network_interface from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan NetworkInterfaceResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *NetworkInterfaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data NetworkInterfaceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating network_interface", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.NetworkInterface{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.DedicatedInterface != nil {
		dedicated_interfaceMap := make(map[string]interface{})
		if data.DedicatedInterface.Cluster != nil {
			dedicated_interfaceMap["cluster"] = map[string]interface{}{}
		}
		if !data.DedicatedInterface.Device.IsNull() && !data.DedicatedInterface.Device.IsUnknown() {
			dedicated_interfaceMap["device"] = data.DedicatedInterface.Device.ValueString()
		}
		if data.DedicatedInterface.IsPrimary != nil {
			dedicated_interfaceMap["is_primary"] = map[string]interface{}{}
		}
		if data.DedicatedInterface.Monitor != nil {
			dedicated_interfaceMap["monitor"] = map[string]interface{}{}
		}
		if data.DedicatedInterface.MonitorDisabled != nil {
			dedicated_interfaceMap["monitor_disabled"] = map[string]interface{}{}
		}
		if !data.DedicatedInterface.MTU.IsNull() && !data.DedicatedInterface.MTU.IsUnknown() {
			dedicated_interfaceMap["mtu"] = data.DedicatedInterface.MTU.ValueInt64()
		}
		if !data.DedicatedInterface.Node.IsNull() && !data.DedicatedInterface.Node.IsUnknown() {
			dedicated_interfaceMap["node"] = data.DedicatedInterface.Node.ValueString()
		}
		if data.DedicatedInterface.NotPrimary != nil {
			dedicated_interfaceMap["not_primary"] = map[string]interface{}{}
		}
		if !data.DedicatedInterface.Priority.IsNull() && !data.DedicatedInterface.Priority.IsUnknown() {
			dedicated_interfaceMap["priority"] = data.DedicatedInterface.Priority.ValueInt64()
		}
		createReq.Spec["dedicated_interface"] = dedicated_interfaceMap
	}
	if data.DedicatedManagementInterface != nil {
		dedicated_management_interfaceMap := make(map[string]interface{})
		if data.DedicatedManagementInterface.Cluster != nil {
			dedicated_management_interfaceMap["cluster"] = map[string]interface{}{}
		}
		if !data.DedicatedManagementInterface.Device.IsNull() && !data.DedicatedManagementInterface.Device.IsUnknown() {
			dedicated_management_interfaceMap["device"] = data.DedicatedManagementInterface.Device.ValueString()
		}
		if !data.DedicatedManagementInterface.MTU.IsNull() && !data.DedicatedManagementInterface.MTU.IsUnknown() {
			dedicated_management_interfaceMap["mtu"] = data.DedicatedManagementInterface.MTU.ValueInt64()
		}
		if !data.DedicatedManagementInterface.Node.IsNull() && !data.DedicatedManagementInterface.Node.IsUnknown() {
			dedicated_management_interfaceMap["node"] = data.DedicatedManagementInterface.Node.ValueString()
		}
		createReq.Spec["dedicated_management_interface"] = dedicated_management_interfaceMap
	}
	if data.EthernetInterface != nil {
		ethernet_interfaceMap := make(map[string]interface{})
		if data.EthernetInterface.Cluster != nil {
			ethernet_interfaceMap["cluster"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.Device.IsNull() && !data.EthernetInterface.Device.IsUnknown() {
			ethernet_interfaceMap["device"] = data.EthernetInterface.Device.ValueString()
		}
		if data.EthernetInterface.DHCPClient != nil {
			ethernet_interfaceMap["dhcp_client"] = map[string]interface{}{}
		}
		if data.EthernetInterface.DHCPServer != nil {
			dhcp_serverNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["dhcp_server"] = dhcp_serverNestedMap
		}
		if data.EthernetInterface.Ipv6AutoConfig != nil {
			ipv6_auto_configNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["ipv6_auto_config"] = ipv6_auto_configNestedMap
		}
		if data.EthernetInterface.IsPrimary != nil {
			ethernet_interfaceMap["is_primary"] = map[string]interface{}{}
		}
		if data.EthernetInterface.Monitor != nil {
			ethernet_interfaceMap["monitor"] = map[string]interface{}{}
		}
		if data.EthernetInterface.MonitorDisabled != nil {
			ethernet_interfaceMap["monitor_disabled"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.MTU.IsNull() && !data.EthernetInterface.MTU.IsUnknown() {
			ethernet_interfaceMap["mtu"] = data.EthernetInterface.MTU.ValueInt64()
		}
		if data.EthernetInterface.NoIpv6Address != nil {
			ethernet_interfaceMap["no_ipv6_address"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.Node.IsNull() && !data.EthernetInterface.Node.IsUnknown() {
			ethernet_interfaceMap["node"] = data.EthernetInterface.Node.ValueString()
		}
		if data.EthernetInterface.NotPrimary != nil {
			ethernet_interfaceMap["not_primary"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.Priority.IsNull() && !data.EthernetInterface.Priority.IsUnknown() {
			ethernet_interfaceMap["priority"] = data.EthernetInterface.Priority.ValueInt64()
		}
		if data.EthernetInterface.SiteLocalInsideNetwork != nil {
			ethernet_interfaceMap["site_local_inside_network"] = map[string]interface{}{}
		}
		if data.EthernetInterface.SiteLocalNetwork != nil {
			ethernet_interfaceMap["site_local_network"] = map[string]interface{}{}
		}
		if data.EthernetInterface.StaticIP != nil {
			static_ipNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["static_ip"] = static_ipNestedMap
		}
		if data.EthernetInterface.StaticIpv6Address != nil {
			static_ipv6_addressNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["static_ipv6_address"] = static_ipv6_addressNestedMap
		}
		if data.EthernetInterface.StorageNetwork != nil {
			ethernet_interfaceMap["storage_network"] = map[string]interface{}{}
		}
		if data.EthernetInterface.Untagged != nil {
			ethernet_interfaceMap["untagged"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.VLANID.IsNull() && !data.EthernetInterface.VLANID.IsUnknown() {
			ethernet_interfaceMap["vlan_id"] = data.EthernetInterface.VLANID.ValueInt64()
		}
		createReq.Spec["ethernet_interface"] = ethernet_interfaceMap
	}
	if data.Layer2Interface != nil {
		layer2_interfaceMap := make(map[string]interface{})
		if data.Layer2Interface.L2sriovInterface != nil {
			l2sriov_interfaceNestedMap := make(map[string]interface{})
			if !data.Layer2Interface.L2sriovInterface.Device.IsNull() && !data.Layer2Interface.L2sriovInterface.Device.IsUnknown() {
				l2sriov_interfaceNestedMap["device"] = data.Layer2Interface.L2sriovInterface.Device.ValueString()
			}
			if !data.Layer2Interface.L2sriovInterface.VLANID.IsNull() && !data.Layer2Interface.L2sriovInterface.VLANID.IsUnknown() {
				l2sriov_interfaceNestedMap["vlan_id"] = data.Layer2Interface.L2sriovInterface.VLANID.ValueInt64()
			}
			layer2_interfaceMap["l2sriov_interface"] = l2sriov_interfaceNestedMap
		}
		if data.Layer2Interface.L2vlanInterface != nil {
			l2vlan_interfaceNestedMap := make(map[string]interface{})
			if !data.Layer2Interface.L2vlanInterface.Device.IsNull() && !data.Layer2Interface.L2vlanInterface.Device.IsUnknown() {
				l2vlan_interfaceNestedMap["device"] = data.Layer2Interface.L2vlanInterface.Device.ValueString()
			}
			if !data.Layer2Interface.L2vlanInterface.VLANID.IsNull() && !data.Layer2Interface.L2vlanInterface.VLANID.IsUnknown() {
				l2vlan_interfaceNestedMap["vlan_id"] = data.Layer2Interface.L2vlanInterface.VLANID.ValueInt64()
			}
			layer2_interfaceMap["l2vlan_interface"] = l2vlan_interfaceNestedMap
		}
		if data.Layer2Interface.L2vlanSloInterface != nil {
			l2vlan_slo_interfaceNestedMap := make(map[string]interface{})
			if !data.Layer2Interface.L2vlanSloInterface.VLANID.IsNull() && !data.Layer2Interface.L2vlanSloInterface.VLANID.IsUnknown() {
				l2vlan_slo_interfaceNestedMap["vlan_id"] = data.Layer2Interface.L2vlanSloInterface.VLANID.ValueInt64()
			}
			layer2_interfaceMap["l2vlan_slo_interface"] = l2vlan_slo_interfaceNestedMap
		}
		createReq.Spec["layer2_interface"] = layer2_interfaceMap
	}
	if data.TunnelInterface != nil {
		tunnel_interfaceMap := make(map[string]interface{})
		if !data.TunnelInterface.MTU.IsNull() && !data.TunnelInterface.MTU.IsUnknown() {
			tunnel_interfaceMap["mtu"] = data.TunnelInterface.MTU.ValueInt64()
		}
		if !data.TunnelInterface.Node.IsNull() && !data.TunnelInterface.Node.IsUnknown() {
			tunnel_interfaceMap["node"] = data.TunnelInterface.Node.ValueString()
		}
		if !data.TunnelInterface.Priority.IsNull() && !data.TunnelInterface.Priority.IsUnknown() {
			tunnel_interfaceMap["priority"] = data.TunnelInterface.Priority.ValueInt64()
		}
		if data.TunnelInterface.SiteLocalInsideNetwork != nil {
			tunnel_interfaceMap["site_local_inside_network"] = map[string]interface{}{}
		}
		if data.TunnelInterface.SiteLocalNetwork != nil {
			tunnel_interfaceMap["site_local_network"] = map[string]interface{}{}
		}
		if data.TunnelInterface.StaticIP != nil {
			static_ipNestedMap := make(map[string]interface{})
			tunnel_interfaceMap["static_ip"] = static_ipNestedMap
		}
		if data.TunnelInterface.Tunnel != nil {
			tunnelNestedMap := make(map[string]interface{})
			if !data.TunnelInterface.Tunnel.Name.IsNull() && !data.TunnelInterface.Tunnel.Name.IsUnknown() {
				tunnelNestedMap["name"] = data.TunnelInterface.Tunnel.Name.ValueString()
			}
			if !data.TunnelInterface.Tunnel.Namespace.IsNull() && !data.TunnelInterface.Tunnel.Namespace.IsUnknown() {
				tunnelNestedMap["namespace"] = data.TunnelInterface.Tunnel.Namespace.ValueString()
			}
			if !data.TunnelInterface.Tunnel.Tenant.IsNull() && !data.TunnelInterface.Tunnel.Tenant.IsUnknown() {
				tunnelNestedMap["tenant"] = data.TunnelInterface.Tunnel.Tenant.ValueString()
			}
			tunnel_interfaceMap["tunnel"] = tunnelNestedMap
		}
		createReq.Spec["tunnel_interface"] = tunnel_interfaceMap
	}

	apiResource, err := r.client.CreateNetworkInterface(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create NetworkInterface: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["dedicated_interface"].(map[string]interface{}); ok && (isImport || data.DedicatedInterface != nil) {
		data.DedicatedInterface = &NetworkInterfaceDedicatedInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			IsPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.IsPrimary
				}
				// Import case: read from API
				if _, ok := blockData["is_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Monitor: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.Monitor
				}
				// Import case: read from API
				if _, ok := blockData["monitor"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MonitorDisabled: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.MonitorDisabled
				}
				// Import case: read from API
				if _, ok := blockData["monitor_disabled"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.DedicatedInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NotPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.NotPrimary
				}
				// Import case: read from API
				if _, ok := blockData["not_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.DedicatedInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["dedicated_management_interface"].(map[string]interface{}); ok && (isImport || data.DedicatedManagementInterface != nil) {
		data.DedicatedManagementInterface = &NetworkInterfaceDedicatedManagementInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedManagementInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedManagementInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.DedicatedManagementInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedManagementInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ethernet_interface"].(map[string]interface{}); ok && (isImport || data.EthernetInterface != nil) {
		data.EthernetInterface = &NetworkInterfaceEthernetInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DHCPClient: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.DHCPClient
				}
				// Import case: read from API
				if _, ok := blockData["dhcp_client"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			DHCPServer: func() *NetworkInterfaceEthernetInterfaceDHCPServerModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.DHCPServer != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.DHCPServer
				}
				// Import case: read from API
				if _, ok := blockData["dhcp_server"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceDHCPServerModel{}
				}
				return nil
			}(),
			Ipv6AutoConfig: func() *NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.Ipv6AutoConfig != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.Ipv6AutoConfig
				}
				// Import case: read from API
				if _, ok := blockData["ipv6_auto_config"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel{}
				}
				return nil
			}(),
			IsPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.IsPrimary
				}
				// Import case: read from API
				if _, ok := blockData["is_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Monitor: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Monitor
				}
				// Import case: read from API
				if _, ok := blockData["monitor"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MonitorDisabled: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.MonitorDisabled
				}
				// Import case: read from API
				if _, ok := blockData["monitor_disabled"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoIpv6Address: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.NoIpv6Address
				}
				// Import case: read from API
				if _, ok := blockData["no_ipv6_address"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NotPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.NotPrimary
				}
				// Import case: read from API
				if _, ok := blockData["not_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SiteLocalInsideNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.SiteLocalInsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_inside_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			StaticIP: func() *NetworkInterfaceEthernetInterfaceStaticIPModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.StaticIP != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.StaticIP
				}
				// Import case: read from API
				if _, ok := blockData["static_ip"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceStaticIPModel{}
				}
				return nil
			}(),
			StaticIpv6Address: func() *NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.StaticIpv6Address != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.StaticIpv6Address
				}
				// Import case: read from API
				if _, ok := blockData["static_ipv6_address"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel{}
				}
				return nil
			}(),
			StorageNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.StorageNetwork
				}
				// Import case: read from API
				if _, ok := blockData["storage_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Untagged: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Untagged
				}
				// Import case: read from API
				if _, ok := blockData["untagged"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			VLANID: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.VLANID
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["vlan_id"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["layer2_interface"].(map[string]interface{}); ok && isImport && data.Layer2Interface == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Layer2Interface = &NetworkInterfaceLayer2InterfaceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["tunnel_interface"].(map[string]interface{}); ok && (isImport || data.TunnelInterface != nil) {
		data.TunnelInterface = &NetworkInterfaceTunnelInterfaceModel{
			MTU: func() types.Int64 {
				if !isImport && data.TunnelInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.TunnelInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.TunnelInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.TunnelInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SiteLocalInsideNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.TunnelInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TunnelInterface.SiteLocalInsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_inside_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.TunnelInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TunnelInterface.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			StaticIP: func() *NetworkInterfaceTunnelInterfaceStaticIPModel {
				if !isImport && data.TunnelInterface != nil && data.TunnelInterface.StaticIP != nil {
					// Normal Read: preserve existing state value
					return data.TunnelInterface.StaticIP
				}
				// Import case: read from API
				if _, ok := blockData["static_ip"].(map[string]interface{}); ok {
					return &NetworkInterfaceTunnelInterfaceStaticIPModel{}
				}
				return nil
			}(),
			Tunnel: func() *NetworkInterfaceTunnelInterfaceTunnelModel {
				if !isImport && data.TunnelInterface != nil && data.TunnelInterface.Tunnel != nil {
					// Normal Read: preserve existing state value
					return data.TunnelInterface.Tunnel
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["tunnel"].(map[string]interface{}); ok {
					return &NetworkInterfaceTunnelInterfaceTunnelModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}

	tflog.Trace(ctx, "created NetworkInterface resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NetworkInterfaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data NetworkInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetNetworkInterface(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "NetworkInterface not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read NetworkInterface: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["dedicated_interface"].(map[string]interface{}); ok && (isImport || data.DedicatedInterface != nil) {
		data.DedicatedInterface = &NetworkInterfaceDedicatedInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			IsPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.IsPrimary
				}
				// Import case: read from API
				if _, ok := blockData["is_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Monitor: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.Monitor
				}
				// Import case: read from API
				if _, ok := blockData["monitor"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MonitorDisabled: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.MonitorDisabled
				}
				// Import case: read from API
				if _, ok := blockData["monitor_disabled"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.DedicatedInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NotPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.NotPrimary
				}
				// Import case: read from API
				if _, ok := blockData["not_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.DedicatedInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["dedicated_management_interface"].(map[string]interface{}); ok && (isImport || data.DedicatedManagementInterface != nil) {
		data.DedicatedManagementInterface = &NetworkInterfaceDedicatedManagementInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedManagementInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedManagementInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.DedicatedManagementInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedManagementInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ethernet_interface"].(map[string]interface{}); ok && (isImport || data.EthernetInterface != nil) {
		data.EthernetInterface = &NetworkInterfaceEthernetInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DHCPClient: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.DHCPClient
				}
				// Import case: read from API
				if _, ok := blockData["dhcp_client"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			DHCPServer: func() *NetworkInterfaceEthernetInterfaceDHCPServerModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.DHCPServer != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.DHCPServer
				}
				// Import case: read from API
				if _, ok := blockData["dhcp_server"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceDHCPServerModel{}
				}
				return nil
			}(),
			Ipv6AutoConfig: func() *NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.Ipv6AutoConfig != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.Ipv6AutoConfig
				}
				// Import case: read from API
				if _, ok := blockData["ipv6_auto_config"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel{}
				}
				return nil
			}(),
			IsPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.IsPrimary
				}
				// Import case: read from API
				if _, ok := blockData["is_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Monitor: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Monitor
				}
				// Import case: read from API
				if _, ok := blockData["monitor"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MonitorDisabled: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.MonitorDisabled
				}
				// Import case: read from API
				if _, ok := blockData["monitor_disabled"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoIpv6Address: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.NoIpv6Address
				}
				// Import case: read from API
				if _, ok := blockData["no_ipv6_address"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NotPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.NotPrimary
				}
				// Import case: read from API
				if _, ok := blockData["not_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SiteLocalInsideNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.SiteLocalInsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_inside_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			StaticIP: func() *NetworkInterfaceEthernetInterfaceStaticIPModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.StaticIP != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.StaticIP
				}
				// Import case: read from API
				if _, ok := blockData["static_ip"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceStaticIPModel{}
				}
				return nil
			}(),
			StaticIpv6Address: func() *NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.StaticIpv6Address != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.StaticIpv6Address
				}
				// Import case: read from API
				if _, ok := blockData["static_ipv6_address"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel{}
				}
				return nil
			}(),
			StorageNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.StorageNetwork
				}
				// Import case: read from API
				if _, ok := blockData["storage_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Untagged: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Untagged
				}
				// Import case: read from API
				if _, ok := blockData["untagged"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			VLANID: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.VLANID
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["vlan_id"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["layer2_interface"].(map[string]interface{}); ok && isImport && data.Layer2Interface == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Layer2Interface = &NetworkInterfaceLayer2InterfaceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["tunnel_interface"].(map[string]interface{}); ok && (isImport || data.TunnelInterface != nil) {
		data.TunnelInterface = &NetworkInterfaceTunnelInterfaceModel{
			MTU: func() types.Int64 {
				if !isImport && data.TunnelInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.TunnelInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.TunnelInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.TunnelInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SiteLocalInsideNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.TunnelInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TunnelInterface.SiteLocalInsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_inside_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.TunnelInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TunnelInterface.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			StaticIP: func() *NetworkInterfaceTunnelInterfaceStaticIPModel {
				if !isImport && data.TunnelInterface != nil && data.TunnelInterface.StaticIP != nil {
					// Normal Read: preserve existing state value
					return data.TunnelInterface.StaticIP
				}
				// Import case: read from API
				if _, ok := blockData["static_ip"].(map[string]interface{}); ok {
					return &NetworkInterfaceTunnelInterfaceStaticIPModel{}
				}
				return nil
			}(),
			Tunnel: func() *NetworkInterfaceTunnelInterfaceTunnelModel {
				if !isImport && data.TunnelInterface != nil && data.TunnelInterface.Tunnel != nil {
					// Normal Read: preserve existing state value
					return data.TunnelInterface.Tunnel
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["tunnel"].(map[string]interface{}); ok {
					return &NetworkInterfaceTunnelInterfaceTunnelModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NetworkInterfaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data NetworkInterfaceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.NetworkInterface{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.DedicatedInterface != nil {
		dedicated_interfaceMap := make(map[string]interface{})
		if data.DedicatedInterface.Cluster != nil {
			dedicated_interfaceMap["cluster"] = map[string]interface{}{}
		}
		if !data.DedicatedInterface.Device.IsNull() && !data.DedicatedInterface.Device.IsUnknown() {
			dedicated_interfaceMap["device"] = data.DedicatedInterface.Device.ValueString()
		}
		if data.DedicatedInterface.IsPrimary != nil {
			dedicated_interfaceMap["is_primary"] = map[string]interface{}{}
		}
		if data.DedicatedInterface.Monitor != nil {
			dedicated_interfaceMap["monitor"] = map[string]interface{}{}
		}
		if data.DedicatedInterface.MonitorDisabled != nil {
			dedicated_interfaceMap["monitor_disabled"] = map[string]interface{}{}
		}
		if !data.DedicatedInterface.MTU.IsNull() && !data.DedicatedInterface.MTU.IsUnknown() {
			dedicated_interfaceMap["mtu"] = data.DedicatedInterface.MTU.ValueInt64()
		}
		if !data.DedicatedInterface.Node.IsNull() && !data.DedicatedInterface.Node.IsUnknown() {
			dedicated_interfaceMap["node"] = data.DedicatedInterface.Node.ValueString()
		}
		if data.DedicatedInterface.NotPrimary != nil {
			dedicated_interfaceMap["not_primary"] = map[string]interface{}{}
		}
		if !data.DedicatedInterface.Priority.IsNull() && !data.DedicatedInterface.Priority.IsUnknown() {
			dedicated_interfaceMap["priority"] = data.DedicatedInterface.Priority.ValueInt64()
		}
		apiResource.Spec["dedicated_interface"] = dedicated_interfaceMap
	}
	if data.DedicatedManagementInterface != nil {
		dedicated_management_interfaceMap := make(map[string]interface{})
		if data.DedicatedManagementInterface.Cluster != nil {
			dedicated_management_interfaceMap["cluster"] = map[string]interface{}{}
		}
		if !data.DedicatedManagementInterface.Device.IsNull() && !data.DedicatedManagementInterface.Device.IsUnknown() {
			dedicated_management_interfaceMap["device"] = data.DedicatedManagementInterface.Device.ValueString()
		}
		if !data.DedicatedManagementInterface.MTU.IsNull() && !data.DedicatedManagementInterface.MTU.IsUnknown() {
			dedicated_management_interfaceMap["mtu"] = data.DedicatedManagementInterface.MTU.ValueInt64()
		}
		if !data.DedicatedManagementInterface.Node.IsNull() && !data.DedicatedManagementInterface.Node.IsUnknown() {
			dedicated_management_interfaceMap["node"] = data.DedicatedManagementInterface.Node.ValueString()
		}
		apiResource.Spec["dedicated_management_interface"] = dedicated_management_interfaceMap
	}
	if data.EthernetInterface != nil {
		ethernet_interfaceMap := make(map[string]interface{})
		if data.EthernetInterface.Cluster != nil {
			ethernet_interfaceMap["cluster"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.Device.IsNull() && !data.EthernetInterface.Device.IsUnknown() {
			ethernet_interfaceMap["device"] = data.EthernetInterface.Device.ValueString()
		}
		if data.EthernetInterface.DHCPClient != nil {
			ethernet_interfaceMap["dhcp_client"] = map[string]interface{}{}
		}
		if data.EthernetInterface.DHCPServer != nil {
			dhcp_serverNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["dhcp_server"] = dhcp_serverNestedMap
		}
		if data.EthernetInterface.Ipv6AutoConfig != nil {
			ipv6_auto_configNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["ipv6_auto_config"] = ipv6_auto_configNestedMap
		}
		if data.EthernetInterface.IsPrimary != nil {
			ethernet_interfaceMap["is_primary"] = map[string]interface{}{}
		}
		if data.EthernetInterface.Monitor != nil {
			ethernet_interfaceMap["monitor"] = map[string]interface{}{}
		}
		if data.EthernetInterface.MonitorDisabled != nil {
			ethernet_interfaceMap["monitor_disabled"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.MTU.IsNull() && !data.EthernetInterface.MTU.IsUnknown() {
			ethernet_interfaceMap["mtu"] = data.EthernetInterface.MTU.ValueInt64()
		}
		if data.EthernetInterface.NoIpv6Address != nil {
			ethernet_interfaceMap["no_ipv6_address"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.Node.IsNull() && !data.EthernetInterface.Node.IsUnknown() {
			ethernet_interfaceMap["node"] = data.EthernetInterface.Node.ValueString()
		}
		if data.EthernetInterface.NotPrimary != nil {
			ethernet_interfaceMap["not_primary"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.Priority.IsNull() && !data.EthernetInterface.Priority.IsUnknown() {
			ethernet_interfaceMap["priority"] = data.EthernetInterface.Priority.ValueInt64()
		}
		if data.EthernetInterface.SiteLocalInsideNetwork != nil {
			ethernet_interfaceMap["site_local_inside_network"] = map[string]interface{}{}
		}
		if data.EthernetInterface.SiteLocalNetwork != nil {
			ethernet_interfaceMap["site_local_network"] = map[string]interface{}{}
		}
		if data.EthernetInterface.StaticIP != nil {
			static_ipNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["static_ip"] = static_ipNestedMap
		}
		if data.EthernetInterface.StaticIpv6Address != nil {
			static_ipv6_addressNestedMap := make(map[string]interface{})
			ethernet_interfaceMap["static_ipv6_address"] = static_ipv6_addressNestedMap
		}
		if data.EthernetInterface.StorageNetwork != nil {
			ethernet_interfaceMap["storage_network"] = map[string]interface{}{}
		}
		if data.EthernetInterface.Untagged != nil {
			ethernet_interfaceMap["untagged"] = map[string]interface{}{}
		}
		if !data.EthernetInterface.VLANID.IsNull() && !data.EthernetInterface.VLANID.IsUnknown() {
			ethernet_interfaceMap["vlan_id"] = data.EthernetInterface.VLANID.ValueInt64()
		}
		apiResource.Spec["ethernet_interface"] = ethernet_interfaceMap
	}
	if data.Layer2Interface != nil {
		layer2_interfaceMap := make(map[string]interface{})
		if data.Layer2Interface.L2sriovInterface != nil {
			l2sriov_interfaceNestedMap := make(map[string]interface{})
			if !data.Layer2Interface.L2sriovInterface.Device.IsNull() && !data.Layer2Interface.L2sriovInterface.Device.IsUnknown() {
				l2sriov_interfaceNestedMap["device"] = data.Layer2Interface.L2sriovInterface.Device.ValueString()
			}
			if !data.Layer2Interface.L2sriovInterface.VLANID.IsNull() && !data.Layer2Interface.L2sriovInterface.VLANID.IsUnknown() {
				l2sriov_interfaceNestedMap["vlan_id"] = data.Layer2Interface.L2sriovInterface.VLANID.ValueInt64()
			}
			layer2_interfaceMap["l2sriov_interface"] = l2sriov_interfaceNestedMap
		}
		if data.Layer2Interface.L2vlanInterface != nil {
			l2vlan_interfaceNestedMap := make(map[string]interface{})
			if !data.Layer2Interface.L2vlanInterface.Device.IsNull() && !data.Layer2Interface.L2vlanInterface.Device.IsUnknown() {
				l2vlan_interfaceNestedMap["device"] = data.Layer2Interface.L2vlanInterface.Device.ValueString()
			}
			if !data.Layer2Interface.L2vlanInterface.VLANID.IsNull() && !data.Layer2Interface.L2vlanInterface.VLANID.IsUnknown() {
				l2vlan_interfaceNestedMap["vlan_id"] = data.Layer2Interface.L2vlanInterface.VLANID.ValueInt64()
			}
			layer2_interfaceMap["l2vlan_interface"] = l2vlan_interfaceNestedMap
		}
		if data.Layer2Interface.L2vlanSloInterface != nil {
			l2vlan_slo_interfaceNestedMap := make(map[string]interface{})
			if !data.Layer2Interface.L2vlanSloInterface.VLANID.IsNull() && !data.Layer2Interface.L2vlanSloInterface.VLANID.IsUnknown() {
				l2vlan_slo_interfaceNestedMap["vlan_id"] = data.Layer2Interface.L2vlanSloInterface.VLANID.ValueInt64()
			}
			layer2_interfaceMap["l2vlan_slo_interface"] = l2vlan_slo_interfaceNestedMap
		}
		apiResource.Spec["layer2_interface"] = layer2_interfaceMap
	}
	if data.TunnelInterface != nil {
		tunnel_interfaceMap := make(map[string]interface{})
		if !data.TunnelInterface.MTU.IsNull() && !data.TunnelInterface.MTU.IsUnknown() {
			tunnel_interfaceMap["mtu"] = data.TunnelInterface.MTU.ValueInt64()
		}
		if !data.TunnelInterface.Node.IsNull() && !data.TunnelInterface.Node.IsUnknown() {
			tunnel_interfaceMap["node"] = data.TunnelInterface.Node.ValueString()
		}
		if !data.TunnelInterface.Priority.IsNull() && !data.TunnelInterface.Priority.IsUnknown() {
			tunnel_interfaceMap["priority"] = data.TunnelInterface.Priority.ValueInt64()
		}
		if data.TunnelInterface.SiteLocalInsideNetwork != nil {
			tunnel_interfaceMap["site_local_inside_network"] = map[string]interface{}{}
		}
		if data.TunnelInterface.SiteLocalNetwork != nil {
			tunnel_interfaceMap["site_local_network"] = map[string]interface{}{}
		}
		if data.TunnelInterface.StaticIP != nil {
			static_ipNestedMap := make(map[string]interface{})
			tunnel_interfaceMap["static_ip"] = static_ipNestedMap
		}
		if data.TunnelInterface.Tunnel != nil {
			tunnelNestedMap := make(map[string]interface{})
			if !data.TunnelInterface.Tunnel.Name.IsNull() && !data.TunnelInterface.Tunnel.Name.IsUnknown() {
				tunnelNestedMap["name"] = data.TunnelInterface.Tunnel.Name.ValueString()
			}
			if !data.TunnelInterface.Tunnel.Namespace.IsNull() && !data.TunnelInterface.Tunnel.Namespace.IsUnknown() {
				tunnelNestedMap["namespace"] = data.TunnelInterface.Tunnel.Namespace.ValueString()
			}
			if !data.TunnelInterface.Tunnel.Tenant.IsNull() && !data.TunnelInterface.Tunnel.Tenant.IsUnknown() {
				tunnelNestedMap["tenant"] = data.TunnelInterface.Tunnel.Tenant.ValueString()
			}
			tunnel_interfaceMap["tunnel"] = tunnelNestedMap
		}
		apiResource.Spec["tunnel_interface"] = tunnel_interfaceMap
	}

	_, err := r.client.UpdateNetworkInterface(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update NetworkInterface: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetNetworkInterface(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read NetworkInterface after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["dedicated_interface"].(map[string]interface{}); ok && (isImport || data.DedicatedInterface != nil) {
		data.DedicatedInterface = &NetworkInterfaceDedicatedInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			IsPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.IsPrimary
				}
				// Import case: read from API
				if _, ok := blockData["is_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Monitor: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.Monitor
				}
				// Import case: read from API
				if _, ok := blockData["monitor"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MonitorDisabled: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.MonitorDisabled
				}
				// Import case: read from API
				if _, ok := blockData["monitor_disabled"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.DedicatedInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NotPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedInterface.NotPrimary
				}
				// Import case: read from API
				if _, ok := blockData["not_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.DedicatedInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["dedicated_management_interface"].(map[string]interface{}); ok && (isImport || data.DedicatedManagementInterface != nil) {
		data.DedicatedManagementInterface = &NetworkInterfaceDedicatedManagementInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.DedicatedManagementInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DedicatedManagementInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.DedicatedManagementInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DedicatedManagementInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["ethernet_interface"].(map[string]interface{}); ok && (isImport || data.EthernetInterface != nil) {
		data.EthernetInterface = &NetworkInterfaceEthernetInterfaceModel{
			Cluster: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Cluster
				}
				// Import case: read from API
				if _, ok := blockData["cluster"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Device: func() types.String {
				if v, ok := blockData["device"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DHCPClient: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.DHCPClient
				}
				// Import case: read from API
				if _, ok := blockData["dhcp_client"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			DHCPServer: func() *NetworkInterfaceEthernetInterfaceDHCPServerModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.DHCPServer != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.DHCPServer
				}
				// Import case: read from API
				if _, ok := blockData["dhcp_server"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceDHCPServerModel{}
				}
				return nil
			}(),
			Ipv6AutoConfig: func() *NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.Ipv6AutoConfig != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.Ipv6AutoConfig
				}
				// Import case: read from API
				if _, ok := blockData["ipv6_auto_config"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceIpv6AutoConfigModel{}
				}
				return nil
			}(),
			IsPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.IsPrimary
				}
				// Import case: read from API
				if _, ok := blockData["is_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Monitor: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Monitor
				}
				// Import case: read from API
				if _, ok := blockData["monitor"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MonitorDisabled: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.MonitorDisabled
				}
				// Import case: read from API
				if _, ok := blockData["monitor_disabled"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			MTU: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoIpv6Address: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.NoIpv6Address
				}
				// Import case: read from API
				if _, ok := blockData["no_ipv6_address"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NotPrimary: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.NotPrimary
				}
				// Import case: read from API
				if _, ok := blockData["not_primary"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SiteLocalInsideNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.SiteLocalInsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_inside_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			StaticIP: func() *NetworkInterfaceEthernetInterfaceStaticIPModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.StaticIP != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.StaticIP
				}
				// Import case: read from API
				if _, ok := blockData["static_ip"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceStaticIPModel{}
				}
				return nil
			}(),
			StaticIpv6Address: func() *NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel {
				if !isImport && data.EthernetInterface != nil && data.EthernetInterface.StaticIpv6Address != nil {
					// Normal Read: preserve existing state value
					return data.EthernetInterface.StaticIpv6Address
				}
				// Import case: read from API
				if _, ok := blockData["static_ipv6_address"].(map[string]interface{}); ok {
					return &NetworkInterfaceEthernetInterfaceStaticIpv6AddressModel{}
				}
				return nil
			}(),
			StorageNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.StorageNetwork
				}
				// Import case: read from API
				if _, ok := blockData["storage_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			Untagged: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.EthernetInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EthernetInterface.Untagged
				}
				// Import case: read from API
				if _, ok := blockData["untagged"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			VLANID: func() types.Int64 {
				if !isImport && data.EthernetInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.EthernetInterface.VLANID
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["vlan_id"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if _, ok := apiResource.Spec["layer2_interface"].(map[string]interface{}); ok && isImport && data.Layer2Interface == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Layer2Interface = &NetworkInterfaceLayer2InterfaceModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["tunnel_interface"].(map[string]interface{}); ok && (isImport || data.TunnelInterface != nil) {
		data.TunnelInterface = &NetworkInterfaceTunnelInterfaceModel{
			MTU: func() types.Int64 {
				if !isImport && data.TunnelInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.TunnelInterface.MTU
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["mtu"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Node: func() types.String {
				if v, ok := blockData["node"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Priority: func() types.Int64 {
				if !isImport && data.TunnelInterface != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.TunnelInterface.Priority
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["priority"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			SiteLocalInsideNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.TunnelInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TunnelInterface.SiteLocalInsideNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_inside_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			SiteLocalNetwork: func() *NetworkInterfaceEmptyModel {
				if !isImport && data.TunnelInterface != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TunnelInterface.SiteLocalNetwork
				}
				// Import case: read from API
				if _, ok := blockData["site_local_network"].(map[string]interface{}); ok {
					return &NetworkInterfaceEmptyModel{}
				}
				return nil
			}(),
			StaticIP: func() *NetworkInterfaceTunnelInterfaceStaticIPModel {
				if !isImport && data.TunnelInterface != nil && data.TunnelInterface.StaticIP != nil {
					// Normal Read: preserve existing state value
					return data.TunnelInterface.StaticIP
				}
				// Import case: read from API
				if _, ok := blockData["static_ip"].(map[string]interface{}); ok {
					return &NetworkInterfaceTunnelInterfaceStaticIPModel{}
				}
				return nil
			}(),
			Tunnel: func() *NetworkInterfaceTunnelInterfaceTunnelModel {
				if !isImport && data.TunnelInterface != nil && data.TunnelInterface.Tunnel != nil {
					// Normal Read: preserve existing state value
					return data.TunnelInterface.Tunnel
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["tunnel"].(map[string]interface{}); ok {
					return &NetworkInterfaceTunnelInterfaceTunnelModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NetworkInterfaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data NetworkInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteNetworkInterface(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "NetworkInterface already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "NetworkInterface delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete NetworkInterface: %s", err))
		return
	}
}

func (r *NetworkInterfaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
