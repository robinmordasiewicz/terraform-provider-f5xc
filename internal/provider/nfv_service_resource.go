// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &NfvServiceResource{}
	_ resource.ResourceWithConfigure      = &NfvServiceResource{}
	_ resource.ResourceWithImportState    = &NfvServiceResource{}
	_ resource.ResourceWithModifyPlan     = &NfvServiceResource{}
	_ resource.ResourceWithUpgradeState   = &NfvServiceResource{}
	_ resource.ResourceWithValidateConfig = &NfvServiceResource{}
)

// nfv_serviceSchemaVersion is the schema version for state upgrades
const nfv_serviceSchemaVersion int64 = 1

func NewNfvServiceResource() resource.Resource {
	return &NfvServiceResource{}
}

type NfvServiceResource struct {
	client *client.Client
}

// NfvServiceEmptyModel represents empty nested blocks
type NfvServiceEmptyModel struct {
}

// NfvServiceEnabledSSHAccessModel represents enabled_ssh_access block
type NfvServiceEnabledSSHAccessModel struct {
	DomainSuffix      types.String                                  `tfsdk:"domain_suffix"`
	AdvertiseOnSLI    *NfvServiceEmptyModel                         `tfsdk:"advertise_on_sli"`
	AdvertiseOnSlo    *NfvServiceEmptyModel                         `tfsdk:"advertise_on_slo"`
	AdvertiseOnSloSLI *NfvServiceEmptyModel                         `tfsdk:"advertise_on_slo_sli"`
	NodeSSHPorts      []NfvServiceEnabledSSHAccessNodeSSHPortsModel `tfsdk:"node_ssh_ports"`
}

// NfvServiceEnabledSSHAccessNodeSSHPortsModel represents node_ssh_ports block
type NfvServiceEnabledSSHAccessNodeSSHPortsModel struct {
	NodeName types.String `tfsdk:"node_name"`
	SSHPort  types.Int64  `tfsdk:"ssh_port"`
}

// NfvServiceF5BigIPAWSServiceModel represents f5_big_ip_aws_service block
type NfvServiceF5BigIPAWSServiceModel struct {
	AdminUsername    types.String                                      `tfsdk:"admin_username"`
	SSHKey           types.String                                      `tfsdk:"ssh_key"`
	AdminPassword    *NfvServiceF5BigIPAWSServiceAdminPasswordModel    `tfsdk:"admin_password"`
	AWSTGWSiteParams *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel `tfsdk:"aws_tgw_site_params"`
	EndpointService  *NfvServiceF5BigIPAWSServiceEndpointServiceModel  `tfsdk:"endpoint_service"`
	MarketPlaceImage *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel `tfsdk:"market_place_image"`
	Nodes            []NfvServiceF5BigIPAWSServiceNodesModel           `tfsdk:"nodes"`
	Tags             *NfvServiceEmptyModel                             `tfsdk:"tags"`
}

// NfvServiceF5BigIPAWSServiceAdminPasswordModel represents admin_password block
type NfvServiceF5BigIPAWSServiceAdminPasswordModel struct {
	BlindfoldSecretInfo *NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel represents clear_secret_info block
type NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel represents aws_tgw_site_params block
type NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel struct {
	AWSTGWSite *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel `tfsdk:"aws_tgw_site"`
}

// NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel represents aws_tgw_site block
type NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceF5BigIPAWSServiceEndpointServiceModel represents endpoint_service block
type NfvServiceF5BigIPAWSServiceEndpointServiceModel struct {
	ConfiguredVIP            types.String                                                   `tfsdk:"configured_vip"`
	AdvertiseOnSloIP         *NfvServiceEmptyModel                                          `tfsdk:"advertise_on_slo_ip"`
	AdvertiseOnSloIPExternal *NfvServiceEmptyModel                                          `tfsdk:"advertise_on_slo_ip_external"`
	AutomaticVIP             *NfvServiceEmptyModel                                          `tfsdk:"automatic_vip"`
	CustomTCPPorts           *NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel `tfsdk:"custom_tcp_ports"`
	CustomUDPPorts           *NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel `tfsdk:"custom_udp_ports"`
	DefaultTCPPorts          *NfvServiceEmptyModel                                          `tfsdk:"default_tcp_ports"`
	DisableAdvertiseOnSloIP  *NfvServiceEmptyModel                                          `tfsdk:"disable_advertise_on_slo_ip"`
	HTTPPort                 *NfvServiceEmptyModel                                          `tfsdk:"http_port"`
	HTTPSPort                *NfvServiceEmptyModel                                          `tfsdk:"https_port"`
	NoTCPPorts               *NfvServiceEmptyModel                                          `tfsdk:"no_tcp_ports"`
	NoUDPPorts               *NfvServiceEmptyModel                                          `tfsdk:"no_udp_ports"`
}

// NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel represents custom_tcp_ports block
type NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel represents custom_udp_ports block
type NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// NfvServiceF5BigIPAWSServiceMarketPlaceImageModel represents market_place_image block
type NfvServiceF5BigIPAWSServiceMarketPlaceImageModel struct {
	Awafpayg200mbps *NfvServiceEmptyModel `tfsdk:"awafpay_g200_mbps"`
	Awafpayg3gbps   *NfvServiceEmptyModel `tfsdk:"awafpay_g3_gbps"`
}

// NfvServiceF5BigIPAWSServiceNodesModel represents nodes block
type NfvServiceF5BigIPAWSServiceNodesModel struct {
	AWSAzName          types.String                                     `tfsdk:"aws_az_name"`
	NodeName           types.String                                     `tfsdk:"node_name"`
	TunnelPrefix       types.String                                     `tfsdk:"tunnel_prefix"`
	AutomaticPrefix    *NfvServiceEmptyModel                            `tfsdk:"automatic_prefix"`
	MgmtSubnet         *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel `tfsdk:"mgmt_subnet"`
	ReservedMgmtSubnet *NfvServiceEmptyModel                            `tfsdk:"reserved_mgmt_subnet"`
}

// NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel represents mgmt_subnet block
type NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel struct {
	ExistingSubnetID types.String                                                `tfsdk:"existing_subnet_id"`
	SubnetParam      *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel represents subnet_param block
type NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// NfvServiceHTTPSManagementModel represents https_management block
type NfvServiceHTTPSManagementModel struct {
	DomainSuffix                  types.String                                             `tfsdk:"domain_suffix"`
	HTTPSPort                     types.Int64                                              `tfsdk:"https_port"`
	AdvertiseOnInternet           *NfvServiceHTTPSManagementAdvertiseOnInternetModel       `tfsdk:"advertise_on_internet"`
	AdvertiseOnInternetDefaultVIP *NfvServiceEmptyModel                                    `tfsdk:"advertise_on_internet_default_vip"`
	AdvertiseOnSLIVIP             *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel         `tfsdk:"advertise_on_sli_vip"`
	AdvertiseOnSloInternetVIP     *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel `tfsdk:"advertise_on_slo_internet_vip"`
	AdvertiseOnSloSLI             *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel         `tfsdk:"advertise_on_slo_sli"`
	AdvertiseOnSloVIP             *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel         `tfsdk:"advertise_on_slo_vip"`
	DefaultHTTPSPort              *NfvServiceEmptyModel                                    `tfsdk:"default_https_port"`
}

// NfvServiceHTTPSManagementAdvertiseOnInternetModel represents advertise_on_internet block
type NfvServiceHTTPSManagementAdvertiseOnInternetModel struct {
	PublicIP *NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel `tfsdk:"public_ip"`
}

// NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel represents public_ip block
type NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel represents advertise_on_sli_vip block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel struct {
	NoMtls          *NfvServiceEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                        `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                        `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                   `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                         `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                       `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel represents advertise_on_slo_internet_vip block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel struct {
	NoMtls          *NfvServiceEmptyModel                                                    `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                                       `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                                       `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                           `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                           `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                           `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                               `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                                      `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                                      `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIModel represents advertise_on_slo_sli block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIModel struct {
	NoMtls          *NfvServiceEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel struct {
	CertificateURL       types.String                                                                        `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                        `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                   `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                         `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                       `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPModel represents advertise_on_slo_vip block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPModel struct {
	NoMtls          *NfvServiceEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                        `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                        `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                   `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                         `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                       `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServicePaloAltoFwServiceModel represents palo_alto_fw_service block
type NfvServicePaloAltoFwServiceModel struct {
	InstanceType    types.String                                    `tfsdk:"instance_type"`
	SSHKey          types.String                                    `tfsdk:"ssh_key"`
	Version         types.String                                    `tfsdk:"version"`
	AutoSetup       *NfvServicePaloAltoFwServiceAutoSetupModel      `tfsdk:"auto_setup"`
	AWSTGWSite      *NfvServicePaloAltoFwServiceAWSTGWSiteModel     `tfsdk:"aws_tgw_site"`
	DisablePanaroma *NfvServiceEmptyModel                           `tfsdk:"disable_panaroma"`
	PanAmiBundle1   *NfvServiceEmptyModel                           `tfsdk:"pan_ami_bundle1"`
	PanAmiBundle2   *NfvServiceEmptyModel                           `tfsdk:"pan_ami_bundle2"`
	PanoramaServer  *NfvServicePaloAltoFwServicePanoramaServerModel `tfsdk:"panorama_server"`
	ServiceNodes    *NfvServicePaloAltoFwServiceServiceNodesModel   `tfsdk:"service_nodes"`
	Tags            *NfvServiceEmptyModel                           `tfsdk:"tags"`
}

// NfvServicePaloAltoFwServiceAutoSetupModel represents auto_setup block
type NfvServicePaloAltoFwServiceAutoSetupModel struct {
	AdminUsername types.String                                            `tfsdk:"admin_username"`
	AdminPassword *NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel `tfsdk:"admin_password"`
	ManualSSHKeys *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel `tfsdk:"manual_ssh_keys"`
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel represents admin_password block
type NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel struct {
	BlindfoldSecretInfo *NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel represents clear_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel represents manual_ssh_keys block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel struct {
	PublicKey  types.String                                                      `tfsdk:"public_key"`
	PrivateKey *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel `tfsdk:"private_key"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel represents private_key block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServicePaloAltoFwServiceAWSTGWSiteModel represents aws_tgw_site block
type NfvServicePaloAltoFwServiceAWSTGWSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServicePaloAltoFwServicePanoramaServerModel represents panorama_server block
type NfvServicePaloAltoFwServicePanoramaServerModel struct {
	DeviceGroupName   types.String                                                    `tfsdk:"device_group_name"`
	Server            types.String                                                    `tfsdk:"server"`
	TemplateStackName types.String                                                    `tfsdk:"template_stack_name"`
	AuthorizationKey  *NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel `tfsdk:"authorization_key"`
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel represents authorization_key block
type NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel struct {
	BlindfoldSecretInfo *NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel represents clear_secret_info block
type NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServicePaloAltoFwServiceServiceNodesModel represents service_nodes block
type NfvServicePaloAltoFwServiceServiceNodesModel struct {
	Nodes []NfvServicePaloAltoFwServiceServiceNodesNodesModel `tfsdk:"nodes"`
}

// NfvServicePaloAltoFwServiceServiceNodesNodesModel represents nodes block
type NfvServicePaloAltoFwServiceServiceNodesNodesModel struct {
	AWSAzName          types.String                                                 `tfsdk:"aws_az_name"`
	NodeName           types.String                                                 `tfsdk:"node_name"`
	MgmtSubnet         *NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel `tfsdk:"mgmt_subnet"`
	ReservedMgmtSubnet *NfvServiceEmptyModel                                        `tfsdk:"reserved_mgmt_subnet"`
}

// NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel represents mgmt_subnet block
type NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel struct {
	ExistingSubnetID types.String                                                            `tfsdk:"existing_subnet_id"`
	SubnetParam      *NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel represents subnet_param block
type NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

type NfvServiceResourceModel struct {
	Name                   types.String                      `tfsdk:"name"`
	Namespace              types.String                      `tfsdk:"namespace"`
	Annotations            types.Map                         `tfsdk:"annotations"`
	Description            types.String                      `tfsdk:"description"`
	Disable                types.Bool                        `tfsdk:"disable"`
	Labels                 types.Map                         `tfsdk:"labels"`
	ID                     types.String                      `tfsdk:"id"`
	Timeouts               timeouts.Value                    `tfsdk:"timeouts"`
	DisableHTTPSManagement *NfvServiceEmptyModel             `tfsdk:"disable_https_management"`
	DisableSSHAccess       *NfvServiceEmptyModel             `tfsdk:"disable_ssh_access"`
	EnabledSSHAccess       *NfvServiceEnabledSSHAccessModel  `tfsdk:"enabled_ssh_access"`
	F5BigIPAWSService      *NfvServiceF5BigIPAWSServiceModel `tfsdk:"f5_big_ip_aws_service"`
	HTTPSManagement        *NfvServiceHTTPSManagementModel   `tfsdk:"https_management"`
	PaloAltoFwService      *NfvServicePaloAltoFwServiceModel `tfsdk:"palo_alto_fw_service"`
}

func (r *NfvServiceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_nfv_service"
}

func (r *NfvServiceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             nfv_serviceSchemaVersion,
		MarkdownDescription: "[Namespace: required] Manages new NFV service with configured parameters in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Nfv Service. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Nfv Service will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"disable_https_management": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_https_management, https_management; Default: disable_https_management] Empty. This can be used for messages where no values are needed",
			},
			"disable_ssh_access": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ssh_access, enabled_ssh_access; Default: disable_ssh_access] Empty. This can be used for messages where no values are needed",
			},
			"enabled_ssh_access": schema.SingleNestedBlock{
				MarkdownDescription: "SSH based management. SSH based configuration",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain Suffix. Domain suffix will be used along with node name to form the hostname for ssh node management",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"advertise_on_slo": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"node_ssh_ports": schema.ListNestedBlock{
						MarkdownDescription: "Management Node SSH Port. Enter TCP port and node name per node",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"node_name": schema.StringAttribute{
									MarkdownDescription: "Node Name. Node name will be used to match a particular node with the desired TCP port",
									Optional:            true,
								},
								"ssh_port": schema.Int64Attribute{
									MarkdownDescription: "SSH Port. Enter TCP port per node",
									Optional:            true,
								},
							},
						},
					},
				},
			},
			"f5_big_ip_aws_service": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: f5_big_ip_aws_service, palo_alto_fw_service] Virtual BIG-IP AWS. Virtual BIG-IP specification for AWS",
				Attributes: map[string]schema.Attribute{
					"admin_username": schema.StringAttribute{
						MarkdownDescription: "Admin Username. Admin Username for BIG-IP",
						Optional:            true,
					},
					"ssh_key": schema.StringAttribute{
						MarkdownDescription: "Public SSH key. Public SSH key for accessing the Big IP nodes.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"admin_password": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional:            true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional:            true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional:            true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional:            true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional:            true,
									},
								},
							},
						},
					},
					"aws_tgw_site_params": schema.SingleNestedBlock{
						MarkdownDescription: "BIG-IP AWS TGW Site. BIG-IP AWS TGW site specification",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"aws_tgw_site": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
									},
								},
							},
						},
					},
					"endpoint_service": schema.SingleNestedBlock{
						MarkdownDescription: "Endpoint Service. Endpoint Service is a type of NFV service where the packets are destined to NFV and service modifies the destination with a new destination address",
						Attributes: map[string]schema.Attribute{
							"configured_vip": schema.StringAttribute{
								MarkdownDescription: "Configured VIP. Enter IP address for the default VIP",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"advertise_on_slo_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"advertise_on_slo_ip_external": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"automatic_vip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"custom_tcp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Port Range List. List of port ranges",
								Attributes: map[string]schema.Attribute{
									"ports": schema.ListAttribute{
										MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"custom_udp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Port Range List. List of port ranges",
								Attributes: map[string]schema.Attribute{
									"ports": schema.ListAttribute{
										MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"default_tcp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"disable_advertise_on_slo_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_tcp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_udp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"market_place_image": schema.SingleNestedBlock{
						MarkdownDescription: "BIG-IP AWS Pay as You Go Image. BIG-IP AWS Pay as You Go Image Selection",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"awafpay_g200_mbps": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"awafpay_g3_gbps": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"nodes": schema.ListNestedBlock{
						MarkdownDescription: "Service Nodes. Specify how and where the service nodes are spawned",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS AZ Name. The AWS Availability Zone must be consistent with the AWS Region chosen. Please select an AZ in the same Region as your TGW Site",
									Optional:            true,
								},
								"node_name": schema.StringAttribute{
									MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
									Optional:            true,
								},
								"tunnel_prefix": schema.StringAttribute{
									MarkdownDescription: "Tunnel IP Prefix. Enter IP prefix for the tunnel, it has to be /30",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"automatic_prefix": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"mgmt_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional:            true,
												},
											},
										},
									},
								},
								"reserved_mgmt_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
					},
					"tags": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
					},
				},
			},
			"https_management": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS based management. HTTPS based configuration",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain Suffix. Domain suffix will be used along with node name to form URL to access node management",
						Optional:            true,
					},
					"https_port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS Port. Enter TCP port number",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_internet": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"public_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
									},
								},
							},
						},
					},
					"advertise_on_internet_default_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"advertise_on_sli_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"default_https_port": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},
			},
			"palo_alto_fw_service": schema.SingleNestedBlock{
				MarkdownDescription: "Palo Alto Networks VM-Series Firewall. Palo Alto Networks VM-Series next-generation firewall configuration",
				Attributes: map[string]schema.Attribute{
					"instance_type": schema.StringAttribute{
						MarkdownDescription: "[Enum: PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_12XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_8XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_9XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_18XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_9XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_18XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_R5_2XLARGE] Palo Alto Networks VM-Series Instance Typ. - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE: m4.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_2XLARGE: m4.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_4XLARGE: m4.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_LARGE: m5.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_XLARGE: m5.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_2XLARGE: m5.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_4XLARGE: m5.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_12XLARGE: m5.12xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_LARGE: m5n.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_XLARGE: m5n.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_2XLARGE: m5n.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_4XLARGE: m5n.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_LARGE: c4.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_XLARGE: c4.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_2XLARGE: c4.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_4XLARGE: c4.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_8XLARGE: c4.8xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_LARGE: c5.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_XLARGE: c5.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_2XLARGE: c5.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_4XLARGE: c5.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_9XLARGE: c5.9xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_18XLARGE: c5.18xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_LARGE: c5n.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_XLARGE: c5n.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_2XLARGE: c5n.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_4XLARGE: c5n.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_9XLARGE: c5n.9xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_18XLARGE: c5n.18xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_R5_2XLARGE: r5.2xlarge. Possible values are `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_12XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_8XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_9XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_18XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_9XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_18XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_R5_2XLARGE`. Defaults to `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE`.",
						Optional:            true,
					},
					"ssh_key": schema.StringAttribute{
						MarkdownDescription: "Setup Authorized Public SSH key. Setup Authorized Public SSH key. User will be able to ssh to the vmseries nodes using its corresponding ssh private key.",
						Optional:            true,
					},
					"version": schema.StringAttribute{
						MarkdownDescription: "PAN VM-Series version. PAN-OS version",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auto_setup": schema.SingleNestedBlock{
						MarkdownDescription: "PAN VM Series Firewall Auto Setup. For auto-setup, ssh public and pvt keys are needed. Using the given config user, ssh and api access will be configured",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Firewall Admin Username. Firewall Admin Username",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"manual_ssh_keys": schema.SingleNestedBlock{
								MarkdownDescription: "SSH key. SSH Key includes both public and private key",
								Attributes: map[string]schema.Attribute{
									"public_key": schema.StringAttribute{
										MarkdownDescription: "Public SSH key. Authorized Public SSH key which will be programmed on the node",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"private_key": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"aws_tgw_site": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
					"disable_panaroma": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"pan_ami_bundle1": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"pan_ami_bundle2": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"panorama_server": schema.SingleNestedBlock{
						MarkdownDescription: "Panorama Server Type. Panorama Server Type",
						Attributes: map[string]schema.Attribute{
							"device_group_name": schema.StringAttribute{
								MarkdownDescription: "Device Group Name. Device Group Name",
								Optional:            true,
							},
							"server": schema.StringAttribute{
								MarkdownDescription: "Server Ipv4 Address. Panorama Server Address to which the firewall should connect to",
								Optional:            true,
							},
							"template_stack_name": schema.StringAttribute{
								MarkdownDescription: "template stack name. Template Stack Name",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"authorization_key": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"service_nodes": schema.SingleNestedBlock{
						MarkdownDescription: "Palo Alto Networks Vm-Series AZ Nodes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Palo Alto Networks AZ Nodes.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"aws_az_name": schema.StringAttribute{
											MarkdownDescription: "AWS AZ Name. AWS availability zone, must be consistent with the selected AWS region. It is recommended that AZ is one of the AZ for sites",
											Optional:            true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
											Attributes: map[string]schema.Attribute{
												"existing_subnet_id": schema.StringAttribute{
													MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"subnet_param": schema.SingleNestedBlock{
													MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
													Attributes: map[string]schema.Attribute{
														"ipv4": schema.StringAttribute{
															MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
															Optional:            true,
														},
													},
												},
											},
										},
										"reserved_mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
							},
						},
					},
					"tags": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
					},
				},
			},
		},
	}
}

func (r *NfvServiceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *NfvServiceResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *NfvServiceResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the nfv_service from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan NfvServiceResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *NfvServiceResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := NfvServiceResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *NfvServiceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating nfv_service", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.NfvService{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.DisableHTTPSManagement != nil {
		disable_https_managementMap := make(map[string]interface{})
		createReq.Spec["disable_https_management"] = disable_https_managementMap
	}
	if data.DisableSSHAccess != nil {
		disable_ssh_accessMap := make(map[string]interface{})
		createReq.Spec["disable_ssh_access"] = disable_ssh_accessMap
	}
	if data.EnabledSSHAccess != nil {
		enabled_ssh_accessMap := make(map[string]interface{})
		if data.EnabledSSHAccess.AdvertiseOnSLI != nil {
			enabled_ssh_accessMap["advertise_on_sli"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSlo != nil {
			enabled_ssh_accessMap["advertise_on_slo"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSloSLI != nil {
			enabled_ssh_accessMap["advertise_on_slo_sli"] = map[string]interface{}{}
		}
		if !data.EnabledSSHAccess.DomainSuffix.IsNull() && !data.EnabledSSHAccess.DomainSuffix.IsUnknown() {
			enabled_ssh_accessMap["domain_suffix"] = data.EnabledSSHAccess.DomainSuffix.ValueString()
		}
		if len(data.EnabledSSHAccess.NodeSSHPorts) > 0 {
			var node_ssh_portsList []map[string]interface{}
			for _, listItem := range data.EnabledSSHAccess.NodeSSHPorts {
				listItemMap := make(map[string]interface{})
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if !listItem.SSHPort.IsNull() && !listItem.SSHPort.IsUnknown() {
					listItemMap["ssh_port"] = listItem.SSHPort.ValueInt64()
				}
				node_ssh_portsList = append(node_ssh_portsList, listItemMap)
			}
			enabled_ssh_accessMap["node_ssh_ports"] = node_ssh_portsList
		}
		createReq.Spec["enabled_ssh_access"] = enabled_ssh_accessMap
	}
	if data.F5BigIPAWSService != nil {
		f5_big_ip_aws_serviceMap := make(map[string]interface{})
		if data.F5BigIPAWSService.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["admin_password"] = admin_passwordNestedMap
		}
		if !data.F5BigIPAWSService.AdminUsername.IsNull() && !data.F5BigIPAWSService.AdminUsername.IsUnknown() {
			f5_big_ip_aws_serviceMap["admin_username"] = data.F5BigIPAWSService.AdminUsername.ValueString()
		}
		if data.F5BigIPAWSService.AWSTGWSiteParams != nil {
			aws_tgw_site_paramsNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["aws_tgw_site_params"] = aws_tgw_site_paramsNestedMap
		}
		if data.F5BigIPAWSService.EndpointService != nil {
			endpoint_serviceNestedMap := make(map[string]interface{})
			if !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsNull() && !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsUnknown() {
				endpoint_serviceNestedMap["configured_vip"] = data.F5BigIPAWSService.EndpointService.ConfiguredVIP.ValueString()
			}
			f5_big_ip_aws_serviceMap["endpoint_service"] = endpoint_serviceNestedMap
		}
		if data.F5BigIPAWSService.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["market_place_image"] = market_place_imageNestedMap
		}
		if len(data.F5BigIPAWSService.Nodes) > 0 {
			var nodesList []map[string]interface{}
			for _, listItem := range data.F5BigIPAWSService.Nodes {
				listItemMap := make(map[string]interface{})
				if listItem.AutomaticPrefix != nil {
					listItemMap["automatic_prefix"] = map[string]interface{}{}
				}
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.MgmtSubnet != nil {
					mgmt_subnetDeepMap := make(map[string]interface{})
					if !listItem.MgmtSubnet.ExistingSubnetID.IsNull() && !listItem.MgmtSubnet.ExistingSubnetID.IsUnknown() {
						mgmt_subnetDeepMap["existing_subnet_id"] = listItem.MgmtSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["mgmt_subnet"] = mgmt_subnetDeepMap
				}
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if listItem.ReservedMgmtSubnet != nil {
					listItemMap["reserved_mgmt_subnet"] = map[string]interface{}{}
				}
				if !listItem.TunnelPrefix.IsNull() && !listItem.TunnelPrefix.IsUnknown() {
					listItemMap["tunnel_prefix"] = listItem.TunnelPrefix.ValueString()
				}
				nodesList = append(nodesList, listItemMap)
			}
			f5_big_ip_aws_serviceMap["nodes"] = nodesList
		}
		if !data.F5BigIPAWSService.SSHKey.IsNull() && !data.F5BigIPAWSService.SSHKey.IsUnknown() {
			f5_big_ip_aws_serviceMap["ssh_key"] = data.F5BigIPAWSService.SSHKey.ValueString()
		}
		if data.F5BigIPAWSService.Tags != nil {
			f5_big_ip_aws_serviceMap["tags"] = map[string]interface{}{}
		}
		createReq.Spec["f5_big_ip_aws_service"] = f5_big_ip_aws_serviceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVIP != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloVIP != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		createReq.Spec["https_management"] = https_managementMap
	}
	if data.PaloAltoFwService != nil {
		palo_alto_fw_serviceMap := make(map[string]interface{})
		if data.PaloAltoFwService.AutoSetup != nil {
			auto_setupNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AutoSetup.AdminUsername.IsNull() && !data.PaloAltoFwService.AutoSetup.AdminUsername.IsUnknown() {
				auto_setupNestedMap["admin_username"] = data.PaloAltoFwService.AutoSetup.AdminUsername.ValueString()
			}
			palo_alto_fw_serviceMap["auto_setup"] = auto_setupNestedMap
		}
		if data.PaloAltoFwService.AWSTGWSite != nil {
			aws_tgw_siteNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AWSTGWSite.Name.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Name.IsUnknown() {
				aws_tgw_siteNestedMap["name"] = data.PaloAltoFwService.AWSTGWSite.Name.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Namespace.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Namespace.IsUnknown() {
				aws_tgw_siteNestedMap["namespace"] = data.PaloAltoFwService.AWSTGWSite.Namespace.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Tenant.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Tenant.IsUnknown() {
				aws_tgw_siteNestedMap["tenant"] = data.PaloAltoFwService.AWSTGWSite.Tenant.ValueString()
			}
			palo_alto_fw_serviceMap["aws_tgw_site"] = aws_tgw_siteNestedMap
		}
		if data.PaloAltoFwService.DisablePanaroma != nil {
			palo_alto_fw_serviceMap["disable_panaroma"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.InstanceType.IsNull() && !data.PaloAltoFwService.InstanceType.IsUnknown() {
			palo_alto_fw_serviceMap["instance_type"] = data.PaloAltoFwService.InstanceType.ValueString()
		}
		if data.PaloAltoFwService.PanAmiBundle1 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle1"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanAmiBundle2 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle2"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanoramaServer != nil {
			panorama_serverNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsNull() && !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsUnknown() {
				panorama_serverNestedMap["device_group_name"] = data.PaloAltoFwService.PanoramaServer.DeviceGroupName.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.Server.IsNull() && !data.PaloAltoFwService.PanoramaServer.Server.IsUnknown() {
				panorama_serverNestedMap["server"] = data.PaloAltoFwService.PanoramaServer.Server.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsNull() && !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsUnknown() {
				panorama_serverNestedMap["template_stack_name"] = data.PaloAltoFwService.PanoramaServer.TemplateStackName.ValueString()
			}
			palo_alto_fw_serviceMap["panorama_server"] = panorama_serverNestedMap
		}
		if data.PaloAltoFwService.ServiceNodes != nil {
			service_nodesNestedMap := make(map[string]interface{})
			palo_alto_fw_serviceMap["service_nodes"] = service_nodesNestedMap
		}
		if !data.PaloAltoFwService.SSHKey.IsNull() && !data.PaloAltoFwService.SSHKey.IsUnknown() {
			palo_alto_fw_serviceMap["ssh_key"] = data.PaloAltoFwService.SSHKey.ValueString()
		}
		if data.PaloAltoFwService.Tags != nil {
			palo_alto_fw_serviceMap["tags"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.Version.IsNull() && !data.PaloAltoFwService.Version.IsUnknown() {
			palo_alto_fw_serviceMap["version"] = data.PaloAltoFwService.Version.ValueString()
		}
		createReq.Spec["palo_alto_fw_service"] = palo_alto_fw_serviceMap
	}

	apiResource, err := r.client.CreateNfvService(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create NfvService: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["disable_https_management"].(map[string]interface{}); ok && isImport && data.DisableHTTPSManagement == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHTTPSManagement = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ssh_access"].(map[string]interface{}); ok && isImport && data.DisableSSHAccess == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableSSHAccess = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enabled_ssh_access"].(map[string]interface{}); ok && (isImport || data.EnabledSSHAccess != nil) {
		data.EnabledSSHAccess = &NfvServiceEnabledSSHAccessModel{
			AdvertiseOnSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSlo: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSlo
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeSSHPorts: func() []NfvServiceEnabledSSHAccessNodeSSHPortsModel {
				if listData, ok := blockData["node_ssh_ports"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceEnabledSSHAccessNodeSSHPortsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceEnabledSSHAccessNodeSSHPortsModel{
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSHPort: func() types.Int64 {
									if v, ok := itemMap["ssh_port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["f5_big_ip_aws_service"].(map[string]interface{}); ok && (isImport || data.F5BigIPAWSService != nil) {
		data.F5BigIPAWSService = &NfvServiceF5BigIPAWSServiceModel{
			AdminPassword: func() *NfvServiceF5BigIPAWSServiceAdminPasswordModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAdminPasswordModel{}
				}
				return nil
			}(),
			AdminUsername: func() types.String {
				if v, ok := blockData["admin_username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AWSTGWSiteParams: func() *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AWSTGWSiteParams != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AWSTGWSiteParams
				}
				// Import case: read from API
				if _, ok := blockData["aws_tgw_site_params"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel{}
				}
				return nil
			}(),
			EndpointService: func() *NfvServiceF5BigIPAWSServiceEndpointServiceModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.EndpointService != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.EndpointService
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["endpoint_service"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceEndpointServiceModel{
						ConfiguredVIP: func() types.String {
							if v, ok := nestedBlockData["configured_vip"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MarketPlaceImage: func() *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.MarketPlaceImage != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.MarketPlaceImage
				}
				// Import case: read from API
				if _, ok := blockData["market_place_image"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceMarketPlaceImageModel{}
				}
				return nil
			}(),
			Nodes: func() []NfvServiceF5BigIPAWSServiceNodesModel {
				if listData, ok := blockData["nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceF5BigIPAWSServiceNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceF5BigIPAWSServiceNodesModel{
								AutomaticPrefix: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["automatic_prefix"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								MgmtSubnet: func() *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel {
									if deepMap, ok := itemMap["mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReservedMgmtSubnet: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["reserved_mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								TunnelPrefix: func() types.String {
									if v, ok := itemMap["tunnel_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.F5BigIPAWSService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.F5BigIPAWSService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &NfvServiceHTTPSManagementModel{
			AdvertiseOnInternet: func() *NfvServiceHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["palo_alto_fw_service"].(map[string]interface{}); ok && (isImport || data.PaloAltoFwService != nil) {
		data.PaloAltoFwService = &NfvServicePaloAltoFwServiceModel{
			AutoSetup: func() *NfvServicePaloAltoFwServiceAutoSetupModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AutoSetup != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AutoSetup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auto_setup"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAutoSetupModel{
						AdminUsername: func() types.String {
							if v, ok := nestedBlockData["admin_username"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSTGWSite: func() *NfvServicePaloAltoFwServiceAWSTGWSiteModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AWSTGWSite != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AWSTGWSite
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_tgw_site"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAWSTGWSiteModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisablePanaroma: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.DisablePanaroma
				}
				// Import case: read from API
				if _, ok := blockData["disable_panaroma"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PanAmiBundle1: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle1
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle1"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanAmiBundle2: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle2
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle2"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanoramaServer: func() *NfvServicePaloAltoFwServicePanoramaServerModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.PanoramaServer != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.PanoramaServer
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["panorama_server"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServicePanoramaServerModel{
						DeviceGroupName: func() types.String {
							if v, ok := nestedBlockData["device_group_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Server: func() types.String {
							if v, ok := nestedBlockData["server"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TemplateStackName: func() types.String {
							if v, ok := nestedBlockData["template_stack_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ServiceNodes: func() *NfvServicePaloAltoFwServiceServiceNodesModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.ServiceNodes != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.ServiceNodes
				}
				// Import case: read from API
				if _, ok := blockData["service_nodes"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceServiceNodesModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			Version: func() types.String {
				if v, ok := blockData["version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created NfvService resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NfvServiceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetNfvService(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "NfvService not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read NfvService: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The nfv_service may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["disable_https_management"].(map[string]interface{}); ok && isImport && data.DisableHTTPSManagement == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHTTPSManagement = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ssh_access"].(map[string]interface{}); ok && isImport && data.DisableSSHAccess == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableSSHAccess = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enabled_ssh_access"].(map[string]interface{}); ok && (isImport || data.EnabledSSHAccess != nil) {
		data.EnabledSSHAccess = &NfvServiceEnabledSSHAccessModel{
			AdvertiseOnSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSlo: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSlo
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeSSHPorts: func() []NfvServiceEnabledSSHAccessNodeSSHPortsModel {
				if listData, ok := blockData["node_ssh_ports"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceEnabledSSHAccessNodeSSHPortsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceEnabledSSHAccessNodeSSHPortsModel{
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSHPort: func() types.Int64 {
									if v, ok := itemMap["ssh_port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["f5_big_ip_aws_service"].(map[string]interface{}); ok && (isImport || data.F5BigIPAWSService != nil) {
		data.F5BigIPAWSService = &NfvServiceF5BigIPAWSServiceModel{
			AdminPassword: func() *NfvServiceF5BigIPAWSServiceAdminPasswordModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAdminPasswordModel{}
				}
				return nil
			}(),
			AdminUsername: func() types.String {
				if v, ok := blockData["admin_username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AWSTGWSiteParams: func() *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AWSTGWSiteParams != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AWSTGWSiteParams
				}
				// Import case: read from API
				if _, ok := blockData["aws_tgw_site_params"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel{}
				}
				return nil
			}(),
			EndpointService: func() *NfvServiceF5BigIPAWSServiceEndpointServiceModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.EndpointService != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.EndpointService
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["endpoint_service"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceEndpointServiceModel{
						ConfiguredVIP: func() types.String {
							if v, ok := nestedBlockData["configured_vip"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MarketPlaceImage: func() *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.MarketPlaceImage != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.MarketPlaceImage
				}
				// Import case: read from API
				if _, ok := blockData["market_place_image"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceMarketPlaceImageModel{}
				}
				return nil
			}(),
			Nodes: func() []NfvServiceF5BigIPAWSServiceNodesModel {
				if listData, ok := blockData["nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceF5BigIPAWSServiceNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceF5BigIPAWSServiceNodesModel{
								AutomaticPrefix: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["automatic_prefix"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								MgmtSubnet: func() *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel {
									if deepMap, ok := itemMap["mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReservedMgmtSubnet: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["reserved_mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								TunnelPrefix: func() types.String {
									if v, ok := itemMap["tunnel_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.F5BigIPAWSService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.F5BigIPAWSService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &NfvServiceHTTPSManagementModel{
			AdvertiseOnInternet: func() *NfvServiceHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["palo_alto_fw_service"].(map[string]interface{}); ok && (isImport || data.PaloAltoFwService != nil) {
		data.PaloAltoFwService = &NfvServicePaloAltoFwServiceModel{
			AutoSetup: func() *NfvServicePaloAltoFwServiceAutoSetupModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AutoSetup != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AutoSetup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auto_setup"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAutoSetupModel{
						AdminUsername: func() types.String {
							if v, ok := nestedBlockData["admin_username"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSTGWSite: func() *NfvServicePaloAltoFwServiceAWSTGWSiteModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AWSTGWSite != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AWSTGWSite
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_tgw_site"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAWSTGWSiteModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisablePanaroma: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.DisablePanaroma
				}
				// Import case: read from API
				if _, ok := blockData["disable_panaroma"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PanAmiBundle1: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle1
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle1"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanAmiBundle2: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle2
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle2"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanoramaServer: func() *NfvServicePaloAltoFwServicePanoramaServerModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.PanoramaServer != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.PanoramaServer
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["panorama_server"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServicePanoramaServerModel{
						DeviceGroupName: func() types.String {
							if v, ok := nestedBlockData["device_group_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Server: func() types.String {
							if v, ok := nestedBlockData["server"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TemplateStackName: func() types.String {
							if v, ok := nestedBlockData["template_stack_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ServiceNodes: func() *NfvServicePaloAltoFwServiceServiceNodesModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.ServiceNodes != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.ServiceNodes
				}
				// Import case: read from API
				if _, ok := blockData["service_nodes"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceServiceNodesModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			Version: func() types.String {
				if v, ok := blockData["version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NfvServiceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.NfvService{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.DisableHTTPSManagement != nil {
		disable_https_managementMap := make(map[string]interface{})
		apiResource.Spec["disable_https_management"] = disable_https_managementMap
	}
	if data.DisableSSHAccess != nil {
		disable_ssh_accessMap := make(map[string]interface{})
		apiResource.Spec["disable_ssh_access"] = disable_ssh_accessMap
	}
	if data.EnabledSSHAccess != nil {
		enabled_ssh_accessMap := make(map[string]interface{})
		if data.EnabledSSHAccess.AdvertiseOnSLI != nil {
			enabled_ssh_accessMap["advertise_on_sli"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSlo != nil {
			enabled_ssh_accessMap["advertise_on_slo"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSloSLI != nil {
			enabled_ssh_accessMap["advertise_on_slo_sli"] = map[string]interface{}{}
		}
		if !data.EnabledSSHAccess.DomainSuffix.IsNull() && !data.EnabledSSHAccess.DomainSuffix.IsUnknown() {
			enabled_ssh_accessMap["domain_suffix"] = data.EnabledSSHAccess.DomainSuffix.ValueString()
		}
		if len(data.EnabledSSHAccess.NodeSSHPorts) > 0 {
			var node_ssh_portsList []map[string]interface{}
			for _, listItem := range data.EnabledSSHAccess.NodeSSHPorts {
				listItemMap := make(map[string]interface{})
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if !listItem.SSHPort.IsNull() && !listItem.SSHPort.IsUnknown() {
					listItemMap["ssh_port"] = listItem.SSHPort.ValueInt64()
				}
				node_ssh_portsList = append(node_ssh_portsList, listItemMap)
			}
			enabled_ssh_accessMap["node_ssh_ports"] = node_ssh_portsList
		}
		apiResource.Spec["enabled_ssh_access"] = enabled_ssh_accessMap
	}
	if data.F5BigIPAWSService != nil {
		f5_big_ip_aws_serviceMap := make(map[string]interface{})
		if data.F5BigIPAWSService.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["admin_password"] = admin_passwordNestedMap
		}
		if !data.F5BigIPAWSService.AdminUsername.IsNull() && !data.F5BigIPAWSService.AdminUsername.IsUnknown() {
			f5_big_ip_aws_serviceMap["admin_username"] = data.F5BigIPAWSService.AdminUsername.ValueString()
		}
		if data.F5BigIPAWSService.AWSTGWSiteParams != nil {
			aws_tgw_site_paramsNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["aws_tgw_site_params"] = aws_tgw_site_paramsNestedMap
		}
		if data.F5BigIPAWSService.EndpointService != nil {
			endpoint_serviceNestedMap := make(map[string]interface{})
			if !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsNull() && !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsUnknown() {
				endpoint_serviceNestedMap["configured_vip"] = data.F5BigIPAWSService.EndpointService.ConfiguredVIP.ValueString()
			}
			f5_big_ip_aws_serviceMap["endpoint_service"] = endpoint_serviceNestedMap
		}
		if data.F5BigIPAWSService.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["market_place_image"] = market_place_imageNestedMap
		}
		if len(data.F5BigIPAWSService.Nodes) > 0 {
			var nodesList []map[string]interface{}
			for _, listItem := range data.F5BigIPAWSService.Nodes {
				listItemMap := make(map[string]interface{})
				if listItem.AutomaticPrefix != nil {
					listItemMap["automatic_prefix"] = map[string]interface{}{}
				}
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.MgmtSubnet != nil {
					mgmt_subnetDeepMap := make(map[string]interface{})
					if !listItem.MgmtSubnet.ExistingSubnetID.IsNull() && !listItem.MgmtSubnet.ExistingSubnetID.IsUnknown() {
						mgmt_subnetDeepMap["existing_subnet_id"] = listItem.MgmtSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["mgmt_subnet"] = mgmt_subnetDeepMap
				}
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if listItem.ReservedMgmtSubnet != nil {
					listItemMap["reserved_mgmt_subnet"] = map[string]interface{}{}
				}
				if !listItem.TunnelPrefix.IsNull() && !listItem.TunnelPrefix.IsUnknown() {
					listItemMap["tunnel_prefix"] = listItem.TunnelPrefix.ValueString()
				}
				nodesList = append(nodesList, listItemMap)
			}
			f5_big_ip_aws_serviceMap["nodes"] = nodesList
		}
		if !data.F5BigIPAWSService.SSHKey.IsNull() && !data.F5BigIPAWSService.SSHKey.IsUnknown() {
			f5_big_ip_aws_serviceMap["ssh_key"] = data.F5BigIPAWSService.SSHKey.ValueString()
		}
		if data.F5BigIPAWSService.Tags != nil {
			f5_big_ip_aws_serviceMap["tags"] = map[string]interface{}{}
		}
		apiResource.Spec["f5_big_ip_aws_service"] = f5_big_ip_aws_serviceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVIP != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloVIP != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		apiResource.Spec["https_management"] = https_managementMap
	}
	if data.PaloAltoFwService != nil {
		palo_alto_fw_serviceMap := make(map[string]interface{})
		if data.PaloAltoFwService.AutoSetup != nil {
			auto_setupNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AutoSetup.AdminUsername.IsNull() && !data.PaloAltoFwService.AutoSetup.AdminUsername.IsUnknown() {
				auto_setupNestedMap["admin_username"] = data.PaloAltoFwService.AutoSetup.AdminUsername.ValueString()
			}
			palo_alto_fw_serviceMap["auto_setup"] = auto_setupNestedMap
		}
		if data.PaloAltoFwService.AWSTGWSite != nil {
			aws_tgw_siteNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AWSTGWSite.Name.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Name.IsUnknown() {
				aws_tgw_siteNestedMap["name"] = data.PaloAltoFwService.AWSTGWSite.Name.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Namespace.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Namespace.IsUnknown() {
				aws_tgw_siteNestedMap["namespace"] = data.PaloAltoFwService.AWSTGWSite.Namespace.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Tenant.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Tenant.IsUnknown() {
				aws_tgw_siteNestedMap["tenant"] = data.PaloAltoFwService.AWSTGWSite.Tenant.ValueString()
			}
			palo_alto_fw_serviceMap["aws_tgw_site"] = aws_tgw_siteNestedMap
		}
		if data.PaloAltoFwService.DisablePanaroma != nil {
			palo_alto_fw_serviceMap["disable_panaroma"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.InstanceType.IsNull() && !data.PaloAltoFwService.InstanceType.IsUnknown() {
			palo_alto_fw_serviceMap["instance_type"] = data.PaloAltoFwService.InstanceType.ValueString()
		}
		if data.PaloAltoFwService.PanAmiBundle1 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle1"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanAmiBundle2 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle2"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanoramaServer != nil {
			panorama_serverNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsNull() && !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsUnknown() {
				panorama_serverNestedMap["device_group_name"] = data.PaloAltoFwService.PanoramaServer.DeviceGroupName.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.Server.IsNull() && !data.PaloAltoFwService.PanoramaServer.Server.IsUnknown() {
				panorama_serverNestedMap["server"] = data.PaloAltoFwService.PanoramaServer.Server.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsNull() && !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsUnknown() {
				panorama_serverNestedMap["template_stack_name"] = data.PaloAltoFwService.PanoramaServer.TemplateStackName.ValueString()
			}
			palo_alto_fw_serviceMap["panorama_server"] = panorama_serverNestedMap
		}
		if data.PaloAltoFwService.ServiceNodes != nil {
			service_nodesNestedMap := make(map[string]interface{})
			palo_alto_fw_serviceMap["service_nodes"] = service_nodesNestedMap
		}
		if !data.PaloAltoFwService.SSHKey.IsNull() && !data.PaloAltoFwService.SSHKey.IsUnknown() {
			palo_alto_fw_serviceMap["ssh_key"] = data.PaloAltoFwService.SSHKey.ValueString()
		}
		if data.PaloAltoFwService.Tags != nil {
			palo_alto_fw_serviceMap["tags"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.Version.IsNull() && !data.PaloAltoFwService.Version.IsUnknown() {
			palo_alto_fw_serviceMap["version"] = data.PaloAltoFwService.Version.ValueString()
		}
		apiResource.Spec["palo_alto_fw_service"] = palo_alto_fw_serviceMap
	}

	_, err := r.client.UpdateNfvService(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update NfvService: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetNfvService(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read NfvService after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["disable_https_management"].(map[string]interface{}); ok && isImport && data.DisableHTTPSManagement == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHTTPSManagement = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ssh_access"].(map[string]interface{}); ok && isImport && data.DisableSSHAccess == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableSSHAccess = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enabled_ssh_access"].(map[string]interface{}); ok && (isImport || data.EnabledSSHAccess != nil) {
		data.EnabledSSHAccess = &NfvServiceEnabledSSHAccessModel{
			AdvertiseOnSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSlo: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSlo
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeSSHPorts: func() []NfvServiceEnabledSSHAccessNodeSSHPortsModel {
				if listData, ok := blockData["node_ssh_ports"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceEnabledSSHAccessNodeSSHPortsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceEnabledSSHAccessNodeSSHPortsModel{
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSHPort: func() types.Int64 {
									if v, ok := itemMap["ssh_port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["f5_big_ip_aws_service"].(map[string]interface{}); ok && (isImport || data.F5BigIPAWSService != nil) {
		data.F5BigIPAWSService = &NfvServiceF5BigIPAWSServiceModel{
			AdminPassword: func() *NfvServiceF5BigIPAWSServiceAdminPasswordModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAdminPasswordModel{}
				}
				return nil
			}(),
			AdminUsername: func() types.String {
				if v, ok := blockData["admin_username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AWSTGWSiteParams: func() *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AWSTGWSiteParams != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AWSTGWSiteParams
				}
				// Import case: read from API
				if _, ok := blockData["aws_tgw_site_params"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel{}
				}
				return nil
			}(),
			EndpointService: func() *NfvServiceF5BigIPAWSServiceEndpointServiceModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.EndpointService != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.EndpointService
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["endpoint_service"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceEndpointServiceModel{
						ConfiguredVIP: func() types.String {
							if v, ok := nestedBlockData["configured_vip"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MarketPlaceImage: func() *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.MarketPlaceImage != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.MarketPlaceImage
				}
				// Import case: read from API
				if _, ok := blockData["market_place_image"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceMarketPlaceImageModel{}
				}
				return nil
			}(),
			Nodes: func() []NfvServiceF5BigIPAWSServiceNodesModel {
				if listData, ok := blockData["nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceF5BigIPAWSServiceNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceF5BigIPAWSServiceNodesModel{
								AutomaticPrefix: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["automatic_prefix"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								MgmtSubnet: func() *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel {
									if deepMap, ok := itemMap["mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReservedMgmtSubnet: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["reserved_mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								TunnelPrefix: func() types.String {
									if v, ok := itemMap["tunnel_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.F5BigIPAWSService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.F5BigIPAWSService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &NfvServiceHTTPSManagementModel{
			AdvertiseOnInternet: func() *NfvServiceHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["palo_alto_fw_service"].(map[string]interface{}); ok && (isImport || data.PaloAltoFwService != nil) {
		data.PaloAltoFwService = &NfvServicePaloAltoFwServiceModel{
			AutoSetup: func() *NfvServicePaloAltoFwServiceAutoSetupModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AutoSetup != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AutoSetup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auto_setup"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAutoSetupModel{
						AdminUsername: func() types.String {
							if v, ok := nestedBlockData["admin_username"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSTGWSite: func() *NfvServicePaloAltoFwServiceAWSTGWSiteModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AWSTGWSite != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AWSTGWSite
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_tgw_site"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAWSTGWSiteModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisablePanaroma: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.DisablePanaroma
				}
				// Import case: read from API
				if _, ok := blockData["disable_panaroma"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PanAmiBundle1: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle1
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle1"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanAmiBundle2: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle2
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle2"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanoramaServer: func() *NfvServicePaloAltoFwServicePanoramaServerModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.PanoramaServer != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.PanoramaServer
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["panorama_server"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServicePanoramaServerModel{
						DeviceGroupName: func() types.String {
							if v, ok := nestedBlockData["device_group_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Server: func() types.String {
							if v, ok := nestedBlockData["server"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TemplateStackName: func() types.String {
							if v, ok := nestedBlockData["template_stack_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ServiceNodes: func() *NfvServicePaloAltoFwServiceServiceNodesModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.ServiceNodes != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.ServiceNodes
				}
				// Import case: read from API
				if _, ok := blockData["service_nodes"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceServiceNodesModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			Version: func() types.String {
				if v, ok := blockData["version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NfvServiceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteNfvService(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "NfvService already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "NfvService delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete NfvService: %s", err))
		return
	}
}

func (r *NfvServiceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
