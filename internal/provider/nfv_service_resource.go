// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &NfvServiceResource{}
	_ resource.ResourceWithConfigure      = &NfvServiceResource{}
	_ resource.ResourceWithImportState    = &NfvServiceResource{}
	_ resource.ResourceWithModifyPlan     = &NfvServiceResource{}
	_ resource.ResourceWithUpgradeState   = &NfvServiceResource{}
	_ resource.ResourceWithValidateConfig = &NfvServiceResource{}
)

// nfv_serviceSchemaVersion is the schema version for state upgrades
const nfv_serviceSchemaVersion int64 = 1

func NewNfvServiceResource() resource.Resource {
	return &NfvServiceResource{}
}

type NfvServiceResource struct {
	client *client.Client
}

// NfvServiceEmptyModel represents empty nested blocks
type NfvServiceEmptyModel struct {
}

// NfvServiceEnabledSSHAccessModel represents enabled_ssh_access block
type NfvServiceEnabledSSHAccessModel struct {
	DomainSuffix      types.String                                  `tfsdk:"domain_suffix"`
	AdvertiseOnSLI    *NfvServiceEmptyModel                         `tfsdk:"advertise_on_sli"`
	AdvertiseOnSlo    *NfvServiceEmptyModel                         `tfsdk:"advertise_on_slo"`
	AdvertiseOnSloSLI *NfvServiceEmptyModel                         `tfsdk:"advertise_on_slo_sli"`
	NodeSSHPorts      []NfvServiceEnabledSSHAccessNodeSSHPortsModel `tfsdk:"node_ssh_ports"`
}

// NfvServiceEnabledSSHAccessModelAttrTypes defines the attribute types for NfvServiceEnabledSSHAccessModel
var NfvServiceEnabledSSHAccessModelAttrTypes = map[string]attr.Type{
	"domain_suffix":        types.StringType,
	"advertise_on_sli":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo_sli": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"node_ssh_ports":       types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServiceEnabledSSHAccessNodeSSHPortsModelAttrTypes}},
}

// NfvServiceEnabledSSHAccessNodeSSHPortsModel represents node_ssh_ports block
type NfvServiceEnabledSSHAccessNodeSSHPortsModel struct {
	NodeName types.String `tfsdk:"node_name"`
	SSHPort  types.Int64  `tfsdk:"ssh_port"`
}

// NfvServiceEnabledSSHAccessNodeSSHPortsModelAttrTypes defines the attribute types for NfvServiceEnabledSSHAccessNodeSSHPortsModel
var NfvServiceEnabledSSHAccessNodeSSHPortsModelAttrTypes = map[string]attr.Type{
	"node_name": types.StringType,
	"ssh_port":  types.Int64Type,
}

// NfvServiceF5BigIPAWSServiceModel represents f5_big_ip_aws_service block
type NfvServiceF5BigIPAWSServiceModel struct {
	AdminUsername    types.String                                      `tfsdk:"admin_username"`
	SSHKey           types.String                                      `tfsdk:"ssh_key"`
	AdminPassword    *NfvServiceF5BigIPAWSServiceAdminPasswordModel    `tfsdk:"admin_password"`
	AWSTGWSiteParams *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel `tfsdk:"aws_tgw_site_params"`
	EndpointService  *NfvServiceF5BigIPAWSServiceEndpointServiceModel  `tfsdk:"endpoint_service"`
	MarketPlaceImage *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel `tfsdk:"market_place_image"`
	Nodes            []NfvServiceF5BigIPAWSServiceNodesModel           `tfsdk:"nodes"`
	Tags             *NfvServiceEmptyModel                             `tfsdk:"tags"`
}

// NfvServiceF5BigIPAWSServiceModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceModel
var NfvServiceF5BigIPAWSServiceModelAttrTypes = map[string]attr.Type{
	"admin_username":      types.StringType,
	"ssh_key":             types.StringType,
	"admin_password":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"aws_tgw_site_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"endpoint_service":    types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceEndpointServiceModelAttrTypes},
	"market_place_image":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nodes":               types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceNodesModelAttrTypes}},
	"tags":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceF5BigIPAWSServiceAdminPasswordModel represents admin_password block
type NfvServiceF5BigIPAWSServiceAdminPasswordModel struct {
	BlindfoldSecretInfo *NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceF5BigIPAWSServiceAdminPasswordModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceAdminPasswordModel
var NfvServiceF5BigIPAWSServiceAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModelAttrTypes},
}

// NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModel
var NfvServiceF5BigIPAWSServiceAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel represents clear_secret_info block
type NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModel
var NfvServiceF5BigIPAWSServiceAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel represents aws_tgw_site_params block
type NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel struct {
	AWSTGWSite *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel `tfsdk:"aws_tgw_site"`
}

// NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel
var NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModelAttrTypes = map[string]attr.Type{
	"aws_tgw_site": types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModelAttrTypes},
}

// NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel represents aws_tgw_site block
type NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModel
var NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsAWSTGWSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceF5BigIPAWSServiceEndpointServiceModel represents endpoint_service block
type NfvServiceF5BigIPAWSServiceEndpointServiceModel struct {
	ConfiguredVIP            types.String                                                   `tfsdk:"configured_vip"`
	AdvertiseOnSloIP         *NfvServiceEmptyModel                                          `tfsdk:"advertise_on_slo_ip"`
	AdvertiseOnSloIPExternal *NfvServiceEmptyModel                                          `tfsdk:"advertise_on_slo_ip_external"`
	AutomaticVIP             *NfvServiceEmptyModel                                          `tfsdk:"automatic_vip"`
	CustomTCPPorts           *NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel `tfsdk:"custom_tcp_ports"`
	CustomUDPPorts           *NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel `tfsdk:"custom_udp_ports"`
	DefaultTCPPorts          *NfvServiceEmptyModel                                          `tfsdk:"default_tcp_ports"`
	DisableAdvertiseOnSloIP  *NfvServiceEmptyModel                                          `tfsdk:"disable_advertise_on_slo_ip"`
	HTTPPort                 *NfvServiceEmptyModel                                          `tfsdk:"http_port"`
	HTTPSPort                *NfvServiceEmptyModel                                          `tfsdk:"https_port"`
	NoTCPPorts               *NfvServiceEmptyModel                                          `tfsdk:"no_tcp_ports"`
	NoUDPPorts               *NfvServiceEmptyModel                                          `tfsdk:"no_udp_ports"`
}

// NfvServiceF5BigIPAWSServiceEndpointServiceModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceEndpointServiceModel
var NfvServiceF5BigIPAWSServiceEndpointServiceModelAttrTypes = map[string]attr.Type{
	"configured_vip":               types.StringType,
	"advertise_on_slo_ip":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo_ip_external": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"automatic_vip":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"custom_tcp_ports":             types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModelAttrTypes},
	"custom_udp_ports":             types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModelAttrTypes},
	"default_tcp_ports":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_advertise_on_slo_ip":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_port":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"https_port":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_tcp_ports":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_udp_ports":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel represents custom_tcp_ports block
type NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModel
var NfvServiceF5BigIPAWSServiceEndpointServiceCustomTCPPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.StringType},
}

// NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel represents custom_udp_ports block
type NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel struct {
	Ports types.List `tfsdk:"ports"`
}

// NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModel
var NfvServiceF5BigIPAWSServiceEndpointServiceCustomUDPPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.StringType},
}

// NfvServiceF5BigIPAWSServiceMarketPlaceImageModel represents market_place_image block
type NfvServiceF5BigIPAWSServiceMarketPlaceImageModel struct {
	Awafpayg200mbps *NfvServiceEmptyModel `tfsdk:"awafpay_g200_mbps"`
	Awafpayg3gbps   *NfvServiceEmptyModel `tfsdk:"awafpay_g3_gbps"`
}

// NfvServiceF5BigIPAWSServiceMarketPlaceImageModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceMarketPlaceImageModel
var NfvServiceF5BigIPAWSServiceMarketPlaceImageModelAttrTypes = map[string]attr.Type{
	"awafpay_g200_mbps": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"awafpay_g3_gbps":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceF5BigIPAWSServiceNodesModel represents nodes block
type NfvServiceF5BigIPAWSServiceNodesModel struct {
	AWSAzName          types.String                                     `tfsdk:"aws_az_name"`
	NodeName           types.String                                     `tfsdk:"node_name"`
	TunnelPrefix       types.String                                     `tfsdk:"tunnel_prefix"`
	AutomaticPrefix    *NfvServiceEmptyModel                            `tfsdk:"automatic_prefix"`
	MgmtSubnet         *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel `tfsdk:"mgmt_subnet"`
	ReservedMgmtSubnet *NfvServiceEmptyModel                            `tfsdk:"reserved_mgmt_subnet"`
}

// NfvServiceF5BigIPAWSServiceNodesModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceNodesModel
var NfvServiceF5BigIPAWSServiceNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":          types.StringType,
	"node_name":            types.StringType,
	"tunnel_prefix":        types.StringType,
	"automatic_prefix":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"mgmt_subnet":          types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModelAttrTypes},
	"reserved_mgmt_subnet": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel represents mgmt_subnet block
type NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel struct {
	ExistingSubnetID types.String                                                `tfsdk:"existing_subnet_id"`
	SubnetParam      *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel
var NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModelAttrTypes},
}

// NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel represents subnet_param block
type NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModelAttrTypes defines the attribute types for NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModel
var NfvServiceF5BigIPAWSServiceNodesMgmtSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// NfvServiceHTTPSManagementModel represents https_management block
type NfvServiceHTTPSManagementModel struct {
	DomainSuffix                  types.String                                             `tfsdk:"domain_suffix"`
	HTTPSPort                     types.Int64                                              `tfsdk:"https_port"`
	AdvertiseOnInternet           *NfvServiceHTTPSManagementAdvertiseOnInternetModel       `tfsdk:"advertise_on_internet"`
	AdvertiseOnInternetDefaultVIP *NfvServiceEmptyModel                                    `tfsdk:"advertise_on_internet_default_vip"`
	AdvertiseOnSLIVIP             *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel         `tfsdk:"advertise_on_sli_vip"`
	AdvertiseOnSloInternetVIP     *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel `tfsdk:"advertise_on_slo_internet_vip"`
	AdvertiseOnSloSLI             *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel         `tfsdk:"advertise_on_slo_sli"`
	AdvertiseOnSloVIP             *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel         `tfsdk:"advertise_on_slo_vip"`
	DefaultHTTPSPort              *NfvServiceEmptyModel                                    `tfsdk:"default_https_port"`
}

// NfvServiceHTTPSManagementModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementModel
var NfvServiceHTTPSManagementModelAttrTypes = map[string]attr.Type{
	"domain_suffix":                     types.StringType,
	"https_port":                        types.Int64Type,
	"advertise_on_internet":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_internet_default_vip": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_sli_vip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo_internet_vip":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo_sli":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"advertise_on_slo_vip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_https_port":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnInternetModel represents advertise_on_internet block
type NfvServiceHTTPSManagementAdvertiseOnInternetModel struct {
	PublicIP *NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel `tfsdk:"public_ip"`
}

// NfvServiceHTTPSManagementAdvertiseOnInternetModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnInternetModel
var NfvServiceHTTPSManagementAdvertiseOnInternetModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel represents public_ip block
type NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModel
var NfvServiceHTTPSManagementAdvertiseOnInternetPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel represents advertise_on_sli_vip block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel struct {
	NoMtls          *NfvServiceEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                        `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                        `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                   `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                         `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                       `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModel
var NfvServiceHTTPSManagementAdvertiseOnSLIVIPUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel represents advertise_on_slo_internet_vip block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel struct {
	NoMtls          *NfvServiceEmptyModel                                                    `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                                       `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                                       `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                           `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                           `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                           `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                               `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                                      `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                                      `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModel
var NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIModel represents advertise_on_slo_sli block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIModel struct {
	NoMtls          *NfvServiceEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLIModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLIModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel struct {
	CertificateURL       types.String                                                                        `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                        `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                   `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLITLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                         `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                       `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModel
var NfvServiceHTTPSManagementAdvertiseOnSloSLIUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPModel represents advertise_on_slo_vip block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPModel struct {
	NoMtls          *NfvServiceEmptyModel                                            `tfsdk:"no_mtls"`
	TLSCertificates []NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel          `tfsdk:"use_mtls"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel represents tls_certificates block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel struct {
	CertificateURL       types.String                                                                        `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                        `tfsdk:"description_spec"`
	CustomHashAlgorithms *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *NfvServiceEmptyModel                                                               `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *NfvServiceEmptyModel                                                               `tfsdk:"use_system_defaults"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel represents private_key block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel represents tls_config block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel struct {
	CustomSecurity  *NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *NfvServiceEmptyModel                                                   `tfsdk:"default_security"`
	LowSecurity     *NfvServiceEmptyModel                                                   `tfsdk:"low_security"`
	MediumSecurity  *NfvServiceEmptyModel                                                   `tfsdk:"medium_security"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel represents custom_security block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel represents use_mtls block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                         `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                       `tfsdk:"trusted_ca_url"`
	CRL                       *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *NfvServiceEmptyModel                                              `tfsdk:"no_crl"`
	TrustedCA                 *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *NfvServiceEmptyModel                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModelAttrTypes},
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel represents crl block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel represents trusted_ca block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel represents xfcc_options block
type NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModelAttrTypes defines the attribute types for NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModel
var NfvServiceHTTPSManagementAdvertiseOnSloVIPUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// NfvServicePaloAltoFwServiceModel represents palo_alto_fw_service block
type NfvServicePaloAltoFwServiceModel struct {
	InstanceType    types.String                                    `tfsdk:"instance_type"`
	SSHKey          types.String                                    `tfsdk:"ssh_key"`
	Version         types.String                                    `tfsdk:"version"`
	AutoSetup       *NfvServicePaloAltoFwServiceAutoSetupModel      `tfsdk:"auto_setup"`
	AWSTGWSite      *NfvServicePaloAltoFwServiceAWSTGWSiteModel     `tfsdk:"aws_tgw_site"`
	DisablePanaroma *NfvServiceEmptyModel                           `tfsdk:"disable_panaroma"`
	PanAmiBundle1   *NfvServiceEmptyModel                           `tfsdk:"pan_ami_bundle1"`
	PanAmiBundle2   *NfvServiceEmptyModel                           `tfsdk:"pan_ami_bundle2"`
	PanoramaServer  *NfvServicePaloAltoFwServicePanoramaServerModel `tfsdk:"panorama_server"`
	ServiceNodes    *NfvServicePaloAltoFwServiceServiceNodesModel   `tfsdk:"service_nodes"`
	Tags            *NfvServiceEmptyModel                           `tfsdk:"tags"`
}

// NfvServicePaloAltoFwServiceModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceModel
var NfvServicePaloAltoFwServiceModelAttrTypes = map[string]attr.Type{
	"instance_type":    types.StringType,
	"ssh_key":          types.StringType,
	"version":          types.StringType,
	"auto_setup":       types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAutoSetupModelAttrTypes},
	"aws_tgw_site":     types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAWSTGWSiteModelAttrTypes},
	"disable_panaroma": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pan_ami_bundle1":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pan_ami_bundle2":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"panorama_server":  types.ObjectType{AttrTypes: NfvServicePaloAltoFwServicePanoramaServerModelAttrTypes},
	"service_nodes":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tags":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServicePaloAltoFwServiceAutoSetupModel represents auto_setup block
type NfvServicePaloAltoFwServiceAutoSetupModel struct {
	AdminUsername types.String                                            `tfsdk:"admin_username"`
	AdminPassword *NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel `tfsdk:"admin_password"`
	ManualSSHKeys *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel `tfsdk:"manual_ssh_keys"`
}

// NfvServicePaloAltoFwServiceAutoSetupModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupModel
var NfvServicePaloAltoFwServiceAutoSetupModelAttrTypes = map[string]attr.Type{
	"admin_username":  types.StringType,
	"admin_password":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"manual_ssh_keys": types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModelAttrTypes},
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel represents admin_password block
type NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel struct {
	BlindfoldSecretInfo *NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModel
var NfvServicePaloAltoFwServiceAutoSetupAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModelAttrTypes},
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModel
var NfvServicePaloAltoFwServiceAutoSetupAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel represents clear_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModel
var NfvServicePaloAltoFwServiceAutoSetupAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel represents manual_ssh_keys block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel struct {
	PublicKey  types.String                                                      `tfsdk:"public_key"`
	PrivateKey *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel `tfsdk:"private_key"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModel
var NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysModelAttrTypes = map[string]attr.Type{
	"public_key":  types.StringType,
	"private_key": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel represents private_key block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel struct {
	BlindfoldSecretInfo *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModel
var NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModelAttrTypes},
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModel
var NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel represents clear_secret_info block
type NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModel
var NfvServicePaloAltoFwServiceAutoSetupManualSSHKeysPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServicePaloAltoFwServiceAWSTGWSiteModel represents aws_tgw_site block
type NfvServicePaloAltoFwServiceAWSTGWSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// NfvServicePaloAltoFwServiceAWSTGWSiteModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceAWSTGWSiteModel
var NfvServicePaloAltoFwServiceAWSTGWSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// NfvServicePaloAltoFwServicePanoramaServerModel represents panorama_server block
type NfvServicePaloAltoFwServicePanoramaServerModel struct {
	DeviceGroupName   types.String                                                    `tfsdk:"device_group_name"`
	Server            types.String                                                    `tfsdk:"server"`
	TemplateStackName types.String                                                    `tfsdk:"template_stack_name"`
	AuthorizationKey  *NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel `tfsdk:"authorization_key"`
}

// NfvServicePaloAltoFwServicePanoramaServerModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServicePanoramaServerModel
var NfvServicePaloAltoFwServicePanoramaServerModelAttrTypes = map[string]attr.Type{
	"device_group_name":   types.StringType,
	"server":              types.StringType,
	"template_stack_name": types.StringType,
	"authorization_key":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel represents authorization_key block
type NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel struct {
	BlindfoldSecretInfo *NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModel
var NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModelAttrTypes},
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModel
var NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel represents clear_secret_info block
type NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModel
var NfvServicePaloAltoFwServicePanoramaServerAuthorizationKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// NfvServicePaloAltoFwServiceServiceNodesModel represents service_nodes block
type NfvServicePaloAltoFwServiceServiceNodesModel struct {
	Nodes []NfvServicePaloAltoFwServiceServiceNodesNodesModel `tfsdk:"nodes"`
}

// NfvServicePaloAltoFwServiceServiceNodesModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceServiceNodesModel
var NfvServicePaloAltoFwServiceServiceNodesModelAttrTypes = map[string]attr.Type{
	"nodes": types.ListType{ElemType: types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceServiceNodesNodesModelAttrTypes}},
}

// NfvServicePaloAltoFwServiceServiceNodesNodesModel represents nodes block
type NfvServicePaloAltoFwServiceServiceNodesNodesModel struct {
	AWSAzName          types.String                                                 `tfsdk:"aws_az_name"`
	NodeName           types.String                                                 `tfsdk:"node_name"`
	MgmtSubnet         *NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel `tfsdk:"mgmt_subnet"`
	ReservedMgmtSubnet *NfvServiceEmptyModel                                        `tfsdk:"reserved_mgmt_subnet"`
}

// NfvServicePaloAltoFwServiceServiceNodesNodesModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceServiceNodesNodesModel
var NfvServicePaloAltoFwServiceServiceNodesNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":          types.StringType,
	"node_name":            types.StringType,
	"mgmt_subnet":          types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModelAttrTypes},
	"reserved_mgmt_subnet": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel represents mgmt_subnet block
type NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel struct {
	ExistingSubnetID types.String                                                            `tfsdk:"existing_subnet_id"`
	SubnetParam      *NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModel
var NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModelAttrTypes},
}

// NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel represents subnet_param block
type NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModelAttrTypes defines the attribute types for NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModel
var NfvServicePaloAltoFwServiceServiceNodesNodesMgmtSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

type NfvServiceResourceModel struct {
	Name                   types.String                      `tfsdk:"name"`
	Namespace              types.String                      `tfsdk:"namespace"`
	Annotations            types.Map                         `tfsdk:"annotations"`
	Description            types.String                      `tfsdk:"description"`
	Disable                types.Bool                        `tfsdk:"disable"`
	Labels                 types.Map                         `tfsdk:"labels"`
	ID                     types.String                      `tfsdk:"id"`
	Timeouts               timeouts.Value                    `tfsdk:"timeouts"`
	DisableHTTPSManagement *NfvServiceEmptyModel             `tfsdk:"disable_https_management"`
	DisableSSHAccess       *NfvServiceEmptyModel             `tfsdk:"disable_ssh_access"`
	EnabledSSHAccess       *NfvServiceEnabledSSHAccessModel  `tfsdk:"enabled_ssh_access"`
	F5BigIPAWSService      *NfvServiceF5BigIPAWSServiceModel `tfsdk:"f5_big_ip_aws_service"`
	HTTPSManagement        *NfvServiceHTTPSManagementModel   `tfsdk:"https_management"`
	PaloAltoFwService      *NfvServicePaloAltoFwServiceModel `tfsdk:"palo_alto_fw_service"`
}

func (r *NfvServiceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_nfv_service"
}

func (r *NfvServiceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             nfv_serviceSchemaVersion,
		MarkdownDescription: "[Namespace: required] Manages new NFV service with configured parameters in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Nfv Service. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Nfv Service will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"disable_https_management": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_https_management, https_management; Default: disable_https_management] Enable this option",
			},
			"disable_ssh_access": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ssh_access, enabled_ssh_access; Default: disable_ssh_access] Enable this option",
			},
			"enabled_ssh_access": schema.SingleNestedBlock{
				MarkdownDescription: "SSH based management. SSH based configuration",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain Suffix. Domain suffix will be used along with node name to form the hostname for ssh node management",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"advertise_on_slo": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"node_ssh_ports": schema.ListNestedBlock{
						MarkdownDescription: "Management Node SSH Port. Enter TCP port and node name per node",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"node_name": schema.StringAttribute{
									MarkdownDescription: "Node Name. Node name will be used to match a particular node with the desired TCP port",
									Optional:            true,
								},
								"ssh_port": schema.Int64Attribute{
									MarkdownDescription: "SSH Port. Enter TCP port per node",
									Optional:            true,
								},
							},
						},
					},
				},
			},
			"f5_big_ip_aws_service": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: f5_big_ip_aws_service, palo_alto_fw_service] Virtual BIG-IP AWS. Virtual BIG-IP specification for AWS",
				Attributes: map[string]schema.Attribute{
					"admin_username": schema.StringAttribute{
						MarkdownDescription: "Admin Username. Admin Username for BIG-IP",
						Optional:            true,
					},
					"ssh_key": schema.StringAttribute{
						MarkdownDescription: "Public SSH key. Public SSH key for accessing the Big IP nodes.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"admin_password": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional:            true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional:            true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional:            true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional:            true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional:            true,
									},
								},
							},
						},
					},
					"aws_tgw_site_params": schema.SingleNestedBlock{
						MarkdownDescription: "BIG-IP AWS TGW Site. BIG-IP AWS TGW site specification",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"aws_tgw_site": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
						},
					},
					"endpoint_service": schema.SingleNestedBlock{
						MarkdownDescription: "Endpoint Service. Endpoint Service is a type of NFV service where the packets are destined to NFV and service modifies the destination with a new destination address",
						Attributes: map[string]schema.Attribute{
							"configured_vip": schema.StringAttribute{
								MarkdownDescription: "Configured VIP. Enter IP address for the default VIP",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"advertise_on_slo_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"advertise_on_slo_ip_external": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"automatic_vip": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"custom_tcp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Port Range List. List of port ranges",
								Attributes: map[string]schema.Attribute{
									"ports": schema.ListAttribute{
										MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"custom_udp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Port Range List. List of port ranges",
								Attributes: map[string]schema.Attribute{
									"ports": schema.ListAttribute{
										MarkdownDescription: "Port Ranges. List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"default_tcp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"disable_advertise_on_slo_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"no_tcp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"no_udp_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"market_place_image": schema.SingleNestedBlock{
						MarkdownDescription: "BIG-IP AWS Pay as You Go Image. BIG-IP AWS Pay as You Go Image Selection",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"awafpay_g200_mbps": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"awafpay_g3_gbps": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"nodes": schema.ListNestedBlock{
						MarkdownDescription: "Service Nodes. Specify how and where the service nodes are spawned",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS AZ Name. The AWS Availability Zone must be consistent with the AWS Region chosen. Please select an AZ in the same Region as your TGW Site",
									Optional:            true,
								},
								"node_name": schema.StringAttribute{
									MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
									Optional:            true,
								},
								"tunnel_prefix": schema.StringAttribute{
									MarkdownDescription: "Tunnel IP Prefix. Enter IP prefix for the tunnel, it has to be /30",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"automatic_prefix": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"mgmt_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
													Optional:            true,
												},
											},
										},
									},
								},
								"reserved_mgmt_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
					"tags": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
					},
				},
			},
			"https_management": schema.SingleNestedBlock{
				MarkdownDescription: "HTTPS based management. HTTPS based configuration",
				Attributes: map[string]schema.Attribute{
					"domain_suffix": schema.StringAttribute{
						MarkdownDescription: "Domain Suffix. Domain suffix will be used along with node name to form URL to access node management",
						Optional:            true,
					},
					"https_port": schema.Int64Attribute{
						MarkdownDescription: "HTTPS Port. Enter TCP port number",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_on_internet": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"public_ip": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
						},
					},
					"advertise_on_internet_default_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"advertise_on_sli_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"advertise_on_slo_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"default_https_port": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"palo_alto_fw_service": schema.SingleNestedBlock{
				MarkdownDescription: "Palo Alto Networks VM-Series Firewall. Palo Alto Networks VM-Series next-generation firewall configuration",
				Attributes: map[string]schema.Attribute{
					"instance_type": schema.StringAttribute{
						MarkdownDescription: "[Enum: PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_12XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_8XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_9XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_18XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_LARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_2XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_4XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_9XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_18XLARGE|PALO_ALTO_FW_AWS_INSTANCE_TYPE_R5_2XLARGE] Palo Alto Networks VM-Series Instance Typ. - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE: m4.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_2XLARGE: m4.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_4XLARGE: m4.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_LARGE: m5.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_XLARGE: m5.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_2XLARGE: m5.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_4XLARGE: m5.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_12XLARGE: m5.12xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_LARGE: m5n.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_XLARGE: m5n.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_2XLARGE: m5n.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_4XLARGE: m5n.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_LARGE: c4.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_XLARGE: c4.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_2XLARGE: c4.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_4XLARGE: c4.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_8XLARGE: c4.8xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_LARGE: c5.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_XLARGE: c5.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_2XLARGE: c5.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_4XLARGE: c5.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_9XLARGE: c5.9xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_18XLARGE: c5.18xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_LARGE: c5n.large - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_XLARGE: c5n.xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_2XLARGE: c5n.2xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_4XLARGE: c5n.4xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_9XLARGE: c5n.9xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_18XLARGE: c5n.18xlarge - PALO_ALTO_FW_AWS_INSTANCE_TYPE_R5_2XLARGE: r5.2xlarge. Possible values are `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5_12XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M5N_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C4_8XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_9XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5_18XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_LARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_2XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_4XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_9XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_C5N_18XLARGE`, `PALO_ALTO_FW_AWS_INSTANCE_TYPE_R5_2XLARGE`. Defaults to `PALO_ALTO_FW_AWS_INSTANCE_TYPE_M4_XLARGE`.",
						Optional:            true,
					},
					"ssh_key": schema.StringAttribute{
						MarkdownDescription: "Setup Authorized Public SSH key. Setup Authorized Public SSH key. User will be able to ssh to the vmseries nodes using its corresponding ssh private key.",
						Optional:            true,
					},
					"version": schema.StringAttribute{
						MarkdownDescription: "PAN VM-Series version. PAN-OS version",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auto_setup": schema.SingleNestedBlock{
						MarkdownDescription: "PAN VM Series Firewall Auto Setup. For auto-setup, ssh public and pvt keys are needed. Using the given config user, ssh and api access will be configured",
						Attributes: map[string]schema.Attribute{
							"admin_username": schema.StringAttribute{
								MarkdownDescription: "Firewall Admin Username. Firewall Admin Username",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"admin_password": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"manual_ssh_keys": schema.SingleNestedBlock{
								MarkdownDescription: "SSH key. SSH Key includes both public and private key",
								Attributes: map[string]schema.Attribute{
									"public_key": schema.StringAttribute{
										MarkdownDescription: "Public SSH key. Authorized Public SSH key which will be programmed on the node",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"private_key": schema.SingleNestedBlock{
										MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"aws_tgw_site": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"disable_panaroma": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"pan_ami_bundle1": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"pan_ami_bundle2": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"panorama_server": schema.SingleNestedBlock{
						MarkdownDescription: "Panorama Server Type. Panorama Server Type",
						Attributes: map[string]schema.Attribute{
							"device_group_name": schema.StringAttribute{
								MarkdownDescription: "Device Group Name. Device Group Name",
								Optional:            true,
							},
							"server": schema.StringAttribute{
								MarkdownDescription: "Server Ipv4 Address. Panorama Server Address to which the firewall should connect to",
								Optional:            true,
							},
							"template_stack_name": schema.StringAttribute{
								MarkdownDescription: "template stack name. Template Stack Name",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"authorization_key": schema.SingleNestedBlock{
								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
						},
					},
					"service_nodes": schema.SingleNestedBlock{
						MarkdownDescription: "Palo Alto Networks Vm-Series AZ Nodes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"nodes": schema.ListNestedBlock{
								MarkdownDescription: "Palo Alto Networks AZ Nodes.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"aws_az_name": schema.StringAttribute{
											MarkdownDescription: "AWS AZ Name. AWS availability zone, must be consistent with the selected AWS region. It is recommended that AZ is one of the AZ for sites",
											Optional:            true,
										},
										"node_name": schema.StringAttribute{
											MarkdownDescription: "Node Name. Node Name will be used to assign as hostname to the service",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "AWS Subnet. Parameters for AWS subnet",
											Attributes: map[string]schema.Attribute{
												"existing_subnet_id": schema.StringAttribute{
													MarkdownDescription: "Existing Subnet ID. Information about existing subnet ID",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"subnet_param": schema.SingleNestedBlock{
													MarkdownDescription: "New Cloud Subnet Parameters. Parameters for creating a new cloud subnet",
													Attributes: map[string]schema.Attribute{
														"ipv4": schema.StringAttribute{
															MarkdownDescription: "IPv4 Subnet. IPv4 subnet prefix for this subnet",
															Optional:            true,
														},
													},
												},
											},
										},
										"reserved_mgmt_subnet": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"tags": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Tags. AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
					},
				},
			},
		},
	}
}

func (r *NfvServiceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *NfvServiceResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *NfvServiceResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the nfv_service from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan NfvServiceResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *NfvServiceResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := NfvServiceResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *NfvServiceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating nfv_service", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.NfvService{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.DisableHTTPSManagement != nil {
		disable_https_managementMap := make(map[string]interface{})
		createReq.Spec["disable_https_management"] = disable_https_managementMap
	}
	if data.DisableSSHAccess != nil {
		disable_ssh_accessMap := make(map[string]interface{})
		createReq.Spec["disable_ssh_access"] = disable_ssh_accessMap
	}
	if data.EnabledSSHAccess != nil {
		enabled_ssh_accessMap := make(map[string]interface{})
		if data.EnabledSSHAccess.AdvertiseOnSLI != nil {
			enabled_ssh_accessMap["advertise_on_sli"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSlo != nil {
			enabled_ssh_accessMap["advertise_on_slo"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSloSLI != nil {
			enabled_ssh_accessMap["advertise_on_slo_sli"] = map[string]interface{}{}
		}
		if !data.EnabledSSHAccess.DomainSuffix.IsNull() && !data.EnabledSSHAccess.DomainSuffix.IsUnknown() {
			enabled_ssh_accessMap["domain_suffix"] = data.EnabledSSHAccess.DomainSuffix.ValueString()
		}
		if len(data.EnabledSSHAccess.NodeSSHPorts) > 0 {
			var node_ssh_portsList []map[string]interface{}
			for _, listItem := range data.EnabledSSHAccess.NodeSSHPorts {
				listItemMap := make(map[string]interface{})
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if !listItem.SSHPort.IsNull() && !listItem.SSHPort.IsUnknown() {
					listItemMap["ssh_port"] = listItem.SSHPort.ValueInt64()
				}
				node_ssh_portsList = append(node_ssh_portsList, listItemMap)
			}
			enabled_ssh_accessMap["node_ssh_ports"] = node_ssh_portsList
		}
		createReq.Spec["enabled_ssh_access"] = enabled_ssh_accessMap
	}
	if data.F5BigIPAWSService != nil {
		f5_big_ip_aws_serviceMap := make(map[string]interface{})
		if data.F5BigIPAWSService.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["admin_password"] = admin_passwordNestedMap
		}
		if !data.F5BigIPAWSService.AdminUsername.IsNull() && !data.F5BigIPAWSService.AdminUsername.IsUnknown() {
			f5_big_ip_aws_serviceMap["admin_username"] = data.F5BigIPAWSService.AdminUsername.ValueString()
		}
		if data.F5BigIPAWSService.AWSTGWSiteParams != nil {
			aws_tgw_site_paramsNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["aws_tgw_site_params"] = aws_tgw_site_paramsNestedMap
		}
		if data.F5BigIPAWSService.EndpointService != nil {
			endpoint_serviceNestedMap := make(map[string]interface{})
			if !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsNull() && !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsUnknown() {
				endpoint_serviceNestedMap["configured_vip"] = data.F5BigIPAWSService.EndpointService.ConfiguredVIP.ValueString()
			}
			f5_big_ip_aws_serviceMap["endpoint_service"] = endpoint_serviceNestedMap
		}
		if data.F5BigIPAWSService.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["market_place_image"] = market_place_imageNestedMap
		}
		if len(data.F5BigIPAWSService.Nodes) > 0 {
			var nodesList []map[string]interface{}
			for _, listItem := range data.F5BigIPAWSService.Nodes {
				listItemMap := make(map[string]interface{})
				if listItem.AutomaticPrefix != nil {
					listItemMap["automatic_prefix"] = map[string]interface{}{}
				}
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.MgmtSubnet != nil {
					mgmt_subnetDeepMap := make(map[string]interface{})
					if !listItem.MgmtSubnet.ExistingSubnetID.IsNull() && !listItem.MgmtSubnet.ExistingSubnetID.IsUnknown() {
						mgmt_subnetDeepMap["existing_subnet_id"] = listItem.MgmtSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["mgmt_subnet"] = mgmt_subnetDeepMap
				}
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if listItem.ReservedMgmtSubnet != nil {
					listItemMap["reserved_mgmt_subnet"] = map[string]interface{}{}
				}
				if !listItem.TunnelPrefix.IsNull() && !listItem.TunnelPrefix.IsUnknown() {
					listItemMap["tunnel_prefix"] = listItem.TunnelPrefix.ValueString()
				}
				nodesList = append(nodesList, listItemMap)
			}
			f5_big_ip_aws_serviceMap["nodes"] = nodesList
		}
		if !data.F5BigIPAWSService.SSHKey.IsNull() && !data.F5BigIPAWSService.SSHKey.IsUnknown() {
			f5_big_ip_aws_serviceMap["ssh_key"] = data.F5BigIPAWSService.SSHKey.ValueString()
		}
		if data.F5BigIPAWSService.Tags != nil {
			f5_big_ip_aws_serviceMap["tags"] = map[string]interface{}{}
		}
		createReq.Spec["f5_big_ip_aws_service"] = f5_big_ip_aws_serviceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVIP != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloVIP != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		createReq.Spec["https_management"] = https_managementMap
	}
	if data.PaloAltoFwService != nil {
		palo_alto_fw_serviceMap := make(map[string]interface{})
		if data.PaloAltoFwService.AutoSetup != nil {
			auto_setupNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AutoSetup.AdminUsername.IsNull() && !data.PaloAltoFwService.AutoSetup.AdminUsername.IsUnknown() {
				auto_setupNestedMap["admin_username"] = data.PaloAltoFwService.AutoSetup.AdminUsername.ValueString()
			}
			palo_alto_fw_serviceMap["auto_setup"] = auto_setupNestedMap
		}
		if data.PaloAltoFwService.AWSTGWSite != nil {
			aws_tgw_siteNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AWSTGWSite.Name.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Name.IsUnknown() {
				aws_tgw_siteNestedMap["name"] = data.PaloAltoFwService.AWSTGWSite.Name.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Namespace.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Namespace.IsUnknown() {
				aws_tgw_siteNestedMap["namespace"] = data.PaloAltoFwService.AWSTGWSite.Namespace.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Tenant.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Tenant.IsUnknown() {
				aws_tgw_siteNestedMap["tenant"] = data.PaloAltoFwService.AWSTGWSite.Tenant.ValueString()
			}
			palo_alto_fw_serviceMap["aws_tgw_site"] = aws_tgw_siteNestedMap
		}
		if data.PaloAltoFwService.DisablePanaroma != nil {
			palo_alto_fw_serviceMap["disable_panaroma"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.InstanceType.IsNull() && !data.PaloAltoFwService.InstanceType.IsUnknown() {
			palo_alto_fw_serviceMap["instance_type"] = data.PaloAltoFwService.InstanceType.ValueString()
		}
		if data.PaloAltoFwService.PanAmiBundle1 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle1"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanAmiBundle2 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle2"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanoramaServer != nil {
			panorama_serverNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsNull() && !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsUnknown() {
				panorama_serverNestedMap["device_group_name"] = data.PaloAltoFwService.PanoramaServer.DeviceGroupName.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.Server.IsNull() && !data.PaloAltoFwService.PanoramaServer.Server.IsUnknown() {
				panorama_serverNestedMap["server"] = data.PaloAltoFwService.PanoramaServer.Server.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsNull() && !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsUnknown() {
				panorama_serverNestedMap["template_stack_name"] = data.PaloAltoFwService.PanoramaServer.TemplateStackName.ValueString()
			}
			palo_alto_fw_serviceMap["panorama_server"] = panorama_serverNestedMap
		}
		if data.PaloAltoFwService.ServiceNodes != nil {
			service_nodesNestedMap := make(map[string]interface{})
			palo_alto_fw_serviceMap["service_nodes"] = service_nodesNestedMap
		}
		if !data.PaloAltoFwService.SSHKey.IsNull() && !data.PaloAltoFwService.SSHKey.IsUnknown() {
			palo_alto_fw_serviceMap["ssh_key"] = data.PaloAltoFwService.SSHKey.ValueString()
		}
		if data.PaloAltoFwService.Tags != nil {
			palo_alto_fw_serviceMap["tags"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.Version.IsNull() && !data.PaloAltoFwService.Version.IsUnknown() {
			palo_alto_fw_serviceMap["version"] = data.PaloAltoFwService.Version.ValueString()
		}
		createReq.Spec["palo_alto_fw_service"] = palo_alto_fw_serviceMap
	}

	apiResource, err := r.client.CreateNfvService(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create NfvService: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["disable_https_management"].(map[string]interface{}); ok && isImport && data.DisableHTTPSManagement == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHTTPSManagement = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ssh_access"].(map[string]interface{}); ok && isImport && data.DisableSSHAccess == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableSSHAccess = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enabled_ssh_access"].(map[string]interface{}); ok && (isImport || data.EnabledSSHAccess != nil) {
		data.EnabledSSHAccess = &NfvServiceEnabledSSHAccessModel{
			AdvertiseOnSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSlo: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSlo
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeSSHPorts: func() []NfvServiceEnabledSSHAccessNodeSSHPortsModel {
				if listData, ok := blockData["node_ssh_ports"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceEnabledSSHAccessNodeSSHPortsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceEnabledSSHAccessNodeSSHPortsModel{
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSHPort: func() types.Int64 {
									if v, ok := itemMap["ssh_port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["f5_big_ip_aws_service"].(map[string]interface{}); ok && (isImport || data.F5BigIPAWSService != nil) {
		data.F5BigIPAWSService = &NfvServiceF5BigIPAWSServiceModel{
			AdminPassword: func() *NfvServiceF5BigIPAWSServiceAdminPasswordModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAdminPasswordModel{}
				}
				return nil
			}(),
			AdminUsername: func() types.String {
				if v, ok := blockData["admin_username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AWSTGWSiteParams: func() *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AWSTGWSiteParams != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AWSTGWSiteParams
				}
				// Import case: read from API
				if _, ok := blockData["aws_tgw_site_params"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel{}
				}
				return nil
			}(),
			EndpointService: func() *NfvServiceF5BigIPAWSServiceEndpointServiceModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.EndpointService != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.EndpointService
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["endpoint_service"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceEndpointServiceModel{
						ConfiguredVIP: func() types.String {
							if v, ok := nestedBlockData["configured_vip"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MarketPlaceImage: func() *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.MarketPlaceImage != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.MarketPlaceImage
				}
				// Import case: read from API
				if _, ok := blockData["market_place_image"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceMarketPlaceImageModel{}
				}
				return nil
			}(),
			Nodes: func() []NfvServiceF5BigIPAWSServiceNodesModel {
				if listData, ok := blockData["nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceF5BigIPAWSServiceNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceF5BigIPAWSServiceNodesModel{
								AutomaticPrefix: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["automatic_prefix"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								MgmtSubnet: func() *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel {
									if deepMap, ok := itemMap["mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReservedMgmtSubnet: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["reserved_mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								TunnelPrefix: func() types.String {
									if v, ok := itemMap["tunnel_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.F5BigIPAWSService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.F5BigIPAWSService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &NfvServiceHTTPSManagementModel{
			AdvertiseOnInternet: func() *NfvServiceHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["palo_alto_fw_service"].(map[string]interface{}); ok && (isImport || data.PaloAltoFwService != nil) {
		data.PaloAltoFwService = &NfvServicePaloAltoFwServiceModel{
			AutoSetup: func() *NfvServicePaloAltoFwServiceAutoSetupModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AutoSetup != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AutoSetup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auto_setup"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAutoSetupModel{
						AdminUsername: func() types.String {
							if v, ok := nestedBlockData["admin_username"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSTGWSite: func() *NfvServicePaloAltoFwServiceAWSTGWSiteModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AWSTGWSite != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AWSTGWSite
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_tgw_site"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAWSTGWSiteModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisablePanaroma: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.DisablePanaroma
				}
				// Import case: read from API
				if _, ok := blockData["disable_panaroma"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PanAmiBundle1: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle1
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle1"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanAmiBundle2: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle2
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle2"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanoramaServer: func() *NfvServicePaloAltoFwServicePanoramaServerModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.PanoramaServer != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.PanoramaServer
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["panorama_server"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServicePanoramaServerModel{
						DeviceGroupName: func() types.String {
							if v, ok := nestedBlockData["device_group_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Server: func() types.String {
							if v, ok := nestedBlockData["server"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TemplateStackName: func() types.String {
							if v, ok := nestedBlockData["template_stack_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ServiceNodes: func() *NfvServicePaloAltoFwServiceServiceNodesModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.ServiceNodes != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.ServiceNodes
				}
				// Import case: read from API
				if _, ok := blockData["service_nodes"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceServiceNodesModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			Version: func() types.String {
				if v, ok := blockData["version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created NfvService resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NfvServiceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetNfvService(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "NfvService not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read NfvService: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The nfv_service may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if _, ok := apiResource.Spec["disable_https_management"].(map[string]interface{}); ok && isImport && data.DisableHTTPSManagement == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHTTPSManagement = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ssh_access"].(map[string]interface{}); ok && isImport && data.DisableSSHAccess == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableSSHAccess = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enabled_ssh_access"].(map[string]interface{}); ok && (isImport || data.EnabledSSHAccess != nil) {
		data.EnabledSSHAccess = &NfvServiceEnabledSSHAccessModel{
			AdvertiseOnSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSlo: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSlo
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeSSHPorts: func() []NfvServiceEnabledSSHAccessNodeSSHPortsModel {
				if listData, ok := blockData["node_ssh_ports"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceEnabledSSHAccessNodeSSHPortsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceEnabledSSHAccessNodeSSHPortsModel{
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSHPort: func() types.Int64 {
									if v, ok := itemMap["ssh_port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["f5_big_ip_aws_service"].(map[string]interface{}); ok && (isImport || data.F5BigIPAWSService != nil) {
		data.F5BigIPAWSService = &NfvServiceF5BigIPAWSServiceModel{
			AdminPassword: func() *NfvServiceF5BigIPAWSServiceAdminPasswordModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAdminPasswordModel{}
				}
				return nil
			}(),
			AdminUsername: func() types.String {
				if v, ok := blockData["admin_username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AWSTGWSiteParams: func() *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AWSTGWSiteParams != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AWSTGWSiteParams
				}
				// Import case: read from API
				if _, ok := blockData["aws_tgw_site_params"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel{}
				}
				return nil
			}(),
			EndpointService: func() *NfvServiceF5BigIPAWSServiceEndpointServiceModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.EndpointService != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.EndpointService
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["endpoint_service"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceEndpointServiceModel{
						ConfiguredVIP: func() types.String {
							if v, ok := nestedBlockData["configured_vip"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MarketPlaceImage: func() *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.MarketPlaceImage != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.MarketPlaceImage
				}
				// Import case: read from API
				if _, ok := blockData["market_place_image"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceMarketPlaceImageModel{}
				}
				return nil
			}(),
			Nodes: func() []NfvServiceF5BigIPAWSServiceNodesModel {
				if listData, ok := blockData["nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceF5BigIPAWSServiceNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceF5BigIPAWSServiceNodesModel{
								AutomaticPrefix: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["automatic_prefix"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								MgmtSubnet: func() *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel {
									if deepMap, ok := itemMap["mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReservedMgmtSubnet: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["reserved_mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								TunnelPrefix: func() types.String {
									if v, ok := itemMap["tunnel_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.F5BigIPAWSService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.F5BigIPAWSService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &NfvServiceHTTPSManagementModel{
			AdvertiseOnInternet: func() *NfvServiceHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["palo_alto_fw_service"].(map[string]interface{}); ok && (isImport || data.PaloAltoFwService != nil) {
		data.PaloAltoFwService = &NfvServicePaloAltoFwServiceModel{
			AutoSetup: func() *NfvServicePaloAltoFwServiceAutoSetupModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AutoSetup != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AutoSetup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auto_setup"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAutoSetupModel{
						AdminUsername: func() types.String {
							if v, ok := nestedBlockData["admin_username"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSTGWSite: func() *NfvServicePaloAltoFwServiceAWSTGWSiteModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AWSTGWSite != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AWSTGWSite
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_tgw_site"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAWSTGWSiteModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisablePanaroma: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.DisablePanaroma
				}
				// Import case: read from API
				if _, ok := blockData["disable_panaroma"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PanAmiBundle1: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle1
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle1"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanAmiBundle2: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle2
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle2"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanoramaServer: func() *NfvServicePaloAltoFwServicePanoramaServerModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.PanoramaServer != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.PanoramaServer
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["panorama_server"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServicePanoramaServerModel{
						DeviceGroupName: func() types.String {
							if v, ok := nestedBlockData["device_group_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Server: func() types.String {
							if v, ok := nestedBlockData["server"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TemplateStackName: func() types.String {
							if v, ok := nestedBlockData["template_stack_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ServiceNodes: func() *NfvServicePaloAltoFwServiceServiceNodesModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.ServiceNodes != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.ServiceNodes
				}
				// Import case: read from API
				if _, ok := blockData["service_nodes"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceServiceNodesModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			Version: func() types.String {
				if v, ok := blockData["version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NfvServiceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.NfvService{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.DisableHTTPSManagement != nil {
		disable_https_managementMap := make(map[string]interface{})
		apiResource.Spec["disable_https_management"] = disable_https_managementMap
	}
	if data.DisableSSHAccess != nil {
		disable_ssh_accessMap := make(map[string]interface{})
		apiResource.Spec["disable_ssh_access"] = disable_ssh_accessMap
	}
	if data.EnabledSSHAccess != nil {
		enabled_ssh_accessMap := make(map[string]interface{})
		if data.EnabledSSHAccess.AdvertiseOnSLI != nil {
			enabled_ssh_accessMap["advertise_on_sli"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSlo != nil {
			enabled_ssh_accessMap["advertise_on_slo"] = map[string]interface{}{}
		}
		if data.EnabledSSHAccess.AdvertiseOnSloSLI != nil {
			enabled_ssh_accessMap["advertise_on_slo_sli"] = map[string]interface{}{}
		}
		if !data.EnabledSSHAccess.DomainSuffix.IsNull() && !data.EnabledSSHAccess.DomainSuffix.IsUnknown() {
			enabled_ssh_accessMap["domain_suffix"] = data.EnabledSSHAccess.DomainSuffix.ValueString()
		}
		if len(data.EnabledSSHAccess.NodeSSHPorts) > 0 {
			var node_ssh_portsList []map[string]interface{}
			for _, listItem := range data.EnabledSSHAccess.NodeSSHPorts {
				listItemMap := make(map[string]interface{})
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if !listItem.SSHPort.IsNull() && !listItem.SSHPort.IsUnknown() {
					listItemMap["ssh_port"] = listItem.SSHPort.ValueInt64()
				}
				node_ssh_portsList = append(node_ssh_portsList, listItemMap)
			}
			enabled_ssh_accessMap["node_ssh_ports"] = node_ssh_portsList
		}
		apiResource.Spec["enabled_ssh_access"] = enabled_ssh_accessMap
	}
	if data.F5BigIPAWSService != nil {
		f5_big_ip_aws_serviceMap := make(map[string]interface{})
		if data.F5BigIPAWSService.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["admin_password"] = admin_passwordNestedMap
		}
		if !data.F5BigIPAWSService.AdminUsername.IsNull() && !data.F5BigIPAWSService.AdminUsername.IsUnknown() {
			f5_big_ip_aws_serviceMap["admin_username"] = data.F5BigIPAWSService.AdminUsername.ValueString()
		}
		if data.F5BigIPAWSService.AWSTGWSiteParams != nil {
			aws_tgw_site_paramsNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["aws_tgw_site_params"] = aws_tgw_site_paramsNestedMap
		}
		if data.F5BigIPAWSService.EndpointService != nil {
			endpoint_serviceNestedMap := make(map[string]interface{})
			if !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsNull() && !data.F5BigIPAWSService.EndpointService.ConfiguredVIP.IsUnknown() {
				endpoint_serviceNestedMap["configured_vip"] = data.F5BigIPAWSService.EndpointService.ConfiguredVIP.ValueString()
			}
			f5_big_ip_aws_serviceMap["endpoint_service"] = endpoint_serviceNestedMap
		}
		if data.F5BigIPAWSService.MarketPlaceImage != nil {
			market_place_imageNestedMap := make(map[string]interface{})
			f5_big_ip_aws_serviceMap["market_place_image"] = market_place_imageNestedMap
		}
		if len(data.F5BigIPAWSService.Nodes) > 0 {
			var nodesList []map[string]interface{}
			for _, listItem := range data.F5BigIPAWSService.Nodes {
				listItemMap := make(map[string]interface{})
				if listItem.AutomaticPrefix != nil {
					listItemMap["automatic_prefix"] = map[string]interface{}{}
				}
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.MgmtSubnet != nil {
					mgmt_subnetDeepMap := make(map[string]interface{})
					if !listItem.MgmtSubnet.ExistingSubnetID.IsNull() && !listItem.MgmtSubnet.ExistingSubnetID.IsUnknown() {
						mgmt_subnetDeepMap["existing_subnet_id"] = listItem.MgmtSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["mgmt_subnet"] = mgmt_subnetDeepMap
				}
				if !listItem.NodeName.IsNull() && !listItem.NodeName.IsUnknown() {
					listItemMap["node_name"] = listItem.NodeName.ValueString()
				}
				if listItem.ReservedMgmtSubnet != nil {
					listItemMap["reserved_mgmt_subnet"] = map[string]interface{}{}
				}
				if !listItem.TunnelPrefix.IsNull() && !listItem.TunnelPrefix.IsUnknown() {
					listItemMap["tunnel_prefix"] = listItem.TunnelPrefix.ValueString()
				}
				nodesList = append(nodesList, listItemMap)
			}
			f5_big_ip_aws_serviceMap["nodes"] = nodesList
		}
		if !data.F5BigIPAWSService.SSHKey.IsNull() && !data.F5BigIPAWSService.SSHKey.IsUnknown() {
			f5_big_ip_aws_serviceMap["ssh_key"] = data.F5BigIPAWSService.SSHKey.ValueString()
		}
		if data.F5BigIPAWSService.Tags != nil {
			f5_big_ip_aws_serviceMap["tags"] = map[string]interface{}{}
		}
		apiResource.Spec["f5_big_ip_aws_service"] = f5_big_ip_aws_serviceMap
	}
	if data.HTTPSManagement != nil {
		https_managementMap := make(map[string]interface{})
		if data.HTTPSManagement.AdvertiseOnInternet != nil {
			advertise_on_internetNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_internet"] = advertise_on_internetNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnInternetDefaultVIP != nil {
			https_managementMap["advertise_on_internet_default_vip"] = map[string]interface{}{}
		}
		if data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
			advertise_on_sli_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_sli_vip"] = advertise_on_sli_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
			advertise_on_slo_internet_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_internet_vip"] = advertise_on_slo_internet_vipNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloSLI != nil {
			advertise_on_slo_sliNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_sli"] = advertise_on_slo_sliNestedMap
		}
		if data.HTTPSManagement.AdvertiseOnSloVIP != nil {
			advertise_on_slo_vipNestedMap := make(map[string]interface{})
			https_managementMap["advertise_on_slo_vip"] = advertise_on_slo_vipNestedMap
		}
		if data.HTTPSManagement.DefaultHTTPSPort != nil {
			https_managementMap["default_https_port"] = map[string]interface{}{}
		}
		if !data.HTTPSManagement.DomainSuffix.IsNull() && !data.HTTPSManagement.DomainSuffix.IsUnknown() {
			https_managementMap["domain_suffix"] = data.HTTPSManagement.DomainSuffix.ValueString()
		}
		if !data.HTTPSManagement.HTTPSPort.IsNull() && !data.HTTPSManagement.HTTPSPort.IsUnknown() {
			https_managementMap["https_port"] = data.HTTPSManagement.HTTPSPort.ValueInt64()
		}
		apiResource.Spec["https_management"] = https_managementMap
	}
	if data.PaloAltoFwService != nil {
		palo_alto_fw_serviceMap := make(map[string]interface{})
		if data.PaloAltoFwService.AutoSetup != nil {
			auto_setupNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AutoSetup.AdminUsername.IsNull() && !data.PaloAltoFwService.AutoSetup.AdminUsername.IsUnknown() {
				auto_setupNestedMap["admin_username"] = data.PaloAltoFwService.AutoSetup.AdminUsername.ValueString()
			}
			palo_alto_fw_serviceMap["auto_setup"] = auto_setupNestedMap
		}
		if data.PaloAltoFwService.AWSTGWSite != nil {
			aws_tgw_siteNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.AWSTGWSite.Name.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Name.IsUnknown() {
				aws_tgw_siteNestedMap["name"] = data.PaloAltoFwService.AWSTGWSite.Name.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Namespace.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Namespace.IsUnknown() {
				aws_tgw_siteNestedMap["namespace"] = data.PaloAltoFwService.AWSTGWSite.Namespace.ValueString()
			}
			if !data.PaloAltoFwService.AWSTGWSite.Tenant.IsNull() && !data.PaloAltoFwService.AWSTGWSite.Tenant.IsUnknown() {
				aws_tgw_siteNestedMap["tenant"] = data.PaloAltoFwService.AWSTGWSite.Tenant.ValueString()
			}
			palo_alto_fw_serviceMap["aws_tgw_site"] = aws_tgw_siteNestedMap
		}
		if data.PaloAltoFwService.DisablePanaroma != nil {
			palo_alto_fw_serviceMap["disable_panaroma"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.InstanceType.IsNull() && !data.PaloAltoFwService.InstanceType.IsUnknown() {
			palo_alto_fw_serviceMap["instance_type"] = data.PaloAltoFwService.InstanceType.ValueString()
		}
		if data.PaloAltoFwService.PanAmiBundle1 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle1"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanAmiBundle2 != nil {
			palo_alto_fw_serviceMap["pan_ami_bundle2"] = map[string]interface{}{}
		}
		if data.PaloAltoFwService.PanoramaServer != nil {
			panorama_serverNestedMap := make(map[string]interface{})
			if !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsNull() && !data.PaloAltoFwService.PanoramaServer.DeviceGroupName.IsUnknown() {
				panorama_serverNestedMap["device_group_name"] = data.PaloAltoFwService.PanoramaServer.DeviceGroupName.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.Server.IsNull() && !data.PaloAltoFwService.PanoramaServer.Server.IsUnknown() {
				panorama_serverNestedMap["server"] = data.PaloAltoFwService.PanoramaServer.Server.ValueString()
			}
			if !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsNull() && !data.PaloAltoFwService.PanoramaServer.TemplateStackName.IsUnknown() {
				panorama_serverNestedMap["template_stack_name"] = data.PaloAltoFwService.PanoramaServer.TemplateStackName.ValueString()
			}
			palo_alto_fw_serviceMap["panorama_server"] = panorama_serverNestedMap
		}
		if data.PaloAltoFwService.ServiceNodes != nil {
			service_nodesNestedMap := make(map[string]interface{})
			palo_alto_fw_serviceMap["service_nodes"] = service_nodesNestedMap
		}
		if !data.PaloAltoFwService.SSHKey.IsNull() && !data.PaloAltoFwService.SSHKey.IsUnknown() {
			palo_alto_fw_serviceMap["ssh_key"] = data.PaloAltoFwService.SSHKey.ValueString()
		}
		if data.PaloAltoFwService.Tags != nil {
			palo_alto_fw_serviceMap["tags"] = map[string]interface{}{}
		}
		if !data.PaloAltoFwService.Version.IsNull() && !data.PaloAltoFwService.Version.IsUnknown() {
			palo_alto_fw_serviceMap["version"] = data.PaloAltoFwService.Version.ValueString()
		}
		apiResource.Spec["palo_alto_fw_service"] = palo_alto_fw_serviceMap
	}

	_, err := r.client.UpdateNfvService(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update NfvService: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetNfvService(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read NfvService after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["disable_https_management"].(map[string]interface{}); ok && isImport && data.DisableHTTPSManagement == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHTTPSManagement = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_ssh_access"].(map[string]interface{}); ok && isImport && data.DisableSSHAccess == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableSSHAccess = &NfvServiceEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["enabled_ssh_access"].(map[string]interface{}); ok && (isImport || data.EnabledSSHAccess != nil) {
		data.EnabledSSHAccess = &NfvServiceEnabledSSHAccessModel{
			AdvertiseOnSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSlo: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSlo
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceEmptyModel {
				if !isImport && data.EnabledSSHAccess != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.EnabledSSHAccess.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NodeSSHPorts: func() []NfvServiceEnabledSSHAccessNodeSSHPortsModel {
				if listData, ok := blockData["node_ssh_ports"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceEnabledSSHAccessNodeSSHPortsModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceEnabledSSHAccessNodeSSHPortsModel{
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSHPort: func() types.Int64 {
									if v, ok := itemMap["ssh_port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["f5_big_ip_aws_service"].(map[string]interface{}); ok && (isImport || data.F5BigIPAWSService != nil) {
		data.F5BigIPAWSService = &NfvServiceF5BigIPAWSServiceModel{
			AdminPassword: func() *NfvServiceF5BigIPAWSServiceAdminPasswordModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAdminPasswordModel{}
				}
				return nil
			}(),
			AdminUsername: func() types.String {
				if v, ok := blockData["admin_username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AWSTGWSiteParams: func() *NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.AWSTGWSiteParams != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.AWSTGWSiteParams
				}
				// Import case: read from API
				if _, ok := blockData["aws_tgw_site_params"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceAWSTGWSiteParamsModel{}
				}
				return nil
			}(),
			EndpointService: func() *NfvServiceF5BigIPAWSServiceEndpointServiceModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.EndpointService != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.EndpointService
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["endpoint_service"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceEndpointServiceModel{
						ConfiguredVIP: func() types.String {
							if v, ok := nestedBlockData["configured_vip"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MarketPlaceImage: func() *NfvServiceF5BigIPAWSServiceMarketPlaceImageModel {
				if !isImport && data.F5BigIPAWSService != nil && data.F5BigIPAWSService.MarketPlaceImage != nil {
					// Normal Read: preserve existing state value
					return data.F5BigIPAWSService.MarketPlaceImage
				}
				// Import case: read from API
				if _, ok := blockData["market_place_image"].(map[string]interface{}); ok {
					return &NfvServiceF5BigIPAWSServiceMarketPlaceImageModel{}
				}
				return nil
			}(),
			Nodes: func() []NfvServiceF5BigIPAWSServiceNodesModel {
				if listData, ok := blockData["nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []NfvServiceF5BigIPAWSServiceNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, NfvServiceF5BigIPAWSServiceNodesModel{
								AutomaticPrefix: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["automatic_prefix"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								MgmtSubnet: func() *NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel {
									if deepMap, ok := itemMap["mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceF5BigIPAWSServiceNodesMgmtSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								NodeName: func() types.String {
									if v, ok := itemMap["node_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReservedMgmtSubnet: func() *NfvServiceEmptyModel {
									if _, ok := itemMap["reserved_mgmt_subnet"].(map[string]interface{}); ok {
										return &NfvServiceEmptyModel{}
									}
									return nil
								}(),
								TunnelPrefix: func() types.String {
									if v, ok := itemMap["tunnel_prefix"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.F5BigIPAWSService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.F5BigIPAWSService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["https_management"].(map[string]interface{}); ok && (isImport || data.HTTPSManagement != nil) {
		data.HTTPSManagement = &NfvServiceHTTPSManagementModel{
			AdvertiseOnInternet: func() *NfvServiceHTTPSManagementAdvertiseOnInternetModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnInternet != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnInternet
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnInternetModel{}
				}
				return nil
			}(),
			AdvertiseOnInternetDefaultVIP: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.AdvertiseOnInternetDefaultVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_internet_default_vip"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			AdvertiseOnSLIVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSLIVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSLIVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_sli_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSLIVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloInternetVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloInternetVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_internet_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloInternetVIPModel{}
				}
				return nil
			}(),
			AdvertiseOnSloSLI: func() *NfvServiceHTTPSManagementAdvertiseOnSloSLIModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloSLI != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloSLI
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_sli"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloSLIModel{}
				}
				return nil
			}(),
			AdvertiseOnSloVIP: func() *NfvServiceHTTPSManagementAdvertiseOnSloVIPModel {
				if !isImport && data.HTTPSManagement != nil && data.HTTPSManagement.AdvertiseOnSloVIP != nil {
					// Normal Read: preserve existing state value
					return data.HTTPSManagement.AdvertiseOnSloVIP
				}
				// Import case: read from API
				if _, ok := blockData["advertise_on_slo_vip"].(map[string]interface{}); ok {
					return &NfvServiceHTTPSManagementAdvertiseOnSloVIPModel{}
				}
				return nil
			}(),
			DefaultHTTPSPort: func() *NfvServiceEmptyModel {
				if !isImport && data.HTTPSManagement != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.HTTPSManagement.DefaultHTTPSPort
				}
				// Import case: read from API
				if _, ok := blockData["default_https_port"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			DomainSuffix: func() types.String {
				if v, ok := blockData["domain_suffix"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HTTPSPort: func() types.Int64 {
				if v, ok := blockData["https_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["palo_alto_fw_service"].(map[string]interface{}); ok && (isImport || data.PaloAltoFwService != nil) {
		data.PaloAltoFwService = &NfvServicePaloAltoFwServiceModel{
			AutoSetup: func() *NfvServicePaloAltoFwServiceAutoSetupModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AutoSetup != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AutoSetup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["auto_setup"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAutoSetupModel{
						AdminUsername: func() types.String {
							if v, ok := nestedBlockData["admin_username"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSTGWSite: func() *NfvServicePaloAltoFwServiceAWSTGWSiteModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.AWSTGWSite != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.AWSTGWSite
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_tgw_site"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceAWSTGWSiteModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisablePanaroma: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.DisablePanaroma
				}
				// Import case: read from API
				if _, ok := blockData["disable_panaroma"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PanAmiBundle1: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle1
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle1"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanAmiBundle2: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.PanAmiBundle2
				}
				// Import case: read from API
				if _, ok := blockData["pan_ami_bundle2"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			PanoramaServer: func() *NfvServicePaloAltoFwServicePanoramaServerModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.PanoramaServer != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.PanoramaServer
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["panorama_server"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServicePanoramaServerModel{
						DeviceGroupName: func() types.String {
							if v, ok := nestedBlockData["device_group_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Server: func() types.String {
							if v, ok := nestedBlockData["server"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						TemplateStackName: func() types.String {
							if v, ok := nestedBlockData["template_stack_name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ServiceNodes: func() *NfvServicePaloAltoFwServiceServiceNodesModel {
				if !isImport && data.PaloAltoFwService != nil && data.PaloAltoFwService.ServiceNodes != nil {
					// Normal Read: preserve existing state value
					return data.PaloAltoFwService.ServiceNodes
				}
				// Import case: read from API
				if _, ok := blockData["service_nodes"].(map[string]interface{}); ok {
					return &NfvServicePaloAltoFwServiceServiceNodesModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tags: func() *NfvServiceEmptyModel {
				if !isImport && data.PaloAltoFwService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.PaloAltoFwService.Tags
				}
				// Import case: read from API
				if _, ok := blockData["tags"].(map[string]interface{}); ok {
					return &NfvServiceEmptyModel{}
				}
				return nil
			}(),
			Version: func() types.String {
				if v, ok := blockData["version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NfvServiceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data NfvServiceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteNfvService(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "NfvService already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "NfvService delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete NfvService: %s", err))
		return
	}
}

func (r *NfvServiceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
