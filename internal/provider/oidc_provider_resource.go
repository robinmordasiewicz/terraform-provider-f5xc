// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

var (
	_ resource.Resource                = &OidcProviderResource{}
	_ resource.ResourceWithConfigure   = &OidcProviderResource{}
	_ resource.ResourceWithImportState = &OidcProviderResource{}
)

func NewOidcProviderResource() resource.Resource {
	return &OidcProviderResource{}
}

type OidcProviderResource struct {
	client *client.Client
}

type OidcProviderResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Labels types.Map `tfsdk:"labels"`
	ProviderType types.String `tfsdk:"provider_type"`
	ID types.String `tfsdk:"id"`
}

func (r *OidcProviderResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_oidc_provider"
}

func (r *OidcProviderResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a OidcProvider resource in F5 Distributed Cloud for customcreatespectype is the spec to create oidc provider configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the OidcProvider. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the OidcProvider will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"provider_type": schema.StringAttribute{
				MarkdownDescription: "Provider Type. Types of OIDC providers Default provider. use this for standard OpenIDConnect v1.0 Authenticate with Google OIDC Authenticate with Azure OIDC Authenticate with Okta OIDC. Possible values are `DEFAULT`, `GOOGLE`, `AZURE`, `OKTA`.",
				Optional: true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"azure_oidc_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: azure_oidc_spec_type, google_oidc_spec_type, oidc_v10_spec_type, okta_oidc_spec_type] Azure OIDC Spec Type. AzureOIDCSpecType specifies the attributes required to configure Azure provider",
				Attributes: map[string]schema.Attribute{
					"authorization_url": schema.StringAttribute{
						MarkdownDescription: "Authorization URL. The authorization url of your OIDC application.",
						Optional: true,
					},
					"backchannel_logout": schema.BoolAttribute{
						MarkdownDescription: "Backchannel Logout. Does the external IDP support backchannel logout?",
						Optional: true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with azure provider. REQUIRED field",
						Optional: true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with azure provider.",
						Optional: true,
					},
					"default_scopes": schema.StringAttribute{
						MarkdownDescription: "Default Scopes. The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. The recommendation is to set the default scopes as 'openid profile email' and is to add additional scopes if needed.",
						Optional: true,
					},
					"issuer": schema.StringAttribute{
						MarkdownDescription: "Issuer. The issuer identifier for the issuer of the response. If not provided, no validation will be performed",
						Optional: true,
					},
					"jwks_url": schema.StringAttribute{
						MarkdownDescription: "JWKS URL. URL where identity provider keys in JWK format are stored.",
						Optional: true,
					},
					"logout_url": schema.StringAttribute{
						MarkdownDescription: "Logout URL. Logout URL specified in your OIDC application.",
						Optional: true,
					},
					"prompt": schema.StringAttribute{
						MarkdownDescription: "Prompt Type. Type of prompt authorization server for end-user reauthentication and consent default value for no prompt. when this is set, no prompt parameter will be set on authorization request. The Authorization Server will not display any authentication or consent user interface page. The Authorization Server prompts the End-User for consent before returning information to the Client The Authorization Server prompts the End-User for reauthentication. The Authorization Server prompts the En... Possible values are `UNSPECIFIED`, `NONE`, `CONSENT`, `LOGIN`, `SELECT_ACCOUNT`.",
						Optional: true,
					},
					"token_url": schema.StringAttribute{
						MarkdownDescription: "Token URL. The token URL of your OIDC application.",
						Optional: true,
					},
					"user_info_url": schema.StringAttribute{
						MarkdownDescription: "User Info URL. The User Info Url specified in your OIDC application.",
						Optional: true,
					},
				},

			},
			"google_oidc_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "Google OIDC Spec Type. GoogleOIDCSpecType specifies the attributes required to configure google provider",
				Attributes: map[string]schema.Attribute{
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with google provider. REQUIRED field",
						Optional: true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with google provider.",
						Optional: true,
					},
					"hosted_domain": schema.StringAttribute{
						MarkdownDescription: "Hosted Domain. set hosted domain to restrict user input on login form to use email address from this email domain. for example, setting value company.com will enforce user email input to have only username@company.com leave empty if no restriction is required for email address. ie for example allow user@company1.com and user@company2.com",
						Optional: true,
					},
				},

			},
			"oidc_v10_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "OpenID Connect v1.0 Spec Type. OIDCV10SpecType specifies the attributes required to configure OIDC provider",
				Attributes: map[string]schema.Attribute{
					"allowed_clock_skew": schema.StringAttribute{
						MarkdownDescription: "Allowed Clock Skew. Clock skew in seconds that is tolerated when validating identity provider tokens. Default value is zero.",
						Optional: true,
					},
					"authorization_url": schema.StringAttribute{
						MarkdownDescription: "Authorization URL. The authorization url of your OIDC application.",
						Optional: true,
					},
					"backchannel_logout": schema.BoolAttribute{
						MarkdownDescription: "Backchannel Logout. Does the external IDP support backchannel logout?",
						Optional: true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with your identity/OIDC provider.",
						Optional: true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with your identity/OIDC provider.",
						Optional: true,
					},
					"default_scopes": schema.StringAttribute{
						MarkdownDescription: "Default Scopes. The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. The recommendation is to set the default scopes as 'openid profile email' and is to add additional scopes if needed.",
						Optional: true,
					},
					"disable_user_info": schema.BoolAttribute{
						MarkdownDescription: "Disable User Info. Disable fetching of user info information.",
						Optional: true,
					},
					"display_name": schema.StringAttribute{
						MarkdownDescription: "Display Name. Friendly name for identity provider",
						Optional: true,
					},
					"forwarded_query_parameters": schema.StringAttribute{
						MarkdownDescription: "Forwarded Query Parameters. Non OpenID Connect/OAuth standard query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).",
						Optional: true,
					},
					"issuer": schema.StringAttribute{
						MarkdownDescription: "Issuer. The issuer identifier for the issuer of the response. If not provided, no validation will be performed.",
						Optional: true,
					},
					"jwks_url": schema.StringAttribute{
						MarkdownDescription: "JWKS URL. URL where identity provider keys in JWK format are stored.",
						Optional: true,
					},
					"logout_url": schema.StringAttribute{
						MarkdownDescription: "Logout URL. Logout URL specified in your OIDC application.",
						Optional: true,
					},
					"pass_current_locale": schema.BoolAttribute{
						MarkdownDescription: "Pass Current Locale. Pass the current locale to the identity provider.",
						Optional: true,
					},
					"pass_login_hint": schema.BoolAttribute{
						MarkdownDescription: "Pass Login Hint. Pass login_hint to identity provider.",
						Optional: true,
					},
					"prompt": schema.StringAttribute{
						MarkdownDescription: "Prompt Type. Type of prompt authorization server for end-user reauthentication and consent default value for no prompt. when this is set, no prompt parameter will be set on authorization request. The Authorization Server will not display any authentication or consent user interface page. The Authorization Server prompts the End-User for consent before returning information to the Client The Authorization Server prompts the End-User for reauthentication. The Authorization Server prompts the En... Possible values are `UNSPECIFIED`, `NONE`, `CONSENT`, `LOGIN`, `SELECT_ACCOUNT`.",
						Optional: true,
					},
					"token_url": schema.StringAttribute{
						MarkdownDescription: "Token URL. The token URL of your OIDC application.",
						Optional: true,
					},
					"user_info_url": schema.StringAttribute{
						MarkdownDescription: "User Info URL. The User Info Url specified in your OIDC application.",
						Optional: true,
					},
					"validate_signatures": schema.BoolAttribute{
						MarkdownDescription: "Validate Signatures. Enable/disable signature validation of external IDP signatures.",
						Optional: true,
					},
				},

			},
			"okta_oidc_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "Okta OpenID Connect Spec Type. OKTAOIDCSpecType specifies the attributes required to configure okta OIDC provider",
				Attributes: map[string]schema.Attribute{
					"authorization_url": schema.StringAttribute{
						MarkdownDescription: "Authorization URL. The authorization url of your OIDC application.",
						Optional: true,
					},
					"backchannel_logout": schema.BoolAttribute{
						MarkdownDescription: "Backchannel Logout. Does the external IDP support backchannel logout?",
						Optional: true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with azure provider.",
						Optional: true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with azure provider.",
						Optional: true,
					},
					"default_scopes": schema.StringAttribute{
						MarkdownDescription: "Default Scopes. The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. The recommendation is to set the default scopes as 'openid profile email' and is to add additional scopes if needed.",
						Optional: true,
					},
					"issuer": schema.StringAttribute{
						MarkdownDescription: "Issuer. The issuer identifier for the issuer of the response. If not provided, no validation will be performed",
						Optional: true,
					},
					"jwks_url": schema.StringAttribute{
						MarkdownDescription: "JWKS URL. URL where identity provider keys in JWK format are stored.",
						Optional: true,
					},
					"logout_url": schema.StringAttribute{
						MarkdownDescription: "Logout URL. Logout URL specified in your OIDC application.",
						Optional: true,
					},
					"prompt": schema.StringAttribute{
						MarkdownDescription: "Prompt Type. Type of prompt authorization server for end-user reauthentication and consent default value for no prompt. when this is set, no prompt parameter will be set on authorization request. The Authorization Server will not display any authentication or consent user interface page. The Authorization Server prompts the End-User for consent before returning information to the Client The Authorization Server prompts the End-User for reauthentication. The Authorization Server prompts the En... Possible values are `UNSPECIFIED`, `NONE`, `CONSENT`, `LOGIN`, `SELECT_ACCOUNT`.",
						Optional: true,
					},
					"token_url": schema.StringAttribute{
						MarkdownDescription: "Token URL. The token URL of your OIDC application.",
						Optional: true,
					},
					"user_info_url": schema.StringAttribute{
						MarkdownDescription: "User Info URL. The User Info Url specified in your OIDC application.",
						Optional: true,
					},
				},

			},
		},
	}
}

func (r *OidcProviderResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *OidcProviderResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data OidcProviderResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.OidcProvider{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.OidcProviderSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateOidcProvider(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create OidcProvider: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)
	tflog.Trace(ctx, "created OidcProvider resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OidcProviderResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data OidcProviderResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource, err := r.client.GetOidcProvider(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read OidcProvider: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OidcProviderResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data OidcProviderResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiResource := &client.OidcProvider{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.OidcProviderSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateOidcProvider(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update OidcProvider: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OidcProviderResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data OidcProviderResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteOidcProvider(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete OidcProvider: %s", err))
		return
	}
}

func (r *OidcProviderResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
