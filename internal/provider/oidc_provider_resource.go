// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &OIDCProviderResource{}
	_ resource.ResourceWithConfigure      = &OIDCProviderResource{}
	_ resource.ResourceWithImportState    = &OIDCProviderResource{}
	_ resource.ResourceWithModifyPlan     = &OIDCProviderResource{}
	_ resource.ResourceWithUpgradeState   = &OIDCProviderResource{}
	_ resource.ResourceWithValidateConfig = &OIDCProviderResource{}
)

// oidc_providerSchemaVersion is the schema version for state upgrades
const oidc_providerSchemaVersion int64 = 1

func NewOIDCProviderResource() resource.Resource {
	return &OIDCProviderResource{}
}

type OIDCProviderResource struct {
	client *client.Client
}

// OIDCProviderEmptyModel represents empty nested blocks
type OIDCProviderEmptyModel struct {
}

// OIDCProviderAzureOIDCSpecTypeModel represents azure_oidc_spec_type block
type OIDCProviderAzureOIDCSpecTypeModel struct {
	AuthorizationURL  types.String `tfsdk:"authorization_url"`
	BackchannelLogout types.Bool   `tfsdk:"backchannel_logout"`
	ClientID          types.String `tfsdk:"client_id"`
	ClientSecret      types.String `tfsdk:"client_secret"`
	DefaultScopes     types.String `tfsdk:"default_scopes"`
	Issuer            types.String `tfsdk:"issuer"`
	JwksURL           types.String `tfsdk:"jwks_url"`
	LogoutURL         types.String `tfsdk:"logout_url"`
	Prompt            types.String `tfsdk:"prompt"`
	TokenURL          types.String `tfsdk:"token_url"`
	UserInfoURL       types.String `tfsdk:"user_info_url"`
}

// OIDCProviderGoogleOIDCSpecTypeModel represents google_oidc_spec_type block
type OIDCProviderGoogleOIDCSpecTypeModel struct {
	ClientID     types.String `tfsdk:"client_id"`
	ClientSecret types.String `tfsdk:"client_secret"`
	HostedDomain types.String `tfsdk:"hosted_domain"`
}

// OIDCProviderOIDCV10SpecTypeModel represents oidc_v10_spec_type block
type OIDCProviderOIDCV10SpecTypeModel struct {
	AllowedClockSkew         types.String `tfsdk:"allowed_clock_skew"`
	AuthorizationURL         types.String `tfsdk:"authorization_url"`
	BackchannelLogout        types.Bool   `tfsdk:"backchannel_logout"`
	ClientID                 types.String `tfsdk:"client_id"`
	ClientSecret             types.String `tfsdk:"client_secret"`
	DefaultScopes            types.String `tfsdk:"default_scopes"`
	DisableUserInfo          types.Bool   `tfsdk:"disable_user_info"`
	DisplayName              types.String `tfsdk:"display_name"`
	ForwardedQueryParameters types.String `tfsdk:"forwarded_query_parameters"`
	Issuer                   types.String `tfsdk:"issuer"`
	JwksURL                  types.String `tfsdk:"jwks_url"`
	LogoutURL                types.String `tfsdk:"logout_url"`
	PassCurrentLocale        types.Bool   `tfsdk:"pass_current_locale"`
	PassLoginHint            types.Bool   `tfsdk:"pass_login_hint"`
	Prompt                   types.String `tfsdk:"prompt"`
	TokenURL                 types.String `tfsdk:"token_url"`
	UserInfoURL              types.String `tfsdk:"user_info_url"`
	ValidateSignatures       types.Bool   `tfsdk:"validate_signatures"`
}

// OIDCProviderOktaOIDCSpecTypeModel represents okta_oidc_spec_type block
type OIDCProviderOktaOIDCSpecTypeModel struct {
	AuthorizationURL  types.String `tfsdk:"authorization_url"`
	BackchannelLogout types.Bool   `tfsdk:"backchannel_logout"`
	ClientID          types.String `tfsdk:"client_id"`
	ClientSecret      types.String `tfsdk:"client_secret"`
	DefaultScopes     types.String `tfsdk:"default_scopes"`
	Issuer            types.String `tfsdk:"issuer"`
	JwksURL           types.String `tfsdk:"jwks_url"`
	LogoutURL         types.String `tfsdk:"logout_url"`
	Prompt            types.String `tfsdk:"prompt"`
	TokenURL          types.String `tfsdk:"token_url"`
	UserInfoURL       types.String `tfsdk:"user_info_url"`
}

type OIDCProviderResourceModel struct {
	Name               types.String                         `tfsdk:"name"`
	Namespace          types.String                         `tfsdk:"namespace"`
	Annotations        types.Map                            `tfsdk:"annotations"`
	Description        types.String                         `tfsdk:"description"`
	Disable            types.Bool                           `tfsdk:"disable"`
	Labels             types.Map                            `tfsdk:"labels"`
	ID                 types.String                         `tfsdk:"id"`
	ProviderType       types.String                         `tfsdk:"provider_type"`
	Timeouts           timeouts.Value                       `tfsdk:"timeouts"`
	AzureOIDCSpecType  *OIDCProviderAzureOIDCSpecTypeModel  `tfsdk:"azure_oidc_spec_type"`
	GoogleOIDCSpecType *OIDCProviderGoogleOIDCSpecTypeModel `tfsdk:"google_oidc_spec_type"`
	OIDCV10SpecType    *OIDCProviderOIDCV10SpecTypeModel    `tfsdk:"oidc_v10_spec_type"`
	OktaOIDCSpecType   *OIDCProviderOktaOIDCSpecTypeModel   `tfsdk:"okta_oidc_spec_type"`
}

func (r *OIDCProviderResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_oidc_provider"
}

func (r *OIDCProviderResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             oidc_providerSchemaVersion,
		MarkdownDescription: "[Namespace: required] Manages a OIDC Provider resource in F5 Distributed Cloud for customcreatespectype is the spec to create oidc provider configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the OIDC Provider. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the OIDC Provider will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"provider_type": schema.StringAttribute{
				MarkdownDescription: "[Enum: DEFAULT|GOOGLE|AZURE|OKTA] Provider Type. Types of OIDC providers Default provider. use this for standard OpenIDConnect v1.0 Authenticate with Google OIDC Authenticate with Azure OIDC Authenticate with Okta OIDC. Possible values are `DEFAULT`, `GOOGLE`, `AZURE`, `OKTA`. Defaults to `DEFAULT`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"azure_oidc_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: azure_oidc_spec_type, google_oidc_spec_type, oidc_v10_spec_type, okta_oidc_spec_type] Azure OIDC Spec Type. AzureOIDCSpecType specifies the attributes required to configure Azure provider",
				Attributes: map[string]schema.Attribute{
					"authorization_url": schema.StringAttribute{
						MarkdownDescription: "Authorization URL. The authorization url of your OIDC application.",
						Optional:            true,
					},
					"backchannel_logout": schema.BoolAttribute{
						MarkdownDescription: "Backchannel Logout. Does the external IDP support backchannel logout?",
						Optional:            true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with azure provider. REQUIRED field",
						Optional:            true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with azure provider.",
						Optional:            true,
					},
					"default_scopes": schema.StringAttribute{
						MarkdownDescription: "Default Scopes. The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. The recommendation is to set the default scopes as 'openid profile email' and is to add additional scopes if needed.",
						Optional:            true,
					},
					"issuer": schema.StringAttribute{
						MarkdownDescription: "Issuer. The issuer identifier for the issuer of the response. If not provided, no validation will be performed",
						Optional:            true,
					},
					"jwks_url": schema.StringAttribute{
						MarkdownDescription: "JWKS URL. URL where identity provider keys in JWK format are stored.",
						Optional:            true,
					},
					"logout_url": schema.StringAttribute{
						MarkdownDescription: "Logout URL. Logout URL specified in your OIDC application.",
						Optional:            true,
					},
					"prompt": schema.StringAttribute{
						MarkdownDescription: "[Enum: UNSPECIFIED|NONE|CONSENT|LOGIN|SELECT_ACCOUNT] Prompt Type. Type of prompt authorization server for end-user reauthentication and consent default value for no prompt. when this is set, no prompt parameter will be set on authorization request. The Authorization Server will not display any authentication or consent user interface page. The Authorization Server prompts the End-User for consent before returning information to the Client The Authorization Server prompts the End-User for reauthentication. The Authorization Server prompts the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. Possible values are `UNSPECIFIED`, `NONE`, `CONSENT`, `LOGIN`, `SELECT_ACCOUNT`.",
						Optional:            true,
					},
					"token_url": schema.StringAttribute{
						MarkdownDescription: "Token URL. The token URL of your OIDC application.",
						Optional:            true,
					},
					"user_info_url": schema.StringAttribute{
						MarkdownDescription: "User Info URL. The User Info Url specified in your OIDC application.",
						Optional:            true,
					},
				},
			},
			"google_oidc_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "Google OIDC Spec Type. GoogleOIDCSpecType specifies the attributes required to configure google provider",
				Attributes: map[string]schema.Attribute{
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with google provider. REQUIRED field",
						Optional:            true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with google provider.",
						Optional:            true,
					},
					"hosted_domain": schema.StringAttribute{
						MarkdownDescription: "Hosted Domain. set hosted domain to restrict user input on login form to use email address from this email domain. for example, setting value company.com will enforce user email input to have only username@company.com leave empty if no restriction is required for email address. ie for example allow user@company1.com and user@company2.com",
						Optional:            true,
					},
				},
			},
			"oidc_v10_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "OpenID Connect v1.0 Spec Type. OIDCV10SpecType specifies the attributes required to configure OIDC provider",
				Attributes: map[string]schema.Attribute{
					"allowed_clock_skew": schema.StringAttribute{
						MarkdownDescription: "Allowed Clock Skew. Clock skew in seconds that is tolerated when validating identity provider tokens. Defaults to `zero`.",
						Optional:            true,
					},
					"authorization_url": schema.StringAttribute{
						MarkdownDescription: "Authorization URL. The authorization url of your OIDC application.",
						Optional:            true,
					},
					"backchannel_logout": schema.BoolAttribute{
						MarkdownDescription: "Backchannel Logout. Does the external IDP support backchannel logout?",
						Optional:            true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with your identity/OIDC provider.",
						Optional:            true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with your identity/OIDC provider.",
						Optional:            true,
					},
					"default_scopes": schema.StringAttribute{
						MarkdownDescription: "Default Scopes. The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. The recommendation is to set the default scopes as 'openid profile email' and is to add additional scopes if needed.",
						Optional:            true,
					},
					"disable_user_info": schema.BoolAttribute{
						MarkdownDescription: "Disable User Info. Disable fetching of user info information.",
						Optional:            true,
					},
					"display_name": schema.StringAttribute{
						MarkdownDescription: "Display Name. Friendly name for identity provider",
						Optional:            true,
					},
					"forwarded_query_parameters": schema.StringAttribute{
						MarkdownDescription: "Forwarded Query Parameters. Non OpenID Connect/OAuth standard query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).",
						Optional:            true,
					},
					"issuer": schema.StringAttribute{
						MarkdownDescription: "Issuer. The issuer identifier for the issuer of the response. If not provided, no validation will be performed.",
						Optional:            true,
					},
					"jwks_url": schema.StringAttribute{
						MarkdownDescription: "JWKS URL. URL where identity provider keys in JWK format are stored.",
						Optional:            true,
					},
					"logout_url": schema.StringAttribute{
						MarkdownDescription: "Logout URL. Logout URL specified in your OIDC application.",
						Optional:            true,
					},
					"pass_current_locale": schema.BoolAttribute{
						MarkdownDescription: "Pass Current Locale. Pass the current locale to the identity provider.",
						Optional:            true,
					},
					"pass_login_hint": schema.BoolAttribute{
						MarkdownDescription: "Pass Login Hint. Pass login_hint to identity provider.",
						Optional:            true,
					},
					"prompt": schema.StringAttribute{
						MarkdownDescription: "[Enum: UNSPECIFIED|NONE|CONSENT|LOGIN|SELECT_ACCOUNT] Prompt Type. Type of prompt authorization server for end-user reauthentication and consent default value for no prompt. when this is set, no prompt parameter will be set on authorization request. The Authorization Server will not display any authentication or consent user interface page. The Authorization Server prompts the End-User for consent before returning information to the Client The Authorization Server prompts the End-User for reauthentication. The Authorization Server prompts the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. Possible values are `UNSPECIFIED`, `NONE`, `CONSENT`, `LOGIN`, `SELECT_ACCOUNT`.",
						Optional:            true,
					},
					"token_url": schema.StringAttribute{
						MarkdownDescription: "Token URL. The token URL of your OIDC application.",
						Optional:            true,
					},
					"user_info_url": schema.StringAttribute{
						MarkdownDescription: "User Info URL. The User Info Url specified in your OIDC application.",
						Optional:            true,
					},
					"validate_signatures": schema.BoolAttribute{
						MarkdownDescription: "Validate Signatures. Enable/disable signature validation of external IDP signatures.",
						Optional:            true,
					},
				},
			},
			"okta_oidc_spec_type": schema.SingleNestedBlock{
				MarkdownDescription: "Okta OpenID Connect Spec Type. OKTAOIDCSpecType specifies the attributes required to configure okta OIDC provider",
				Attributes: map[string]schema.Attribute{
					"authorization_url": schema.StringAttribute{
						MarkdownDescription: "Authorization URL. The authorization url of your OIDC application.",
						Optional:            true,
					},
					"backchannel_logout": schema.BoolAttribute{
						MarkdownDescription: "Backchannel Logout. Does the external IDP support backchannel logout?",
						Optional:            true,
					},
					"client_id": schema.StringAttribute{
						MarkdownDescription: "Client ID. Client ID of the OIDC application registered with azure provider.",
						Optional:            true,
					},
					"client_secret": schema.StringAttribute{
						MarkdownDescription: "Client Secret. Secret of the OIDC application registered with azure provider.",
						Optional:            true,
					},
					"default_scopes": schema.StringAttribute{
						MarkdownDescription: "Default Scopes. The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. The recommendation is to set the default scopes as 'openid profile email' and is to add additional scopes if needed.",
						Optional:            true,
					},
					"issuer": schema.StringAttribute{
						MarkdownDescription: "Issuer. The issuer identifier for the issuer of the response. If not provided, no validation will be performed",
						Optional:            true,
					},
					"jwks_url": schema.StringAttribute{
						MarkdownDescription: "JWKS URL. URL where identity provider keys in JWK format are stored.",
						Optional:            true,
					},
					"logout_url": schema.StringAttribute{
						MarkdownDescription: "Logout URL. Logout URL specified in your OIDC application.",
						Optional:            true,
					},
					"prompt": schema.StringAttribute{
						MarkdownDescription: "[Enum: UNSPECIFIED|NONE|CONSENT|LOGIN|SELECT_ACCOUNT] Prompt Type. Type of prompt authorization server for end-user reauthentication and consent default value for no prompt. when this is set, no prompt parameter will be set on authorization request. The Authorization Server will not display any authentication or consent user interface page. The Authorization Server prompts the End-User for consent before returning information to the Client The Authorization Server prompts the End-User for reauthentication. The Authorization Server prompts the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. Possible values are `UNSPECIFIED`, `NONE`, `CONSENT`, `LOGIN`, `SELECT_ACCOUNT`.",
						Optional:            true,
					},
					"token_url": schema.StringAttribute{
						MarkdownDescription: "Token URL. The token URL of your OIDC application.",
						Optional:            true,
					},
					"user_info_url": schema.StringAttribute{
						MarkdownDescription: "User Info URL. The User Info Url specified in your OIDC application.",
						Optional:            true,
					},
				},
			},
		},
	}
}

func (r *OIDCProviderResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *OIDCProviderResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data OIDCProviderResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *OIDCProviderResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the oidc_provider from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan OIDCProviderResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *OIDCProviderResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := OIDCProviderResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *OIDCProviderResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data OIDCProviderResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating oidc_provider", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.OIDCProvider{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AzureOIDCSpecType != nil {
		azure_oidc_spec_typeMap := make(map[string]interface{})
		if !data.AzureOIDCSpecType.AuthorizationURL.IsNull() && !data.AzureOIDCSpecType.AuthorizationURL.IsUnknown() {
			azure_oidc_spec_typeMap["authorization_url"] = data.AzureOIDCSpecType.AuthorizationURL.ValueString()
		}
		if !data.AzureOIDCSpecType.BackchannelLogout.IsNull() && !data.AzureOIDCSpecType.BackchannelLogout.IsUnknown() {
			azure_oidc_spec_typeMap["backchannel_logout"] = data.AzureOIDCSpecType.BackchannelLogout.ValueBool()
		}
		if !data.AzureOIDCSpecType.ClientID.IsNull() && !data.AzureOIDCSpecType.ClientID.IsUnknown() {
			azure_oidc_spec_typeMap["client_id"] = data.AzureOIDCSpecType.ClientID.ValueString()
		}
		if !data.AzureOIDCSpecType.ClientSecret.IsNull() && !data.AzureOIDCSpecType.ClientSecret.IsUnknown() {
			azure_oidc_spec_typeMap["client_secret"] = data.AzureOIDCSpecType.ClientSecret.ValueString()
		}
		if !data.AzureOIDCSpecType.DefaultScopes.IsNull() && !data.AzureOIDCSpecType.DefaultScopes.IsUnknown() {
			azure_oidc_spec_typeMap["default_scopes"] = data.AzureOIDCSpecType.DefaultScopes.ValueString()
		}
		if !data.AzureOIDCSpecType.Issuer.IsNull() && !data.AzureOIDCSpecType.Issuer.IsUnknown() {
			azure_oidc_spec_typeMap["issuer"] = data.AzureOIDCSpecType.Issuer.ValueString()
		}
		if !data.AzureOIDCSpecType.JwksURL.IsNull() && !data.AzureOIDCSpecType.JwksURL.IsUnknown() {
			azure_oidc_spec_typeMap["jwks_url"] = data.AzureOIDCSpecType.JwksURL.ValueString()
		}
		if !data.AzureOIDCSpecType.LogoutURL.IsNull() && !data.AzureOIDCSpecType.LogoutURL.IsUnknown() {
			azure_oidc_spec_typeMap["logout_url"] = data.AzureOIDCSpecType.LogoutURL.ValueString()
		}
		if !data.AzureOIDCSpecType.Prompt.IsNull() && !data.AzureOIDCSpecType.Prompt.IsUnknown() {
			azure_oidc_spec_typeMap["prompt"] = data.AzureOIDCSpecType.Prompt.ValueString()
		}
		if !data.AzureOIDCSpecType.TokenURL.IsNull() && !data.AzureOIDCSpecType.TokenURL.IsUnknown() {
			azure_oidc_spec_typeMap["token_url"] = data.AzureOIDCSpecType.TokenURL.ValueString()
		}
		if !data.AzureOIDCSpecType.UserInfoURL.IsNull() && !data.AzureOIDCSpecType.UserInfoURL.IsUnknown() {
			azure_oidc_spec_typeMap["user_info_url"] = data.AzureOIDCSpecType.UserInfoURL.ValueString()
		}
		createReq.Spec["azure_oidc_spec_type"] = azure_oidc_spec_typeMap
	}
	if data.GoogleOIDCSpecType != nil {
		google_oidc_spec_typeMap := make(map[string]interface{})
		if !data.GoogleOIDCSpecType.ClientID.IsNull() && !data.GoogleOIDCSpecType.ClientID.IsUnknown() {
			google_oidc_spec_typeMap["client_id"] = data.GoogleOIDCSpecType.ClientID.ValueString()
		}
		if !data.GoogleOIDCSpecType.ClientSecret.IsNull() && !data.GoogleOIDCSpecType.ClientSecret.IsUnknown() {
			google_oidc_spec_typeMap["client_secret"] = data.GoogleOIDCSpecType.ClientSecret.ValueString()
		}
		if !data.GoogleOIDCSpecType.HostedDomain.IsNull() && !data.GoogleOIDCSpecType.HostedDomain.IsUnknown() {
			google_oidc_spec_typeMap["hosted_domain"] = data.GoogleOIDCSpecType.HostedDomain.ValueString()
		}
		createReq.Spec["google_oidc_spec_type"] = google_oidc_spec_typeMap
	}
	if data.OIDCV10SpecType != nil {
		oidc_v10_spec_typeMap := make(map[string]interface{})
		if !data.OIDCV10SpecType.AllowedClockSkew.IsNull() && !data.OIDCV10SpecType.AllowedClockSkew.IsUnknown() {
			oidc_v10_spec_typeMap["allowed_clock_skew"] = data.OIDCV10SpecType.AllowedClockSkew.ValueString()
		}
		if !data.OIDCV10SpecType.AuthorizationURL.IsNull() && !data.OIDCV10SpecType.AuthorizationURL.IsUnknown() {
			oidc_v10_spec_typeMap["authorization_url"] = data.OIDCV10SpecType.AuthorizationURL.ValueString()
		}
		if !data.OIDCV10SpecType.BackchannelLogout.IsNull() && !data.OIDCV10SpecType.BackchannelLogout.IsUnknown() {
			oidc_v10_spec_typeMap["backchannel_logout"] = data.OIDCV10SpecType.BackchannelLogout.ValueBool()
		}
		if !data.OIDCV10SpecType.ClientID.IsNull() && !data.OIDCV10SpecType.ClientID.IsUnknown() {
			oidc_v10_spec_typeMap["client_id"] = data.OIDCV10SpecType.ClientID.ValueString()
		}
		if !data.OIDCV10SpecType.ClientSecret.IsNull() && !data.OIDCV10SpecType.ClientSecret.IsUnknown() {
			oidc_v10_spec_typeMap["client_secret"] = data.OIDCV10SpecType.ClientSecret.ValueString()
		}
		if !data.OIDCV10SpecType.DefaultScopes.IsNull() && !data.OIDCV10SpecType.DefaultScopes.IsUnknown() {
			oidc_v10_spec_typeMap["default_scopes"] = data.OIDCV10SpecType.DefaultScopes.ValueString()
		}
		if !data.OIDCV10SpecType.DisableUserInfo.IsNull() && !data.OIDCV10SpecType.DisableUserInfo.IsUnknown() {
			oidc_v10_spec_typeMap["disable_user_info"] = data.OIDCV10SpecType.DisableUserInfo.ValueBool()
		}
		if !data.OIDCV10SpecType.DisplayName.IsNull() && !data.OIDCV10SpecType.DisplayName.IsUnknown() {
			oidc_v10_spec_typeMap["display_name"] = data.OIDCV10SpecType.DisplayName.ValueString()
		}
		if !data.OIDCV10SpecType.ForwardedQueryParameters.IsNull() && !data.OIDCV10SpecType.ForwardedQueryParameters.IsUnknown() {
			oidc_v10_spec_typeMap["forwarded_query_parameters"] = data.OIDCV10SpecType.ForwardedQueryParameters.ValueString()
		}
		if !data.OIDCV10SpecType.Issuer.IsNull() && !data.OIDCV10SpecType.Issuer.IsUnknown() {
			oidc_v10_spec_typeMap["issuer"] = data.OIDCV10SpecType.Issuer.ValueString()
		}
		if !data.OIDCV10SpecType.JwksURL.IsNull() && !data.OIDCV10SpecType.JwksURL.IsUnknown() {
			oidc_v10_spec_typeMap["jwks_url"] = data.OIDCV10SpecType.JwksURL.ValueString()
		}
		if !data.OIDCV10SpecType.LogoutURL.IsNull() && !data.OIDCV10SpecType.LogoutURL.IsUnknown() {
			oidc_v10_spec_typeMap["logout_url"] = data.OIDCV10SpecType.LogoutURL.ValueString()
		}
		if !data.OIDCV10SpecType.PassCurrentLocale.IsNull() && !data.OIDCV10SpecType.PassCurrentLocale.IsUnknown() {
			oidc_v10_spec_typeMap["pass_current_locale"] = data.OIDCV10SpecType.PassCurrentLocale.ValueBool()
		}
		if !data.OIDCV10SpecType.PassLoginHint.IsNull() && !data.OIDCV10SpecType.PassLoginHint.IsUnknown() {
			oidc_v10_spec_typeMap["pass_login_hint"] = data.OIDCV10SpecType.PassLoginHint.ValueBool()
		}
		if !data.OIDCV10SpecType.Prompt.IsNull() && !data.OIDCV10SpecType.Prompt.IsUnknown() {
			oidc_v10_spec_typeMap["prompt"] = data.OIDCV10SpecType.Prompt.ValueString()
		}
		if !data.OIDCV10SpecType.TokenURL.IsNull() && !data.OIDCV10SpecType.TokenURL.IsUnknown() {
			oidc_v10_spec_typeMap["token_url"] = data.OIDCV10SpecType.TokenURL.ValueString()
		}
		if !data.OIDCV10SpecType.UserInfoURL.IsNull() && !data.OIDCV10SpecType.UserInfoURL.IsUnknown() {
			oidc_v10_spec_typeMap["user_info_url"] = data.OIDCV10SpecType.UserInfoURL.ValueString()
		}
		if !data.OIDCV10SpecType.ValidateSignatures.IsNull() && !data.OIDCV10SpecType.ValidateSignatures.IsUnknown() {
			oidc_v10_spec_typeMap["validate_signatures"] = data.OIDCV10SpecType.ValidateSignatures.ValueBool()
		}
		createReq.Spec["oidc_v10_spec_type"] = oidc_v10_spec_typeMap
	}
	if data.OktaOIDCSpecType != nil {
		okta_oidc_spec_typeMap := make(map[string]interface{})
		if !data.OktaOIDCSpecType.AuthorizationURL.IsNull() && !data.OktaOIDCSpecType.AuthorizationURL.IsUnknown() {
			okta_oidc_spec_typeMap["authorization_url"] = data.OktaOIDCSpecType.AuthorizationURL.ValueString()
		}
		if !data.OktaOIDCSpecType.BackchannelLogout.IsNull() && !data.OktaOIDCSpecType.BackchannelLogout.IsUnknown() {
			okta_oidc_spec_typeMap["backchannel_logout"] = data.OktaOIDCSpecType.BackchannelLogout.ValueBool()
		}
		if !data.OktaOIDCSpecType.ClientID.IsNull() && !data.OktaOIDCSpecType.ClientID.IsUnknown() {
			okta_oidc_spec_typeMap["client_id"] = data.OktaOIDCSpecType.ClientID.ValueString()
		}
		if !data.OktaOIDCSpecType.ClientSecret.IsNull() && !data.OktaOIDCSpecType.ClientSecret.IsUnknown() {
			okta_oidc_spec_typeMap["client_secret"] = data.OktaOIDCSpecType.ClientSecret.ValueString()
		}
		if !data.OktaOIDCSpecType.DefaultScopes.IsNull() && !data.OktaOIDCSpecType.DefaultScopes.IsUnknown() {
			okta_oidc_spec_typeMap["default_scopes"] = data.OktaOIDCSpecType.DefaultScopes.ValueString()
		}
		if !data.OktaOIDCSpecType.Issuer.IsNull() && !data.OktaOIDCSpecType.Issuer.IsUnknown() {
			okta_oidc_spec_typeMap["issuer"] = data.OktaOIDCSpecType.Issuer.ValueString()
		}
		if !data.OktaOIDCSpecType.JwksURL.IsNull() && !data.OktaOIDCSpecType.JwksURL.IsUnknown() {
			okta_oidc_spec_typeMap["jwks_url"] = data.OktaOIDCSpecType.JwksURL.ValueString()
		}
		if !data.OktaOIDCSpecType.LogoutURL.IsNull() && !data.OktaOIDCSpecType.LogoutURL.IsUnknown() {
			okta_oidc_spec_typeMap["logout_url"] = data.OktaOIDCSpecType.LogoutURL.ValueString()
		}
		if !data.OktaOIDCSpecType.Prompt.IsNull() && !data.OktaOIDCSpecType.Prompt.IsUnknown() {
			okta_oidc_spec_typeMap["prompt"] = data.OktaOIDCSpecType.Prompt.ValueString()
		}
		if !data.OktaOIDCSpecType.TokenURL.IsNull() && !data.OktaOIDCSpecType.TokenURL.IsUnknown() {
			okta_oidc_spec_typeMap["token_url"] = data.OktaOIDCSpecType.TokenURL.ValueString()
		}
		if !data.OktaOIDCSpecType.UserInfoURL.IsNull() && !data.OktaOIDCSpecType.UserInfoURL.IsUnknown() {
			okta_oidc_spec_typeMap["user_info_url"] = data.OktaOIDCSpecType.UserInfoURL.ValueString()
		}
		createReq.Spec["okta_oidc_spec_type"] = okta_oidc_spec_typeMap
	}
	if !data.ProviderType.IsNull() && !data.ProviderType.IsUnknown() {
		createReq.Spec["provider_type"] = data.ProviderType.ValueString()
	}

	apiResource, err := r.client.CreateOIDCProvider(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create OIDCProvider: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["azure_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.AzureOIDCSpecType != nil) {
		data.AzureOIDCSpecType = &OIDCProviderAzureOIDCSpecTypeModel{
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.AzureOIDCSpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.AzureOIDCSpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["google_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.GoogleOIDCSpecType != nil) {
		data.GoogleOIDCSpecType = &OIDCProviderGoogleOIDCSpecTypeModel{
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HostedDomain: func() types.String {
				if v, ok := blockData["hosted_domain"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_v10_spec_type"].(map[string]interface{}); ok && (isImport || data.OIDCV10SpecType != nil) {
		data.OIDCV10SpecType = &OIDCProviderOIDCV10SpecTypeModel{
			AllowedClockSkew: func() types.String {
				if v, ok := blockData["allowed_clock_skew"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DisableUserInfo: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.DisableUserInfo
				}
				// Import case: read from API
				if v, ok := blockData["disable_user_info"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisplayName: func() types.String {
				if v, ok := blockData["display_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ForwardedQueryParameters: func() types.String {
				if v, ok := blockData["forwarded_query_parameters"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PassCurrentLocale: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.PassCurrentLocale
				}
				// Import case: read from API
				if v, ok := blockData["pass_current_locale"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			PassLoginHint: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.PassLoginHint
				}
				// Import case: read from API
				if v, ok := blockData["pass_login_hint"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ValidateSignatures: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.ValidateSignatures
				}
				// Import case: read from API
				if v, ok := blockData["validate_signatures"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["okta_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.OktaOIDCSpecType != nil) {
		data.OktaOIDCSpecType = &OIDCProviderOktaOIDCSpecTypeModel{
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.OktaOIDCSpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OktaOIDCSpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["provider_type"].(string); ok && v != "" {
		data.ProviderType = types.StringValue(v)
	} else {
		data.ProviderType = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created OIDCProvider resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OIDCProviderResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data OIDCProviderResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetOIDCProvider(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "OIDCProvider not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read OIDCProvider: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The oidc_provider may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["azure_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.AzureOIDCSpecType != nil) {
		data.AzureOIDCSpecType = &OIDCProviderAzureOIDCSpecTypeModel{
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.AzureOIDCSpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.AzureOIDCSpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["google_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.GoogleOIDCSpecType != nil) {
		data.GoogleOIDCSpecType = &OIDCProviderGoogleOIDCSpecTypeModel{
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HostedDomain: func() types.String {
				if v, ok := blockData["hosted_domain"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_v10_spec_type"].(map[string]interface{}); ok && (isImport || data.OIDCV10SpecType != nil) {
		data.OIDCV10SpecType = &OIDCProviderOIDCV10SpecTypeModel{
			AllowedClockSkew: func() types.String {
				if v, ok := blockData["allowed_clock_skew"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DisableUserInfo: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.DisableUserInfo
				}
				// Import case: read from API
				if v, ok := blockData["disable_user_info"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisplayName: func() types.String {
				if v, ok := blockData["display_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ForwardedQueryParameters: func() types.String {
				if v, ok := blockData["forwarded_query_parameters"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PassCurrentLocale: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.PassCurrentLocale
				}
				// Import case: read from API
				if v, ok := blockData["pass_current_locale"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			PassLoginHint: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.PassLoginHint
				}
				// Import case: read from API
				if v, ok := blockData["pass_login_hint"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ValidateSignatures: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.ValidateSignatures
				}
				// Import case: read from API
				if v, ok := blockData["validate_signatures"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["okta_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.OktaOIDCSpecType != nil) {
		data.OktaOIDCSpecType = &OIDCProviderOktaOIDCSpecTypeModel{
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.OktaOIDCSpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OktaOIDCSpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["provider_type"].(string); ok && v != "" {
		data.ProviderType = types.StringValue(v)
	} else {
		data.ProviderType = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OIDCProviderResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data OIDCProviderResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.OIDCProvider{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AzureOIDCSpecType != nil {
		azure_oidc_spec_typeMap := make(map[string]interface{})
		if !data.AzureOIDCSpecType.AuthorizationURL.IsNull() && !data.AzureOIDCSpecType.AuthorizationURL.IsUnknown() {
			azure_oidc_spec_typeMap["authorization_url"] = data.AzureOIDCSpecType.AuthorizationURL.ValueString()
		}
		if !data.AzureOIDCSpecType.BackchannelLogout.IsNull() && !data.AzureOIDCSpecType.BackchannelLogout.IsUnknown() {
			azure_oidc_spec_typeMap["backchannel_logout"] = data.AzureOIDCSpecType.BackchannelLogout.ValueBool()
		}
		if !data.AzureOIDCSpecType.ClientID.IsNull() && !data.AzureOIDCSpecType.ClientID.IsUnknown() {
			azure_oidc_spec_typeMap["client_id"] = data.AzureOIDCSpecType.ClientID.ValueString()
		}
		if !data.AzureOIDCSpecType.ClientSecret.IsNull() && !data.AzureOIDCSpecType.ClientSecret.IsUnknown() {
			azure_oidc_spec_typeMap["client_secret"] = data.AzureOIDCSpecType.ClientSecret.ValueString()
		}
		if !data.AzureOIDCSpecType.DefaultScopes.IsNull() && !data.AzureOIDCSpecType.DefaultScopes.IsUnknown() {
			azure_oidc_spec_typeMap["default_scopes"] = data.AzureOIDCSpecType.DefaultScopes.ValueString()
		}
		if !data.AzureOIDCSpecType.Issuer.IsNull() && !data.AzureOIDCSpecType.Issuer.IsUnknown() {
			azure_oidc_spec_typeMap["issuer"] = data.AzureOIDCSpecType.Issuer.ValueString()
		}
		if !data.AzureOIDCSpecType.JwksURL.IsNull() && !data.AzureOIDCSpecType.JwksURL.IsUnknown() {
			azure_oidc_spec_typeMap["jwks_url"] = data.AzureOIDCSpecType.JwksURL.ValueString()
		}
		if !data.AzureOIDCSpecType.LogoutURL.IsNull() && !data.AzureOIDCSpecType.LogoutURL.IsUnknown() {
			azure_oidc_spec_typeMap["logout_url"] = data.AzureOIDCSpecType.LogoutURL.ValueString()
		}
		if !data.AzureOIDCSpecType.Prompt.IsNull() && !data.AzureOIDCSpecType.Prompt.IsUnknown() {
			azure_oidc_spec_typeMap["prompt"] = data.AzureOIDCSpecType.Prompt.ValueString()
		}
		if !data.AzureOIDCSpecType.TokenURL.IsNull() && !data.AzureOIDCSpecType.TokenURL.IsUnknown() {
			azure_oidc_spec_typeMap["token_url"] = data.AzureOIDCSpecType.TokenURL.ValueString()
		}
		if !data.AzureOIDCSpecType.UserInfoURL.IsNull() && !data.AzureOIDCSpecType.UserInfoURL.IsUnknown() {
			azure_oidc_spec_typeMap["user_info_url"] = data.AzureOIDCSpecType.UserInfoURL.ValueString()
		}
		apiResource.Spec["azure_oidc_spec_type"] = azure_oidc_spec_typeMap
	}
	if data.GoogleOIDCSpecType != nil {
		google_oidc_spec_typeMap := make(map[string]interface{})
		if !data.GoogleOIDCSpecType.ClientID.IsNull() && !data.GoogleOIDCSpecType.ClientID.IsUnknown() {
			google_oidc_spec_typeMap["client_id"] = data.GoogleOIDCSpecType.ClientID.ValueString()
		}
		if !data.GoogleOIDCSpecType.ClientSecret.IsNull() && !data.GoogleOIDCSpecType.ClientSecret.IsUnknown() {
			google_oidc_spec_typeMap["client_secret"] = data.GoogleOIDCSpecType.ClientSecret.ValueString()
		}
		if !data.GoogleOIDCSpecType.HostedDomain.IsNull() && !data.GoogleOIDCSpecType.HostedDomain.IsUnknown() {
			google_oidc_spec_typeMap["hosted_domain"] = data.GoogleOIDCSpecType.HostedDomain.ValueString()
		}
		apiResource.Spec["google_oidc_spec_type"] = google_oidc_spec_typeMap
	}
	if data.OIDCV10SpecType != nil {
		oidc_v10_spec_typeMap := make(map[string]interface{})
		if !data.OIDCV10SpecType.AllowedClockSkew.IsNull() && !data.OIDCV10SpecType.AllowedClockSkew.IsUnknown() {
			oidc_v10_spec_typeMap["allowed_clock_skew"] = data.OIDCV10SpecType.AllowedClockSkew.ValueString()
		}
		if !data.OIDCV10SpecType.AuthorizationURL.IsNull() && !data.OIDCV10SpecType.AuthorizationURL.IsUnknown() {
			oidc_v10_spec_typeMap["authorization_url"] = data.OIDCV10SpecType.AuthorizationURL.ValueString()
		}
		if !data.OIDCV10SpecType.BackchannelLogout.IsNull() && !data.OIDCV10SpecType.BackchannelLogout.IsUnknown() {
			oidc_v10_spec_typeMap["backchannel_logout"] = data.OIDCV10SpecType.BackchannelLogout.ValueBool()
		}
		if !data.OIDCV10SpecType.ClientID.IsNull() && !data.OIDCV10SpecType.ClientID.IsUnknown() {
			oidc_v10_spec_typeMap["client_id"] = data.OIDCV10SpecType.ClientID.ValueString()
		}
		if !data.OIDCV10SpecType.ClientSecret.IsNull() && !data.OIDCV10SpecType.ClientSecret.IsUnknown() {
			oidc_v10_spec_typeMap["client_secret"] = data.OIDCV10SpecType.ClientSecret.ValueString()
		}
		if !data.OIDCV10SpecType.DefaultScopes.IsNull() && !data.OIDCV10SpecType.DefaultScopes.IsUnknown() {
			oidc_v10_spec_typeMap["default_scopes"] = data.OIDCV10SpecType.DefaultScopes.ValueString()
		}
		if !data.OIDCV10SpecType.DisableUserInfo.IsNull() && !data.OIDCV10SpecType.DisableUserInfo.IsUnknown() {
			oidc_v10_spec_typeMap["disable_user_info"] = data.OIDCV10SpecType.DisableUserInfo.ValueBool()
		}
		if !data.OIDCV10SpecType.DisplayName.IsNull() && !data.OIDCV10SpecType.DisplayName.IsUnknown() {
			oidc_v10_spec_typeMap["display_name"] = data.OIDCV10SpecType.DisplayName.ValueString()
		}
		if !data.OIDCV10SpecType.ForwardedQueryParameters.IsNull() && !data.OIDCV10SpecType.ForwardedQueryParameters.IsUnknown() {
			oidc_v10_spec_typeMap["forwarded_query_parameters"] = data.OIDCV10SpecType.ForwardedQueryParameters.ValueString()
		}
		if !data.OIDCV10SpecType.Issuer.IsNull() && !data.OIDCV10SpecType.Issuer.IsUnknown() {
			oidc_v10_spec_typeMap["issuer"] = data.OIDCV10SpecType.Issuer.ValueString()
		}
		if !data.OIDCV10SpecType.JwksURL.IsNull() && !data.OIDCV10SpecType.JwksURL.IsUnknown() {
			oidc_v10_spec_typeMap["jwks_url"] = data.OIDCV10SpecType.JwksURL.ValueString()
		}
		if !data.OIDCV10SpecType.LogoutURL.IsNull() && !data.OIDCV10SpecType.LogoutURL.IsUnknown() {
			oidc_v10_spec_typeMap["logout_url"] = data.OIDCV10SpecType.LogoutURL.ValueString()
		}
		if !data.OIDCV10SpecType.PassCurrentLocale.IsNull() && !data.OIDCV10SpecType.PassCurrentLocale.IsUnknown() {
			oidc_v10_spec_typeMap["pass_current_locale"] = data.OIDCV10SpecType.PassCurrentLocale.ValueBool()
		}
		if !data.OIDCV10SpecType.PassLoginHint.IsNull() && !data.OIDCV10SpecType.PassLoginHint.IsUnknown() {
			oidc_v10_spec_typeMap["pass_login_hint"] = data.OIDCV10SpecType.PassLoginHint.ValueBool()
		}
		if !data.OIDCV10SpecType.Prompt.IsNull() && !data.OIDCV10SpecType.Prompt.IsUnknown() {
			oidc_v10_spec_typeMap["prompt"] = data.OIDCV10SpecType.Prompt.ValueString()
		}
		if !data.OIDCV10SpecType.TokenURL.IsNull() && !data.OIDCV10SpecType.TokenURL.IsUnknown() {
			oidc_v10_spec_typeMap["token_url"] = data.OIDCV10SpecType.TokenURL.ValueString()
		}
		if !data.OIDCV10SpecType.UserInfoURL.IsNull() && !data.OIDCV10SpecType.UserInfoURL.IsUnknown() {
			oidc_v10_spec_typeMap["user_info_url"] = data.OIDCV10SpecType.UserInfoURL.ValueString()
		}
		if !data.OIDCV10SpecType.ValidateSignatures.IsNull() && !data.OIDCV10SpecType.ValidateSignatures.IsUnknown() {
			oidc_v10_spec_typeMap["validate_signatures"] = data.OIDCV10SpecType.ValidateSignatures.ValueBool()
		}
		apiResource.Spec["oidc_v10_spec_type"] = oidc_v10_spec_typeMap
	}
	if data.OktaOIDCSpecType != nil {
		okta_oidc_spec_typeMap := make(map[string]interface{})
		if !data.OktaOIDCSpecType.AuthorizationURL.IsNull() && !data.OktaOIDCSpecType.AuthorizationURL.IsUnknown() {
			okta_oidc_spec_typeMap["authorization_url"] = data.OktaOIDCSpecType.AuthorizationURL.ValueString()
		}
		if !data.OktaOIDCSpecType.BackchannelLogout.IsNull() && !data.OktaOIDCSpecType.BackchannelLogout.IsUnknown() {
			okta_oidc_spec_typeMap["backchannel_logout"] = data.OktaOIDCSpecType.BackchannelLogout.ValueBool()
		}
		if !data.OktaOIDCSpecType.ClientID.IsNull() && !data.OktaOIDCSpecType.ClientID.IsUnknown() {
			okta_oidc_spec_typeMap["client_id"] = data.OktaOIDCSpecType.ClientID.ValueString()
		}
		if !data.OktaOIDCSpecType.ClientSecret.IsNull() && !data.OktaOIDCSpecType.ClientSecret.IsUnknown() {
			okta_oidc_spec_typeMap["client_secret"] = data.OktaOIDCSpecType.ClientSecret.ValueString()
		}
		if !data.OktaOIDCSpecType.DefaultScopes.IsNull() && !data.OktaOIDCSpecType.DefaultScopes.IsUnknown() {
			okta_oidc_spec_typeMap["default_scopes"] = data.OktaOIDCSpecType.DefaultScopes.ValueString()
		}
		if !data.OktaOIDCSpecType.Issuer.IsNull() && !data.OktaOIDCSpecType.Issuer.IsUnknown() {
			okta_oidc_spec_typeMap["issuer"] = data.OktaOIDCSpecType.Issuer.ValueString()
		}
		if !data.OktaOIDCSpecType.JwksURL.IsNull() && !data.OktaOIDCSpecType.JwksURL.IsUnknown() {
			okta_oidc_spec_typeMap["jwks_url"] = data.OktaOIDCSpecType.JwksURL.ValueString()
		}
		if !data.OktaOIDCSpecType.LogoutURL.IsNull() && !data.OktaOIDCSpecType.LogoutURL.IsUnknown() {
			okta_oidc_spec_typeMap["logout_url"] = data.OktaOIDCSpecType.LogoutURL.ValueString()
		}
		if !data.OktaOIDCSpecType.Prompt.IsNull() && !data.OktaOIDCSpecType.Prompt.IsUnknown() {
			okta_oidc_spec_typeMap["prompt"] = data.OktaOIDCSpecType.Prompt.ValueString()
		}
		if !data.OktaOIDCSpecType.TokenURL.IsNull() && !data.OktaOIDCSpecType.TokenURL.IsUnknown() {
			okta_oidc_spec_typeMap["token_url"] = data.OktaOIDCSpecType.TokenURL.ValueString()
		}
		if !data.OktaOIDCSpecType.UserInfoURL.IsNull() && !data.OktaOIDCSpecType.UserInfoURL.IsUnknown() {
			okta_oidc_spec_typeMap["user_info_url"] = data.OktaOIDCSpecType.UserInfoURL.ValueString()
		}
		apiResource.Spec["okta_oidc_spec_type"] = okta_oidc_spec_typeMap
	}
	if !data.ProviderType.IsNull() && !data.ProviderType.IsUnknown() {
		apiResource.Spec["provider_type"] = data.ProviderType.ValueString()
	}

	_, err := r.client.UpdateOIDCProvider(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update OIDCProvider: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetOIDCProvider(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read OIDCProvider after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["provider_type"].(string); ok && v != "" {
		data.ProviderType = types.StringValue(v)
	} else if data.ProviderType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ProviderType = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["azure_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.AzureOIDCSpecType != nil) {
		data.AzureOIDCSpecType = &OIDCProviderAzureOIDCSpecTypeModel{
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.AzureOIDCSpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.AzureOIDCSpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["google_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.GoogleOIDCSpecType != nil) {
		data.GoogleOIDCSpecType = &OIDCProviderGoogleOIDCSpecTypeModel{
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HostedDomain: func() types.String {
				if v, ok := blockData["hosted_domain"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["oidc_v10_spec_type"].(map[string]interface{}); ok && (isImport || data.OIDCV10SpecType != nil) {
		data.OIDCV10SpecType = &OIDCProviderOIDCV10SpecTypeModel{
			AllowedClockSkew: func() types.String {
				if v, ok := blockData["allowed_clock_skew"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DisableUserInfo: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.DisableUserInfo
				}
				// Import case: read from API
				if v, ok := blockData["disable_user_info"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			DisplayName: func() types.String {
				if v, ok := blockData["display_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ForwardedQueryParameters: func() types.String {
				if v, ok := blockData["forwarded_query_parameters"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PassCurrentLocale: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.PassCurrentLocale
				}
				// Import case: read from API
				if v, ok := blockData["pass_current_locale"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			PassLoginHint: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.PassLoginHint
				}
				// Import case: read from API
				if v, ok := blockData["pass_login_hint"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ValidateSignatures: func() types.Bool {
				if !isImport && data.OIDCV10SpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OIDCV10SpecType.ValidateSignatures
				}
				// Import case: read from API
				if v, ok := blockData["validate_signatures"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["okta_oidc_spec_type"].(map[string]interface{}); ok && (isImport || data.OktaOIDCSpecType != nil) {
		data.OktaOIDCSpecType = &OIDCProviderOktaOIDCSpecTypeModel{
			AuthorizationURL: func() types.String {
				if v, ok := blockData["authorization_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			BackchannelLogout: func() types.Bool {
				if !isImport && data.OktaOIDCSpecType != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.OktaOIDCSpecType.BackchannelLogout
				}
				// Import case: read from API
				if v, ok := blockData["backchannel_logout"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			ClientID: func() types.String {
				if v, ok := blockData["client_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClientSecret: func() types.String {
				if v, ok := blockData["client_secret"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultScopes: func() types.String {
				if v, ok := blockData["default_scopes"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Issuer: func() types.String {
				if v, ok := blockData["issuer"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			JwksURL: func() types.String {
				if v, ok := blockData["jwks_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			LogoutURL: func() types.String {
				if v, ok := blockData["logout_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Prompt: func() types.String {
				if v, ok := blockData["prompt"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TokenURL: func() types.String {
				if v, ok := blockData["token_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			UserInfoURL: func() types.String {
				if v, ok := blockData["user_info_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["provider_type"].(string); ok && v != "" {
		data.ProviderType = types.StringValue(v)
	} else {
		data.ProviderType = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OIDCProviderResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data OIDCProviderResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteOIDCProvider(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "OIDCProvider already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "OIDCProvider delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete OIDCProvider: %s", err))
		return
	}
}

func (r *OIDCProviderResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
