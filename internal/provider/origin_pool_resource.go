// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &OriginPoolResource{}
	_ resource.ResourceWithConfigure      = &OriginPoolResource{}
	_ resource.ResourceWithImportState    = &OriginPoolResource{}
	_ resource.ResourceWithModifyPlan     = &OriginPoolResource{}
	_ resource.ResourceWithValidateConfig = &OriginPoolResource{}
)

func NewOriginPoolResource() resource.Resource {
	return &OriginPoolResource{}
}

type OriginPoolResource struct {
	client *client.Client
}

// OriginPoolEmptyModel represents empty nested blocks
type OriginPoolEmptyModel struct {
}

// OriginPoolAdvancedOptionsModel represents advanced_options block
type OriginPoolAdvancedOptionsModel struct {
	ConnectionTimeout            types.Int64                                     `tfsdk:"connection_timeout"`
	HTTPIdleTimeout              types.Int64                                     `tfsdk:"http_idle_timeout"`
	PanicThreshold               types.Int64                                     `tfsdk:"panic_threshold"`
	AutoHTTPConfig               *OriginPoolEmptyModel                           `tfsdk:"auto_http_config"`
	CircuitBreaker               *OriginPoolAdvancedOptionsCircuitBreakerModel   `tfsdk:"circuit_breaker"`
	DefaultCircuitBreaker        *OriginPoolEmptyModel                           `tfsdk:"default_circuit_breaker"`
	DisableCircuitBreaker        *OriginPoolEmptyModel                           `tfsdk:"disable_circuit_breaker"`
	DisableLBSourceIPPersistance *OriginPoolEmptyModel                           `tfsdk:"disable_lb_source_ip_persistance"`
	DisableOutlierDetection      *OriginPoolEmptyModel                           `tfsdk:"disable_outlier_detection"`
	DisableProxyProtocol         *OriginPoolEmptyModel                           `tfsdk:"disable_proxy_protocol"`
	DisableSubsets               *OriginPoolEmptyModel                           `tfsdk:"disable_subsets"`
	EnableLBSourceIPPersistance  *OriginPoolEmptyModel                           `tfsdk:"enable_lb_source_ip_persistance"`
	EnableSubsets                *OriginPoolAdvancedOptionsEnableSubsetsModel    `tfsdk:"enable_subsets"`
	Http1Config                  *OriginPoolAdvancedOptionsHttp1ConfigModel      `tfsdk:"http1_config"`
	Http2Options                 *OriginPoolAdvancedOptionsHttp2OptionsModel     `tfsdk:"http2_options"`
	NoPanicThreshold             *OriginPoolEmptyModel                           `tfsdk:"no_panic_threshold"`
	OutlierDetection             *OriginPoolAdvancedOptionsOutlierDetectionModel `tfsdk:"outlier_detection"`
	ProxyProtocolV1              *OriginPoolEmptyModel                           `tfsdk:"proxy_protocol_v1"`
	ProxyProtocolV2              *OriginPoolEmptyModel                           `tfsdk:"proxy_protocol_v2"`
}

// OriginPoolAdvancedOptionsModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsModel
var OriginPoolAdvancedOptionsModelAttrTypes = map[string]attr.Type{
	"connection_timeout":               types.Int64Type,
	"http_idle_timeout":                types.Int64Type,
	"panic_threshold":                  types.Int64Type,
	"auto_http_config":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"circuit_breaker":                  types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsCircuitBreakerModelAttrTypes},
	"default_circuit_breaker":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_circuit_breaker":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_lb_source_ip_persistance": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_outlier_detection":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_proxy_protocol":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_subsets":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_lb_source_ip_persistance":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_subsets":                   types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsEnableSubsetsModelAttrTypes},
	"http1_config":                     types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsHttp1ConfigModelAttrTypes},
	"http2_options":                    types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsHttp2OptionsModelAttrTypes},
	"no_panic_threshold":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outlier_detection":                types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsOutlierDetectionModelAttrTypes},
	"proxy_protocol_v1":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proxy_protocol_v2":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolAdvancedOptionsCircuitBreakerModel represents circuit_breaker block
type OriginPoolAdvancedOptionsCircuitBreakerModel struct {
	ConnectionLimit types.Int64  `tfsdk:"connection_limit"`
	MaxRequests     types.Int64  `tfsdk:"max_requests"`
	PendingRequests types.Int64  `tfsdk:"pending_requests"`
	Priority        types.String `tfsdk:"priority"`
	Retries         types.Int64  `tfsdk:"retries"`
}

// OriginPoolAdvancedOptionsCircuitBreakerModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsCircuitBreakerModel
var OriginPoolAdvancedOptionsCircuitBreakerModelAttrTypes = map[string]attr.Type{
	"connection_limit": types.Int64Type,
	"max_requests":     types.Int64Type,
	"pending_requests": types.Int64Type,
	"priority":         types.StringType,
	"retries":          types.Int64Type,
}

// OriginPoolAdvancedOptionsEnableSubsetsModel represents enable_subsets block
type OriginPoolAdvancedOptionsEnableSubsetsModel struct {
	AnyEndpoint     *OriginPoolEmptyModel                                        `tfsdk:"any_endpoint"`
	DefaultSubset   *OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel    `tfsdk:"default_subset"`
	EndpointSubsets []OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel `tfsdk:"endpoint_subsets"`
	FailRequest     *OriginPoolEmptyModel                                        `tfsdk:"fail_request"`
}

// OriginPoolAdvancedOptionsEnableSubsetsModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsEnableSubsetsModel
var OriginPoolAdvancedOptionsEnableSubsetsModelAttrTypes = map[string]attr.Type{
	"any_endpoint":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_subset":   types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModelAttrTypes},
	"endpoint_subsets": types.ListType{ElemType: types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModelAttrTypes}},
	"fail_request":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel represents default_subset block
type OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel struct {
	DefaultSubset *OriginPoolEmptyModel `tfsdk:"default_subset"`
}

// OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModel
var OriginPoolAdvancedOptionsEnableSubsetsDefaultSubsetModelAttrTypes = map[string]attr.Type{
	"default_subset": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel represents endpoint_subsets block
type OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel struct {
	Keys types.List `tfsdk:"keys"`
}

// OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModel
var OriginPoolAdvancedOptionsEnableSubsetsEndpointSubsetsModelAttrTypes = map[string]attr.Type{
	"keys": types.ListType{ElemType: types.StringType},
}

// OriginPoolAdvancedOptionsHttp1ConfigModel represents http1_config block
type OriginPoolAdvancedOptionsHttp1ConfigModel struct {
	HeaderTransformation *OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel `tfsdk:"header_transformation"`
}

// OriginPoolAdvancedOptionsHttp1ConfigModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsHttp1ConfigModel
var OriginPoolAdvancedOptionsHttp1ConfigModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModelAttrTypes},
}

// OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel represents header_transformation block
type OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel struct {
	DefaultHeaderTransformation      *OriginPoolEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *OriginPoolEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *OriginPoolEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *OriginPoolEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModel
var OriginPoolAdvancedOptionsHttp1ConfigHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolAdvancedOptionsHttp2OptionsModel represents http2_options block
type OriginPoolAdvancedOptionsHttp2OptionsModel struct {
	Enabled types.Bool `tfsdk:"enabled"`
}

// OriginPoolAdvancedOptionsHttp2OptionsModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsHttp2OptionsModel
var OriginPoolAdvancedOptionsHttp2OptionsModelAttrTypes = map[string]attr.Type{
	"enabled": types.BoolType,
}

// OriginPoolAdvancedOptionsOutlierDetectionModel represents outlier_detection block
type OriginPoolAdvancedOptionsOutlierDetectionModel struct {
	BaseEjectionTime          types.Int64 `tfsdk:"base_ejection_time"`
	Consecutive5xx            types.Int64 `tfsdk:"consecutive_5xx"`
	ConsecutiveGatewayFailure types.Int64 `tfsdk:"consecutive_gateway_failure"`
	Interval                  types.Int64 `tfsdk:"interval"`
	MaxEjectionPercent        types.Int64 `tfsdk:"max_ejection_percent"`
}

// OriginPoolAdvancedOptionsOutlierDetectionModelAttrTypes defines the attribute types for OriginPoolAdvancedOptionsOutlierDetectionModel
var OriginPoolAdvancedOptionsOutlierDetectionModelAttrTypes = map[string]attr.Type{
	"base_ejection_time":          types.Int64Type,
	"consecutive_5xx":             types.Int64Type,
	"consecutive_gateway_failure": types.Int64Type,
	"interval":                    types.Int64Type,
	"max_ejection_percent":        types.Int64Type,
}

// OriginPoolHealthcheckModel represents healthcheck block
type OriginPoolHealthcheckModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolHealthcheckModelAttrTypes defines the attribute types for OriginPoolHealthcheckModel
var OriginPoolHealthcheckModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersModel represents origin_servers block
type OriginPoolOriginServersModel struct {
	CbipService          *OriginPoolOriginServersCbipServiceModel          `tfsdk:"cbip_service"`
	ConsulService        *OriginPoolOriginServersConsulServiceModel        `tfsdk:"consul_service"`
	CustomEndpointObject *OriginPoolOriginServersCustomEndpointObjectModel `tfsdk:"custom_endpoint_object"`
	K8SService           *OriginPoolOriginServersK8SServiceModel           `tfsdk:"k8s_service"`
	Labels               *OriginPoolEmptyModel                             `tfsdk:"labels"`
	PrivateIP            *OriginPoolOriginServersPrivateIPModel            `tfsdk:"private_ip"`
	PrivateName          *OriginPoolOriginServersPrivateNameModel          `tfsdk:"private_name"`
	PublicIP             *OriginPoolOriginServersPublicIPModel             `tfsdk:"public_ip"`
	PublicName           *OriginPoolOriginServersPublicNameModel           `tfsdk:"public_name"`
	VnPrivateIP          *OriginPoolOriginServersVnPrivateIPModel          `tfsdk:"vn_private_ip"`
	VnPrivateName        *OriginPoolOriginServersVnPrivateNameModel        `tfsdk:"vn_private_name"`
}

// OriginPoolOriginServersModelAttrTypes defines the attribute types for OriginPoolOriginServersModel
var OriginPoolOriginServersModelAttrTypes = map[string]attr.Type{
	"cbip_service":           types.ObjectType{AttrTypes: OriginPoolOriginServersCbipServiceModelAttrTypes},
	"consul_service":         types.ObjectType{AttrTypes: OriginPoolOriginServersConsulServiceModelAttrTypes},
	"custom_endpoint_object": types.ObjectType{AttrTypes: OriginPoolOriginServersCustomEndpointObjectModelAttrTypes},
	"k8s_service":            types.ObjectType{AttrTypes: OriginPoolOriginServersK8SServiceModelAttrTypes},
	"labels":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_ip":             types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPModelAttrTypes},
	"private_name":           types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameModelAttrTypes},
	"public_ip":              types.ObjectType{AttrTypes: OriginPoolOriginServersPublicIPModelAttrTypes},
	"public_name":            types.ObjectType{AttrTypes: OriginPoolOriginServersPublicNameModelAttrTypes},
	"vn_private_ip":          types.ObjectType{AttrTypes: OriginPoolOriginServersVnPrivateIPModelAttrTypes},
	"vn_private_name":        types.ObjectType{AttrTypes: OriginPoolOriginServersVnPrivateNameModelAttrTypes},
}

// OriginPoolOriginServersCbipServiceModel represents cbip_service block
type OriginPoolOriginServersCbipServiceModel struct {
	ServiceName types.String `tfsdk:"service_name"`
}

// OriginPoolOriginServersCbipServiceModelAttrTypes defines the attribute types for OriginPoolOriginServersCbipServiceModel
var OriginPoolOriginServersCbipServiceModelAttrTypes = map[string]attr.Type{
	"service_name": types.StringType,
}

// OriginPoolOriginServersConsulServiceModel represents consul_service block
type OriginPoolOriginServersConsulServiceModel struct {
	ServiceName    types.String                                          `tfsdk:"service_name"`
	InsideNetwork  *OriginPoolEmptyModel                                 `tfsdk:"inside_network"`
	OutsideNetwork *OriginPoolEmptyModel                                 `tfsdk:"outside_network"`
	SiteLocator    *OriginPoolOriginServersConsulServiceSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool       *OriginPoolOriginServersConsulServiceSnatPoolModel    `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersConsulServiceModelAttrTypes defines the attribute types for OriginPoolOriginServersConsulServiceModel
var OriginPoolOriginServersConsulServiceModelAttrTypes = map[string]attr.Type{
	"service_name":    types.StringType,
	"inside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_locator":    types.ObjectType{AttrTypes: OriginPoolOriginServersConsulServiceSiteLocatorModelAttrTypes},
	"snat_pool":       types.ObjectType{AttrTypes: OriginPoolOriginServersConsulServiceSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersConsulServiceSiteLocatorModel represents site_locator block
type OriginPoolOriginServersConsulServiceSiteLocatorModel struct {
	Site        *OriginPoolOriginServersConsulServiceSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// OriginPoolOriginServersConsulServiceSiteLocatorModelAttrTypes defines the attribute types for OriginPoolOriginServersConsulServiceSiteLocatorModel
var OriginPoolOriginServersConsulServiceSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: OriginPoolOriginServersConsulServiceSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModelAttrTypes},
}

// OriginPoolOriginServersConsulServiceSiteLocatorSiteModel represents site block
type OriginPoolOriginServersConsulServiceSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersConsulServiceSiteLocatorSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersConsulServiceSiteLocatorSiteModel
var OriginPoolOriginServersConsulServiceSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel represents virtual_site block
type OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModel
var OriginPoolOriginServersConsulServiceSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersConsulServiceSnatPoolModel represents snat_pool block
type OriginPoolOriginServersConsulServiceSnatPoolModel struct {
	NoSnatPool *OriginPoolEmptyModel                                      `tfsdk:"no_snat_pool"`
	SnatPool   *OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersConsulServiceSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersConsulServiceSnatPoolModel
var OriginPoolOriginServersConsulServiceSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModel represents snat_pool block
type OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModel
var OriginPoolOriginServersConsulServiceSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// OriginPoolOriginServersCustomEndpointObjectModel represents custom_endpoint_object block
type OriginPoolOriginServersCustomEndpointObjectModel struct {
	Endpoint *OriginPoolOriginServersCustomEndpointObjectEndpointModel `tfsdk:"endpoint"`
}

// OriginPoolOriginServersCustomEndpointObjectModelAttrTypes defines the attribute types for OriginPoolOriginServersCustomEndpointObjectModel
var OriginPoolOriginServersCustomEndpointObjectModelAttrTypes = map[string]attr.Type{
	"endpoint": types.ObjectType{AttrTypes: OriginPoolOriginServersCustomEndpointObjectEndpointModelAttrTypes},
}

// OriginPoolOriginServersCustomEndpointObjectEndpointModel represents endpoint block
type OriginPoolOriginServersCustomEndpointObjectEndpointModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersCustomEndpointObjectEndpointModelAttrTypes defines the attribute types for OriginPoolOriginServersCustomEndpointObjectEndpointModel
var OriginPoolOriginServersCustomEndpointObjectEndpointModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersK8SServiceModel represents k8s_service block
type OriginPoolOriginServersK8SServiceModel struct {
	Protocol       types.String                                       `tfsdk:"protocol"`
	ServiceName    types.String                                       `tfsdk:"service_name"`
	InsideNetwork  *OriginPoolEmptyModel                              `tfsdk:"inside_network"`
	OutsideNetwork *OriginPoolEmptyModel                              `tfsdk:"outside_network"`
	SiteLocator    *OriginPoolOriginServersK8SServiceSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool       *OriginPoolOriginServersK8SServiceSnatPoolModel    `tfsdk:"snat_pool"`
	Vk8sNetworks   *OriginPoolEmptyModel                              `tfsdk:"vk8s_networks"`
}

// OriginPoolOriginServersK8SServiceModelAttrTypes defines the attribute types for OriginPoolOriginServersK8SServiceModel
var OriginPoolOriginServersK8SServiceModelAttrTypes = map[string]attr.Type{
	"protocol":        types.StringType,
	"service_name":    types.StringType,
	"inside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"site_locator":    types.ObjectType{AttrTypes: OriginPoolOriginServersK8SServiceSiteLocatorModelAttrTypes},
	"snat_pool":       types.ObjectType{AttrTypes: OriginPoolOriginServersK8SServiceSnatPoolModelAttrTypes},
	"vk8s_networks":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolOriginServersK8SServiceSiteLocatorModel represents site_locator block
type OriginPoolOriginServersK8SServiceSiteLocatorModel struct {
	Site        *OriginPoolOriginServersK8SServiceSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// OriginPoolOriginServersK8SServiceSiteLocatorModelAttrTypes defines the attribute types for OriginPoolOriginServersK8SServiceSiteLocatorModel
var OriginPoolOriginServersK8SServiceSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: OriginPoolOriginServersK8SServiceSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModelAttrTypes},
}

// OriginPoolOriginServersK8SServiceSiteLocatorSiteModel represents site block
type OriginPoolOriginServersK8SServiceSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersK8SServiceSiteLocatorSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersK8SServiceSiteLocatorSiteModel
var OriginPoolOriginServersK8SServiceSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel represents virtual_site block
type OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModel
var OriginPoolOriginServersK8SServiceSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersK8SServiceSnatPoolModel represents snat_pool block
type OriginPoolOriginServersK8SServiceSnatPoolModel struct {
	NoSnatPool *OriginPoolEmptyModel                                   `tfsdk:"no_snat_pool"`
	SnatPool   *OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersK8SServiceSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersK8SServiceSnatPoolModel
var OriginPoolOriginServersK8SServiceSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModel represents snat_pool block
type OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModel
var OriginPoolOriginServersK8SServiceSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// OriginPoolOriginServersPrivateIPModel represents private_ip block
type OriginPoolOriginServersPrivateIPModel struct {
	IP             types.String                                      `tfsdk:"ip"`
	InsideNetwork  *OriginPoolEmptyModel                             `tfsdk:"inside_network"`
	OutsideNetwork *OriginPoolEmptyModel                             `tfsdk:"outside_network"`
	Segment        *OriginPoolOriginServersPrivateIPSegmentModel     `tfsdk:"segment"`
	SiteLocator    *OriginPoolOriginServersPrivateIPSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool       *OriginPoolOriginServersPrivateIPSnatPoolModel    `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersPrivateIPModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPModel
var OriginPoolOriginServersPrivateIPModelAttrTypes = map[string]attr.Type{
	"ip":              types.StringType,
	"inside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"segment":         types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPSegmentModelAttrTypes},
	"site_locator":    types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPSiteLocatorModelAttrTypes},
	"snat_pool":       types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersPrivateIPSegmentModel represents segment block
type OriginPoolOriginServersPrivateIPSegmentModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersPrivateIPSegmentModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPSegmentModel
var OriginPoolOriginServersPrivateIPSegmentModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersPrivateIPSiteLocatorModel represents site_locator block
type OriginPoolOriginServersPrivateIPSiteLocatorModel struct {
	Site        *OriginPoolOriginServersPrivateIPSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// OriginPoolOriginServersPrivateIPSiteLocatorModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPSiteLocatorModel
var OriginPoolOriginServersPrivateIPSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModelAttrTypes},
}

// OriginPoolOriginServersPrivateIPSiteLocatorSiteModel represents site block
type OriginPoolOriginServersPrivateIPSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersPrivateIPSiteLocatorSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPSiteLocatorSiteModel
var OriginPoolOriginServersPrivateIPSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel represents virtual_site block
type OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModel
var OriginPoolOriginServersPrivateIPSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersPrivateIPSnatPoolModel represents snat_pool block
type OriginPoolOriginServersPrivateIPSnatPoolModel struct {
	NoSnatPool *OriginPoolEmptyModel                                  `tfsdk:"no_snat_pool"`
	SnatPool   *OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersPrivateIPSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPSnatPoolModel
var OriginPoolOriginServersPrivateIPSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModel represents snat_pool block
type OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModel
var OriginPoolOriginServersPrivateIPSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// OriginPoolOriginServersPrivateNameModel represents private_name block
type OriginPoolOriginServersPrivateNameModel struct {
	DNSName         types.String                                        `tfsdk:"dns_name"`
	RefreshInterval types.Int64                                         `tfsdk:"refresh_interval"`
	InsideNetwork   *OriginPoolEmptyModel                               `tfsdk:"inside_network"`
	OutsideNetwork  *OriginPoolEmptyModel                               `tfsdk:"outside_network"`
	Segment         *OriginPoolOriginServersPrivateNameSegmentModel     `tfsdk:"segment"`
	SiteLocator     *OriginPoolOriginServersPrivateNameSiteLocatorModel `tfsdk:"site_locator"`
	SnatPool        *OriginPoolOriginServersPrivateNameSnatPoolModel    `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersPrivateNameModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameModel
var OriginPoolOriginServersPrivateNameModelAttrTypes = map[string]attr.Type{
	"dns_name":         types.StringType,
	"refresh_interval": types.Int64Type,
	"inside_network":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_network":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"segment":          types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameSegmentModelAttrTypes},
	"site_locator":     types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameSiteLocatorModelAttrTypes},
	"snat_pool":        types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersPrivateNameSegmentModel represents segment block
type OriginPoolOriginServersPrivateNameSegmentModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersPrivateNameSegmentModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameSegmentModel
var OriginPoolOriginServersPrivateNameSegmentModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersPrivateNameSiteLocatorModel represents site_locator block
type OriginPoolOriginServersPrivateNameSiteLocatorModel struct {
	Site        *OriginPoolOriginServersPrivateNameSiteLocatorSiteModel        `tfsdk:"site"`
	VirtualSite *OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel `tfsdk:"virtual_site"`
}

// OriginPoolOriginServersPrivateNameSiteLocatorModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameSiteLocatorModel
var OriginPoolOriginServersPrivateNameSiteLocatorModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameSiteLocatorSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModelAttrTypes},
}

// OriginPoolOriginServersPrivateNameSiteLocatorSiteModel represents site block
type OriginPoolOriginServersPrivateNameSiteLocatorSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersPrivateNameSiteLocatorSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameSiteLocatorSiteModel
var OriginPoolOriginServersPrivateNameSiteLocatorSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel represents virtual_site block
type OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModel
var OriginPoolOriginServersPrivateNameSiteLocatorVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersPrivateNameSnatPoolModel represents snat_pool block
type OriginPoolOriginServersPrivateNameSnatPoolModel struct {
	NoSnatPool *OriginPoolEmptyModel                                    `tfsdk:"no_snat_pool"`
	SnatPool   *OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModel `tfsdk:"snat_pool"`
}

// OriginPoolOriginServersPrivateNameSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameSnatPoolModel
var OriginPoolOriginServersPrivateNameSnatPoolModelAttrTypes = map[string]attr.Type{
	"no_snat_pool": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"snat_pool":    types.ObjectType{AttrTypes: OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModelAttrTypes},
}

// OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModel represents snat_pool block
type OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModel struct {
	Prefixes types.List `tfsdk:"prefixes"`
}

// OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModelAttrTypes defines the attribute types for OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModel
var OriginPoolOriginServersPrivateNameSnatPoolSnatPoolModelAttrTypes = map[string]attr.Type{
	"prefixes": types.ListType{ElemType: types.StringType},
}

// OriginPoolOriginServersPublicIPModel represents public_ip block
type OriginPoolOriginServersPublicIPModel struct {
	IP types.String `tfsdk:"ip"`
}

// OriginPoolOriginServersPublicIPModelAttrTypes defines the attribute types for OriginPoolOriginServersPublicIPModel
var OriginPoolOriginServersPublicIPModelAttrTypes = map[string]attr.Type{
	"ip": types.StringType,
}

// OriginPoolOriginServersPublicNameModel represents public_name block
type OriginPoolOriginServersPublicNameModel struct {
	DNSName         types.String `tfsdk:"dns_name"`
	RefreshInterval types.Int64  `tfsdk:"refresh_interval"`
}

// OriginPoolOriginServersPublicNameModelAttrTypes defines the attribute types for OriginPoolOriginServersPublicNameModel
var OriginPoolOriginServersPublicNameModelAttrTypes = map[string]attr.Type{
	"dns_name":         types.StringType,
	"refresh_interval": types.Int64Type,
}

// OriginPoolOriginServersVnPrivateIPModel represents vn_private_ip block
type OriginPoolOriginServersVnPrivateIPModel struct {
	IP             types.String                                           `tfsdk:"ip"`
	VirtualNetwork *OriginPoolOriginServersVnPrivateIPVirtualNetworkModel `tfsdk:"virtual_network"`
}

// OriginPoolOriginServersVnPrivateIPModelAttrTypes defines the attribute types for OriginPoolOriginServersVnPrivateIPModel
var OriginPoolOriginServersVnPrivateIPModelAttrTypes = map[string]attr.Type{
	"ip":              types.StringType,
	"virtual_network": types.ObjectType{AttrTypes: OriginPoolOriginServersVnPrivateIPVirtualNetworkModelAttrTypes},
}

// OriginPoolOriginServersVnPrivateIPVirtualNetworkModel represents virtual_network block
type OriginPoolOriginServersVnPrivateIPVirtualNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersVnPrivateIPVirtualNetworkModelAttrTypes defines the attribute types for OriginPoolOriginServersVnPrivateIPVirtualNetworkModel
var OriginPoolOriginServersVnPrivateIPVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolOriginServersVnPrivateNameModel represents vn_private_name block
type OriginPoolOriginServersVnPrivateNameModel struct {
	DNSName        types.String                                             `tfsdk:"dns_name"`
	PrivateNetwork *OriginPoolOriginServersVnPrivateNamePrivateNetworkModel `tfsdk:"private_network"`
}

// OriginPoolOriginServersVnPrivateNameModelAttrTypes defines the attribute types for OriginPoolOriginServersVnPrivateNameModel
var OriginPoolOriginServersVnPrivateNameModelAttrTypes = map[string]attr.Type{
	"dns_name":        types.StringType,
	"private_network": types.ObjectType{AttrTypes: OriginPoolOriginServersVnPrivateNamePrivateNetworkModelAttrTypes},
}

// OriginPoolOriginServersVnPrivateNamePrivateNetworkModel represents private_network block
type OriginPoolOriginServersVnPrivateNamePrivateNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolOriginServersVnPrivateNamePrivateNetworkModelAttrTypes defines the attribute types for OriginPoolOriginServersVnPrivateNamePrivateNetworkModel
var OriginPoolOriginServersVnPrivateNamePrivateNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolUpstreamConnPoolReuseTypeModel represents upstream_conn_pool_reuse_type block
type OriginPoolUpstreamConnPoolReuseTypeModel struct {
	DisableConnPoolReuse *OriginPoolEmptyModel `tfsdk:"disable_conn_pool_reuse"`
	EnableConnPoolReuse  *OriginPoolEmptyModel `tfsdk:"enable_conn_pool_reuse"`
}

// OriginPoolUpstreamConnPoolReuseTypeModelAttrTypes defines the attribute types for OriginPoolUpstreamConnPoolReuseTypeModel
var OriginPoolUpstreamConnPoolReuseTypeModelAttrTypes = map[string]attr.Type{
	"disable_conn_pool_reuse": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_conn_pool_reuse":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolUseTLSModel represents use_tls block
type OriginPoolUseTLSModel struct {
	MaxSessionKeys           types.Int64                                 `tfsdk:"max_session_keys"`
	Sni                      types.String                                `tfsdk:"sni"`
	DefaultSessionKeyCaching *OriginPoolEmptyModel                       `tfsdk:"default_session_key_caching"`
	DisableSessionKeyCaching *OriginPoolEmptyModel                       `tfsdk:"disable_session_key_caching"`
	DisableSni               *OriginPoolEmptyModel                       `tfsdk:"disable_sni"`
	NoMtls                   *OriginPoolEmptyModel                       `tfsdk:"no_mtls"`
	SkipServerVerification   *OriginPoolEmptyModel                       `tfsdk:"skip_server_verification"`
	TLSConfig                *OriginPoolUseTLSTLSConfigModel             `tfsdk:"tls_config"`
	UseHostHeaderAsSni       *OriginPoolEmptyModel                       `tfsdk:"use_host_header_as_sni"`
	UseMtls                  *OriginPoolUseTLSUseMtlsModel               `tfsdk:"use_mtls"`
	UseMtlsObj               *OriginPoolUseTLSUseMtlsObjModel            `tfsdk:"use_mtls_obj"`
	UseServerVerification    *OriginPoolUseTLSUseServerVerificationModel `tfsdk:"use_server_verification"`
	VolterraTrustedCA        *OriginPoolEmptyModel                       `tfsdk:"volterra_trusted_ca"`
}

// OriginPoolUseTLSModelAttrTypes defines the attribute types for OriginPoolUseTLSModel
var OriginPoolUseTLSModelAttrTypes = map[string]attr.Type{
	"max_session_keys":            types.Int64Type,
	"sni":                         types.StringType,
	"default_session_key_caching": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_session_key_caching": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_sni":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_mtls":                     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"skip_server_verification":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":                  types.ObjectType{AttrTypes: OriginPoolUseTLSTLSConfigModelAttrTypes},
	"use_host_header_as_sni":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_mtls":                    types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsModelAttrTypes},
	"use_mtls_obj":                types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsObjModelAttrTypes},
	"use_server_verification":     types.ObjectType{AttrTypes: OriginPoolUseTLSUseServerVerificationModelAttrTypes},
	"volterra_trusted_ca":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolUseTLSTLSConfigModel represents tls_config block
type OriginPoolUseTLSTLSConfigModel struct {
	CustomSecurity  *OriginPoolUseTLSTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *OriginPoolEmptyModel                         `tfsdk:"default_security"`
	LowSecurity     *OriginPoolEmptyModel                         `tfsdk:"low_security"`
	MediumSecurity  *OriginPoolEmptyModel                         `tfsdk:"medium_security"`
}

// OriginPoolUseTLSTLSConfigModelAttrTypes defines the attribute types for OriginPoolUseTLSTLSConfigModel
var OriginPoolUseTLSTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: OriginPoolUseTLSTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolUseTLSTLSConfigCustomSecurityModel represents custom_security block
type OriginPoolUseTLSTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// OriginPoolUseTLSTLSConfigCustomSecurityModelAttrTypes defines the attribute types for OriginPoolUseTLSTLSConfigCustomSecurityModel
var OriginPoolUseTLSTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// OriginPoolUseTLSUseMtlsModel represents use_mtls block
type OriginPoolUseTLSUseMtlsModel struct {
	TLSCertificates []OriginPoolUseTLSUseMtlsTLSCertificatesModel `tfsdk:"tls_certificates"`
}

// OriginPoolUseTLSUseMtlsModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsModel
var OriginPoolUseTLSUseMtlsModelAttrTypes = map[string]attr.Type{
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes}},
}

// OriginPoolUseTLSUseMtlsTLSCertificatesModel represents tls_certificates block
type OriginPoolUseTLSUseMtlsTLSCertificatesModel struct {
	CertificateURL       types.String                                                     `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                     `tfsdk:"description_spec"`
	CustomHashAlgorithms *OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *OriginPoolEmptyModel                                            `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *OriginPoolEmptyModel                                            `tfsdk:"use_system_defaults"`
}

// OriginPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsTLSCertificatesModel
var OriginPoolUseTLSUseMtlsTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModel
var OriginPoolUseTLSUseMtlsTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel represents private_key block
type OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModel
var OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModel
var OriginPoolUseTLSUseMtlsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// OriginPoolUseTLSUseMtlsObjModel represents use_mtls_obj block
type OriginPoolUseTLSUseMtlsObjModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolUseTLSUseMtlsObjModelAttrTypes defines the attribute types for OriginPoolUseTLSUseMtlsObjModel
var OriginPoolUseTLSUseMtlsObjModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// OriginPoolUseTLSUseServerVerificationModel represents use_server_verification block
type OriginPoolUseTLSUseServerVerificationModel struct {
	TrustedCAURL types.String                                         `tfsdk:"trusted_ca_url"`
	TrustedCA    *OriginPoolUseTLSUseServerVerificationTrustedCAModel `tfsdk:"trusted_ca"`
}

// OriginPoolUseTLSUseServerVerificationModelAttrTypes defines the attribute types for OriginPoolUseTLSUseServerVerificationModel
var OriginPoolUseTLSUseServerVerificationModelAttrTypes = map[string]attr.Type{
	"trusted_ca_url": types.StringType,
	"trusted_ca":     types.ObjectType{AttrTypes: OriginPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes},
}

// OriginPoolUseTLSUseServerVerificationTrustedCAModel represents trusted_ca block
type OriginPoolUseTLSUseServerVerificationTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// OriginPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes defines the attribute types for OriginPoolUseTLSUseServerVerificationTrustedCAModel
var OriginPoolUseTLSUseServerVerificationTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

type OriginPoolResourceModel struct {
	Name                      types.String                              `tfsdk:"name"`
	Namespace                 types.String                              `tfsdk:"namespace"`
	Annotations               types.Map                                 `tfsdk:"annotations"`
	Description               types.String                              `tfsdk:"description"`
	Disable                   types.Bool                                `tfsdk:"disable"`
	Labels                    types.Map                                 `tfsdk:"labels"`
	ID                        types.String                              `tfsdk:"id"`
	EndpointSelection         types.String                              `tfsdk:"endpoint_selection"`
	HealthCheckPort           types.Int64                               `tfsdk:"health_check_port"`
	LoadBalancerAlgorithm     types.String                              `tfsdk:"loadbalancer_algorithm"`
	Port                      types.Int64                               `tfsdk:"port"`
	Timeouts                  timeouts.Value                            `tfsdk:"timeouts"`
	AdvancedOptions           *OriginPoolAdvancedOptionsModel           `tfsdk:"advanced_options"`
	AutomaticPort             *OriginPoolEmptyModel                     `tfsdk:"automatic_port"`
	Healthcheck               types.List                                `tfsdk:"healthcheck"`
	LBPort                    *OriginPoolEmptyModel                     `tfsdk:"lb_port"`
	NoTLS                     *OriginPoolEmptyModel                     `tfsdk:"no_tls"`
	OriginServers             types.List                                `tfsdk:"origin_servers"`
	SameAsEndpointPort        *OriginPoolEmptyModel                     `tfsdk:"same_as_endpoint_port"`
	UpstreamConnPoolReuseType *OriginPoolUpstreamConnPoolReuseTypeModel `tfsdk:"upstream_conn_pool_reuse_type"`
	UseTLS                    *OriginPoolUseTLSModel                    `tfsdk:"use_tls"`
}

func (r *OriginPoolResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_origin_pool"
}

func (r *OriginPoolResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Origin Pool resource in F5 Distributed Cloud for defining backend server pools for load balancer targets.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Origin Pool. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Origin Pool will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"endpoint_selection": schema.StringAttribute{
				MarkdownDescription: "[Enum: DISTRIBUTED|LOCAL_ONLY|LOCAL_PREFERRED] Policy for selection of endpoints from local site/remote site/both Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing Enable this policy to load balance ONLY among locally discovered endpoints Prefer the local endpoints for.. Possible values are `DISTRIBUTED`, `LOCAL_ONLY`, `LOCAL_PREFERRED`. Defaults to `DISTRIBUTED`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"health_check_port": schema.Int64Attribute{
				MarkdownDescription: "[OneOf: health_check_port, same_as_endpoint_port] Port used for performing health check.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"loadbalancer_algorithm": schema.StringAttribute{
				MarkdownDescription: "[Enum: ROUND_ROBIN|LEAST_REQUEST|RING_HASH|RANDOM|LB_OVERRIDE] Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load balancer uses loadbalancer_algorithm to determine which host is selected. - ROUND_ROBIN: ROUND_ROBIN Policy in which each healthy/available upstream endpoint is selected in.. Possible values are `ROUND_ROBIN`, `LEAST_REQUEST`, `RING_HASH`, `RANDOM`, `LB_OVERRIDE`. Defaults to `ROUND_ROBIN`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"port": schema.Int64Attribute{
				MarkdownDescription: "Endpoint service is available on this port.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"advanced_options": schema.SingleNestedBlock{
				MarkdownDescription: "Configure Advanced OPTIONS for origin pool.",
				Attributes: map[string]schema.Attribute{
					"connection_timeout": schema.Int64Attribute{
						MarkdownDescription: "The timeout for new network connections to endpoints in the cluster. This is specified in milliseconds. The  seconds. Defaults to `2`.",
						Optional:            true,
					},
					"http_idle_timeout": schema.Int64Attribute{
						MarkdownDescription: "The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
						Optional:            true,
					},
					"panic_threshold": schema.Int64Attribute{
						MarkdownDescription: "Configure a threshold (percentage of unhealthy endpoints) below which all endpoints will be considered for load balancing ignoring its health status.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auto_http_config": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"circuit_breaker": schema.SingleNestedBlock{
						MarkdownDescription: "CircuitBreaker provides a mechanism for watching failures in upstream connections or requests and if the failures reach a certain threshold, automatically fail subsequent requests which allows to apply back pressure on downstream quickly.",
						Attributes: map[string]schema.Attribute{
							"connection_limit": schema.Int64Attribute{
								MarkdownDescription: "The maximum number of connections that loadbalancer will establish to all hosts in an upstream cluster. In practice this is only applicable to TCP and HTTP/1.1 clusters since HTTP/2 uses a single connection to each host. Remove endpoint out of load balancing decision, if number of connections..",
								Optional:            true,
							},
							"max_requests": schema.Int64Attribute{
								MarkdownDescription: "The maximum number of requests that can be outstanding to all hosts in a cluster at any given time. In practice this is applicable to HTTP/2 clusters since HTTP/1.1 clusters are governed by the maximum connections (connection_limit). Remove endpoint out of load balancing decision, if requests..",
								Optional:            true,
							},
							"pending_requests": schema.Int64Attribute{
								MarkdownDescription: "The maximum number of requests that will be queued while waiting for a ready connection pool connection. Since HTTP/2 requests are sent over a single connection, this circuit breaker only comes into play as the initial connection is created, as requests will be multiplexed immediately..",
								Optional:            true,
							},
							"priority": schema.StringAttribute{
								MarkdownDescription: "[Enum: DEFAULT|HIGH] Priority routing for each request. Different connection pools are used based on the priority selected for the request. Also, circuit-breaker configuration at destination cluster is chosen based on selected priority. Possible values are `DEFAULT`, `HIGH`. Defaults to `DEFAULT`.",
								Optional:            true,
							},
							"retries": schema.Int64Attribute{
								MarkdownDescription: "The maximum number of retries that can be outstanding to all hosts in a cluster at any given time. Remove endpoint out of load balancing decision, if retries for request exceed this count.",
								Optional:            true,
							},
						},
					},
					"default_circuit_breaker": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_circuit_breaker": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_lb_source_ip_persistance": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_outlier_detection": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_proxy_protocol": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_subsets": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_lb_source_ip_persistance": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_subsets": schema.SingleNestedBlock{
						MarkdownDescription: "Configure subset OPTIONS for origin pool.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"any_endpoint": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"default_subset": schema.SingleNestedBlock{
								MarkdownDescription: "Origin Pool Default Subset. Default Subset definition.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"default_subset": schema.SingleNestedBlock{
										MarkdownDescription: "List of key-value pairs that define default subset. Which gets used when route specifies no metadata or no subset matching the metadata exists.",
									},
								},
							},
							"endpoint_subsets": schema.ListNestedBlock{
								MarkdownDescription: "List of subset class. Subsets class is defined using list of keys. Every unique combination of values of these keys form a subset withing the class.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"keys": schema.ListAttribute{
											MarkdownDescription: "List of keys that define a cluster subset class.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
							},
							"fail_request": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"http1_config": schema.SingleNestedBlock{
						MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for upstream connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"header_transformation": schema.SingleNestedBlock{
								MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"default_header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"legacy_header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"preserve_case_header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"proper_case_header_transformation": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
						},
					},
					"http2_options": schema.SingleNestedBlock{
						MarkdownDescription: "Http2 Protocol OPTIONS for upstream connections.",
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								MarkdownDescription: "Enable/disable HTTP2 Protocol for upstream connections.",
								Optional:            true,
							},
						},
					},
					"no_panic_threshold": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outlier_detection": schema.SingleNestedBlock{
						MarkdownDescription: "Outlier detection and ejection is the process of dynamically determining whether some number of hosts in an upstream cluster are performing unlike the others and removing them from the healthy load balancing set. Outlier detection is a form of passive health checking. Algorithm 1.",
						Attributes: map[string]schema.Attribute{
							"base_ejection_time": schema.Int64Attribute{
								MarkdownDescription: "The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the host has been ejected. This causes hosts to GET ejected for longer periods if they continue to fail.",
								Optional:            true,
							},
							"consecutive_5xx": schema.Int64Attribute{
								MarkdownDescription: "If an upstream endpoint returns some number of consecutive 5xx, it will be ejected. Note that in this case a 5xx means an actual 5xx respond code, or an event that would cause the HTTP router to return one on the upstreams behalf(reset, connection failure, etc.) consecutive_5xx indicates the..",
								Optional:            true,
							},
							"consecutive_gateway_failure": schema.Int64Attribute{
								MarkdownDescription: "If an upstream endpoint returns some number of consecutive gateway errors (502, 503 or 504 status code), it will be ejected. Note that this includes events that would cause the HTTP router to return one of these status codes on the upstreams behalf (reset, connection failure, etc.)..",
								Optional:            true,
							},
							"interval": schema.Int64Attribute{
								MarkdownDescription: "The time interval between ejection analysis sweeps. This can result in both new ejections as well as endpoints being returned to service. Defaults to `10000ms`.",
								Optional:            true,
							},
							"max_ejection_percent": schema.Int64Attribute{
								MarkdownDescription: "The maximum % of an upstream cluster that can be ejected due to outlier detection.  but will eject at least one host regardless of the value. Defaults to `10%`.",
								Optional:            true,
							},
						},
					},
					"proxy_protocol_v1": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"proxy_protocol_v2": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"automatic_port": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: automatic_port, lb_port, port] Enable this option",
			},
			"healthcheck": schema.ListNestedBlock{
				MarkdownDescription: "Reference to healthcheck configuration objects.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
							Optional:            true,
						},
						"namespace": schema.StringAttribute{
							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"tenant": schema.StringAttribute{
							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
					},
				},
			},
			"lb_port": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_tls": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_tls, use_tls; Default: no_tls] Enable this option",
			},
			"origin_servers": schema.ListNestedBlock{
				MarkdownDescription: "List of origin servers in this pool .",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{},
					Blocks: map[string]schema.Block{
						"cbip_service": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with Classic BIG-IP Service (Virtual Server).",
							Attributes: map[string]schema.Attribute{
								"service_name": schema.StringAttribute{
									MarkdownDescription: "Name of the discovered Classic BIG-IP virtual server to be used as origin.",
									Optional:            true,
								},
							},
						},
						"consul_service": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with Hashi Corp Consul service name and site information.",
							Attributes: map[string]schema.Attribute{
								"service_name": schema.StringAttribute{
									MarkdownDescription: "Consul service name of this origin server will be listed, including cluster-ID. The format is servicename:cluster-ID.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"outside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"site_locator": schema.SingleNestedBlock{
									MarkdownDescription: "Message defines a reference to a site or virtual site object.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"snat_pool": schema.SingleNestedBlock{
									MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"no_snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
											Attributes: map[string]schema.Attribute{
												"prefixes": schema.ListAttribute{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
							},
						},
						"custom_endpoint_object": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with a reference to endpoint object.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"endpoint": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
						"k8s_service": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with K8s service name and site information.",
							Attributes: map[string]schema.Attribute{
								"protocol": schema.StringAttribute{
									MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP - PROTOCOL_UDP: UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
									Optional:            true,
								},
								"service_name": schema.StringAttribute{
									MarkdownDescription: "K8s service name of the origin server will be listed, including the namespace and cluster-ID. For vK8s services, you need to enter a string with the format servicename.namespace:cluster-ID. If the servicename is 'frontend', namespace is 'speedtest' and cluster-ID is 'prod'..",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"outside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"site_locator": schema.SingleNestedBlock{
									MarkdownDescription: "Message defines a reference to a site or virtual site object.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"snat_pool": schema.SingleNestedBlock{
									MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"no_snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
											Attributes: map[string]schema.Attribute{
												"prefixes": schema.ListAttribute{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
								"vk8s_networks": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
						"labels": schema.SingleNestedBlock{
							MarkdownDescription: "Add Labels for this origin server, these labels can be used to form subset.",
						},
						"private_ip": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with private or public IP address and site information.",
							Attributes: map[string]schema.Attribute{
								"ip": schema.StringAttribute{
									MarkdownDescription: "IP. Private IPv4 address.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"outside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"segment": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"site_locator": schema.SingleNestedBlock{
									MarkdownDescription: "Message defines a reference to a site or virtual site object.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"snat_pool": schema.SingleNestedBlock{
									MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"no_snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
											Attributes: map[string]schema.Attribute{
												"prefixes": schema.ListAttribute{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
							},
						},
						"private_name": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with private or public DNS name and site information.",
							Attributes: map[string]schema.Attribute{
								"dns_name": schema.StringAttribute{
									MarkdownDescription: "DNS Name. DNS Name .",
									Optional:            true,
								},
								"refresh_interval": schema.Int64Attribute{
									MarkdownDescription: "Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/HTML/rfc8767.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"outside_network": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"segment": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"site_locator": schema.SingleNestedBlock{
									MarkdownDescription: "Message defines a reference to a site or virtual site object.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"snat_pool": schema.SingleNestedBlock{
									MarkdownDescription: "SNAT Pool. SNAT Pool configuration.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"no_snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"snat_pool": schema.SingleNestedBlock{
											MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
											Attributes: map[string]schema.Attribute{
												"prefixes": schema.ListAttribute{
													MarkdownDescription: "List of IPv4 prefixes that represent an endpoint.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
							},
						},
						"public_ip": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with public IP address.",
							Attributes: map[string]schema.Attribute{
								"ip": schema.StringAttribute{
									MarkdownDescription: "Public IPv4. Public IPv4 address.",
									Optional:            true,
								},
							},
						},
						"public_name": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with public DNS name.",
							Attributes: map[string]schema.Attribute{
								"dns_name": schema.StringAttribute{
									MarkdownDescription: "DNS Name. DNS Name .",
									Optional:            true,
								},
								"refresh_interval": schema.Int64Attribute{
									MarkdownDescription: "Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/HTML/rfc8767.",
									Optional:            true,
								},
							},
						},
						"vn_private_ip": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with IP on Virtual Network.",
							Attributes: map[string]schema.Attribute{
								"ip": schema.StringAttribute{
									MarkdownDescription: "IPv4. IPv4 address.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"virtual_network": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
						"vn_private_name": schema.SingleNestedBlock{
							MarkdownDescription: "Specify origin server with DNS name on Virtual Network.",
							Attributes: map[string]schema.Attribute{
								"dns_name": schema.StringAttribute{
									MarkdownDescription: "DNS Name. DNS Name .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"private_network": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"same_as_endpoint_port": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"upstream_conn_pool_reuse_type": schema.SingleNestedBlock{
				MarkdownDescription: "Select upstream connection pool reuse state for every downstream connection. This configuration choice is for HTTP(S) LB only.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_conn_pool_reuse": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_conn_pool_reuse": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"use_tls": schema.SingleNestedBlock{
				MarkdownDescription: "TLS Parameters for Origin Servers. Upstream TLS Parameters.",
				Attributes: map[string]schema.Attribute{
					"max_session_keys": schema.Int64Attribute{
						MarkdownDescription: "Number of session keys that are cached.",
						Optional:            true,
					},
					"sni": schema.StringAttribute{
						MarkdownDescription: "SNI value to be used.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_session_key_caching": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_session_key_caching": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"disable_sni": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"skip_server_verification": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_security": schema.SingleNestedBlock{
								MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
								Attributes: map[string]schema.Attribute{
									"cipher_suites": schema.ListAttribute{
										MarkdownDescription: "The TLS listener will only support the specified cipher list.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"max_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
									"min_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
								},
							},
							"default_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"low_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"medium_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"use_host_header_as_sni": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"use_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "MTLS Certificate. MTLS Client Certificate.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "MTLS Client Certificate. MTLS Client Certificate .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"use_mtls_obj": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"use_server_verification": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Validation Context for Origin Servers. Upstream TLS Validation Context.",
						Attributes: map[string]schema.Attribute{
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Upload a Root CA Certificate specifically for this Origin Pool for verification of server's certificate.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
						},
					},
					"volterra_trusted_ca": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
		},
	}
}

func (r *OriginPoolResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *OriginPoolResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data OriginPoolResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *OriginPoolResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the origin_pool from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan OriginPoolResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *OriginPoolResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data OriginPoolResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating origin_pool", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.OriginPool{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdvancedOptions != nil {
		advanced_optionsMap := make(map[string]interface{})
		if data.AdvancedOptions.AutoHTTPConfig != nil {
			advanced_optionsMap["auto_http_config"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.CircuitBreaker != nil {
			circuit_breakerNestedMap := make(map[string]interface{})
			if !data.AdvancedOptions.CircuitBreaker.ConnectionLimit.IsNull() && !data.AdvancedOptions.CircuitBreaker.ConnectionLimit.IsUnknown() {
				circuit_breakerNestedMap["connection_limit"] = data.AdvancedOptions.CircuitBreaker.ConnectionLimit.ValueInt64()
			}
			if !data.AdvancedOptions.CircuitBreaker.MaxRequests.IsNull() && !data.AdvancedOptions.CircuitBreaker.MaxRequests.IsUnknown() {
				circuit_breakerNestedMap["max_requests"] = data.AdvancedOptions.CircuitBreaker.MaxRequests.ValueInt64()
			}
			if !data.AdvancedOptions.CircuitBreaker.PendingRequests.IsNull() && !data.AdvancedOptions.CircuitBreaker.PendingRequests.IsUnknown() {
				circuit_breakerNestedMap["pending_requests"] = data.AdvancedOptions.CircuitBreaker.PendingRequests.ValueInt64()
			}
			if !data.AdvancedOptions.CircuitBreaker.Priority.IsNull() && !data.AdvancedOptions.CircuitBreaker.Priority.IsUnknown() {
				circuit_breakerNestedMap["priority"] = data.AdvancedOptions.CircuitBreaker.Priority.ValueString()
			}
			if !data.AdvancedOptions.CircuitBreaker.Retries.IsNull() && !data.AdvancedOptions.CircuitBreaker.Retries.IsUnknown() {
				circuit_breakerNestedMap["retries"] = data.AdvancedOptions.CircuitBreaker.Retries.ValueInt64()
			}
			advanced_optionsMap["circuit_breaker"] = circuit_breakerNestedMap
		}
		if !data.AdvancedOptions.ConnectionTimeout.IsNull() && !data.AdvancedOptions.ConnectionTimeout.IsUnknown() {
			advanced_optionsMap["connection_timeout"] = data.AdvancedOptions.ConnectionTimeout.ValueInt64()
		}
		if data.AdvancedOptions.DefaultCircuitBreaker != nil {
			advanced_optionsMap["default_circuit_breaker"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableCircuitBreaker != nil {
			advanced_optionsMap["disable_circuit_breaker"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableLBSourceIPPersistance != nil {
			advanced_optionsMap["disable_lb_source_ip_persistance"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableOutlierDetection != nil {
			advanced_optionsMap["disable_outlier_detection"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableProxyProtocol != nil {
			advanced_optionsMap["disable_proxy_protocol"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableSubsets != nil {
			advanced_optionsMap["disable_subsets"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.EnableLBSourceIPPersistance != nil {
			advanced_optionsMap["enable_lb_source_ip_persistance"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.EnableSubsets != nil {
			enable_subsetsNestedMap := make(map[string]interface{})
			advanced_optionsMap["enable_subsets"] = enable_subsetsNestedMap
		}
		if data.AdvancedOptions.Http1Config != nil {
			http1_configNestedMap := make(map[string]interface{})
			advanced_optionsMap["http1_config"] = http1_configNestedMap
		}
		if data.AdvancedOptions.Http2Options != nil {
			http2_optionsNestedMap := make(map[string]interface{})
			if !data.AdvancedOptions.Http2Options.Enabled.IsNull() && !data.AdvancedOptions.Http2Options.Enabled.IsUnknown() {
				http2_optionsNestedMap["enabled"] = data.AdvancedOptions.Http2Options.Enabled.ValueBool()
			}
			advanced_optionsMap["http2_options"] = http2_optionsNestedMap
		}
		if !data.AdvancedOptions.HTTPIdleTimeout.IsNull() && !data.AdvancedOptions.HTTPIdleTimeout.IsUnknown() {
			advanced_optionsMap["http_idle_timeout"] = data.AdvancedOptions.HTTPIdleTimeout.ValueInt64()
		}
		if data.AdvancedOptions.NoPanicThreshold != nil {
			advanced_optionsMap["no_panic_threshold"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.OutlierDetection != nil {
			outlier_detectionNestedMap := make(map[string]interface{})
			if !data.AdvancedOptions.OutlierDetection.BaseEjectionTime.IsNull() && !data.AdvancedOptions.OutlierDetection.BaseEjectionTime.IsUnknown() {
				outlier_detectionNestedMap["base_ejection_time"] = data.AdvancedOptions.OutlierDetection.BaseEjectionTime.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.Consecutive5xx.IsNull() && !data.AdvancedOptions.OutlierDetection.Consecutive5xx.IsUnknown() {
				outlier_detectionNestedMap["consecutive_5xx"] = data.AdvancedOptions.OutlierDetection.Consecutive5xx.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.ConsecutiveGatewayFailure.IsNull() && !data.AdvancedOptions.OutlierDetection.ConsecutiveGatewayFailure.IsUnknown() {
				outlier_detectionNestedMap["consecutive_gateway_failure"] = data.AdvancedOptions.OutlierDetection.ConsecutiveGatewayFailure.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.Interval.IsNull() && !data.AdvancedOptions.OutlierDetection.Interval.IsUnknown() {
				outlier_detectionNestedMap["interval"] = data.AdvancedOptions.OutlierDetection.Interval.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.MaxEjectionPercent.IsNull() && !data.AdvancedOptions.OutlierDetection.MaxEjectionPercent.IsUnknown() {
				outlier_detectionNestedMap["max_ejection_percent"] = data.AdvancedOptions.OutlierDetection.MaxEjectionPercent.ValueInt64()
			}
			advanced_optionsMap["outlier_detection"] = outlier_detectionNestedMap
		}
		if !data.AdvancedOptions.PanicThreshold.IsNull() && !data.AdvancedOptions.PanicThreshold.IsUnknown() {
			advanced_optionsMap["panic_threshold"] = data.AdvancedOptions.PanicThreshold.ValueInt64()
		}
		if data.AdvancedOptions.ProxyProtocolV1 != nil {
			advanced_optionsMap["proxy_protocol_v1"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.ProxyProtocolV2 != nil {
			advanced_optionsMap["proxy_protocol_v2"] = map[string]interface{}{}
		}
		createReq.Spec["advanced_options"] = advanced_optionsMap
	}
	if data.AutomaticPort != nil {
		automatic_portMap := make(map[string]interface{})
		createReq.Spec["automatic_port"] = automatic_portMap
	}
	if !data.Healthcheck.IsNull() && !data.Healthcheck.IsUnknown() {
		var healthcheckItems []OriginPoolHealthcheckModel
		diags := data.Healthcheck.ElementsAs(ctx, &healthcheckItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(healthcheckItems) > 0 {
			var healthcheckList []map[string]interface{}
			for _, item := range healthcheckItems {
				itemMap := make(map[string]interface{})
				if !item.Name.IsNull() && !item.Name.IsUnknown() {
					itemMap["name"] = item.Name.ValueString()
				}
				if !item.Namespace.IsNull() && !item.Namespace.IsUnknown() {
					itemMap["namespace"] = item.Namespace.ValueString()
				}
				if !item.Tenant.IsNull() && !item.Tenant.IsUnknown() {
					itemMap["tenant"] = item.Tenant.ValueString()
				}
				healthcheckList = append(healthcheckList, itemMap)
			}
			createReq.Spec["healthcheck"] = healthcheckList
		}
	}
	if data.LBPort != nil {
		lb_portMap := make(map[string]interface{})
		createReq.Spec["lb_port"] = lb_portMap
	}
	if data.NoTLS != nil {
		no_tlsMap := make(map[string]interface{})
		createReq.Spec["no_tls"] = no_tlsMap
	}
	if !data.OriginServers.IsNull() && !data.OriginServers.IsUnknown() {
		var origin_serversItems []OriginPoolOriginServersModel
		diags := data.OriginServers.ElementsAs(ctx, &origin_serversItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(origin_serversItems) > 0 {
			var origin_serversList []map[string]interface{}
			for _, item := range origin_serversItems {
				itemMap := make(map[string]interface{})
				if item.CbipService != nil {
					cbip_serviceNestedMap := make(map[string]interface{})
					if !item.CbipService.ServiceName.IsNull() && !item.CbipService.ServiceName.IsUnknown() {
						cbip_serviceNestedMap["service_name"] = item.CbipService.ServiceName.ValueString()
					}
					itemMap["cbip_service"] = cbip_serviceNestedMap
				}
				if item.ConsulService != nil {
					consul_serviceNestedMap := make(map[string]interface{})
					if item.ConsulService.InsideNetwork != nil {
						consul_serviceNestedMap["inside_network"] = map[string]interface{}{}
					}
					if item.ConsulService.OutsideNetwork != nil {
						consul_serviceNestedMap["outside_network"] = map[string]interface{}{}
					}
					if !item.ConsulService.ServiceName.IsNull() && !item.ConsulService.ServiceName.IsUnknown() {
						consul_serviceNestedMap["service_name"] = item.ConsulService.ServiceName.ValueString()
					}
					if item.ConsulService.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						consul_serviceNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.ConsulService.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.ConsulService.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						consul_serviceNestedMap["snat_pool"] = snat_poolDeepMap
					}
					itemMap["consul_service"] = consul_serviceNestedMap
				}
				if item.CustomEndpointObject != nil {
					custom_endpoint_objectNestedMap := make(map[string]interface{})
					if item.CustomEndpointObject.Endpoint != nil {
						endpointDeepMap := make(map[string]interface{})
						if !item.CustomEndpointObject.Endpoint.Name.IsNull() && !item.CustomEndpointObject.Endpoint.Name.IsUnknown() {
							endpointDeepMap["name"] = item.CustomEndpointObject.Endpoint.Name.ValueString()
						}
						if !item.CustomEndpointObject.Endpoint.Namespace.IsNull() && !item.CustomEndpointObject.Endpoint.Namespace.IsUnknown() {
							endpointDeepMap["namespace"] = item.CustomEndpointObject.Endpoint.Namespace.ValueString()
						}
						if !item.CustomEndpointObject.Endpoint.Tenant.IsNull() && !item.CustomEndpointObject.Endpoint.Tenant.IsUnknown() {
							endpointDeepMap["tenant"] = item.CustomEndpointObject.Endpoint.Tenant.ValueString()
						}
						custom_endpoint_objectNestedMap["endpoint"] = endpointDeepMap
					}
					itemMap["custom_endpoint_object"] = custom_endpoint_objectNestedMap
				}
				if item.K8SService != nil {
					k8s_serviceNestedMap := make(map[string]interface{})
					if item.K8SService.InsideNetwork != nil {
						k8s_serviceNestedMap["inside_network"] = map[string]interface{}{}
					}
					if item.K8SService.OutsideNetwork != nil {
						k8s_serviceNestedMap["outside_network"] = map[string]interface{}{}
					}
					if !item.K8SService.Protocol.IsNull() && !item.K8SService.Protocol.IsUnknown() {
						k8s_serviceNestedMap["protocol"] = item.K8SService.Protocol.ValueString()
					}
					if !item.K8SService.ServiceName.IsNull() && !item.K8SService.ServiceName.IsUnknown() {
						k8s_serviceNestedMap["service_name"] = item.K8SService.ServiceName.ValueString()
					}
					if item.K8SService.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						k8s_serviceNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.K8SService.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.K8SService.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						k8s_serviceNestedMap["snat_pool"] = snat_poolDeepMap
					}
					if item.K8SService.Vk8sNetworks != nil {
						k8s_serviceNestedMap["vk8s_networks"] = map[string]interface{}{}
					}
					itemMap["k8s_service"] = k8s_serviceNestedMap
				}
				if item.Labels != nil {
					itemMap["labels"] = map[string]interface{}{}
				}
				if item.PrivateIP != nil {
					private_ipNestedMap := make(map[string]interface{})
					if item.PrivateIP.InsideNetwork != nil {
						private_ipNestedMap["inside_network"] = map[string]interface{}{}
					}
					if !item.PrivateIP.IP.IsNull() && !item.PrivateIP.IP.IsUnknown() {
						private_ipNestedMap["ip"] = item.PrivateIP.IP.ValueString()
					}
					if item.PrivateIP.OutsideNetwork != nil {
						private_ipNestedMap["outside_network"] = map[string]interface{}{}
					}
					if item.PrivateIP.Segment != nil {
						segmentDeepMap := make(map[string]interface{})
						if !item.PrivateIP.Segment.Name.IsNull() && !item.PrivateIP.Segment.Name.IsUnknown() {
							segmentDeepMap["name"] = item.PrivateIP.Segment.Name.ValueString()
						}
						if !item.PrivateIP.Segment.Namespace.IsNull() && !item.PrivateIP.Segment.Namespace.IsUnknown() {
							segmentDeepMap["namespace"] = item.PrivateIP.Segment.Namespace.ValueString()
						}
						if !item.PrivateIP.Segment.Tenant.IsNull() && !item.PrivateIP.Segment.Tenant.IsUnknown() {
							segmentDeepMap["tenant"] = item.PrivateIP.Segment.Tenant.ValueString()
						}
						private_ipNestedMap["segment"] = segmentDeepMap
					}
					if item.PrivateIP.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						private_ipNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.PrivateIP.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.PrivateIP.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						private_ipNestedMap["snat_pool"] = snat_poolDeepMap
					}
					itemMap["private_ip"] = private_ipNestedMap
				}
				if item.PrivateName != nil {
					private_nameNestedMap := make(map[string]interface{})
					if !item.PrivateName.DNSName.IsNull() && !item.PrivateName.DNSName.IsUnknown() {
						private_nameNestedMap["dns_name"] = item.PrivateName.DNSName.ValueString()
					}
					if item.PrivateName.InsideNetwork != nil {
						private_nameNestedMap["inside_network"] = map[string]interface{}{}
					}
					if item.PrivateName.OutsideNetwork != nil {
						private_nameNestedMap["outside_network"] = map[string]interface{}{}
					}
					if !item.PrivateName.RefreshInterval.IsNull() && !item.PrivateName.RefreshInterval.IsUnknown() {
						private_nameNestedMap["refresh_interval"] = item.PrivateName.RefreshInterval.ValueInt64()
					}
					if item.PrivateName.Segment != nil {
						segmentDeepMap := make(map[string]interface{})
						if !item.PrivateName.Segment.Name.IsNull() && !item.PrivateName.Segment.Name.IsUnknown() {
							segmentDeepMap["name"] = item.PrivateName.Segment.Name.ValueString()
						}
						if !item.PrivateName.Segment.Namespace.IsNull() && !item.PrivateName.Segment.Namespace.IsUnknown() {
							segmentDeepMap["namespace"] = item.PrivateName.Segment.Namespace.ValueString()
						}
						if !item.PrivateName.Segment.Tenant.IsNull() && !item.PrivateName.Segment.Tenant.IsUnknown() {
							segmentDeepMap["tenant"] = item.PrivateName.Segment.Tenant.ValueString()
						}
						private_nameNestedMap["segment"] = segmentDeepMap
					}
					if item.PrivateName.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						private_nameNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.PrivateName.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.PrivateName.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						private_nameNestedMap["snat_pool"] = snat_poolDeepMap
					}
					itemMap["private_name"] = private_nameNestedMap
				}
				if item.PublicIP != nil {
					public_ipNestedMap := make(map[string]interface{})
					if !item.PublicIP.IP.IsNull() && !item.PublicIP.IP.IsUnknown() {
						public_ipNestedMap["ip"] = item.PublicIP.IP.ValueString()
					}
					itemMap["public_ip"] = public_ipNestedMap
				}
				if item.PublicName != nil {
					public_nameNestedMap := make(map[string]interface{})
					if !item.PublicName.DNSName.IsNull() && !item.PublicName.DNSName.IsUnknown() {
						public_nameNestedMap["dns_name"] = item.PublicName.DNSName.ValueString()
					}
					if !item.PublicName.RefreshInterval.IsNull() && !item.PublicName.RefreshInterval.IsUnknown() {
						public_nameNestedMap["refresh_interval"] = item.PublicName.RefreshInterval.ValueInt64()
					}
					itemMap["public_name"] = public_nameNestedMap
				}
				if item.VnPrivateIP != nil {
					vn_private_ipNestedMap := make(map[string]interface{})
					if !item.VnPrivateIP.IP.IsNull() && !item.VnPrivateIP.IP.IsUnknown() {
						vn_private_ipNestedMap["ip"] = item.VnPrivateIP.IP.ValueString()
					}
					if item.VnPrivateIP.VirtualNetwork != nil {
						virtual_networkDeepMap := make(map[string]interface{})
						if !item.VnPrivateIP.VirtualNetwork.Name.IsNull() && !item.VnPrivateIP.VirtualNetwork.Name.IsUnknown() {
							virtual_networkDeepMap["name"] = item.VnPrivateIP.VirtualNetwork.Name.ValueString()
						}
						if !item.VnPrivateIP.VirtualNetwork.Namespace.IsNull() && !item.VnPrivateIP.VirtualNetwork.Namespace.IsUnknown() {
							virtual_networkDeepMap["namespace"] = item.VnPrivateIP.VirtualNetwork.Namespace.ValueString()
						}
						if !item.VnPrivateIP.VirtualNetwork.Tenant.IsNull() && !item.VnPrivateIP.VirtualNetwork.Tenant.IsUnknown() {
							virtual_networkDeepMap["tenant"] = item.VnPrivateIP.VirtualNetwork.Tenant.ValueString()
						}
						vn_private_ipNestedMap["virtual_network"] = virtual_networkDeepMap
					}
					itemMap["vn_private_ip"] = vn_private_ipNestedMap
				}
				if item.VnPrivateName != nil {
					vn_private_nameNestedMap := make(map[string]interface{})
					if !item.VnPrivateName.DNSName.IsNull() && !item.VnPrivateName.DNSName.IsUnknown() {
						vn_private_nameNestedMap["dns_name"] = item.VnPrivateName.DNSName.ValueString()
					}
					if item.VnPrivateName.PrivateNetwork != nil {
						private_networkDeepMap := make(map[string]interface{})
						if !item.VnPrivateName.PrivateNetwork.Name.IsNull() && !item.VnPrivateName.PrivateNetwork.Name.IsUnknown() {
							private_networkDeepMap["name"] = item.VnPrivateName.PrivateNetwork.Name.ValueString()
						}
						if !item.VnPrivateName.PrivateNetwork.Namespace.IsNull() && !item.VnPrivateName.PrivateNetwork.Namespace.IsUnknown() {
							private_networkDeepMap["namespace"] = item.VnPrivateName.PrivateNetwork.Namespace.ValueString()
						}
						if !item.VnPrivateName.PrivateNetwork.Tenant.IsNull() && !item.VnPrivateName.PrivateNetwork.Tenant.IsUnknown() {
							private_networkDeepMap["tenant"] = item.VnPrivateName.PrivateNetwork.Tenant.ValueString()
						}
						vn_private_nameNestedMap["private_network"] = private_networkDeepMap
					}
					itemMap["vn_private_name"] = vn_private_nameNestedMap
				}
				origin_serversList = append(origin_serversList, itemMap)
			}
			createReq.Spec["origin_servers"] = origin_serversList
		}
	}
	if data.SameAsEndpointPort != nil {
		same_as_endpoint_portMap := make(map[string]interface{})
		createReq.Spec["same_as_endpoint_port"] = same_as_endpoint_portMap
	}
	if data.UpstreamConnPoolReuseType != nil {
		upstream_conn_pool_reuse_typeMap := make(map[string]interface{})
		if data.UpstreamConnPoolReuseType.DisableConnPoolReuse != nil {
			upstream_conn_pool_reuse_typeMap["disable_conn_pool_reuse"] = map[string]interface{}{}
		}
		if data.UpstreamConnPoolReuseType.EnableConnPoolReuse != nil {
			upstream_conn_pool_reuse_typeMap["enable_conn_pool_reuse"] = map[string]interface{}{}
		}
		createReq.Spec["upstream_conn_pool_reuse_type"] = upstream_conn_pool_reuse_typeMap
	}
	if data.UseTLS != nil {
		use_tlsMap := make(map[string]interface{})
		if data.UseTLS.DefaultSessionKeyCaching != nil {
			use_tlsMap["default_session_key_caching"] = map[string]interface{}{}
		}
		if data.UseTLS.DisableSessionKeyCaching != nil {
			use_tlsMap["disable_session_key_caching"] = map[string]interface{}{}
		}
		if data.UseTLS.DisableSni != nil {
			use_tlsMap["disable_sni"] = map[string]interface{}{}
		}
		if !data.UseTLS.MaxSessionKeys.IsNull() && !data.UseTLS.MaxSessionKeys.IsUnknown() {
			use_tlsMap["max_session_keys"] = data.UseTLS.MaxSessionKeys.ValueInt64()
		}
		if data.UseTLS.NoMtls != nil {
			use_tlsMap["no_mtls"] = map[string]interface{}{}
		}
		if data.UseTLS.SkipServerVerification != nil {
			use_tlsMap["skip_server_verification"] = map[string]interface{}{}
		}
		if !data.UseTLS.Sni.IsNull() && !data.UseTLS.Sni.IsUnknown() {
			use_tlsMap["sni"] = data.UseTLS.Sni.ValueString()
		}
		if data.UseTLS.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			use_tlsMap["tls_config"] = tls_configNestedMap
		}
		if data.UseTLS.UseHostHeaderAsSni != nil {
			use_tlsMap["use_host_header_as_sni"] = map[string]interface{}{}
		}
		if data.UseTLS.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			use_tlsMap["use_mtls"] = use_mtlsNestedMap
		}
		if data.UseTLS.UseMtlsObj != nil {
			use_mtls_objNestedMap := make(map[string]interface{})
			if !data.UseTLS.UseMtlsObj.Name.IsNull() && !data.UseTLS.UseMtlsObj.Name.IsUnknown() {
				use_mtls_objNestedMap["name"] = data.UseTLS.UseMtlsObj.Name.ValueString()
			}
			if !data.UseTLS.UseMtlsObj.Namespace.IsNull() && !data.UseTLS.UseMtlsObj.Namespace.IsUnknown() {
				use_mtls_objNestedMap["namespace"] = data.UseTLS.UseMtlsObj.Namespace.ValueString()
			}
			if !data.UseTLS.UseMtlsObj.Tenant.IsNull() && !data.UseTLS.UseMtlsObj.Tenant.IsUnknown() {
				use_mtls_objNestedMap["tenant"] = data.UseTLS.UseMtlsObj.Tenant.ValueString()
			}
			use_tlsMap["use_mtls_obj"] = use_mtls_objNestedMap
		}
		if data.UseTLS.UseServerVerification != nil {
			use_server_verificationNestedMap := make(map[string]interface{})
			if !data.UseTLS.UseServerVerification.TrustedCAURL.IsNull() && !data.UseTLS.UseServerVerification.TrustedCAURL.IsUnknown() {
				use_server_verificationNestedMap["trusted_ca_url"] = data.UseTLS.UseServerVerification.TrustedCAURL.ValueString()
			}
			use_tlsMap["use_server_verification"] = use_server_verificationNestedMap
		}
		if data.UseTLS.VolterraTrustedCA != nil {
			use_tlsMap["volterra_trusted_ca"] = map[string]interface{}{}
		}
		createReq.Spec["use_tls"] = use_tlsMap
	}
	if !data.EndpointSelection.IsNull() && !data.EndpointSelection.IsUnknown() {
		createReq.Spec["endpoint_selection"] = data.EndpointSelection.ValueString()
	}
	if !data.HealthCheckPort.IsNull() && !data.HealthCheckPort.IsUnknown() {
		createReq.Spec["health_check_port"] = data.HealthCheckPort.ValueInt64()
	}
	if !data.LoadBalancerAlgorithm.IsNull() && !data.LoadBalancerAlgorithm.IsUnknown() {
		createReq.Spec["loadbalancer_algorithm"] = data.LoadBalancerAlgorithm.ValueString()
	}
	if !data.Port.IsNull() && !data.Port.IsUnknown() {
		createReq.Spec["port"] = data.Port.ValueInt64()
	}

	apiResource, err := r.client.CreateOriginPool(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create OriginPool: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["advanced_options"].(map[string]interface{}); ok && (isImport || data.AdvancedOptions != nil) {
		data.AdvancedOptions = &OriginPoolAdvancedOptionsModel{
			AutoHTTPConfig: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.AutoHTTPConfig
				}
				// Import case: read from API
				if _, ok := blockData["auto_http_config"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			CircuitBreaker: func() *OriginPoolAdvancedOptionsCircuitBreakerModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.CircuitBreaker != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.CircuitBreaker
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsCircuitBreakerModel{
						ConnectionLimit: func() types.Int64 {
							if v, ok := nestedBlockData["connection_limit"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						MaxRequests: func() types.Int64 {
							if v, ok := nestedBlockData["max_requests"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PendingRequests: func() types.Int64 {
							if v, ok := nestedBlockData["pending_requests"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Priority: func() types.String {
							if v, ok := nestedBlockData["priority"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Retries: func() types.Int64 {
							if v, ok := nestedBlockData["retries"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ConnectionTimeout: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.ConnectionTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultCircuitBreaker: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DefaultCircuitBreaker
				}
				// Import case: read from API
				if _, ok := blockData["default_circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableCircuitBreaker: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableCircuitBreaker
				}
				// Import case: read from API
				if _, ok := blockData["disable_circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableLBSourceIPPersistance: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableLBSourceIPPersistance
				}
				// Import case: read from API
				if _, ok := blockData["disable_lb_source_ip_persistance"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableOutlierDetection: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableOutlierDetection
				}
				// Import case: read from API
				if _, ok := blockData["disable_outlier_detection"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableProxyProtocol: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableProxyProtocol
				}
				// Import case: read from API
				if _, ok := blockData["disable_proxy_protocol"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSubsets: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableSubsets
				}
				// Import case: read from API
				if _, ok := blockData["disable_subsets"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			EnableLBSourceIPPersistance: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.EnableLBSourceIPPersistance
				}
				// Import case: read from API
				if _, ok := blockData["enable_lb_source_ip_persistance"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			EnableSubsets: func() *OriginPoolAdvancedOptionsEnableSubsetsModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.EnableSubsets != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.EnableSubsets
				}
				// Import case: read from API
				if _, ok := blockData["enable_subsets"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsEnableSubsetsModel{}
				}
				return nil
			}(),
			Http1Config: func() *OriginPoolAdvancedOptionsHttp1ConfigModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.Http1Config != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.Http1Config
				}
				// Import case: read from API
				if _, ok := blockData["http1_config"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsHttp1ConfigModel{}
				}
				return nil
			}(),
			Http2Options: func() *OriginPoolAdvancedOptionsHttp2OptionsModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.Http2Options != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.Http2Options
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["http2_options"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsHttp2OptionsModel{
						Enabled: func() types.Bool {
							if v, ok := nestedBlockData["enabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			HTTPIdleTimeout: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.HTTPIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["http_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoPanicThreshold: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.NoPanicThreshold
				}
				// Import case: read from API
				if _, ok := blockData["no_panic_threshold"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			OutlierDetection: func() *OriginPoolAdvancedOptionsOutlierDetectionModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.OutlierDetection != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.OutlierDetection
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["outlier_detection"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsOutlierDetectionModel{
						BaseEjectionTime: func() types.Int64 {
							if v, ok := nestedBlockData["base_ejection_time"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Consecutive5xx: func() types.Int64 {
							if v, ok := nestedBlockData["consecutive_5xx"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ConsecutiveGatewayFailure: func() types.Int64 {
							if v, ok := nestedBlockData["consecutive_gateway_failure"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Interval: func() types.Int64 {
							if v, ok := nestedBlockData["interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						MaxEjectionPercent: func() types.Int64 {
							if v, ok := nestedBlockData["max_ejection_percent"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PanicThreshold: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.PanicThreshold
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["panic_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ProxyProtocolV1: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.ProxyProtocolV1
				}
				// Import case: read from API
				if _, ok := blockData["proxy_protocol_v1"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			ProxyProtocolV2: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.ProxyProtocolV2
				}
				// Import case: read from API
				if _, ok := blockData["proxy_protocol_v2"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["automatic_port"].(map[string]interface{}); ok && isImport && data.AutomaticPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AutomaticPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["healthcheck"].([]interface{}); ok && len(listData) > 0 {
		var healthcheckList []OriginPoolHealthcheckModel
		var existingHealthcheckItems []OriginPoolHealthcheckModel
		if !data.Healthcheck.IsNull() && !data.Healthcheck.IsUnknown() {
			data.Healthcheck.ElementsAs(ctx, &existingHealthcheckItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				healthcheckList = append(healthcheckList, OriginPoolHealthcheckModel{
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Namespace: func() types.String {
						if v, ok := itemMap["namespace"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Tenant: func() types.String {
						if v, ok := itemMap["tenant"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: OriginPoolHealthcheckModelAttrTypes}, healthcheckList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Healthcheck = listVal
		}
	} else {
		// No data from API - set to null list
		data.Healthcheck = types.ListNull(types.ObjectType{AttrTypes: OriginPoolHealthcheckModelAttrTypes})
	}
	if _, ok := apiResource.Spec["lb_port"].(map[string]interface{}); ok && isImport && data.LBPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LBPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_tls"].(map[string]interface{}); ok && isImport && data.NoTLS == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoTLS = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_servers"].([]interface{}); ok && len(listData) > 0 {
		var origin_serversList []OriginPoolOriginServersModel
		var existingOriginServersItems []OriginPoolOriginServersModel
		if !data.OriginServers.IsNull() && !data.OriginServers.IsUnknown() {
			data.OriginServers.ElementsAs(ctx, &existingOriginServersItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_serversList = append(origin_serversList, OriginPoolOriginServersModel{
					CbipService: func() *OriginPoolOriginServersCbipServiceModel {
						if nestedMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersCbipServiceModel{
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					ConsulService: func() *OriginPoolOriginServersConsulServiceModel {
						if nestedMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersConsulServiceModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].ConsulService != nil && existingOriginServersItems[listIdx].ConsulService.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].ConsulService != nil && existingOriginServersItems[listIdx].ConsulService.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					CustomEndpointObject: func() *OriginPoolOriginServersCustomEndpointObjectModel {
						if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersCustomEndpointObjectModel{}
						}
						return nil
					}(),
					K8SService: func() *OriginPoolOriginServersK8SServiceModel {
						if nestedMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersK8SServiceModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								Protocol: func() types.String {
									if v, ok := nestedMap["protocol"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Vk8sNetworks: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.Vk8sNetworks != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					Labels: func() *OriginPoolEmptyModel {
						if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].Labels != nil {
							return &OriginPoolEmptyModel{}
						}
						return nil
					}(),
					PrivateIP: func() *OriginPoolOriginServersPrivateIPModel {
						if nestedMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPrivateIPModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateIP != nil && existingOriginServersItems[listIdx].PrivateIP.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateIP != nil && existingOriginServersItems[listIdx].PrivateIP.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					PrivateName: func() *OriginPoolOriginServersPrivateNameModel {
						if nestedMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPrivateNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateName != nil && existingOriginServersItems[listIdx].PrivateName.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateName != nil && existingOriginServersItems[listIdx].PrivateName.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								RefreshInterval: func() types.Int64 {
									if v, ok := nestedMap["refresh_interval"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					PublicIP: func() *OriginPoolOriginServersPublicIPModel {
						if nestedMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPublicIPModel{
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					PublicName: func() *OriginPoolOriginServersPublicNameModel {
						if nestedMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPublicNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RefreshInterval: func() types.Int64 {
									if v, ok := nestedMap["refresh_interval"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					VnPrivateIP: func() *OriginPoolOriginServersVnPrivateIPModel {
						if nestedMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersVnPrivateIPModel{
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					VnPrivateName: func() *OriginPoolOriginServersVnPrivateNameModel {
						if nestedMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersVnPrivateNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: OriginPoolOriginServersModelAttrTypes}, origin_serversList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginServers = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginServers = types.ListNull(types.ObjectType{AttrTypes: OriginPoolOriginServersModelAttrTypes})
	}
	if _, ok := apiResource.Spec["same_as_endpoint_port"].(map[string]interface{}); ok && isImport && data.SameAsEndpointPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SameAsEndpointPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok && isImport && data.UpstreamConnPoolReuseType == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UpstreamConnPoolReuseType = &OriginPoolUpstreamConnPoolReuseTypeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["use_tls"].(map[string]interface{}); ok && (isImport || data.UseTLS != nil) {
		data.UseTLS = &OriginPoolUseTLSModel{
			DefaultSessionKeyCaching: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DefaultSessionKeyCaching
				}
				// Import case: read from API
				if _, ok := blockData["default_session_key_caching"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSessionKeyCaching: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DisableSessionKeyCaching
				}
				// Import case: read from API
				if _, ok := blockData["disable_session_key_caching"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSni: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DisableSni
				}
				// Import case: read from API
				if _, ok := blockData["disable_sni"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			MaxSessionKeys: func() types.Int64 {
				if !isImport && data.UseTLS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.UseTLS.MaxSessionKeys
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["max_session_keys"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoMtls: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			SkipServerVerification: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.SkipServerVerification
				}
				// Import case: read from API
				if _, ok := blockData["skip_server_verification"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			Sni: func() types.String {
				if v, ok := blockData["sni"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *OriginPoolUseTLSTLSConfigModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSTLSConfigModel{}
				}
				return nil
			}(),
			UseHostHeaderAsSni: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.UseHostHeaderAsSni
				}
				// Import case: read from API
				if _, ok := blockData["use_host_header_as_sni"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			UseMtls: func() *OriginPoolUseTLSUseMtlsModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseMtls
				}
				// Import case: read from API
				if _, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseMtlsModel{}
				}
				return nil
			}(),
			UseMtlsObj: func() *OriginPoolUseTLSUseMtlsObjModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseMtlsObj != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseMtlsObj
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls_obj"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseMtlsObjModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			UseServerVerification: func() *OriginPoolUseTLSUseServerVerificationModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseServerVerification != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseServerVerification
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_server_verification"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseServerVerificationModel{
						TrustedCAURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			VolterraTrustedCA: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.VolterraTrustedCA
				}
				// Import case: read from API
				if _, ok := blockData["volterra_trusted_ca"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["endpoint_selection"].(string); ok && v != "" {
		data.EndpointSelection = types.StringValue(v)
	} else {
		data.EndpointSelection = types.StringNull()
	}
	if v, ok := apiResource.Spec["health_check_port"].(float64); ok {
		data.HealthCheckPort = types.Int64Value(int64(v))
	} else {
		data.HealthCheckPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["loadbalancer_algorithm"].(string); ok && v != "" {
		data.LoadBalancerAlgorithm = types.StringValue(v)
	} else {
		data.LoadBalancerAlgorithm = types.StringNull()
	}
	if v, ok := apiResource.Spec["port"].(float64); ok {
		data.Port = types.Int64Value(int64(v))
	} else {
		data.Port = types.Int64Null()
	}

	tflog.Trace(ctx, "created OriginPool resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OriginPoolResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data OriginPoolResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetOriginPool(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "OriginPool not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read OriginPool: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["advanced_options"].(map[string]interface{}); ok && (isImport || data.AdvancedOptions != nil) {
		data.AdvancedOptions = &OriginPoolAdvancedOptionsModel{
			AutoHTTPConfig: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.AutoHTTPConfig
				}
				// Import case: read from API
				if _, ok := blockData["auto_http_config"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			CircuitBreaker: func() *OriginPoolAdvancedOptionsCircuitBreakerModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.CircuitBreaker != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.CircuitBreaker
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsCircuitBreakerModel{
						ConnectionLimit: func() types.Int64 {
							if v, ok := nestedBlockData["connection_limit"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						MaxRequests: func() types.Int64 {
							if v, ok := nestedBlockData["max_requests"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PendingRequests: func() types.Int64 {
							if v, ok := nestedBlockData["pending_requests"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Priority: func() types.String {
							if v, ok := nestedBlockData["priority"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Retries: func() types.Int64 {
							if v, ok := nestedBlockData["retries"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ConnectionTimeout: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.ConnectionTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultCircuitBreaker: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DefaultCircuitBreaker
				}
				// Import case: read from API
				if _, ok := blockData["default_circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableCircuitBreaker: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableCircuitBreaker
				}
				// Import case: read from API
				if _, ok := blockData["disable_circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableLBSourceIPPersistance: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableLBSourceIPPersistance
				}
				// Import case: read from API
				if _, ok := blockData["disable_lb_source_ip_persistance"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableOutlierDetection: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableOutlierDetection
				}
				// Import case: read from API
				if _, ok := blockData["disable_outlier_detection"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableProxyProtocol: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableProxyProtocol
				}
				// Import case: read from API
				if _, ok := blockData["disable_proxy_protocol"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSubsets: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableSubsets
				}
				// Import case: read from API
				if _, ok := blockData["disable_subsets"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			EnableLBSourceIPPersistance: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.EnableLBSourceIPPersistance
				}
				// Import case: read from API
				if _, ok := blockData["enable_lb_source_ip_persistance"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			EnableSubsets: func() *OriginPoolAdvancedOptionsEnableSubsetsModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.EnableSubsets != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.EnableSubsets
				}
				// Import case: read from API
				if _, ok := blockData["enable_subsets"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsEnableSubsetsModel{}
				}
				return nil
			}(),
			Http1Config: func() *OriginPoolAdvancedOptionsHttp1ConfigModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.Http1Config != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.Http1Config
				}
				// Import case: read from API
				if _, ok := blockData["http1_config"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsHttp1ConfigModel{}
				}
				return nil
			}(),
			Http2Options: func() *OriginPoolAdvancedOptionsHttp2OptionsModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.Http2Options != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.Http2Options
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["http2_options"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsHttp2OptionsModel{
						Enabled: func() types.Bool {
							if v, ok := nestedBlockData["enabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			HTTPIdleTimeout: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.HTTPIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["http_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoPanicThreshold: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.NoPanicThreshold
				}
				// Import case: read from API
				if _, ok := blockData["no_panic_threshold"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			OutlierDetection: func() *OriginPoolAdvancedOptionsOutlierDetectionModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.OutlierDetection != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.OutlierDetection
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["outlier_detection"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsOutlierDetectionModel{
						BaseEjectionTime: func() types.Int64 {
							if v, ok := nestedBlockData["base_ejection_time"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Consecutive5xx: func() types.Int64 {
							if v, ok := nestedBlockData["consecutive_5xx"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ConsecutiveGatewayFailure: func() types.Int64 {
							if v, ok := nestedBlockData["consecutive_gateway_failure"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Interval: func() types.Int64 {
							if v, ok := nestedBlockData["interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						MaxEjectionPercent: func() types.Int64 {
							if v, ok := nestedBlockData["max_ejection_percent"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PanicThreshold: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.PanicThreshold
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["panic_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ProxyProtocolV1: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.ProxyProtocolV1
				}
				// Import case: read from API
				if _, ok := blockData["proxy_protocol_v1"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			ProxyProtocolV2: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.ProxyProtocolV2
				}
				// Import case: read from API
				if _, ok := blockData["proxy_protocol_v2"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["automatic_port"].(map[string]interface{}); ok && isImport && data.AutomaticPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AutomaticPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["healthcheck"].([]interface{}); ok && len(listData) > 0 {
		var healthcheckList []OriginPoolHealthcheckModel
		var existingHealthcheckItems []OriginPoolHealthcheckModel
		if !data.Healthcheck.IsNull() && !data.Healthcheck.IsUnknown() {
			data.Healthcheck.ElementsAs(ctx, &existingHealthcheckItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				healthcheckList = append(healthcheckList, OriginPoolHealthcheckModel{
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Namespace: func() types.String {
						if v, ok := itemMap["namespace"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Tenant: func() types.String {
						if v, ok := itemMap["tenant"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: OriginPoolHealthcheckModelAttrTypes}, healthcheckList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Healthcheck = listVal
		}
	} else {
		// No data from API - set to null list
		data.Healthcheck = types.ListNull(types.ObjectType{AttrTypes: OriginPoolHealthcheckModelAttrTypes})
	}
	if _, ok := apiResource.Spec["lb_port"].(map[string]interface{}); ok && isImport && data.LBPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LBPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_tls"].(map[string]interface{}); ok && isImport && data.NoTLS == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoTLS = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_servers"].([]interface{}); ok && len(listData) > 0 {
		var origin_serversList []OriginPoolOriginServersModel
		var existingOriginServersItems []OriginPoolOriginServersModel
		if !data.OriginServers.IsNull() && !data.OriginServers.IsUnknown() {
			data.OriginServers.ElementsAs(ctx, &existingOriginServersItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_serversList = append(origin_serversList, OriginPoolOriginServersModel{
					CbipService: func() *OriginPoolOriginServersCbipServiceModel {
						if nestedMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersCbipServiceModel{
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					ConsulService: func() *OriginPoolOriginServersConsulServiceModel {
						if nestedMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersConsulServiceModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].ConsulService != nil && existingOriginServersItems[listIdx].ConsulService.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].ConsulService != nil && existingOriginServersItems[listIdx].ConsulService.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					CustomEndpointObject: func() *OriginPoolOriginServersCustomEndpointObjectModel {
						if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersCustomEndpointObjectModel{}
						}
						return nil
					}(),
					K8SService: func() *OriginPoolOriginServersK8SServiceModel {
						if nestedMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersK8SServiceModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								Protocol: func() types.String {
									if v, ok := nestedMap["protocol"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Vk8sNetworks: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.Vk8sNetworks != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					Labels: func() *OriginPoolEmptyModel {
						if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].Labels != nil {
							return &OriginPoolEmptyModel{}
						}
						return nil
					}(),
					PrivateIP: func() *OriginPoolOriginServersPrivateIPModel {
						if nestedMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPrivateIPModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateIP != nil && existingOriginServersItems[listIdx].PrivateIP.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateIP != nil && existingOriginServersItems[listIdx].PrivateIP.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					PrivateName: func() *OriginPoolOriginServersPrivateNameModel {
						if nestedMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPrivateNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateName != nil && existingOriginServersItems[listIdx].PrivateName.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateName != nil && existingOriginServersItems[listIdx].PrivateName.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								RefreshInterval: func() types.Int64 {
									if v, ok := nestedMap["refresh_interval"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					PublicIP: func() *OriginPoolOriginServersPublicIPModel {
						if nestedMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPublicIPModel{
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					PublicName: func() *OriginPoolOriginServersPublicNameModel {
						if nestedMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPublicNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RefreshInterval: func() types.Int64 {
									if v, ok := nestedMap["refresh_interval"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					VnPrivateIP: func() *OriginPoolOriginServersVnPrivateIPModel {
						if nestedMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersVnPrivateIPModel{
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					VnPrivateName: func() *OriginPoolOriginServersVnPrivateNameModel {
						if nestedMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersVnPrivateNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: OriginPoolOriginServersModelAttrTypes}, origin_serversList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginServers = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginServers = types.ListNull(types.ObjectType{AttrTypes: OriginPoolOriginServersModelAttrTypes})
	}
	if _, ok := apiResource.Spec["same_as_endpoint_port"].(map[string]interface{}); ok && isImport && data.SameAsEndpointPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SameAsEndpointPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok && isImport && data.UpstreamConnPoolReuseType == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UpstreamConnPoolReuseType = &OriginPoolUpstreamConnPoolReuseTypeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["use_tls"].(map[string]interface{}); ok && (isImport || data.UseTLS != nil) {
		data.UseTLS = &OriginPoolUseTLSModel{
			DefaultSessionKeyCaching: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DefaultSessionKeyCaching
				}
				// Import case: read from API
				if _, ok := blockData["default_session_key_caching"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSessionKeyCaching: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DisableSessionKeyCaching
				}
				// Import case: read from API
				if _, ok := blockData["disable_session_key_caching"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSni: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DisableSni
				}
				// Import case: read from API
				if _, ok := blockData["disable_sni"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			MaxSessionKeys: func() types.Int64 {
				if !isImport && data.UseTLS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.UseTLS.MaxSessionKeys
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["max_session_keys"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoMtls: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			SkipServerVerification: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.SkipServerVerification
				}
				// Import case: read from API
				if _, ok := blockData["skip_server_verification"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			Sni: func() types.String {
				if v, ok := blockData["sni"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *OriginPoolUseTLSTLSConfigModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSTLSConfigModel{}
				}
				return nil
			}(),
			UseHostHeaderAsSni: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.UseHostHeaderAsSni
				}
				// Import case: read from API
				if _, ok := blockData["use_host_header_as_sni"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			UseMtls: func() *OriginPoolUseTLSUseMtlsModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseMtls
				}
				// Import case: read from API
				if _, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseMtlsModel{}
				}
				return nil
			}(),
			UseMtlsObj: func() *OriginPoolUseTLSUseMtlsObjModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseMtlsObj != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseMtlsObj
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls_obj"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseMtlsObjModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			UseServerVerification: func() *OriginPoolUseTLSUseServerVerificationModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseServerVerification != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseServerVerification
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_server_verification"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseServerVerificationModel{
						TrustedCAURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			VolterraTrustedCA: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.VolterraTrustedCA
				}
				// Import case: read from API
				if _, ok := blockData["volterra_trusted_ca"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["endpoint_selection"].(string); ok && v != "" {
		data.EndpointSelection = types.StringValue(v)
	} else {
		data.EndpointSelection = types.StringNull()
	}
	if v, ok := apiResource.Spec["health_check_port"].(float64); ok {
		data.HealthCheckPort = types.Int64Value(int64(v))
	} else {
		data.HealthCheckPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["loadbalancer_algorithm"].(string); ok && v != "" {
		data.LoadBalancerAlgorithm = types.StringValue(v)
	} else {
		data.LoadBalancerAlgorithm = types.StringNull()
	}
	if v, ok := apiResource.Spec["port"].(float64); ok {
		data.Port = types.Int64Value(int64(v))
	} else {
		data.Port = types.Int64Null()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OriginPoolResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data OriginPoolResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.OriginPool{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdvancedOptions != nil {
		advanced_optionsMap := make(map[string]interface{})
		if data.AdvancedOptions.AutoHTTPConfig != nil {
			advanced_optionsMap["auto_http_config"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.CircuitBreaker != nil {
			circuit_breakerNestedMap := make(map[string]interface{})
			if !data.AdvancedOptions.CircuitBreaker.ConnectionLimit.IsNull() && !data.AdvancedOptions.CircuitBreaker.ConnectionLimit.IsUnknown() {
				circuit_breakerNestedMap["connection_limit"] = data.AdvancedOptions.CircuitBreaker.ConnectionLimit.ValueInt64()
			}
			if !data.AdvancedOptions.CircuitBreaker.MaxRequests.IsNull() && !data.AdvancedOptions.CircuitBreaker.MaxRequests.IsUnknown() {
				circuit_breakerNestedMap["max_requests"] = data.AdvancedOptions.CircuitBreaker.MaxRequests.ValueInt64()
			}
			if !data.AdvancedOptions.CircuitBreaker.PendingRequests.IsNull() && !data.AdvancedOptions.CircuitBreaker.PendingRequests.IsUnknown() {
				circuit_breakerNestedMap["pending_requests"] = data.AdvancedOptions.CircuitBreaker.PendingRequests.ValueInt64()
			}
			if !data.AdvancedOptions.CircuitBreaker.Priority.IsNull() && !data.AdvancedOptions.CircuitBreaker.Priority.IsUnknown() {
				circuit_breakerNestedMap["priority"] = data.AdvancedOptions.CircuitBreaker.Priority.ValueString()
			}
			if !data.AdvancedOptions.CircuitBreaker.Retries.IsNull() && !data.AdvancedOptions.CircuitBreaker.Retries.IsUnknown() {
				circuit_breakerNestedMap["retries"] = data.AdvancedOptions.CircuitBreaker.Retries.ValueInt64()
			}
			advanced_optionsMap["circuit_breaker"] = circuit_breakerNestedMap
		}
		if !data.AdvancedOptions.ConnectionTimeout.IsNull() && !data.AdvancedOptions.ConnectionTimeout.IsUnknown() {
			advanced_optionsMap["connection_timeout"] = data.AdvancedOptions.ConnectionTimeout.ValueInt64()
		}
		if data.AdvancedOptions.DefaultCircuitBreaker != nil {
			advanced_optionsMap["default_circuit_breaker"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableCircuitBreaker != nil {
			advanced_optionsMap["disable_circuit_breaker"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableLBSourceIPPersistance != nil {
			advanced_optionsMap["disable_lb_source_ip_persistance"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableOutlierDetection != nil {
			advanced_optionsMap["disable_outlier_detection"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableProxyProtocol != nil {
			advanced_optionsMap["disable_proxy_protocol"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.DisableSubsets != nil {
			advanced_optionsMap["disable_subsets"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.EnableLBSourceIPPersistance != nil {
			advanced_optionsMap["enable_lb_source_ip_persistance"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.EnableSubsets != nil {
			enable_subsetsNestedMap := make(map[string]interface{})
			advanced_optionsMap["enable_subsets"] = enable_subsetsNestedMap
		}
		if data.AdvancedOptions.Http1Config != nil {
			http1_configNestedMap := make(map[string]interface{})
			advanced_optionsMap["http1_config"] = http1_configNestedMap
		}
		if data.AdvancedOptions.Http2Options != nil {
			http2_optionsNestedMap := make(map[string]interface{})
			if !data.AdvancedOptions.Http2Options.Enabled.IsNull() && !data.AdvancedOptions.Http2Options.Enabled.IsUnknown() {
				http2_optionsNestedMap["enabled"] = data.AdvancedOptions.Http2Options.Enabled.ValueBool()
			}
			advanced_optionsMap["http2_options"] = http2_optionsNestedMap
		}
		if !data.AdvancedOptions.HTTPIdleTimeout.IsNull() && !data.AdvancedOptions.HTTPIdleTimeout.IsUnknown() {
			advanced_optionsMap["http_idle_timeout"] = data.AdvancedOptions.HTTPIdleTimeout.ValueInt64()
		}
		if data.AdvancedOptions.NoPanicThreshold != nil {
			advanced_optionsMap["no_panic_threshold"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.OutlierDetection != nil {
			outlier_detectionNestedMap := make(map[string]interface{})
			if !data.AdvancedOptions.OutlierDetection.BaseEjectionTime.IsNull() && !data.AdvancedOptions.OutlierDetection.BaseEjectionTime.IsUnknown() {
				outlier_detectionNestedMap["base_ejection_time"] = data.AdvancedOptions.OutlierDetection.BaseEjectionTime.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.Consecutive5xx.IsNull() && !data.AdvancedOptions.OutlierDetection.Consecutive5xx.IsUnknown() {
				outlier_detectionNestedMap["consecutive_5xx"] = data.AdvancedOptions.OutlierDetection.Consecutive5xx.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.ConsecutiveGatewayFailure.IsNull() && !data.AdvancedOptions.OutlierDetection.ConsecutiveGatewayFailure.IsUnknown() {
				outlier_detectionNestedMap["consecutive_gateway_failure"] = data.AdvancedOptions.OutlierDetection.ConsecutiveGatewayFailure.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.Interval.IsNull() && !data.AdvancedOptions.OutlierDetection.Interval.IsUnknown() {
				outlier_detectionNestedMap["interval"] = data.AdvancedOptions.OutlierDetection.Interval.ValueInt64()
			}
			if !data.AdvancedOptions.OutlierDetection.MaxEjectionPercent.IsNull() && !data.AdvancedOptions.OutlierDetection.MaxEjectionPercent.IsUnknown() {
				outlier_detectionNestedMap["max_ejection_percent"] = data.AdvancedOptions.OutlierDetection.MaxEjectionPercent.ValueInt64()
			}
			advanced_optionsMap["outlier_detection"] = outlier_detectionNestedMap
		}
		if !data.AdvancedOptions.PanicThreshold.IsNull() && !data.AdvancedOptions.PanicThreshold.IsUnknown() {
			advanced_optionsMap["panic_threshold"] = data.AdvancedOptions.PanicThreshold.ValueInt64()
		}
		if data.AdvancedOptions.ProxyProtocolV1 != nil {
			advanced_optionsMap["proxy_protocol_v1"] = map[string]interface{}{}
		}
		if data.AdvancedOptions.ProxyProtocolV2 != nil {
			advanced_optionsMap["proxy_protocol_v2"] = map[string]interface{}{}
		}
		apiResource.Spec["advanced_options"] = advanced_optionsMap
	}
	if data.AutomaticPort != nil {
		automatic_portMap := make(map[string]interface{})
		apiResource.Spec["automatic_port"] = automatic_portMap
	}
	if !data.Healthcheck.IsNull() && !data.Healthcheck.IsUnknown() {
		var healthcheckItems []OriginPoolHealthcheckModel
		diags := data.Healthcheck.ElementsAs(ctx, &healthcheckItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(healthcheckItems) > 0 {
			var healthcheckList []map[string]interface{}
			for _, item := range healthcheckItems {
				itemMap := make(map[string]interface{})
				if !item.Name.IsNull() && !item.Name.IsUnknown() {
					itemMap["name"] = item.Name.ValueString()
				}
				if !item.Namespace.IsNull() && !item.Namespace.IsUnknown() {
					itemMap["namespace"] = item.Namespace.ValueString()
				}
				if !item.Tenant.IsNull() && !item.Tenant.IsUnknown() {
					itemMap["tenant"] = item.Tenant.ValueString()
				}
				healthcheckList = append(healthcheckList, itemMap)
			}
			apiResource.Spec["healthcheck"] = healthcheckList
		}
	}
	if data.LBPort != nil {
		lb_portMap := make(map[string]interface{})
		apiResource.Spec["lb_port"] = lb_portMap
	}
	if data.NoTLS != nil {
		no_tlsMap := make(map[string]interface{})
		apiResource.Spec["no_tls"] = no_tlsMap
	}
	if !data.OriginServers.IsNull() && !data.OriginServers.IsUnknown() {
		var origin_serversItems []OriginPoolOriginServersModel
		diags := data.OriginServers.ElementsAs(ctx, &origin_serversItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(origin_serversItems) > 0 {
			var origin_serversList []map[string]interface{}
			for _, item := range origin_serversItems {
				itemMap := make(map[string]interface{})
				if item.CbipService != nil {
					cbip_serviceNestedMap := make(map[string]interface{})
					if !item.CbipService.ServiceName.IsNull() && !item.CbipService.ServiceName.IsUnknown() {
						cbip_serviceNestedMap["service_name"] = item.CbipService.ServiceName.ValueString()
					}
					itemMap["cbip_service"] = cbip_serviceNestedMap
				}
				if item.ConsulService != nil {
					consul_serviceNestedMap := make(map[string]interface{})
					if item.ConsulService.InsideNetwork != nil {
						consul_serviceNestedMap["inside_network"] = map[string]interface{}{}
					}
					if item.ConsulService.OutsideNetwork != nil {
						consul_serviceNestedMap["outside_network"] = map[string]interface{}{}
					}
					if !item.ConsulService.ServiceName.IsNull() && !item.ConsulService.ServiceName.IsUnknown() {
						consul_serviceNestedMap["service_name"] = item.ConsulService.ServiceName.ValueString()
					}
					if item.ConsulService.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						consul_serviceNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.ConsulService.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.ConsulService.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						consul_serviceNestedMap["snat_pool"] = snat_poolDeepMap
					}
					itemMap["consul_service"] = consul_serviceNestedMap
				}
				if item.CustomEndpointObject != nil {
					custom_endpoint_objectNestedMap := make(map[string]interface{})
					if item.CustomEndpointObject.Endpoint != nil {
						endpointDeepMap := make(map[string]interface{})
						if !item.CustomEndpointObject.Endpoint.Name.IsNull() && !item.CustomEndpointObject.Endpoint.Name.IsUnknown() {
							endpointDeepMap["name"] = item.CustomEndpointObject.Endpoint.Name.ValueString()
						}
						if !item.CustomEndpointObject.Endpoint.Namespace.IsNull() && !item.CustomEndpointObject.Endpoint.Namespace.IsUnknown() {
							endpointDeepMap["namespace"] = item.CustomEndpointObject.Endpoint.Namespace.ValueString()
						}
						if !item.CustomEndpointObject.Endpoint.Tenant.IsNull() && !item.CustomEndpointObject.Endpoint.Tenant.IsUnknown() {
							endpointDeepMap["tenant"] = item.CustomEndpointObject.Endpoint.Tenant.ValueString()
						}
						custom_endpoint_objectNestedMap["endpoint"] = endpointDeepMap
					}
					itemMap["custom_endpoint_object"] = custom_endpoint_objectNestedMap
				}
				if item.K8SService != nil {
					k8s_serviceNestedMap := make(map[string]interface{})
					if item.K8SService.InsideNetwork != nil {
						k8s_serviceNestedMap["inside_network"] = map[string]interface{}{}
					}
					if item.K8SService.OutsideNetwork != nil {
						k8s_serviceNestedMap["outside_network"] = map[string]interface{}{}
					}
					if !item.K8SService.Protocol.IsNull() && !item.K8SService.Protocol.IsUnknown() {
						k8s_serviceNestedMap["protocol"] = item.K8SService.Protocol.ValueString()
					}
					if !item.K8SService.ServiceName.IsNull() && !item.K8SService.ServiceName.IsUnknown() {
						k8s_serviceNestedMap["service_name"] = item.K8SService.ServiceName.ValueString()
					}
					if item.K8SService.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						k8s_serviceNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.K8SService.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.K8SService.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						k8s_serviceNestedMap["snat_pool"] = snat_poolDeepMap
					}
					if item.K8SService.Vk8sNetworks != nil {
						k8s_serviceNestedMap["vk8s_networks"] = map[string]interface{}{}
					}
					itemMap["k8s_service"] = k8s_serviceNestedMap
				}
				if item.Labels != nil {
					itemMap["labels"] = map[string]interface{}{}
				}
				if item.PrivateIP != nil {
					private_ipNestedMap := make(map[string]interface{})
					if item.PrivateIP.InsideNetwork != nil {
						private_ipNestedMap["inside_network"] = map[string]interface{}{}
					}
					if !item.PrivateIP.IP.IsNull() && !item.PrivateIP.IP.IsUnknown() {
						private_ipNestedMap["ip"] = item.PrivateIP.IP.ValueString()
					}
					if item.PrivateIP.OutsideNetwork != nil {
						private_ipNestedMap["outside_network"] = map[string]interface{}{}
					}
					if item.PrivateIP.Segment != nil {
						segmentDeepMap := make(map[string]interface{})
						if !item.PrivateIP.Segment.Name.IsNull() && !item.PrivateIP.Segment.Name.IsUnknown() {
							segmentDeepMap["name"] = item.PrivateIP.Segment.Name.ValueString()
						}
						if !item.PrivateIP.Segment.Namespace.IsNull() && !item.PrivateIP.Segment.Namespace.IsUnknown() {
							segmentDeepMap["namespace"] = item.PrivateIP.Segment.Namespace.ValueString()
						}
						if !item.PrivateIP.Segment.Tenant.IsNull() && !item.PrivateIP.Segment.Tenant.IsUnknown() {
							segmentDeepMap["tenant"] = item.PrivateIP.Segment.Tenant.ValueString()
						}
						private_ipNestedMap["segment"] = segmentDeepMap
					}
					if item.PrivateIP.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						private_ipNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.PrivateIP.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.PrivateIP.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						private_ipNestedMap["snat_pool"] = snat_poolDeepMap
					}
					itemMap["private_ip"] = private_ipNestedMap
				}
				if item.PrivateName != nil {
					private_nameNestedMap := make(map[string]interface{})
					if !item.PrivateName.DNSName.IsNull() && !item.PrivateName.DNSName.IsUnknown() {
						private_nameNestedMap["dns_name"] = item.PrivateName.DNSName.ValueString()
					}
					if item.PrivateName.InsideNetwork != nil {
						private_nameNestedMap["inside_network"] = map[string]interface{}{}
					}
					if item.PrivateName.OutsideNetwork != nil {
						private_nameNestedMap["outside_network"] = map[string]interface{}{}
					}
					if !item.PrivateName.RefreshInterval.IsNull() && !item.PrivateName.RefreshInterval.IsUnknown() {
						private_nameNestedMap["refresh_interval"] = item.PrivateName.RefreshInterval.ValueInt64()
					}
					if item.PrivateName.Segment != nil {
						segmentDeepMap := make(map[string]interface{})
						if !item.PrivateName.Segment.Name.IsNull() && !item.PrivateName.Segment.Name.IsUnknown() {
							segmentDeepMap["name"] = item.PrivateName.Segment.Name.ValueString()
						}
						if !item.PrivateName.Segment.Namespace.IsNull() && !item.PrivateName.Segment.Namespace.IsUnknown() {
							segmentDeepMap["namespace"] = item.PrivateName.Segment.Namespace.ValueString()
						}
						if !item.PrivateName.Segment.Tenant.IsNull() && !item.PrivateName.Segment.Tenant.IsUnknown() {
							segmentDeepMap["tenant"] = item.PrivateName.Segment.Tenant.ValueString()
						}
						private_nameNestedMap["segment"] = segmentDeepMap
					}
					if item.PrivateName.SiteLocator != nil {
						site_locatorDeepMap := make(map[string]interface{})
						private_nameNestedMap["site_locator"] = site_locatorDeepMap
					}
					if item.PrivateName.SnatPool != nil {
						snat_poolDeepMap := make(map[string]interface{})
						if item.PrivateName.SnatPool.NoSnatPool != nil {
							snat_poolDeepMap["no_snat_pool"] = map[string]interface{}{}
						}
						private_nameNestedMap["snat_pool"] = snat_poolDeepMap
					}
					itemMap["private_name"] = private_nameNestedMap
				}
				if item.PublicIP != nil {
					public_ipNestedMap := make(map[string]interface{})
					if !item.PublicIP.IP.IsNull() && !item.PublicIP.IP.IsUnknown() {
						public_ipNestedMap["ip"] = item.PublicIP.IP.ValueString()
					}
					itemMap["public_ip"] = public_ipNestedMap
				}
				if item.PublicName != nil {
					public_nameNestedMap := make(map[string]interface{})
					if !item.PublicName.DNSName.IsNull() && !item.PublicName.DNSName.IsUnknown() {
						public_nameNestedMap["dns_name"] = item.PublicName.DNSName.ValueString()
					}
					if !item.PublicName.RefreshInterval.IsNull() && !item.PublicName.RefreshInterval.IsUnknown() {
						public_nameNestedMap["refresh_interval"] = item.PublicName.RefreshInterval.ValueInt64()
					}
					itemMap["public_name"] = public_nameNestedMap
				}
				if item.VnPrivateIP != nil {
					vn_private_ipNestedMap := make(map[string]interface{})
					if !item.VnPrivateIP.IP.IsNull() && !item.VnPrivateIP.IP.IsUnknown() {
						vn_private_ipNestedMap["ip"] = item.VnPrivateIP.IP.ValueString()
					}
					if item.VnPrivateIP.VirtualNetwork != nil {
						virtual_networkDeepMap := make(map[string]interface{})
						if !item.VnPrivateIP.VirtualNetwork.Name.IsNull() && !item.VnPrivateIP.VirtualNetwork.Name.IsUnknown() {
							virtual_networkDeepMap["name"] = item.VnPrivateIP.VirtualNetwork.Name.ValueString()
						}
						if !item.VnPrivateIP.VirtualNetwork.Namespace.IsNull() && !item.VnPrivateIP.VirtualNetwork.Namespace.IsUnknown() {
							virtual_networkDeepMap["namespace"] = item.VnPrivateIP.VirtualNetwork.Namespace.ValueString()
						}
						if !item.VnPrivateIP.VirtualNetwork.Tenant.IsNull() && !item.VnPrivateIP.VirtualNetwork.Tenant.IsUnknown() {
							virtual_networkDeepMap["tenant"] = item.VnPrivateIP.VirtualNetwork.Tenant.ValueString()
						}
						vn_private_ipNestedMap["virtual_network"] = virtual_networkDeepMap
					}
					itemMap["vn_private_ip"] = vn_private_ipNestedMap
				}
				if item.VnPrivateName != nil {
					vn_private_nameNestedMap := make(map[string]interface{})
					if !item.VnPrivateName.DNSName.IsNull() && !item.VnPrivateName.DNSName.IsUnknown() {
						vn_private_nameNestedMap["dns_name"] = item.VnPrivateName.DNSName.ValueString()
					}
					if item.VnPrivateName.PrivateNetwork != nil {
						private_networkDeepMap := make(map[string]interface{})
						if !item.VnPrivateName.PrivateNetwork.Name.IsNull() && !item.VnPrivateName.PrivateNetwork.Name.IsUnknown() {
							private_networkDeepMap["name"] = item.VnPrivateName.PrivateNetwork.Name.ValueString()
						}
						if !item.VnPrivateName.PrivateNetwork.Namespace.IsNull() && !item.VnPrivateName.PrivateNetwork.Namespace.IsUnknown() {
							private_networkDeepMap["namespace"] = item.VnPrivateName.PrivateNetwork.Namespace.ValueString()
						}
						if !item.VnPrivateName.PrivateNetwork.Tenant.IsNull() && !item.VnPrivateName.PrivateNetwork.Tenant.IsUnknown() {
							private_networkDeepMap["tenant"] = item.VnPrivateName.PrivateNetwork.Tenant.ValueString()
						}
						vn_private_nameNestedMap["private_network"] = private_networkDeepMap
					}
					itemMap["vn_private_name"] = vn_private_nameNestedMap
				}
				origin_serversList = append(origin_serversList, itemMap)
			}
			apiResource.Spec["origin_servers"] = origin_serversList
		}
	}
	if data.SameAsEndpointPort != nil {
		same_as_endpoint_portMap := make(map[string]interface{})
		apiResource.Spec["same_as_endpoint_port"] = same_as_endpoint_portMap
	}
	if data.UpstreamConnPoolReuseType != nil {
		upstream_conn_pool_reuse_typeMap := make(map[string]interface{})
		if data.UpstreamConnPoolReuseType.DisableConnPoolReuse != nil {
			upstream_conn_pool_reuse_typeMap["disable_conn_pool_reuse"] = map[string]interface{}{}
		}
		if data.UpstreamConnPoolReuseType.EnableConnPoolReuse != nil {
			upstream_conn_pool_reuse_typeMap["enable_conn_pool_reuse"] = map[string]interface{}{}
		}
		apiResource.Spec["upstream_conn_pool_reuse_type"] = upstream_conn_pool_reuse_typeMap
	}
	if data.UseTLS != nil {
		use_tlsMap := make(map[string]interface{})
		if data.UseTLS.DefaultSessionKeyCaching != nil {
			use_tlsMap["default_session_key_caching"] = map[string]interface{}{}
		}
		if data.UseTLS.DisableSessionKeyCaching != nil {
			use_tlsMap["disable_session_key_caching"] = map[string]interface{}{}
		}
		if data.UseTLS.DisableSni != nil {
			use_tlsMap["disable_sni"] = map[string]interface{}{}
		}
		if !data.UseTLS.MaxSessionKeys.IsNull() && !data.UseTLS.MaxSessionKeys.IsUnknown() {
			use_tlsMap["max_session_keys"] = data.UseTLS.MaxSessionKeys.ValueInt64()
		}
		if data.UseTLS.NoMtls != nil {
			use_tlsMap["no_mtls"] = map[string]interface{}{}
		}
		if data.UseTLS.SkipServerVerification != nil {
			use_tlsMap["skip_server_verification"] = map[string]interface{}{}
		}
		if !data.UseTLS.Sni.IsNull() && !data.UseTLS.Sni.IsUnknown() {
			use_tlsMap["sni"] = data.UseTLS.Sni.ValueString()
		}
		if data.UseTLS.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			use_tlsMap["tls_config"] = tls_configNestedMap
		}
		if data.UseTLS.UseHostHeaderAsSni != nil {
			use_tlsMap["use_host_header_as_sni"] = map[string]interface{}{}
		}
		if data.UseTLS.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			use_tlsMap["use_mtls"] = use_mtlsNestedMap
		}
		if data.UseTLS.UseMtlsObj != nil {
			use_mtls_objNestedMap := make(map[string]interface{})
			if !data.UseTLS.UseMtlsObj.Name.IsNull() && !data.UseTLS.UseMtlsObj.Name.IsUnknown() {
				use_mtls_objNestedMap["name"] = data.UseTLS.UseMtlsObj.Name.ValueString()
			}
			if !data.UseTLS.UseMtlsObj.Namespace.IsNull() && !data.UseTLS.UseMtlsObj.Namespace.IsUnknown() {
				use_mtls_objNestedMap["namespace"] = data.UseTLS.UseMtlsObj.Namespace.ValueString()
			}
			if !data.UseTLS.UseMtlsObj.Tenant.IsNull() && !data.UseTLS.UseMtlsObj.Tenant.IsUnknown() {
				use_mtls_objNestedMap["tenant"] = data.UseTLS.UseMtlsObj.Tenant.ValueString()
			}
			use_tlsMap["use_mtls_obj"] = use_mtls_objNestedMap
		}
		if data.UseTLS.UseServerVerification != nil {
			use_server_verificationNestedMap := make(map[string]interface{})
			if !data.UseTLS.UseServerVerification.TrustedCAURL.IsNull() && !data.UseTLS.UseServerVerification.TrustedCAURL.IsUnknown() {
				use_server_verificationNestedMap["trusted_ca_url"] = data.UseTLS.UseServerVerification.TrustedCAURL.ValueString()
			}
			use_tlsMap["use_server_verification"] = use_server_verificationNestedMap
		}
		if data.UseTLS.VolterraTrustedCA != nil {
			use_tlsMap["volterra_trusted_ca"] = map[string]interface{}{}
		}
		apiResource.Spec["use_tls"] = use_tlsMap
	}
	if !data.EndpointSelection.IsNull() && !data.EndpointSelection.IsUnknown() {
		apiResource.Spec["endpoint_selection"] = data.EndpointSelection.ValueString()
	}
	if !data.HealthCheckPort.IsNull() && !data.HealthCheckPort.IsUnknown() {
		apiResource.Spec["health_check_port"] = data.HealthCheckPort.ValueInt64()
	}
	if !data.LoadBalancerAlgorithm.IsNull() && !data.LoadBalancerAlgorithm.IsUnknown() {
		apiResource.Spec["loadbalancer_algorithm"] = data.LoadBalancerAlgorithm.ValueString()
	}
	if !data.Port.IsNull() && !data.Port.IsUnknown() {
		apiResource.Spec["port"] = data.Port.ValueInt64()
	}

	_, err := r.client.UpdateOriginPool(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update OriginPool: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetOriginPool(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read OriginPool after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["endpoint_selection"].(string); ok && v != "" {
		data.EndpointSelection = types.StringValue(v)
	} else if data.EndpointSelection.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.EndpointSelection = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["health_check_port"].(float64); ok {
		data.HealthCheckPort = types.Int64Value(int64(v))
	} else if data.HealthCheckPort.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.HealthCheckPort = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["loadbalancer_algorithm"].(string); ok && v != "" {
		data.LoadBalancerAlgorithm = types.StringValue(v)
	} else if data.LoadBalancerAlgorithm.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.LoadBalancerAlgorithm = types.StringNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["port"].(float64); ok {
		data.Port = types.Int64Value(int64(v))
	} else if data.Port.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Port = types.Int64Null()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["advanced_options"].(map[string]interface{}); ok && (isImport || data.AdvancedOptions != nil) {
		data.AdvancedOptions = &OriginPoolAdvancedOptionsModel{
			AutoHTTPConfig: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.AutoHTTPConfig
				}
				// Import case: read from API
				if _, ok := blockData["auto_http_config"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			CircuitBreaker: func() *OriginPoolAdvancedOptionsCircuitBreakerModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.CircuitBreaker != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.CircuitBreaker
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsCircuitBreakerModel{
						ConnectionLimit: func() types.Int64 {
							if v, ok := nestedBlockData["connection_limit"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						MaxRequests: func() types.Int64 {
							if v, ok := nestedBlockData["max_requests"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						PendingRequests: func() types.Int64 {
							if v, ok := nestedBlockData["pending_requests"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Priority: func() types.String {
							if v, ok := nestedBlockData["priority"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Retries: func() types.Int64 {
							if v, ok := nestedBlockData["retries"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			ConnectionTimeout: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.ConnectionTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["connection_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			DefaultCircuitBreaker: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DefaultCircuitBreaker
				}
				// Import case: read from API
				if _, ok := blockData["default_circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableCircuitBreaker: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableCircuitBreaker
				}
				// Import case: read from API
				if _, ok := blockData["disable_circuit_breaker"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableLBSourceIPPersistance: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableLBSourceIPPersistance
				}
				// Import case: read from API
				if _, ok := blockData["disable_lb_source_ip_persistance"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableOutlierDetection: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableOutlierDetection
				}
				// Import case: read from API
				if _, ok := blockData["disable_outlier_detection"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableProxyProtocol: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableProxyProtocol
				}
				// Import case: read from API
				if _, ok := blockData["disable_proxy_protocol"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSubsets: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.DisableSubsets
				}
				// Import case: read from API
				if _, ok := blockData["disable_subsets"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			EnableLBSourceIPPersistance: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.EnableLBSourceIPPersistance
				}
				// Import case: read from API
				if _, ok := blockData["enable_lb_source_ip_persistance"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			EnableSubsets: func() *OriginPoolAdvancedOptionsEnableSubsetsModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.EnableSubsets != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.EnableSubsets
				}
				// Import case: read from API
				if _, ok := blockData["enable_subsets"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsEnableSubsetsModel{}
				}
				return nil
			}(),
			Http1Config: func() *OriginPoolAdvancedOptionsHttp1ConfigModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.Http1Config != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.Http1Config
				}
				// Import case: read from API
				if _, ok := blockData["http1_config"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsHttp1ConfigModel{}
				}
				return nil
			}(),
			Http2Options: func() *OriginPoolAdvancedOptionsHttp2OptionsModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.Http2Options != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.Http2Options
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["http2_options"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsHttp2OptionsModel{
						Enabled: func() types.Bool {
							if v, ok := nestedBlockData["enabled"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
					}
				}
				return nil
			}(),
			HTTPIdleTimeout: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.HTTPIdleTimeout
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["http_idle_timeout"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoPanicThreshold: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.NoPanicThreshold
				}
				// Import case: read from API
				if _, ok := blockData["no_panic_threshold"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			OutlierDetection: func() *OriginPoolAdvancedOptionsOutlierDetectionModel {
				if !isImport && data.AdvancedOptions != nil && data.AdvancedOptions.OutlierDetection != nil {
					// Normal Read: preserve existing state value
					return data.AdvancedOptions.OutlierDetection
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["outlier_detection"].(map[string]interface{}); ok {
					return &OriginPoolAdvancedOptionsOutlierDetectionModel{
						BaseEjectionTime: func() types.Int64 {
							if v, ok := nestedBlockData["base_ejection_time"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Consecutive5xx: func() types.Int64 {
							if v, ok := nestedBlockData["consecutive_5xx"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						ConsecutiveGatewayFailure: func() types.Int64 {
							if v, ok := nestedBlockData["consecutive_gateway_failure"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						Interval: func() types.Int64 {
							if v, ok := nestedBlockData["interval"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						MaxEjectionPercent: func() types.Int64 {
							if v, ok := nestedBlockData["max_ejection_percent"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			PanicThreshold: func() types.Int64 {
				if !isImport && data.AdvancedOptions != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AdvancedOptions.PanicThreshold
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["panic_threshold"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ProxyProtocolV1: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.ProxyProtocolV1
				}
				// Import case: read from API
				if _, ok := blockData["proxy_protocol_v1"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			ProxyProtocolV2: func() *OriginPoolEmptyModel {
				if !isImport && data.AdvancedOptions != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AdvancedOptions.ProxyProtocolV2
				}
				// Import case: read from API
				if _, ok := blockData["proxy_protocol_v2"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["automatic_port"].(map[string]interface{}); ok && isImport && data.AutomaticPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AutomaticPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["healthcheck"].([]interface{}); ok && len(listData) > 0 {
		var healthcheckList []OriginPoolHealthcheckModel
		var existingHealthcheckItems []OriginPoolHealthcheckModel
		if !data.Healthcheck.IsNull() && !data.Healthcheck.IsUnknown() {
			data.Healthcheck.ElementsAs(ctx, &existingHealthcheckItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				healthcheckList = append(healthcheckList, OriginPoolHealthcheckModel{
					Name: func() types.String {
						if v, ok := itemMap["name"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Namespace: func() types.String {
						if v, ok := itemMap["namespace"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					Tenant: func() types.String {
						if v, ok := itemMap["tenant"].(string); ok && v != "" {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: OriginPoolHealthcheckModelAttrTypes}, healthcheckList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Healthcheck = listVal
		}
	} else {
		// No data from API - set to null list
		data.Healthcheck = types.ListNull(types.ObjectType{AttrTypes: OriginPoolHealthcheckModelAttrTypes})
	}
	if _, ok := apiResource.Spec["lb_port"].(map[string]interface{}); ok && isImport && data.LBPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LBPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_tls"].(map[string]interface{}); ok && isImport && data.NoTLS == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoTLS = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_servers"].([]interface{}); ok && len(listData) > 0 {
		var origin_serversList []OriginPoolOriginServersModel
		var existingOriginServersItems []OriginPoolOriginServersModel
		if !data.OriginServers.IsNull() && !data.OriginServers.IsUnknown() {
			data.OriginServers.ElementsAs(ctx, &existingOriginServersItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_serversList = append(origin_serversList, OriginPoolOriginServersModel{
					CbipService: func() *OriginPoolOriginServersCbipServiceModel {
						if nestedMap, ok := itemMap["cbip_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersCbipServiceModel{
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					ConsulService: func() *OriginPoolOriginServersConsulServiceModel {
						if nestedMap, ok := itemMap["consul_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersConsulServiceModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].ConsulService != nil && existingOriginServersItems[listIdx].ConsulService.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].ConsulService != nil && existingOriginServersItems[listIdx].ConsulService.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					CustomEndpointObject: func() *OriginPoolOriginServersCustomEndpointObjectModel {
						if _, ok := itemMap["custom_endpoint_object"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersCustomEndpointObjectModel{}
						}
						return nil
					}(),
					K8SService: func() *OriginPoolOriginServersK8SServiceModel {
						if nestedMap, ok := itemMap["k8s_service"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersK8SServiceModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								Protocol: func() types.String {
									if v, ok := nestedMap["protocol"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ServiceName: func() types.String {
									if v, ok := nestedMap["service_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Vk8sNetworks: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].K8SService != nil && existingOriginServersItems[listIdx].K8SService.Vk8sNetworks != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					Labels: func() *OriginPoolEmptyModel {
						if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].Labels != nil {
							return &OriginPoolEmptyModel{}
						}
						return nil
					}(),
					PrivateIP: func() *OriginPoolOriginServersPrivateIPModel {
						if nestedMap, ok := itemMap["private_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPrivateIPModel{
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateIP != nil && existingOriginServersItems[listIdx].PrivateIP.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateIP != nil && existingOriginServersItems[listIdx].PrivateIP.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					PrivateName: func() *OriginPoolOriginServersPrivateNameModel {
						if nestedMap, ok := itemMap["private_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPrivateNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateName != nil && existingOriginServersItems[listIdx].PrivateName.InsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								OutsideNetwork: func() *OriginPoolEmptyModel {
									if !isImport && len(existingOriginServersItems) > listIdx && existingOriginServersItems[listIdx].PrivateName != nil && existingOriginServersItems[listIdx].PrivateName.OutsideNetwork != nil {
										return &OriginPoolEmptyModel{}
									}
									return nil
								}(),
								RefreshInterval: func() types.Int64 {
									if v, ok := nestedMap["refresh_interval"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					PublicIP: func() *OriginPoolOriginServersPublicIPModel {
						if nestedMap, ok := itemMap["public_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPublicIPModel{
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					PublicName: func() *OriginPoolOriginServersPublicNameModel {
						if nestedMap, ok := itemMap["public_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersPublicNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RefreshInterval: func() types.Int64 {
									if v, ok := nestedMap["refresh_interval"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					VnPrivateIP: func() *OriginPoolOriginServersVnPrivateIPModel {
						if nestedMap, ok := itemMap["vn_private_ip"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersVnPrivateIPModel{
								IP: func() types.String {
									if v, ok := nestedMap["ip"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					VnPrivateName: func() *OriginPoolOriginServersVnPrivateNameModel {
						if nestedMap, ok := itemMap["vn_private_name"].(map[string]interface{}); ok {
							return &OriginPoolOriginServersVnPrivateNameModel{
								DNSName: func() types.String {
									if v, ok := nestedMap["dns_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: OriginPoolOriginServersModelAttrTypes}, origin_serversList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginServers = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginServers = types.ListNull(types.ObjectType{AttrTypes: OriginPoolOriginServersModelAttrTypes})
	}
	if _, ok := apiResource.Spec["same_as_endpoint_port"].(map[string]interface{}); ok && isImport && data.SameAsEndpointPort == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SameAsEndpointPort = &OriginPoolEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["upstream_conn_pool_reuse_type"].(map[string]interface{}); ok && isImport && data.UpstreamConnPoolReuseType == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UpstreamConnPoolReuseType = &OriginPoolUpstreamConnPoolReuseTypeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["use_tls"].(map[string]interface{}); ok && (isImport || data.UseTLS != nil) {
		data.UseTLS = &OriginPoolUseTLSModel{
			DefaultSessionKeyCaching: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DefaultSessionKeyCaching
				}
				// Import case: read from API
				if _, ok := blockData["default_session_key_caching"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSessionKeyCaching: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DisableSessionKeyCaching
				}
				// Import case: read from API
				if _, ok := blockData["disable_session_key_caching"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			DisableSni: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.DisableSni
				}
				// Import case: read from API
				if _, ok := blockData["disable_sni"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			MaxSessionKeys: func() types.Int64 {
				if !isImport && data.UseTLS != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.UseTLS.MaxSessionKeys
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["max_session_keys"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NoMtls: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.NoMtls
				}
				// Import case: read from API
				if _, ok := blockData["no_mtls"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			SkipServerVerification: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.SkipServerVerification
				}
				// Import case: read from API
				if _, ok := blockData["skip_server_verification"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			Sni: func() types.String {
				if v, ok := blockData["sni"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TLSConfig: func() *OriginPoolUseTLSTLSConfigModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.TLSConfig != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.TLSConfig
				}
				// Import case: read from API
				if _, ok := blockData["tls_config"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSTLSConfigModel{}
				}
				return nil
			}(),
			UseHostHeaderAsSni: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.UseHostHeaderAsSni
				}
				// Import case: read from API
				if _, ok := blockData["use_host_header_as_sni"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
			UseMtls: func() *OriginPoolUseTLSUseMtlsModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseMtls != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseMtls
				}
				// Import case: read from API
				if _, ok := blockData["use_mtls"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseMtlsModel{}
				}
				return nil
			}(),
			UseMtlsObj: func() *OriginPoolUseTLSUseMtlsObjModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseMtlsObj != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseMtlsObj
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_mtls_obj"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseMtlsObjModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			UseServerVerification: func() *OriginPoolUseTLSUseServerVerificationModel {
				if !isImport && data.UseTLS != nil && data.UseTLS.UseServerVerification != nil {
					// Normal Read: preserve existing state value
					return data.UseTLS.UseServerVerification
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["use_server_verification"].(map[string]interface{}); ok {
					return &OriginPoolUseTLSUseServerVerificationModel{
						TrustedCAURL: func() types.String {
							if v, ok := nestedBlockData["trusted_ca_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			VolterraTrustedCA: func() *OriginPoolEmptyModel {
				if !isImport && data.UseTLS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.UseTLS.VolterraTrustedCA
				}
				// Import case: read from API
				if _, ok := blockData["volterra_trusted_ca"].(map[string]interface{}); ok {
					return &OriginPoolEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["endpoint_selection"].(string); ok && v != "" {
		data.EndpointSelection = types.StringValue(v)
	} else {
		data.EndpointSelection = types.StringNull()
	}
	if v, ok := apiResource.Spec["health_check_port"].(float64); ok {
		data.HealthCheckPort = types.Int64Value(int64(v))
	} else {
		data.HealthCheckPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["loadbalancer_algorithm"].(string); ok && v != "" {
		data.LoadBalancerAlgorithm = types.StringValue(v)
	} else {
		data.LoadBalancerAlgorithm = types.StringNull()
	}
	if v, ok := apiResource.Spec["port"].(float64); ok {
		data.Port = types.Int64Value(int64(v))
	} else {
		data.Port = types.Int64Null()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *OriginPoolResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data OriginPoolResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteOriginPool(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "OriginPool already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "OriginPool delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete OriginPool: %s", err))
		return
	}
}

func (r *OriginPoolResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
